<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="SIMD 和供应商内部功能模块。"><meta name="keywords" content="rust, rustlang, rust-lang, arch"><title>core::arch - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize1.55.0.css"><link rel="stylesheet" type="text/css" href="../../rustdoc1.55.0.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light1.55.0.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark1.55.0.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu1.55.0.css" disabled ><script id="default-settings"></script><script src="../../storage1.55.0.js"></script><script src="../../crates1.55.0.js"></script><noscript><link rel="stylesheet" href="../../noscript1.55.0.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon1.55.0.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x161.55.0.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x321.55.0.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow1.55.0.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../core/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo1.55.0.png' alt='logo'></div></a><h2 class="location">Module arch</h2><div class="sidebar-elems"><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li></ul></div><div id="sidebar-vars" data-name="arch" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img src="../../brush1.55.0.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img src="../../wheel1.55.0.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">core</a>::<wbr><a class="mod" href="#">arch</a><button id="copy-path" onclick="copy_path(this)" title="copy path"><img src="../../clipboard1.55.0.svg" width="19" height="18" alt="Copy item import" title="Copy item import to clipboard"></button></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.27.0">1.27.0</span><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/core/lib.rs.html#325-354" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>SIMD 和供应商内部功能模块。</p>
<p>此模块旨在用作特定于体系结构的固有函数的门户，该固有函数通常与 SIMD 相关 (但并非总是如此! )。
Rust 编译到的每个体系结构都可能在此处包含一个子模块，这意味着这不是便携式模块! 如果您要编写可移植的库，请在使用这些 API 时多加注意!</p>
<p>在此模块下，您将找到一个以架构命名的模块，例如 <code>x86_64</code>。Rust 可以编译的每个 <code>#[cfg(target_arch)]</code> 此处可能都有一个模块条目，仅存在于该特定目标上。
例如，<code>i686-pc-windows-msvc</code> 目标在此处将具有 <code>x86</code> 模块，而 <code>x86_64-pc-windows-msvc</code> 具有 <code>x86_64</code>。</p>
<h1 id="overview" class="section-header"><a href="#overview">Overview</a></h1>
<p>该模块公开了特定于供应商的内联函数，这些内联函数通常对应于一条机器指令。
这些内联函数不是可移植的: 它们的可用性取决于体系结构，并且并非该体系结构的所有机器都可以提供该内联函数。</p>
<p><code>arch</code> 模块旨在作为高级 API 的实现细节。正确使用它可能会非常棘手，因为您需要确保至少遵守以下几点保证:</p>
<ul>
<li>使用了正确的体系结构模块。例如，<code>arm</code> 模块在 <code>x86_64-unknown-linux-gnu</code> 目标上不可用。
通常，通过在使用此模块时确保正确使用 <code>#[cfg]</code> 来完成此操作。</li>
<li>程序当前正在运行的 CPU 支持被调用的函数。例如，在实际上不支持 AVX2 的 CPU 上调用 AVX2 函数是不安全的。</li>
</ul>
<p>由于后者的保证，该模块中的所有内联函数都是 <code>unsafe</code>，因此在调用它们时要格外小心!</p>
<h1 id="cpu-特性检测" class="section-header"><a href="#cpu-特性检测">CPU 特性检测</a></h1>
<p>为了以一种安全的方式调用这些 API，有许多机制可用来确保正确的 CPU 功能可用于调用内联函数。
例如，让我们考虑 <code>x86</code> 和 <code>x86_64</code> 体系结构上的 <code>_mm256_add_epi64</code> 内联函数。
此函数需要 AVX2 功能作为 <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_add_epi64&amp;expand=100">documented by Intel</a>，因此要正确调用此函数，我们需要 (a) 保证我们仅在 <code>x86</code>/<code>x86_64</code> 和 (b) 上调用它，以确保 CPU 功能可用</p>
<h2 id="静态-cpu-特性检测" class="section-header"><a href="#静态-cpu-特性检测">静态 CPU 特性检测</a></h2>
<p>我们可以使用的第一个选项是通过 <code>#[cfg]</code> 属性有条件地编译代码。CPU 功能对应于可用的 <code>target_feature</code> cfg，可以这样使用:</p>

<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">cfg</span>(
    <span class="ident">all</span>(
        <span class="ident">any</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86&quot;</span>, <span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86_64&quot;</span>),
        <span class="ident">target_feature</span> <span class="op">=</span> <span class="string">&quot;avx2&quot;</span>
    )
)]</span>
<span class="kw">fn</span> <span class="ident">foo</span>() {
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86&quot;</span>)]</span>
    <span class="kw">use</span> <span class="ident">std::arch::x86::_mm256_add_epi64</span>;
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86_64&quot;</span>)]</span>
    <span class="kw">use</span> <span class="ident">std::arch::x86_64::_mm256_add_epi64</span>;

    <span class="kw">unsafe</span> {
        <span class="ident">_mm256_add_epi64</span>(...);
    }
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0A%23%5Bcfg(%0A%20%20%20%20all(%0A%20%20%20%20%20%20%20%20any(target_arch%20%3D%20%22x86%22%2C%20target_arch%20%3D%20%22x86_64%22)%2C%0A%20%20%20%20%20%20%20%20target_feature%20%3D%20%22avx2%22%0A%20%20%20%20)%0A)%5D%0Afn%20foo()%20%7B%0A%20%20%20%20%23%5Bcfg(target_arch%20%3D%20%22x86%22)%5D%0A%20%20%20%20use%20std%3A%3Aarch%3A%3Ax86%3A%3A_mm256_add_epi64%3B%0A%20%20%20%20%23%5Bcfg(target_arch%20%3D%20%22x86_64%22)%5D%0A%20%20%20%20use%20std%3A%3Aarch%3A%3Ax86_64%3A%3A_mm256_add_epi64%3B%0A%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20_mm256_add_epi64(...)%3B%0A%20%20%20%20%7D%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<p>在这里，我们使用 <code>#[cfg(target_feature = &quot;avx2&quot;)]</code> 有条件地将此函数编译到我们的模块中。
这意味着，如果 <code>avx2</code> 功能静态地是 <em>enabled</em>，那么我们将在运行时使用 <code>_mm256_add_epi64</code> 函数。
可以通过使用 <code>#[cfg]</code> 来证明此处的 <code>unsafe</code> 块合理，仅在维护安全保证的情况下才编译代码。</p>
<p>通常使用编译器的 <code>-C target-feature</code> 或 <code>-C target-cpu</code> 标志来静态启用功能。例如，如果您的本地 CPU 支持 AVX2，则可以使用以下命令编译上述函数:</p>
<pre><code class="language-sh">$ RUSTFLAGS='-C target-cpu=native' cargo build
</code></pre>
<p>否则，您可以专门启用 AVX2 功能:</p>
<pre><code class="language-sh">$ RUSTFLAGS='-C target-feature=+avx2' cargo build
</code></pre>
<p>请注意，在编译启用了特定功能的二进制文件时，确保仅在满足所需功能集的系统上运行二进制文件非常重要。</p>
<h2 id="动态-cpu-功能检测" class="section-header"><a href="#动态-cpu-功能检测">动态 CPU 功能检测</a></h2>
<p>有时静态分派并不是您想要的。相反，您可能想构建一个可在各种 CPU 上运行的可移植二进制文件，但是在运行时它将选择可用的最优化的实现。
这使您可以构建 “最小公分母” 二进制文件，其中的某些部分针对不同的 CPU 进行了优化。</p>
<p>以之前的示例为例，我们将编译我们的二进制文件，而没有 AVX2 支持，但是我们只想为一个函数启用它。
我们可以按照以下方式进行操作:</p>

<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="kw">fn</span> <span class="ident">foo</span>() {
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86&quot;</span>, <span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86_64&quot;</span>))]</span>
    {
        <span class="kw">if</span> <span class="macro">is_x86_feature_detected!</span>(<span class="string">&quot;avx2&quot;</span>) {
            <span class="kw">return</span> <span class="kw">unsafe</span> { <span class="ident">foo_avx2</span>() };
        }
    }

    <span class="comment">// fallback implementation without using AVX2</span>
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86&quot;</span>, <span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86_64&quot;</span>))]</span>
<span class="attribute">#[<span class="ident">target_feature</span>(<span class="ident">enable</span> <span class="op">=</span> <span class="string">&quot;avx2&quot;</span>)]</span>
<span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">foo_avx2</span>() {
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86&quot;</span>)]</span>
    <span class="kw">use</span> <span class="ident">std::arch::x86::_mm256_add_epi64</span>;
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86_64&quot;</span>)]</span>
    <span class="kw">use</span> <span class="ident">std::arch::x86_64::_mm256_add_epi64</span>;

    <span class="ident">_mm256_add_epi64</span>(...);
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Afn%20foo()%20%7B%0A%20%20%20%20%23%5Bcfg(any(target_arch%20%3D%20%22x86%22%2C%20target_arch%20%3D%20%22x86_64%22))%5D%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20if%20is_x86_feature_detected!(%22avx2%22)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20unsafe%20%7B%20foo_avx2()%20%7D%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20fallback%20implementation%20without%20using%20AVX2%0A%7D%0A%0A%23%5Bcfg(any(target_arch%20%3D%20%22x86%22%2C%20target_arch%20%3D%20%22x86_64%22))%5D%0A%23%5Btarget_feature(enable%20%3D%20%22avx2%22)%5D%0Aunsafe%20fn%20foo_avx2()%20%7B%0A%20%20%20%20%23%5Bcfg(target_arch%20%3D%20%22x86%22)%5D%0A%20%20%20%20use%20std%3A%3Aarch%3A%3Ax86%3A%3A_mm256_add_epi64%3B%0A%20%20%20%20%23%5Bcfg(target_arch%20%3D%20%22x86_64%22)%5D%0A%20%20%20%20use%20std%3A%3Aarch%3A%3Ax86_64%3A%3A_mm256_add_epi64%3B%0A%0A%20%20%20%20_mm256_add_epi64(...)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<p>这里有几个组件在起作用，所以让我们详细研究它们!</p>
<ul>
<li>
<p>首先，我们注意到 <code>is_x86_feature_detected!</code> 宏。
由标准库提供，此宏将执行必要的运行时检测，以确定程序所运行的 CPU 是否支持指定的功能。
在这种情况下，宏将扩展为一个布尔表达式，以评估本地 CPU 是否具有 AVX2 功能。</p>
<p>请注意，与 <code>arch</code> 模块一样，此宏是特定于平台的。例如，在 ARM 上调用 <code>is_x86_feature_detected!(&quot;avx2&quot;)</code> 将是编译时错误。
为了确保我们不会遇到此错误，语句级别 <code>#[cfg]</code> 仅用于编译 <code>x86</code>/<code>x86_64</code> 上的宏用法。</p>
</li>
<li>
<p>接下来，我们看到启用了 AVX2 的函数 <code>foo_avx2</code>。此函数用 <code>#[target_feature]</code> 属性修饰，该属性仅为此一个函数启用 CPU 功能。
使用 <code>-C target-feature=+avx2</code> 之类的编译器标志将为整个程序启用 AVX2，但使用属性将仅为一个函数启用它。
如此处所示，当前使用 <code>#[target_feature]</code> 属性要求函数也必须为 <code>unsafe</code>。
这是因为只能在具有 AVX2 的系统上正确调用该函数 (例如内联函数本身)。</p>
</li>
</ul>
<p>有了所有这些，我们应该有一个有效的程序! 该程序将在所有计算机上运行，并且将在检测到支持的计算机上使用优化的 AVX2 实现。</p>
<h1 id="ergonomics" class="section-header"><a href="#ergonomics">Ergonomics</a></h1>
<p>重要的是要注意，使用 <code>arch</code> 模块并不是世界上最简单的事情，因此，如果您想尝试一下，您可能会想方设法为自己做好准备!</p>
<p>该模块的主要目的是使 crates.io 上的稳定 crates 能够构建更多的人体工程学抽象，最终在引擎盖下使用 SIMD。
随着时间的流逝，这些抽象也可能会移入标准库本身，但是目前，此模块的任务是提供在稳定的 Rust 上使用供应商内联函数所需的最低限度的最低要求。</p>
<h1 id="其他架构" class="section-header"><a href="#其他架构">其他架构</a></h1>
<p>本文档仅适用于一种特定的体系结构，您可以在以下位置找到其他文档:</p>
<ul>
<li><a href="x86/index.html"><code>x86</code></a></li>
<li><a href="x86_64/index.html"><code>x86_64</code></a></li>
<li><a href="arm/index.html"><code>arm</code></a></li>
<li><a href="aarch64/index.html"><code>aarch64</code></a></li>
<li><a href="mips/index.html"><code>mips</code></a></li>
<li><a href="mips64/index.html"><code>mips64</code></a></li>
<li><a href="powerpc/index.html"><code>powerpc</code></a></li>
<li><a href="powerpc64/index.html"><code>powerpc64</code></a></li>
<li><a href="nvptx/index.html"><code>nvptx</code></a></li>
<li><a href="wasm32/index.html"><code>wasm32</code></a></li>
</ul>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>首先，让我们看一下实际上不使用任何内联函数，而是使用 LLVM 的自动矢量化为 AVX2 和默认平台生成优化的矢量化代码。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dst</span> <span class="op">=</span> [<span class="number">0</span>];
    <span class="ident">add_quickly</span>(<span class="kw-2">&amp;</span>[<span class="number">1</span>], <span class="kw-2">&amp;</span>[<span class="number">2</span>], <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">dst</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">dst</span>[<span class="number">0</span>], <span class="number">3</span>);
}

<span class="kw">fn</span> <span class="ident">add_quickly</span>(<span class="ident">a</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">b</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">c</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">u8</span>]) {
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86&quot;</span>, <span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86_64&quot;</span>))]</span>
    {
        <span class="comment">// 请注意，此 `unsafe` 块是安全的，因为我们正在测试 `avx2` 功能确实在我们的 CPU 上可用。</span>
        <span class="comment">//</span>
        <span class="kw">if</span> <span class="macro">is_x86_feature_detected!</span>(<span class="string">&quot;avx2&quot;</span>) {
            <span class="kw">return</span> <span class="kw">unsafe</span> { <span class="ident">add_quickly_avx2</span>(<span class="ident">a</span>, <span class="ident">b</span>, <span class="ident">c</span>) };
        }
    }

    <span class="ident">add_quickly_fallback</span>(<span class="ident">a</span>, <span class="ident">b</span>, <span class="ident">c</span>)
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86&quot;</span>, <span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86_64&quot;</span>))]</span>
<span class="attribute">#[<span class="ident">target_feature</span>(<span class="ident">enable</span> <span class="op">=</span> <span class="string">&quot;avx2&quot;</span>)]</span>
<span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">add_quickly_avx2</span>(<span class="ident">a</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">b</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">c</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">u8</span>]) {
    <span class="ident">add_quickly_fallback</span>(<span class="ident">a</span>, <span class="ident">b</span>, <span class="ident">c</span>) <span class="comment">// 下面的函数内联在这里</span>
}

<span class="kw">fn</span> <span class="ident">add_quickly_fallback</span>(<span class="ident">a</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">b</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">c</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">u8</span>]) {
    <span class="kw">for</span> ((<span class="ident">a</span>, <span class="ident">b</span>), <span class="ident">c</span>) <span class="kw">in</span> <span class="ident">a</span>.<span class="ident">iter</span>().<span class="ident">zip</span>(<span class="ident">b</span>).<span class="ident">zip</span>(<span class="ident">c</span>) {
        <span class="kw-2">*</span><span class="ident">c</span> <span class="op">=</span> <span class="kw-2">*</span><span class="ident">a</span> <span class="op">+</span> <span class="kw-2">*</span><span class="ident">b</span>;
    }
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20dst%20%3D%20%5B0%5D%3B%0A%20%20%20%20add_quickly(%26%5B1%5D%2C%20%26%5B2%5D%2C%20%26mut%20dst)%3B%0A%20%20%20%20assert_eq!(dst%5B0%5D%2C%203)%3B%0A%7D%0A%0Afn%20add_quickly(a%3A%20%26%5Bu8%5D%2C%20b%3A%20%26%5Bu8%5D%2C%20c%3A%20%26mut%20%5Bu8%5D)%20%7B%0A%20%20%20%20%23%5Bcfg(any(target_arch%20%3D%20%22x86%22%2C%20target_arch%20%3D%20%22x86_64%22))%5D%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20%E8%AF%B7%E6%B3%A8%E6%84%8F%EF%BC%8C%E6%AD%A4%20%60unsafe%60%20%E5%9D%97%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%88%91%E4%BB%AC%E6%AD%A3%E5%9C%A8%E6%B5%8B%E8%AF%95%20%60avx2%60%20%E5%8A%9F%E8%83%BD%E7%A1%AE%E5%AE%9E%E5%9C%A8%E6%88%91%E4%BB%AC%E7%9A%84%20CPU%20%E4%B8%8A%E5%8F%AF%E7%94%A8%E3%80%82%0A%20%20%20%20%20%20%20%20%2F%2F%0A%20%20%20%20%20%20%20%20if%20is_x86_feature_detected!(%22avx2%22)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20unsafe%20%7B%20add_quickly_avx2(a%2C%20b%2C%20c)%20%7D%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20add_quickly_fallback(a%2C%20b%2C%20c)%0A%7D%0A%0A%23%5Bcfg(any(target_arch%20%3D%20%22x86%22%2C%20target_arch%20%3D%20%22x86_64%22))%5D%0A%23%5Btarget_feature(enable%20%3D%20%22avx2%22)%5D%0Aunsafe%20fn%20add_quickly_avx2(a%3A%20%26%5Bu8%5D%2C%20b%3A%20%26%5Bu8%5D%2C%20c%3A%20%26mut%20%5Bu8%5D)%20%7B%0A%20%20%20%20add_quickly_fallback(a%2C%20b%2C%20c)%20%2F%2F%20%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%87%BD%E6%95%B0%E5%86%85%E8%81%94%E5%9C%A8%E8%BF%99%E9%87%8C%0A%7D%0A%0Afn%20add_quickly_fallback(a%3A%20%26%5Bu8%5D%2C%20b%3A%20%26%5Bu8%5D%2C%20c%3A%20%26mut%20%5Bu8%5D)%20%7B%0A%20%20%20%20for%20((a%2C%20b)%2C%20c)%20in%20a.iter().zip(b).zip(c)%20%7B%0A%20%20%20%20%20%20%20%20*c%20%3D%20*a%20%2B%20*b%3B%0A%20%20%20%20%7D%0A%7D&amp;edition=2018">Run</a></div>
<p>接下来，让我们来看一个手动使用内联函数的示例。在这里，我们将使用 SSE4.1 功能来实现十六进制编码。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dst</span> <span class="op">=</span> [<span class="number">0</span>; <span class="number">32</span>];
    <span class="ident">hex_encode</span>(<span class="string">b&quot;\x01\x02\x03&quot;</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">dst</span>);
    <span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">dst</span>[..<span class="number">6</span>], <span class="string">b&quot;010203&quot;</span>);

    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">src</span> <span class="op">=</span> [<span class="number">0</span>; <span class="number">16</span>];
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="number">16</span> {
        <span class="ident">src</span>[<span class="ident">i</span>] <span class="op">=</span> (<span class="ident">i</span> <span class="op">+</span> <span class="number">1</span>) <span class="kw">as</span> <span class="ident">u8</span>;
    }
    <span class="ident">hex_encode</span>(<span class="kw-2">&amp;</span><span class="ident">src</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">dst</span>);
    <span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">dst</span>, <span class="string">b&quot;0102030405060708090a0b0c0d0e0f10&quot;</span>);
}

<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">hex_encode</span>(<span class="ident">src</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">dst</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">u8</span>]) {
    <span class="kw">let</span> <span class="ident">len</span> <span class="op">=</span> <span class="ident">src</span>.<span class="ident">len</span>().<span class="ident">checked_mul</span>(<span class="number">2</span>).<span class="ident">unwrap</span>();
    <span class="macro">assert!</span>(<span class="ident">dst</span>.<span class="ident">len</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="ident">len</span>);

    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86&quot;</span>, <span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86_64&quot;</span>))]</span>
    {
        <span class="kw">if</span> <span class="macro">is_x86_feature_detected!</span>(<span class="string">&quot;sse4.1&quot;</span>) {
            <span class="kw">return</span> <span class="kw">unsafe</span> { <span class="ident">hex_encode_sse41</span>(<span class="ident">src</span>, <span class="ident">dst</span>) };
        }
    }

    <span class="ident">hex_encode_fallback</span>(<span class="ident">src</span>, <span class="ident">dst</span>)
}

<span class="comment">// translated from</span>
<span class="comment">// &lt;https://github.com/Matherunner/bin2hex-sse/blob/master/base16_sse4.cpp&gt;</span>
<span class="attribute">#[<span class="ident">target_feature</span>(<span class="ident">enable</span> <span class="op">=</span> <span class="string">&quot;sse4.1&quot;</span>)]</span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86&quot;</span>, <span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86_64&quot;</span>))]</span>
<span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">hex_encode_sse41</span>(<span class="kw-2">mut</span> <span class="ident">src</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">dst</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">u8</span>]) {
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86&quot;</span>)]</span>
    <span class="kw">use</span> <span class="ident">std::arch::x86</span>::<span class="kw-2">*</span>;
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86_64&quot;</span>)]</span>
    <span class="kw">use</span> <span class="ident">std::arch::x86_64</span>::<span class="kw-2">*</span>;

    <span class="kw">let</span> <span class="ident">ascii_zero</span> <span class="op">=</span> <span class="ident">_mm_set1_epi8</span>(<span class="string">b&#39;0&#39;</span> <span class="kw">as</span> <span class="ident">i8</span>);
    <span class="kw">let</span> <span class="ident">nines</span> <span class="op">=</span> <span class="ident">_mm_set1_epi8</span>(<span class="number">9</span>);
    <span class="kw">let</span> <span class="ident">ascii_a</span> <span class="op">=</span> <span class="ident">_mm_set1_epi8</span>((<span class="string">b&#39;a&#39;</span> <span class="op">-</span> <span class="number">9</span> <span class="op">-</span> <span class="number">1</span>) <span class="kw">as</span> <span class="ident">i8</span>);
    <span class="kw">let</span> <span class="ident">and4bits</span> <span class="op">=</span> <span class="ident">_mm_set1_epi8</span>(<span class="number">0xf</span>);

    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">i</span> <span class="op">=</span> <span class="number">0_isize</span>;
    <span class="kw">while</span> <span class="ident">src</span>.<span class="ident">len</span>() <span class="op">&gt;</span><span class="op">=</span> <span class="number">16</span> {
        <span class="kw">let</span> <span class="ident">invec</span> <span class="op">=</span> <span class="ident">_mm_loadu_si128</span>(<span class="ident">src</span>.<span class="ident">as_ptr</span>() <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="kw">_</span>);

        <span class="kw">let</span> <span class="ident">masked1</span> <span class="op">=</span> <span class="ident">_mm_and_si128</span>(<span class="ident">invec</span>, <span class="ident">and4bits</span>);
        <span class="kw">let</span> <span class="ident">masked2</span> <span class="op">=</span> <span class="ident">_mm_and_si128</span>(<span class="ident">_mm_srli_epi64</span>(<span class="ident">invec</span>, <span class="number">4</span>), <span class="ident">and4bits</span>);

        <span class="comment">// return 0xff corresponding to the elements &gt; 9, or 0x00 otherwise</span>
        <span class="kw">let</span> <span class="ident">cmpmask1</span> <span class="op">=</span> <span class="ident">_mm_cmpgt_epi8</span>(<span class="ident">masked1</span>, <span class="ident">nines</span>);
        <span class="kw">let</span> <span class="ident">cmpmask2</span> <span class="op">=</span> <span class="ident">_mm_cmpgt_epi8</span>(<span class="ident">masked2</span>, <span class="ident">nines</span>);

        <span class="comment">// add &#39;0&#39; or the offset depending on the masks</span>
        <span class="kw">let</span> <span class="ident">masked1</span> <span class="op">=</span> <span class="ident">_mm_add_epi8</span>(
            <span class="ident">masked1</span>,
            <span class="ident">_mm_blendv_epi8</span>(<span class="ident">ascii_zero</span>, <span class="ident">ascii_a</span>, <span class="ident">cmpmask1</span>),
        );
        <span class="kw">let</span> <span class="ident">masked2</span> <span class="op">=</span> <span class="ident">_mm_add_epi8</span>(
            <span class="ident">masked2</span>,
            <span class="ident">_mm_blendv_epi8</span>(<span class="ident">ascii_zero</span>, <span class="ident">ascii_a</span>, <span class="ident">cmpmask2</span>),
        );

        <span class="comment">// interleave masked1 and masked2 bytes</span>
        <span class="kw">let</span> <span class="ident">res1</span> <span class="op">=</span> <span class="ident">_mm_unpacklo_epi8</span>(<span class="ident">masked2</span>, <span class="ident">masked1</span>);
        <span class="kw">let</span> <span class="ident">res2</span> <span class="op">=</span> <span class="ident">_mm_unpackhi_epi8</span>(<span class="ident">masked2</span>, <span class="ident">masked1</span>);

        <span class="ident">_mm_storeu_si128</span>(<span class="ident">dst</span>.<span class="ident">as_mut_ptr</span>().<span class="ident">offset</span>(<span class="ident">i</span> <span class="op">*</span> <span class="number">2</span>) <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="kw">_</span>, <span class="ident">res1</span>);
        <span class="ident">_mm_storeu_si128</span>(
            <span class="ident">dst</span>.<span class="ident">as_mut_ptr</span>().<span class="ident">offset</span>(<span class="ident">i</span> <span class="op">*</span> <span class="number">2</span> <span class="op">+</span> <span class="number">16</span>) <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="kw">_</span>,
            <span class="ident">res2</span>,
        );
        <span class="ident">src</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">src</span>[<span class="number">16</span>..];
        <span class="ident">i</span> <span class="op">+</span><span class="op">=</span> <span class="number">16</span>;
    }

    <span class="kw">let</span> <span class="ident">i</span> <span class="op">=</span> <span class="ident">i</span> <span class="kw">as</span> <span class="ident">usize</span>;
    <span class="ident">hex_encode_fallback</span>(<span class="ident">src</span>, <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">dst</span>[<span class="ident">i</span> <span class="op">*</span> <span class="number">2</span>..]);
}

<span class="kw">fn</span> <span class="ident">hex_encode_fallback</span>(<span class="ident">src</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">dst</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">u8</span>]) {
    <span class="kw">fn</span> <span class="ident">hex</span>(<span class="ident">byte</span>: <span class="ident">u8</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">u8</span> {
        <span class="kw">static</span> <span class="ident">TABLE</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] <span class="op">=</span> <span class="string">b&quot;0123456789abcdef&quot;</span>;
        <span class="ident">TABLE</span>[<span class="ident">byte</span> <span class="kw">as</span> <span class="ident">usize</span>]
    }

    <span class="kw">for</span> (<span class="ident">byte</span>, <span class="ident">slots</span>) <span class="kw">in</span> <span class="ident">src</span>.<span class="ident">iter</span>().<span class="ident">zip</span>(<span class="ident">dst</span>.<span class="ident">chunks_mut</span>(<span class="number">2</span>)) {
        <span class="ident">slots</span>[<span class="number">0</span>] <span class="op">=</span> <span class="ident">hex</span>((<span class="kw-2">*</span><span class="ident">byte</span> <span class="op">&gt;</span><span class="op">&gt;</span> <span class="number">4</span>) <span class="op">&amp;</span> <span class="number">0xf</span>);
        <span class="ident">slots</span>[<span class="number">1</span>] <span class="op">=</span> <span class="ident">hex</span>(<span class="kw-2">*</span><span class="ident">byte</span> <span class="op">&amp;</span> <span class="number">0xf</span>);
    }
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20dst%20%3D%20%5B0%3B%2032%5D%3B%0A%20%20%20%20hex_encode(b%22%5Cx01%5Cx02%5Cx03%22%2C%20%26mut%20dst)%3B%0A%20%20%20%20assert_eq!(%26dst%5B..6%5D%2C%20b%22010203%22)%3B%0A%0A%20%20%20%20let%20mut%20src%20%3D%20%5B0%3B%2016%5D%3B%0A%20%20%20%20for%20i%20in%200..16%20%7B%0A%20%20%20%20%20%20%20%20src%5Bi%5D%20%3D%20(i%20%2B%201)%20as%20u8%3B%0A%20%20%20%20%7D%0A%20%20%20%20hex_encode(%26src%2C%20%26mut%20dst)%3B%0A%20%20%20%20assert_eq!(%26dst%2C%20b%220102030405060708090a0b0c0d0e0f10%22)%3B%0A%7D%0A%0Apub%20fn%20hex_encode(src%3A%20%26%5Bu8%5D%2C%20dst%3A%20%26mut%20%5Bu8%5D)%20%7B%0A%20%20%20%20let%20len%20%3D%20src.len().checked_mul(2).unwrap()%3B%0A%20%20%20%20assert!(dst.len()%20%3E%3D%20len)%3B%0A%0A%20%20%20%20%23%5Bcfg(any(target_arch%20%3D%20%22x86%22%2C%20target_arch%20%3D%20%22x86_64%22))%5D%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20if%20is_x86_feature_detected!(%22sse4.1%22)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20unsafe%20%7B%20hex_encode_sse41(src%2C%20dst)%20%7D%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20hex_encode_fallback(src%2C%20dst)%0A%7D%0A%0A%2F%2F%20translated%20from%0A%2F%2F%20%3Chttps%3A%2F%2Fgithub.com%2FMatherunner%2Fbin2hex-sse%2Fblob%2Fmaster%2Fbase16_sse4.cpp%3E%0A%23%5Btarget_feature(enable%20%3D%20%22sse4.1%22)%5D%0A%23%5Bcfg(any(target_arch%20%3D%20%22x86%22%2C%20target_arch%20%3D%20%22x86_64%22))%5D%0Aunsafe%20fn%20hex_encode_sse41(mut%20src%3A%20%26%5Bu8%5D%2C%20dst%3A%20%26mut%20%5Bu8%5D)%20%7B%0A%20%20%20%20%23%5Bcfg(target_arch%20%3D%20%22x86%22)%5D%0A%20%20%20%20use%20std%3A%3Aarch%3A%3Ax86%3A%3A*%3B%0A%20%20%20%20%23%5Bcfg(target_arch%20%3D%20%22x86_64%22)%5D%0A%20%20%20%20use%20std%3A%3Aarch%3A%3Ax86_64%3A%3A*%3B%0A%0A%20%20%20%20let%20ascii_zero%20%3D%20_mm_set1_epi8(b'0'%20as%20i8)%3B%0A%20%20%20%20let%20nines%20%3D%20_mm_set1_epi8(9)%3B%0A%20%20%20%20let%20ascii_a%20%3D%20_mm_set1_epi8((b'a'%20-%209%20-%201)%20as%20i8)%3B%0A%20%20%20%20let%20and4bits%20%3D%20_mm_set1_epi8(0xf)%3B%0A%0A%20%20%20%20let%20mut%20i%20%3D%200_isize%3B%0A%20%20%20%20while%20src.len()%20%3E%3D%2016%20%7B%0A%20%20%20%20%20%20%20%20let%20invec%20%3D%20_mm_loadu_si128(src.as_ptr()%20as%20*const%20_)%3B%0A%0A%20%20%20%20%20%20%20%20let%20masked1%20%3D%20_mm_and_si128(invec%2C%20and4bits)%3B%0A%20%20%20%20%20%20%20%20let%20masked2%20%3D%20_mm_and_si128(_mm_srli_epi64(invec%2C%204)%2C%20and4bits)%3B%0A%0A%20%20%20%20%20%20%20%20%2F%2F%20return%200xff%20corresponding%20to%20the%20elements%20%3E%209%2C%20or%200x00%20otherwise%0A%20%20%20%20%20%20%20%20let%20cmpmask1%20%3D%20_mm_cmpgt_epi8(masked1%2C%20nines)%3B%0A%20%20%20%20%20%20%20%20let%20cmpmask2%20%3D%20_mm_cmpgt_epi8(masked2%2C%20nines)%3B%0A%0A%20%20%20%20%20%20%20%20%2F%2F%20add%20'0'%20or%20the%20offset%20depending%20on%20the%20masks%0A%20%20%20%20%20%20%20%20let%20masked1%20%3D%20_mm_add_epi8(%0A%20%20%20%20%20%20%20%20%20%20%20%20masked1%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20_mm_blendv_epi8(ascii_zero%2C%20ascii_a%2C%20cmpmask1)%2C%0A%20%20%20%20%20%20%20%20)%3B%0A%20%20%20%20%20%20%20%20let%20masked2%20%3D%20_mm_add_epi8(%0A%20%20%20%20%20%20%20%20%20%20%20%20masked2%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20_mm_blendv_epi8(ascii_zero%2C%20ascii_a%2C%20cmpmask2)%2C%0A%20%20%20%20%20%20%20%20)%3B%0A%0A%20%20%20%20%20%20%20%20%2F%2F%20interleave%20masked1%20and%20masked2%20bytes%0A%20%20%20%20%20%20%20%20let%20res1%20%3D%20_mm_unpacklo_epi8(masked2%2C%20masked1)%3B%0A%20%20%20%20%20%20%20%20let%20res2%20%3D%20_mm_unpackhi_epi8(masked2%2C%20masked1)%3B%0A%0A%20%20%20%20%20%20%20%20_mm_storeu_si128(dst.as_mut_ptr().offset(i%20*%202)%20as%20*mut%20_%2C%20res1)%3B%0A%20%20%20%20%20%20%20%20_mm_storeu_si128(%0A%20%20%20%20%20%20%20%20%20%20%20%20dst.as_mut_ptr().offset(i%20*%202%20%2B%2016)%20as%20*mut%20_%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20res2%2C%0A%20%20%20%20%20%20%20%20)%3B%0A%20%20%20%20%20%20%20%20src%20%3D%20%26src%5B16..%5D%3B%0A%20%20%20%20%20%20%20%20i%20%2B%3D%2016%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20let%20i%20%3D%20i%20as%20usize%3B%0A%20%20%20%20hex_encode_fallback(src%2C%20%26mut%20dst%5Bi%20*%202..%5D)%3B%0A%7D%0A%0Afn%20hex_encode_fallback(src%3A%20%26%5Bu8%5D%2C%20dst%3A%20%26mut%20%5Bu8%5D)%20%7B%0A%20%20%20%20fn%20hex(byte%3A%20u8)%20-%3E%20u8%20%7B%0A%20%20%20%20%20%20%20%20static%20TABLE%3A%20%26%5Bu8%5D%20%3D%20b%220123456789abcdef%22%3B%0A%20%20%20%20%20%20%20%20TABLE%5Bbyte%20as%20usize%5D%0A%20%20%20%20%7D%0A%0A%20%20%20%20for%20(byte%2C%20slots)%20in%20src.iter().zip(dst.chunks_mut(2))%20%7B%0A%20%20%20%20%20%20%20%20slots%5B0%5D%20%3D%20hex((*byte%20%3E%3E%204)%20%26%200xf)%3B%0A%20%20%20%20%20%20%20%20slots%5B1%5D%20%3D%20hex(*byte%20%26%200xf)%3B%0A%20%20%20%20%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><h2 id="modules" class="section-header"><a href="#modules">Modules</a></h2>
<table><tr class="unstable module-item"><td><a class="mod" href="aarch64/index.html" title="core::arch::aarch64 mod">aarch64</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported on AArch64 only">AArch64</span><p><code>aarch64</code> 平台的平台特定的内联函数。</p>
</td></tr><tr class="unstable module-item"><td><a class="mod" href="arm/index.html" title="core::arch::arm mod">arm</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported on ARM only">ARM</span><p><code>arm</code> 平台的平台特定的内联函数。</p>
</td></tr><tr class="unstable module-item"><td><a class="mod" href="mips/index.html" title="core::arch::mips mod">mips</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported on MIPS only">MIPS</span><p><code>mips</code> 平台的平台特定的内联函数。</p>
</td></tr><tr class="unstable module-item"><td><a class="mod" href="mips64/index.html" title="core::arch::mips64 mod">mips64</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported on MIPS-64 only">MIPS-64</span><p><code>mips64</code> 平台的平台特定的内联函数。</p>
</td></tr><tr class="unstable module-item"><td><a class="mod" href="nvptx/index.html" title="core::arch::nvptx mod">nvptx</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported on `target_arch=&quot;nvptx&quot;` or `target_arch=&quot;nvptx64&quot;` only"><code>target_arch="nvptx"</code> or <code>target_arch="nvptx64"</code></span><p><code>NVPTX</code> 平台的平台特定的内联函数。</p>
</td></tr><tr class="unstable module-item"><td><a class="mod" href="powerpc/index.html" title="core::arch::powerpc mod">powerpc</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported on PowerPC only">PowerPC</span><p><code>PowerPC</code> 平台的平台特定的内联函数。</p>
</td></tr><tr class="unstable module-item"><td><a class="mod" href="powerpc64/index.html" title="core::arch::powerpc64 mod">powerpc64</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported on PowerPC-64 only">PowerPC-64</span><p><code>PowerPC64</code> 平台的平台特定的内联函数。</p>
</td></tr><tr class="module-item"><td><a class="mod" href="wasm32/index.html" title="core::arch::wasm32 mod">wasm32</a></td><td class="docblock-short"><span class="stab portability" title="This is supported on WebAssembly only">WebAssembly</span><p><code>wasm32</code> 平台的平台特定的内联函数。</p>
</td></tr><tr class="module-item"><td><a class="mod" href="x86/index.html" title="core::arch::x86 mod">x86</a></td><td class="docblock-short"><span class="stab portability" title="This is supported on x86 only">x86</span><p><code>x86</code> 平台的平台特定的内联函数。</p>
</td></tr><tr class="module-item"><td><a class="mod" href="x86_64/index.html" title="core::arch::x86_64 mod">x86_64</a></td><td class="docblock-short"><span class="stab portability" title="This is supported on x86-64 only">x86-64</span><p><code>x86_64</code> 平台的平台特定的内联函数。</p>
</td></tr></table><h2 id="macros" class="section-header"><a href="#macros">Macros</a></h2>
<table><tr class="unstable module-item"><td><a class="macro" href="macro.asm.html" title="core::arch::asm macro">asm</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>内联汇编。</p>
</td></tr><tr class="unstable module-item"><td><a class="macro" href="macro.global_asm.html" title="core::arch::global_asm macro">global_asm</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>模块级内联汇编。</p>
</td></tr></table></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="core" data-search-index-js="../../search-index1.55.0.js" data-search-js="../../search1.55.0.js"></div><script src="../../main1.55.0.js"></script></body></html>