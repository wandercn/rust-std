initSidebarItems({"enum":[["RecvTimeoutError","该枚举是导致 `recv_timeout` 在调用时无法返回数据的可能错误的列表。 [`channel`] 和 [`sync_channel`] 都可能发生这种情况。"],["TryRecvError","该枚举是 `try_recv` 在调用时无法返回数据的可能原因的列表。 [`channel`] 和 [`sync_channel`] 都可能发生这种情况。"],["TrySendError","此枚举是 `try_send` 方法可能出现的错误结果的列表。"]],"fn":[["channel","创建一个新的异步通道，返回 sender/receiver 一半。 在 [`Sender`] 上发送的所有数据将以与发送时相同的顺序在 [`Receiver`] 上可用，并且没有 `send` 将阻塞调用线程 (此通道具有一个 “infinite buffer”，与 [`sync_channel`] 不同，它将在达到其缓冲区限制后阻塞)。 `recv` 当至少有一个 [`Sender`] 活着 (包括克隆) 时，将阻塞直到消息可用。"],["sync_channel","创建一个新的同步有界通道。 [`SyncSender`] 上发送的所有数据将以与发送相同的顺序在 [`Receiver`] 上可用。 像异步 [`channel`] 一样，[`Receiver`] 将阻塞直到消息可用为止。 `sync_channel` 但是，发送者的语义差异很大。"]],"struct":[["IntoIter","[`Receiver`] 上由消息接收者拥有的迭代器，该迭代器由 接收者::into_iter 创建。"],["Iter","`iter` 在 [`Receiver`] 上创建的消息上的迭代器。"],["Receiver","Rust 的 [`channel`] (或 [`sync_channel`]) 类型的接收一半。 这一半只能由一个线程拥有。"],["RecvError","[`Receiver`] 上的 `recv` 函数返回错误。"],["SendError","X X 上的 [`Sender::send`] 或 [`SyncSender::send`] 函数返回错误。"],["Sender","Rust 的异步 [`channel`] 类型的发送一半。 这一半只能由一个线程拥有，但可以克隆以发送给其他线程。"],["SyncSender","Rust 的同步 [`sync_channel`] 类型的发送一半。"],["TryIter","尝试产生 `try_iter` 创建的 [`Receiver`] 的所有挂起值的迭代器。"]]});