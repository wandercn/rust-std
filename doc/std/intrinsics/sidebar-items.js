initSidebarItems({"fn":[["abort","中止进程的执行。"],["add_with_overflow","执行检查的整数加法。"],["arith_offset","计算与指针的偏移量 (可能会自动换行)。"],["assert_inhabited","如果 `T` 未定义，则无法执行的不安全函数的守卫: 这将静态地为 panic，或者什么也不做。"],["assert_uninit_valid","如果 `T` 具有无效的位模式，则永远不能执行的不安全函数的守卫: 这将静态地 panic，或者什么也不做。"],["assert_zero_valid","如果 `T` 不允许零初始化，则永远不能执行的不安全函数的守卫: 这将静态 panic，或者什么也不做。"],["assume","通知优化器条件始终为真。 如果条件为假，则行为是不确定的。"],["atomic_and","对当前值按位与，返回前一个值。"],["atomic_and_acq","对当前值按位与，返回前一个值。"],["atomic_and_acqrel","对当前值按位与，返回前一个值。"],["atomic_and_rel","对当前值按位与，返回前一个值。"],["atomic_and_relaxed","对当前值按位与，返回前一个值。"],["atomic_cxchg","如果当前值与 `old` 值相同，则存储一个值。"],["atomic_cxchg_acq","如果当前值与 `old` 值相同，则存储一个值。"],["atomic_cxchg_acq_failrelaxed","如果当前值与 `old` 值相同，则存储一个值。"],["atomic_cxchg_acqrel","如果当前值与 `old` 值相同，则存储一个值。"],["atomic_cxchg_acqrel_failrelaxed","如果当前值与 `old` 值相同，则存储一个值。"],["atomic_cxchg_failacq","如果当前值与 `old` 值相同，则存储一个值。"],["atomic_cxchg_failrelaxed","如果当前值与 `old` 值相同，则存储一个值。"],["atomic_cxchg_rel","如果当前值与 `old` 值相同，则存储一个值。"],["atomic_cxchg_relaxed","如果当前值与 `old` 值相同，则存储一个值。"],["atomic_cxchgweak","如果当前值与 `old` 值相同，则存储一个值。"],["atomic_cxchgweak_acq","如果当前值与 `old` 值相同，则存储一个值。"],["atomic_cxchgweak_acq_failrelaxed","如果当前值与 `old` 值相同，则存储一个值。"],["atomic_cxchgweak_acqrel","如果当前值与 `old` 值相同，则存储一个值。"],["atomic_cxchgweak_acqrel_failrelaxed","如果当前值与 `old` 值相同，则存储一个值。"],["atomic_cxchgweak_failacq","如果当前值与 `old` 值相同，则存储一个值。"],["atomic_cxchgweak_failrelaxed","如果当前值与 `old` 值相同，则存储一个值。"],["atomic_cxchgweak_rel","如果当前值与 `old` 值相同，则存储一个值。"],["atomic_cxchgweak_relaxed","如果当前值与 `old` 值相同，则存储一个值。"],["atomic_fence","原子 fence。"],["atomic_fence_acq","原子 fence。"],["atomic_fence_acqrel","原子 fence。"],["atomic_fence_rel","原子 fence。"],["atomic_load","加载指针的当前值。"],["atomic_load_acq","加载指针的当前值。"],["atomic_load_relaxed","加载指针的当前值。"],["atomic_load_unordered",""],["atomic_max","使用带符号的比较将当前值设为最大值。"],["atomic_max_acq","使用带符号的比较将当前值设为最大值。"],["atomic_max_acqrel","使用带符号的比较将当前值设为最大值。"],["atomic_max_rel","使用带符号的比较将当前值设为最大值。"],["atomic_max_relaxed","当前值的最大值。"],["atomic_min","使用带符号的比较将当前值设为最小值。"],["atomic_min_acq","使用带符号的比较将当前值设为最小值。"],["atomic_min_acqrel","使用带符号的比较将当前值设为最小值。"],["atomic_min_rel","使用带符号的比较将当前值设为最小值。"],["atomic_min_relaxed","使用带符号的比较将当前值设为最小值。"],["atomic_nand","对当前值按位与，返回前一个值。"],["atomic_nand_acq","对当前值按位与，返回前一个值。"],["atomic_nand_acqrel","对当前值按位与，返回前一个值。"],["atomic_nand_rel","对当前值按位与，返回前一个值。"],["atomic_nand_relaxed","对当前值按位与，返回前一个值。"],["atomic_or","按位或具有当前值，返回前一个值。"],["atomic_or_acq","按位或具有当前值，返回前一个值。"],["atomic_or_acqrel","按位或具有当前值，返回前一个值。"],["atomic_or_rel","按位或具有当前值，返回前一个值。"],["atomic_or_relaxed","按位或具有当前值，返回前一个值。"],["atomic_singlethreadfence","仅编译器的内存屏障。"],["atomic_singlethreadfence_acq","仅编译器的内存屏障。"],["atomic_singlethreadfence_acqrel","仅编译器的内存屏障。"],["atomic_singlethreadfence_rel","仅编译器的内存屏障。"],["atomic_store","将值存储在指定的存储位置。"],["atomic_store_rel","将值存储在指定的存储位置。"],["atomic_store_relaxed","将值存储在指定的存储位置。"],["atomic_store_unordered",""],["atomic_umax","使用无符号比较将当前值设为最大值。"],["atomic_umax_acq","使用无符号比较将当前值设为最大值。"],["atomic_umax_acqrel","使用无符号比较将当前值设为最大值。"],["atomic_umax_rel","使用无符号比较将当前值设为最大值。"],["atomic_umax_relaxed","使用无符号比较将当前值设为最大值。"],["atomic_umin","使用无符号比较，使用当前值的最小值。"],["atomic_umin_acq","使用无符号比较，使用当前值的最小值。"],["atomic_umin_acqrel","使用无符号比较，使用当前值的最小值。"],["atomic_umin_rel","使用无符号比较，使用当前值的最小值。"],["atomic_umin_relaxed","使用无符号比较，使用当前值的最小值。"],["atomic_xadd","加到当前值，返回前一个值。"],["atomic_xadd_acq","加到当前值，返回前一个值。"],["atomic_xadd_acqrel","加到当前值，返回前一个值。"],["atomic_xadd_rel","加到当前值，返回前一个值。"],["atomic_xadd_relaxed","加到当前值，返回前一个值。"],["atomic_xchg","将值存储在指定的内存位置，并返回旧值。"],["atomic_xchg_acq","将值存储在指定的内存位置，并返回旧值。"],["atomic_xchg_acqrel","将值存储在指定的内存位置，并返回旧值。"],["atomic_xchg_rel","将值存储在指定的内存位置，并返回旧值。"],["atomic_xchg_relaxed","将值存储在指定的内存位置，并返回旧值。"],["atomic_xor","与当前值按位异或，返回前一个值。"],["atomic_xor_acq","与当前值按位异或，返回前一个值。"],["atomic_xor_acqrel","与当前值按位异或，返回前一个值。"],["atomic_xor_rel","与当前值按位异或，返回前一个值。"],["atomic_xor_relaxed","与当前值按位异或，返回前一个值。"],["atomic_xsub","从当前值减去，返回前一个值。"],["atomic_xsub_acq","从当前值减去，返回前一个值。"],["atomic_xsub_acqrel","从当前值减去，返回前一个值。"],["atomic_xsub_rel","从当前值减去，返回前一个值。"],["atomic_xsub_relaxed","从当前值减去，返回前一个值。"],["bitreverse","反转整数类型 `T` 中的位。"],["breakpoint","执行一个断点陷阱，以供调试器检查。"],["bswap","反转整数类型 `T` 中的字节。"],["caller_location","获取对静态 `Location` 的引用，以指示在何处调用了它。"],["ceilf32","返回大于或等于 `f32` 的最小整数。"],["ceilf64","返回大于或等于 `f64` 的最小整数。"],["const_allocate","在编译时分配。不应在运行时调用。"],["copy","将 `count * size_of::<T>()` 字节从 `src` 复制到 `dst`。源和目标可能会重叠。"],["copy_nonoverlapping","将 `count * size_of::<T>()` 字节从 `src` 复制到 `dst`。源和目标必须不重叠。"],["copysignf32","将 `f32` 值的符号从 `y` 复制到 `x`。"],["copysignf64","将 `f64` 值的符号从 `y` 复制到 `x`。"],["cosf32","返回 `f32` 的余弦值。"],["cosf64","返回 `f64` 的余弦值。"],["ctlz","返回整数类型 `T` 的前导未设置位 (zeroes) 的数量。"],["ctlz_nonzero","类似于 `ctlz`，但是非常不安全，因为当给定值 `0` 的 `x` 时，它返回 `undef`。"],["ctpop","返回整数类型 `T` 中设置的位数"],["cttz","返回整数类型 `T` 的尾随未设置位 (zeroes) 的数量。"],["cttz_nonzero","类似于 `cttz`，但是非常不安全，因为当给定值 `0` 的 `x` 时，它返回 `undef`。"],["discriminant_value","返回 ‘v’ 中成员的判别式的值; 如果 `T` 没有判别，则返回 `0`。"],["drop_in_place",""],["exact_div","执行精确除法，从而导致 `x % y != 0` 或 `y == 0` 或 `x == T::MIN && y == -1` 出现不确定的行为"],["exp2f32","返回 2 乘以 `f32` 的幂。"],["exp2f64","返回 2 乘以 `f64` 的幂。"],["expf32","返回 `f32` 的指数。"],["expf64","返回 `f64` 的指数。"],["fabsf32","返回 `f32` 的绝对值。"],["fabsf64","返回 `f64` 的绝对值。"],["fadd_fast","浮点数加法允许基于代数规则进行优化。 可以假设输入是有限的。"],["fdiv_fast","浮点除法允许基于代数规则进行优化。 可以假设输入是有限的。"],["float_to_int_unchecked","使用 LLVM 的 fptoui/fptosi 进行转换，对于越界的值可能会返回 undef (https://github.com/rust-lang/rust/issues/10184)"],["floorf32","返回小于或等于 `f32` 的最大整数。"],["floorf64","返回小于或等于 `f64` 的最大整数。"],["fmaf32","为 `f32` 值返回 `a * b + c`。"],["fmaf64","为 `f64` 值返回 `a * b + c`。"],["fmul_fast","浮点乘法允许基于代数规则进行优化。 可以假设输入是有限的。"],["forget","将值移出作用域。而无需运行丢弃守卫。"],["frem_fast","浮余数允许基于代数规则进行优化。 可以假设输入是有限的。"],["fsub_fast","浮点减法允许基于代数规则进行优化。 可以假设输入是有限的。"],["likely","提示编译器分支条件很可能是正确的。 返回传递给它的值。"],["log10f32","返回 `f32` 的以 10 为底的对数。"],["log10f64","返回 `f64` 的以 10 为底的对数。"],["log2f32","返回 `f32` 的以 2 为底的对数。"],["log2f64","返回 `f64` 的以 2 为底的对数。"],["logf32","返回 `f32` 的自然对数。"],["logf64","返回 `f64` 的自然对数。"],["maxnumf32","返回两个 `f32` 值的最大值。"],["maxnumf64","返回两个 `f64` 值的最大值。"],["min_align_of","类型的最小对齐方式。"],["min_align_of_val","参考值的所需对齐方式。"],["minnumf32","返回两个 `f32` 值中的最小值。"],["minnumf64","返回两个 `f64` 值中的最小值。"],["mul_with_overflow","执行检查的整数乘法"],["nearbyintf32","返回最接近 `f32` 的整数。"],["nearbyintf64","返回最接近 `f64` 的整数。"],["needs_drop","如果 `T` 给出的实际类型需要丢弃 glue，则返回 `true`。如果为 `T` 提供的实际类型实现 `Copy`，则返回 `false`。"],["nontemporal_store","根据 LLVM 发出 `!nontemporal` 存储 (请参见其文档)。 可能永远都不会变得稳定。"],["offset","计算与指针的偏移量。"],["powf32","将 `f32` 提升到 `f32` 的幂。"],["powf64","将 `f64` 提升到 `f64` 的幂。"],["powif32","将 `f32` 提升为整数幂。"],["powif64","将 `f64` 提升为整数幂。"],["pref_align_of","类型的首选对齐方式。"],["prefetch_read_data","`prefetch` 内联函数是对代码生成器的提示，如果支持的话，它会插入一个预取指令。否则，它是无操作的。 预取对程序的行为没有影响，但可以更改其性能特征。"],["prefetch_read_instruction","`prefetch` 内联函数是对代码生成器的提示，如果支持的话，它会插入一个预取指令。否则，它是无操作的。 预取对程序的行为没有影响，但可以更改其性能特征。"],["prefetch_write_data","`prefetch` 内联函数是对代码生成器的提示，如果支持的话，它会插入一个预取指令。否则，它是无操作的。 预取对程序的行为没有影响，但可以更改其性能特征。"],["prefetch_write_instruction","`prefetch` 内联函数是对代码生成器的提示，如果支持的话，它会插入一个预取指令。否则，它是无操作的。 预取对程序的行为没有影响，但可以更改其性能特征。"],["ptr_guaranteed_eq","有关详细信息，请参见 `<*const T>::guaranteed_eq` 的文档。"],["ptr_guaranteed_ne","有关详细信息，请参见 `<*const T>::guaranteed_ne` 的文档。"],["ptr_offset_from","有关详细信息，请参见 `<*const T>::offset_from` 的文档。"],["rintf32","返回最接近 `f32` 的整数。 如果参数不是整数，则可能会引发不精确的浮点异常。"],["rintf64","返回最接近 `f64` 的整数。 如果参数不是整数，则可能会引发不精确的浮点异常。"],["rotate_left","向左旋转。"],["rotate_right","向右旋转。"],["roundf32","返回最接近 `f32` 的整数。将中途案例从零舍入。"],["roundf64","返回最接近 `f64` 的整数。将中途案例从零舍入。"],["rustc_peek","从函数附带的属性中获取其含义的魔术内联函数。"],["saturating_add","计算 `a + b`，在数字范围内达到饱和。"],["saturating_sub","计算 `a - b`，在数字范围内达到饱和。"],["sinf32","返回 `f32` 的正弦值。"],["sinf64","返回 `f64` 的正弦值。"],["size_of","类型的大小 (以字节为单位)。"],["size_of_val","引用值的大小 (以字节为单位)。"],["sqrtf32","返回 `f32` 的平方根"],["sqrtf64","返回 `f64` 的平方根"],["sub_with_overflow","执行检查的整数减法"],["transmute","将一种类型的值的位重新解释为另一种类型。"],["truncf32","返回 `f32` 的整数部分。"],["truncf64","返回 `f64` 的整数部分。"],["try","Rust 的 “try catch” 构造使用数据指针 `data` 调用函数指针 `try_fn`。"],["type_id","获取一个标识符，该标识符对于指定的类型是全局唯一的。 无论调用哪个 crate，此函数都将为类型返回相同的值。"],["type_name","获取包含类型名称的静态字符串切片。"],["unaligned_volatile_load","从 `src` 指针执行易失性加载不需要将指针对齐。"],["unaligned_volatile_store","对 `dst` 指针执行易失性存储。 指针不需要对齐。"],["unchecked_add","返回未经检查的加法运算的结果，导致 `x + y > T::MAX` 或 `x + y < T::MIN` 出现不确定的行为。"],["unchecked_div","执行未经检查的除法，从而导致 `y == 0` 或 `x == T::MIN && y == -1` 出现不确定的行为"],["unchecked_mul","返回未经检查的乘法的结果，当 `x *y > T::MAX` 或 `x* y < T::MIN` 时导致未定义的行为。"],["unchecked_rem","返回未经检查的除法的其余部分，从而在 `y == 0` 或 `x == T::MIN && y == -1` 时导致未定义的行为"],["unchecked_shl","执行未经检查的左移，导致 `y < 0` 或 `y >= N` 出现不确定的行为，其中 N 是 T 的宽度 (以位为单位)。"],["unchecked_shr","执行未经检查的右移，导致 `y < 0` 或 `y >= N` 出现不确定的行为，其中 N 是 T 的宽度 (以位为单位)。"],["unchecked_sub","返回未经检查的减法的结果，当 `x - y > T::MAX` 或 `x - y < T::MIN` 时导致未定义的行为。"],["unlikely","提示编译器分支条件可能为 false。 返回传递给它的值。"],["unreachable","通知优化器代码中的这一点不可访问，从而可以进行进一步的优化。"],["variant_count","返回强制转换为 `usize` 的 `T` 类型的成员的数量; 如果 `T` 没有成员，则返回 `0`。无人居住的成员将被计算在内。"],["volatile_copy_memory","等效于适当的 `llvm.memmove.p0i8.0i8.*` 本征，大小为 `count* size_of::<T>()`，对齐方式为"],["volatile_copy_nonoverlapping_memory","等效于适当的 `llvm.memcpy.p0i8.0i8.*` 本征，大小为 `count`*`size_of::<T>()`，对齐方式为"],["volatile_load","从 `src` 指针执行易失性加载。"],["volatile_set_memory","等效于适当的 `llvm.memset.p0i8.*` 内联函数，其大小为 `count* size_of::<T>()`，并且对齐方式为 `min_align_of::<T>()`。"],["volatile_store","对 `dst` 指针执行易失性存储。"],["wrapping_add","返回 (a + b) mod 2 N，其中 N 是 T 的宽度 (以位为单位)。"],["wrapping_mul","返回 (a * b) mod 2 N，其中 N 是 T 的宽度 (以位为单位)。"],["wrapping_sub","返回 (a-b) mod 2 N，其中 N 是 T 的宽度 (以位为单位)。"],["write_bytes","将从 `dst` 开始的 `count * size_of::<T>()` 内存字节设置为 `val`。"]]});