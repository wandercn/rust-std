initSidebarItems({"fn":[["align_of","返回 ABI 要求的类型的最小对齐方式。"],["align_of_val","返回 ABI 所需的 `val` 指向的值的类型的最小对齐方式。"],["align_of_val_raw","返回 ABI 所需的 `val` 指向的值的类型的最小对齐方式。"],["discriminant","返回唯一标识 `v` 中的枚举成员的值。"],["drop","处理一个值。"],["forget","在不运行其析构函数 的情况下，获取所有权和 “forgets” 值。"],["forget_unsized","与 [`forget`] 一样，但也接受未定义大小的值。"],["min_align_of","返回 ABI 要求的类型的最小对齐方式。"],["min_align_of_val","返回 ABI 所需的 `val` 指向的值的类型的最小对齐方式。"],["needs_drop","如果丢弃类型为 `T` 的值很重要，则返回 `true`。"],["replace","将 `src` 移至引用的 `dest`，返回先前的 `dest` 值。"],["size_of","返回类型的大小 (以字节为单位)。"],["size_of_val","返回所指向的值的大小 (以字节为单位)。"],["size_of_val_raw","返回所指向的值的大小 (以字节为单位)。"],["swap","在两个可变位置交换值，而无需对其中一个进行初始化。"],["take","用默认值 `T` 替换 `dest`，并返回以前的 `dest` 值。"],["transmute","将一种类型的值的位重新解释为另一种类型。"],["transmute_copy","将 `src` 解释为具有 `&U` 类型，然后在不移动所包含的值的情况下读取 `src`。"],["uninitialized","假装产生 `T` 类型的值，而实际上什么也不做，从而绕过 Rust 的常规内存初始化检查。"],["variant_count","返回枚举类型 `T` 中的成员数。"],["zeroed","返回由全零字节模式表示的 `T` 类型的值。"]],"struct":[["Discriminant","代表枚举的不透明类型。"],["ManuallyDrop","包装器，用于禁止编译器自动调用 T 的析构函数。 该包装器的成本为 0。"]],"union":[["MaybeUninit","包装器类型，用于创建 `T` 的未初始化实例。"]]});