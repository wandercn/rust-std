<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="用于格式化和打印 `String`s 的实用工具。"><meta name="keywords" content="rust, rustlang, rust-lang, fmt"><title>alloc::fmt - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize1.55.0.css"><link rel="stylesheet" type="text/css" href="../../rustdoc1.55.0.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light1.55.0.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark1.55.0.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu1.55.0.css" disabled ><script id="default-settings"></script><script src="../../storage1.55.0.js"></script><script src="../../crates1.55.0.js"></script><noscript><link rel="stylesheet" href="../../noscript1.55.0.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon1.55.0.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x161.55.0.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x321.55.0.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow1.55.0.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../alloc/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo1.55.0.png' alt='logo'></div></a><h2 class="location">Module fmt</h2><div class="sidebar-elems"><div class="block items"><ul><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div><div id="sidebar-vars" data-name="fmt" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img src="../../brush1.55.0.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img src="../../wheel1.55.0.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">alloc</a>::<wbr><a class="mod" href="#">fmt</a><button id="copy-path" onclick="copy_path(this)" title="copy path"><img src="../../clipboard1.55.0.svg" width="19" height="18" alt="Copy item import" title="Copy item import to clipboard"></button></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/alloc/fmt.rs.html#1-585" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>用于格式化和打印 <code>String</code>s 的实用工具。</p>
<p>该模块包含对 <a href="../macro.format.html"><code>format!</code></a> 语法扩展的运行时支持。
该宏在编译器中实现，以发出对该模块的调用，以便在运行时将参数格式化为字符串。</p>
<h1 id="usage" class="section-header"><a href="#usage">Usage</a></h1>
<p><a href="../macro.format.html"><code>format!</code></a> 宏旨在使那些使用 C 的 <code>printf</code>/<code>fprintf</code> 函数或 Python 的 <code>str.format</code> 函数的用户熟悉。</p>
<p><a href="../macro.format.html"><code>format!</code></a> 扩展的一些示例是:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">format!</span>(<span class="string">&quot;Hello&quot;</span>);                 <span class="comment">// =&gt; &quot;Hello&quot;</span>
<span class="macro">format!</span>(<span class="string">&quot;Hello, {}!&quot;</span>, <span class="string">&quot;world&quot;</span>);   <span class="comment">// =&gt; &quot;Hello, world!&quot;</span>
<span class="macro">format!</span>(<span class="string">&quot;The number is {}&quot;</span>, <span class="number">1</span>);   <span class="comment">// =&gt; &quot;The number is 1&quot;</span>
<span class="macro">format!</span>(<span class="string">&quot;{:?}&quot;</span>, (<span class="number">3</span>, <span class="number">4</span>));          <span class="comment">// =&gt; &quot;(3, 4)&quot;</span>
<span class="macro">format!</span>(<span class="string">&quot;{value}&quot;</span>, <span class="ident">value</span><span class="op">=</span><span class="number">4</span>);      <span class="comment">// =&gt; &quot;4&quot;</span>
<span class="macro">format!</span>(<span class="string">&quot;{} {}&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);           <span class="comment">// =&gt; &quot;1 2&quot;</span>
<span class="macro">format!</span>(<span class="string">&quot;{:04}&quot;</span>, <span class="number">42</span>);             <span class="comment">// =&gt; &quot;0042&quot; 带前导零</span>
<span class="macro">format!</span>(<span class="string">&quot;{:#?}&quot;</span>, (<span class="number">100</span>, <span class="number">200</span>));     <span class="comment">// =&gt; &quot;(</span>
                                  <span class="comment">// 100,</span>
                                  <span class="comment">//       200, )&quot;</span>
                                  <span class="comment">//</span></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aformat!(%22Hello%22)%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%3D%3E%20%22Hello%22%0Aformat!(%22Hello%2C%20%7B%7D!%22%2C%20%22world%22)%3B%20%20%20%2F%2F%20%3D%3E%20%22Hello%2C%20world!%22%0Aformat!(%22The%20number%20is%20%7B%7D%22%2C%201)%3B%20%20%20%2F%2F%20%3D%3E%20%22The%20number%20is%201%22%0Aformat!(%22%7B%3A%3F%7D%22%2C%20(3%2C%204))%3B%20%20%20%20%20%20%20%20%20%20%2F%2F%20%3D%3E%20%22(3%2C%204)%22%0Aformat!(%22%7Bvalue%7D%22%2C%20value%3D4)%3B%20%20%20%20%20%20%2F%2F%20%3D%3E%20%224%22%0Aformat!(%22%7B%7D%20%7B%7D%22%2C%201%2C%202)%3B%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%3D%3E%20%221%202%22%0Aformat!(%22%7B%3A04%7D%22%2C%2042)%3B%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%3D%3E%20%220042%22%20%E5%B8%A6%E5%89%8D%E5%AF%BC%E9%9B%B6%0Aformat!(%22%7B%3A%23%3F%7D%22%2C%20(100%2C%20200))%3B%20%20%20%20%20%2F%2F%20%3D%3E%20%22(%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20100%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%20%20%20%20%20%20200%2C%20)%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%0A%7D&amp;edition=2018">Run</a></div>
<p>从这些中，您可以看到第一个参数是格式字符串。编译器要求它是字符串字面量; 它不能是传入的变量 (以执行有效性检查)。
然后，编译器将解析格式字符串，并确定所提供的参数列表是否适合传递给该格式字符串。</p>
<p>要将单个值转换为字符串，请使用 <a href="../string/trait.ToString.html"><code>to_string</code></a> 方法。这将使用 <a href="trait.Display.html" title="Display"><code>Display</code></a> 格式 trait。</p>
<h2 id="位置参数" class="section-header"><a href="#位置参数">位置参数</a></h2>
<p>允许每个格式参数指定其引用的值参数，如果省略，则假定为 “the next argument”。
例如，格式字符串 <code>{} {} {}</code> 将带有三个参数，并且将按照给定的顺序对其进行格式化。
但是，格式字符串 <code>{2} {1} {0}</code> 将以相反的顺序格式化参数。</p>
<p>一旦开始将两种类型的位置说明符混合在一起，事情就会变得有些棘手。可以将 “next argument” 说明符视为参数的迭代器。
每次看到 “next argument” 说明符时，迭代器都会前进。这导致这样的行为:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">format!</span>(<span class="string">&quot;{1} {} {0} {}&quot;</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// =&gt; &quot;2 1 1 2&quot;</span></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aformat!(%22%7B1%7D%20%7B%7D%20%7B0%7D%20%7B%7D%22%2C%201%2C%202)%3B%20%2F%2F%20%3D%3E%20%222%201%201%202%22%0A%7D&amp;edition=2018">Run</a></div>
<p>看到第一个 <code>{}</code> 时，尚未对参数进行内部迭代，因此它将打印第一个参数。然后，在到达第二个 <code>{}</code> 时，迭代器已前进到第二个参数。
本质上，在位置说明符方面，明确命名其参数的参数不会影响未命名参数的参数。</p>
<p>必须使用格式字符串才能使用其所有参数，否则将导致编译时错误。您可能在格式字符串中多次引用同一参数。</p>
<h2 id="命名参数" class="section-header"><a href="#命名参数">命名参数</a></h2>
<p>Rust 本身不具有类似于 Python 的等效于函数的命名参数，但是 <a href="../macro.format.html"><code>format!</code></a> 宏是一种语法扩展，允许它利用命名参数。
命名参数列在参数列表的末尾，并具有以下语法:</p>
<pre><code class="language-text">identifier '=' expression
</code></pre>
<p>例如，以下 <a href="../macro.format.html"><code>format!</code></a> 表达式都使用命名参数:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">format!</span>(<span class="string">&quot;{argument}&quot;</span>, <span class="ident">argument</span> <span class="op">=</span> <span class="string">&quot;test&quot;</span>);   <span class="comment">// =&gt; &quot;test&quot;</span>
<span class="macro">format!</span>(<span class="string">&quot;{name} {}&quot;</span>, <span class="number">1</span>, <span class="ident">name</span> <span class="op">=</span> <span class="number">2</span>);          <span class="comment">// =&gt; &quot;2 1&quot;</span>
<span class="macro">format!</span>(<span class="string">&quot;{a} {c} {b}&quot;</span>, <span class="ident">a</span><span class="op">=</span><span class="string">&quot;a&quot;</span>, <span class="ident">b</span><span class="op">=</span><span class="string">&#39;b&#39;</span>, <span class="ident">c</span><span class="op">=</span><span class="number">3</span>);  <span class="comment">// =&gt; &quot;a 3 b&quot;</span></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aformat!(%22%7Bargument%7D%22%2C%20argument%20%3D%20%22test%22)%3B%20%20%20%2F%2F%20%3D%3E%20%22test%22%0Aformat!(%22%7Bname%7D%20%7B%7D%22%2C%201%2C%20name%20%3D%202)%3B%20%20%20%20%20%20%20%20%20%20%2F%2F%20%3D%3E%20%222%201%22%0Aformat!(%22%7Ba%7D%20%7Bc%7D%20%7Bb%7D%22%2C%20a%3D%22a%22%2C%20b%3D'b'%2C%20c%3D3)%3B%20%20%2F%2F%20%3D%3E%20%22a%203%20b%22%0A%7D&amp;edition=2018">Run</a></div>
<p>在具有名称的参数之后放置位置参数 (那些没有名称的参数) 是无效的。与位置参数一样，提供格式字符串未使用的命名参数也是无效的。</p>
<h1 id="格式化参数" class="section-header"><a href="#格式化参数">格式化参数</a></h1>
<p>每个要格式化的参数都可以通过许多格式化参数进行转换 (对应于 <a href="#syntax">the syntax</a>) 中的 <code>format_spec</code>。这些参数会影响所格式化内容的字符串表示形式。</p>
<h2 id="width" class="section-header"><a href="#width">Width</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// 所有这些打印 &quot;Hello x !&quot;</span>
<span class="macro">println!</span>(<span class="string">&quot;Hello {:5}!&quot;</span>, <span class="string">&quot;x&quot;</span>);
<span class="macro">println!</span>(<span class="string">&quot;Hello {:1$}!&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="number">5</span>);
<span class="macro">println!</span>(<span class="string">&quot;Hello {1:0$}!&quot;</span>, <span class="number">5</span>, <span class="string">&quot;x&quot;</span>);
<span class="macro">println!</span>(<span class="string">&quot;Hello {:width$}!&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="ident">width</span> <span class="op">=</span> <span class="number">5</span>);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%2F%2F%20%E6%89%80%E6%9C%89%E8%BF%99%E4%BA%9B%E6%89%93%E5%8D%B0%20%22Hello%20x%20!%22%0Afn%20main()%20%7B%0Aprintln!(%22Hello%20%7B%3A5%7D!%22%2C%20%22x%22)%3B%0Aprintln!(%22Hello%20%7B%3A1%24%7D!%22%2C%20%22x%22%2C%205)%3B%0Aprintln!(%22Hello%20%7B1%3A0%24%7D!%22%2C%205%2C%20%22x%22)%3B%0Aprintln!(%22Hello%20%7B%3Awidth%24%7D!%22%2C%20%22x%22%2C%20width%20%3D%205)%3B%0A%7D&amp;edition=2018">Run</a></div>
<p>这是格式应使用的 “minimum width” 的参数。
如果值的字符串不能填满这么多字符，则 fill/alignment 指定的填充将用于占用所需的空间 (请参见下文)。</p>
<p>通过添加后缀 <code>$</code> (表示第二个参数是指定宽度的 <a href="https://doc.rust-lang.org/1.54.0/std/primitive.usize.html" title="usize"><code>usize</code></a>)，也可以在参数列表中以 <a href="https://doc.rust-lang.org/1.54.0/std/primitive.usize.html" title="usize"><code>usize</code></a> 的形式提供宽度值。</p>
<p>使用 Dollar 语法引用参数不会影响 “next argument” 计数器，因此按位置引用参数或使用命名参数通常是一个好主意。</p>
<h2 id="fillalignment" class="section-header"><a href="#fillalignment">Fill/Alignment</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;Hello {:&lt;5}!&quot;</span>, <span class="string">&quot;x&quot;</span>),  <span class="string">&quot;Hello x    !&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;Hello {:-&lt;5}!&quot;</span>, <span class="string">&quot;x&quot;</span>), <span class="string">&quot;Hello x----!&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;Hello {:^5}!&quot;</span>, <span class="string">&quot;x&quot;</span>),  <span class="string">&quot;Hello   x  !&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;Hello {:&gt;5}!&quot;</span>, <span class="string">&quot;x&quot;</span>),  <span class="string">&quot;Hello     x!&quot;</span>);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(format!(%22Hello%20%7B%3A%3C5%7D!%22%2C%20%22x%22)%2C%20%20%22Hello%20x%20%20%20%20!%22)%3B%0Aassert_eq!(format!(%22Hello%20%7B%3A-%3C5%7D!%22%2C%20%22x%22)%2C%20%22Hello%20x----!%22)%3B%0Aassert_eq!(format!(%22Hello%20%7B%3A%5E5%7D!%22%2C%20%22x%22)%2C%20%20%22Hello%20%20%20x%20%20!%22)%3B%0Aassert_eq!(format!(%22Hello%20%7B%3A%3E5%7D!%22%2C%20%22x%22)%2C%20%20%22Hello%20%20%20%20%20x!%22)%3B%0A%7D&amp;edition=2018">Run</a></div>
<p>可选的填充字符和对齐方式通常与 <a href="#width"><code>width</code></a> 参数一起提供。必须在 <code>width</code> 之前，<code>:</code> 之后定义。
这表示如果要格式化的值小于 <code>width</code>，则将在其周围打印一些额外的字符。
填充来自以下成员，用于不同的对齐方式:</p>
<ul>
<li><code>[fill]&lt;</code> - 该参数在 <code>width</code> 列中左对齐</li>
<li><code>[fill]^</code> - 该参数在 <code>width</code> 列中居中对齐</li>
<li><code>[fill]&gt;</code> - 参数在 <code>width</code> 列中右对齐</li>
</ul>
<p>非数字的默认 <a href="#fillalignment">fill/alignment</a> 是空格，并且左对齐。数字格式器的默认值也是空格字符，但带有右对齐。
如果为数字指定了 <code>0</code> 标志 (见下文)，则隐式填充字符为 <code>0</code>。</p>
<p>请注意，某些类型可能无法实现对齐。特别是，对于 <code>Debug</code> trait，通常不会实现该功能。
确保应用填充的一种好方法是格式化输入，然后填充此结果字符串以获得输出:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">println!</span>(<span class="string">&quot;Hello {:^15}!&quot;</span>, <span class="macro">format!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="prelude-val">Some</span>(<span class="string">&quot;hi&quot;</span>))); <span class="comment">// =&gt; &quot;Hello   Some(&quot;hi&quot;)   !&quot;</span></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aprintln!(%22Hello%20%7B%3A%5E15%7D!%22%2C%20format!(%22%7B%3A%3F%7D%22%2C%20Some(%22hi%22)))%3B%20%2F%2F%20%3D%3E%20%22Hello%20%20%20Some(%22hi%22)%20%20%20!%22%0A%7D&amp;edition=2018">Run</a></div>
<h2 id="sign0" class="section-header"><a href="#sign0">Sign/<code>#</code>/<code>0</code></a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;Hello {:+}!&quot;</span>, <span class="number">5</span>), <span class="string">&quot;Hello +5!&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{:#x}!&quot;</span>, <span class="number">27</span>), <span class="string">&quot;0x1b!&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;Hello {:05}!&quot;</span>, <span class="number">5</span>),  <span class="string">&quot;Hello 00005!&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;Hello {:05}!&quot;</span>, <span class="op">-</span><span class="number">5</span>), <span class="string">&quot;Hello -0005!&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{:#010x}!&quot;</span>, <span class="number">27</span>), <span class="string">&quot;0x0000001b!&quot;</span>);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(format!(%22Hello%20%7B%3A%2B%7D!%22%2C%205)%2C%20%22Hello%20%2B5!%22)%3B%0Aassert_eq!(format!(%22%7B%3A%23x%7D!%22%2C%2027)%2C%20%220x1b!%22)%3B%0Aassert_eq!(format!(%22Hello%20%7B%3A05%7D!%22%2C%205)%2C%20%20%22Hello%2000005!%22)%3B%0Aassert_eq!(format!(%22Hello%20%7B%3A05%7D!%22%2C%20-5)%2C%20%22Hello%20-0005!%22)%3B%0Aassert_eq!(format!(%22%7B%3A%23010x%7D!%22%2C%2027)%2C%20%220x0000001b!%22)%3B%0A%7D&amp;edition=2018">Run</a></div>
<p>这些都是更改格式化程序行为的标志。</p>
<ul>
<li><code>+</code> - 这适用于数字类型，并指示应始终打印符号。默认情况下从不打印正号，默认情况下仅对有符号值打印负号。
该标志指示应始终打印正确的符号 (<code>+</code> 或 <code>-</code>)。</li>
<li><code>-</code> - 目前未使用</li>
<li><code>#</code> - 该标志指示应使用 “alternate” 打印形式。替代形式为:
<ul>
<li><code>#?</code> - 漂亮地打印 <a href="trait.Debug.html" title="Debug"><code>Debug</code></a> 格式 (添加换行符和缩进)</li>
<li><code>#x</code> - 在参数之前加上 <code>0x</code></li>
<li><code>#X</code> - 在参数之前加上 <code>0x</code></li>
<li><code>#b</code> - 在参数之前加上 <code>0b</code></li>
<li><code>#o</code> - 在参数之前加上 <code>0o</code></li>
</ul>
</li>
<li><code>0</code> - 这用于指示整数格式，到 <code>width</code> 的填充都应使用 <code>0</code> 字符完成，并且应注意符号。
像 <code>{:08}</code> 这样的格式将为整数 <code>1</code> 产生 <code>00000001</code>，而相同格式将为整数 <code>-1</code> 产生 <code>-0000001</code>。
请注意，负版本的零比正版本的少零。
请注意，填充零总是放在符号 (如果有) 之后和数字之前。当与 <code>#</code> 标志一起使用时，将应用类似的规则: 将填充零插入在前缀之后但在数字之前。
前缀包括在总宽度中。</li>
</ul>
<h2 id="precision" class="section-header"><a href="#precision">Precision</a></h2>
<p>对于非数字类型，可以将其视为 “maximum width”。
如果结果字符串的长度大于此宽度，则将其截断为这么多个字符，并且如果设置了这些参数，则会使用适当的 <code>fill</code>，<code>alignment</code> 和 <code>width</code> 发出该截断的值。</p>
<p>对于整数类型，这将被忽略。</p>
<p>对于浮点类型，这指示小数点后应打印多少位。</p>
<p>有三种可能的方法来指定所需的 <code>precision</code>:</p>
<ol>
<li>
<p>整数 <code>.N</code>:</p>
<p>整数 <code>N</code> 本身就是精度。</p>
</li>
<li>
<p>整数或名称后跟美元符号 <code>.N$</code>:</p>
<p>使用格式 <em>参数</em><code>N</code> (必须为 <code>usize</code>) 作为精度。</p>
</li>
<li>
<p>星号 <code>.*</code>:</p>
<p><code>.*</code> 表示此 <code>{...}</code> 与 <em>两个</em> 格式输入相关联，而不是与一个输入相关联: 第一个输入保存 <code>usize</code> 精度，第二个输入保存要打印的值。
请注意，在这种情况下，如果使用格式字符串 <code>{&lt;arg&gt;:&lt;spec&gt;.*}</code>，则 <code>&lt;arg&gt;</code> 部分将引用* value * 进行打印，并且 <code>precision</code> 必须位于 <code>&lt;arg&gt;</code> 之前的输入中。</p>
</li>
</ol>
<p>例如，以下所有调用均打印相同的内容 <code>Hello x is 0.01000</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// Hello {arg 0 (&quot;x&quot;)} is {arg 1 (0.01) with precision specified inline (5)}</span>
<span class="macro">println!</span>(<span class="string">&quot;Hello {0} is {1:.5}&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="number">0.01</span>);

<span class="comment">// Hello {arg 1 (&quot;x&quot;)} is {arg 2 (0.01) with precision specified in arg 0 (5)}</span>
<span class="macro">println!</span>(<span class="string">&quot;Hello {1} is {2:.0$}&quot;</span>, <span class="number">5</span>, <span class="string">&quot;x&quot;</span>, <span class="number">0.01</span>);

<span class="comment">// Hello {arg 0 (&quot;x&quot;)} is {arg 2 (0.01) with precision specified in arg 1 (5)}</span>
<span class="macro">println!</span>(<span class="string">&quot;Hello {0} is {2:.1$}&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="number">5</span>, <span class="number">0.01</span>);

<span class="comment">// Hello {next arg (&quot;x&quot;)} is {second of next two args (0.01) with precision specified in first of next two args (5)}</span>
<span class="comment">//</span>
<span class="macro">println!</span>(<span class="string">&quot;Hello {} is {:.*}&quot;</span>,    <span class="string">&quot;x&quot;</span>, <span class="number">5</span>, <span class="number">0.01</span>);

<span class="comment">// Hello {next arg (&quot;x&quot;)} is {arg 2 (0.01) with precision specified in its predecessor (5)}</span>
<span class="comment">//</span>
<span class="macro">println!</span>(<span class="string">&quot;Hello {} is {2:.*}&quot;</span>,   <span class="string">&quot;x&quot;</span>, <span class="number">5</span>, <span class="number">0.01</span>);

<span class="comment">// Hello {next arg (&quot;x&quot;)} is {arg &quot;number&quot; (0.01) with precision specified in arg &quot;prec&quot; (5)}</span>
<span class="comment">//</span>
<span class="macro">println!</span>(<span class="string">&quot;Hello {} is {number:.prec$}&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="ident">prec</span> <span class="op">=</span> <span class="number">5</span>, <span class="ident">number</span> <span class="op">=</span> <span class="number">0.01</span>);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%2F%2F%20Hello%20%7Barg%200%20(%22x%22)%7D%20is%20%7Barg%201%20(0.01)%20with%20precision%20specified%20inline%20(5)%7D%0Afn%20main()%20%7B%0Aprintln!(%22Hello%20%7B0%7D%20is%20%7B1%3A.5%7D%22%2C%20%22x%22%2C%200.01)%3B%0A%0A%2F%2F%20Hello%20%7Barg%201%20(%22x%22)%7D%20is%20%7Barg%202%20(0.01)%20with%20precision%20specified%20in%20arg%200%20(5)%7D%0Aprintln!(%22Hello%20%7B1%7D%20is%20%7B2%3A.0%24%7D%22%2C%205%2C%20%22x%22%2C%200.01)%3B%0A%0A%2F%2F%20Hello%20%7Barg%200%20(%22x%22)%7D%20is%20%7Barg%202%20(0.01)%20with%20precision%20specified%20in%20arg%201%20(5)%7D%0Aprintln!(%22Hello%20%7B0%7D%20is%20%7B2%3A.1%24%7D%22%2C%20%22x%22%2C%205%2C%200.01)%3B%0A%0A%2F%2F%20Hello%20%7Bnext%20arg%20(%22x%22)%7D%20is%20%7Bsecond%20of%20next%20two%20args%20(0.01)%20with%20precision%20specified%20in%20first%20of%20next%20two%20args%20(5)%7D%0A%2F%2F%0Aprintln!(%22Hello%20%7B%7D%20is%20%7B%3A.*%7D%22%2C%20%20%20%20%22x%22%2C%205%2C%200.01)%3B%0A%0A%2F%2F%20Hello%20%7Bnext%20arg%20(%22x%22)%7D%20is%20%7Barg%202%20(0.01)%20with%20precision%20specified%20in%20its%20predecessor%20(5)%7D%0A%2F%2F%0Aprintln!(%22Hello%20%7B%7D%20is%20%7B2%3A.*%7D%22%2C%20%20%20%22x%22%2C%205%2C%200.01)%3B%0A%0A%2F%2F%20Hello%20%7Bnext%20arg%20(%22x%22)%7D%20is%20%7Barg%20%22number%22%20(0.01)%20with%20precision%20specified%20in%20arg%20%22prec%22%20(5)%7D%0A%2F%2F%0Aprintln!(%22Hello%20%7B%7D%20is%20%7Bnumber%3A.prec%24%7D%22%2C%20%22x%22%2C%20prec%20%3D%205%2C%20number%20%3D%200.01)%3B%0A%7D&amp;edition=2018">Run</a></div>
<p>虽然这些:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">println!</span>(<span class="string">&quot;{}, `{name:.*}` has 3 fractional digits&quot;</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3</span>, <span class="ident">name</span><span class="op">=</span><span class="number">1234.56</span>);
<span class="macro">println!</span>(<span class="string">&quot;{}, `{name:.*}` has 3 characters&quot;</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3</span>, <span class="ident">name</span><span class="op">=</span><span class="string">&quot;1234.56&quot;</span>);
<span class="macro">println!</span>(<span class="string">&quot;{}, `{name:&gt;8.*}` has 3 right-aligned characters&quot;</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3</span>, <span class="ident">name</span><span class="op">=</span><span class="string">&quot;1234.56&quot;</span>);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aprintln!(%22%7B%7D%2C%20%60%7Bname%3A.*%7D%60%20has%203%20fractional%20digits%22%2C%20%22Hello%22%2C%203%2C%20name%3D1234.56)%3B%0Aprintln!(%22%7B%7D%2C%20%60%7Bname%3A.*%7D%60%20has%203%20characters%22%2C%20%22Hello%22%2C%203%2C%20name%3D%221234.56%22)%3B%0Aprintln!(%22%7B%7D%2C%20%60%7Bname%3A%3E8.*%7D%60%20has%203%20right-aligned%20characters%22%2C%20%22Hello%22%2C%203%2C%20name%3D%221234.56%22)%3B%0A%7D&amp;edition=2018">Run</a></div>
<p>打印三个明显不同的内容:</p>
<pre><code class="language-text">Hello, `1234.560` has 3 fractional digits
Hello, `123` has 3 characters
Hello, `     123` has 3 right-aligned characters
</code></pre>
<h2 id="localization" class="section-header"><a href="#localization">Localization</a></h2>
<p>在某些编程语言中，字符串格式函数的行为取决于操作系统的语言环境设置。
Rust 标准库提供的格式函数没有任何语言环境的概念，并且无论用户配置如何，在所有系统上都会产生相同的结果。</p>
<p>例如，即使系统区域设置使用小数点分隔符 (而不是点)，以下代码也将始终打印 <code>1.5</code>。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">println!</span>(<span class="string">&quot;The value is {}&quot;</span>, <span class="number">1.5</span>);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aprintln!(%22The%20value%20is%20%7B%7D%22%2C%201.5)%3B%0A%7D&amp;edition=2018">Run</a></div>
<h1 id="escaping" class="section-header"><a href="#escaping">Escaping</a></h1>
<p>字面量字符 <code>{</code> 和 <code>}</code> 可以通过在它们之前添加相同的字符而包含在字符串中。例如，<code>{</code> 字符使用 <code>{{</code> 进行转义，而 <code>}</code> 字符使用 <code>}}</code> 进行转义。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;Hello {{}}&quot;</span>), <span class="string">&quot;Hello {}&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{{ Hello&quot;</span>), <span class="string">&quot;{ Hello&quot;</span>);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(format!(%22Hello%20%7B%7B%7D%7D%22)%2C%20%22Hello%20%7B%7D%22)%3B%0Aassert_eq!(format!(%22%7B%7B%20Hello%22)%2C%20%22%7B%20Hello%22)%3B%0A%7D&amp;edition=2018">Run</a></div>
<h1 id="syntax" class="section-header"><a href="#syntax">Syntax</a></h1>
<p>总结一下，您可以在这里找到格式字符串的完整语法。
所用格式语言的语法是从其他语言中提取的，因此不应太陌生。参数使用类似 Python 的语法格式化，这意味着参数被 <code>{}</code> 包围，而不是类似 C 的 <code>%</code>。
格式化语法的实际语法为:</p>
<pre><code class="language-text">format_string := text [ maybe_format text ] *
maybe_format := '{' '{' | '}' '}' | format
format := '{' [ argument ] [ ':' format_spec ] '}'
argument := integer | identifier

format_spec := [[fill]align][sign]['#']['0'][width]['.' precision]type
fill := character
align := '&lt;' | '^' | '&gt;'
sign := '+' | '-'
width := count
precision := count | '*'
type := '' | '?' | 'x?' | 'X?' | identifier
count := parameter | integer
parameter := argument '$'
</code></pre>
<p>在以上语法中，<code>text</code> 不得包含任何 <code>'{'</code> 或 <code>'}'</code> 字符。</p>
<h1 id="格式化-traits" class="section-header"><a href="#格式化-traits">格式化 traits</a></h1>
<p>当请求使用特定类型的参数格式化时，实际上是在请求将参数归因于特定的 trait。
这允许通过 <code>{:x}</code> 格式化多种实际类型 (例如 <a href="https://doc.rust-lang.org/1.54.0/std/primitive.i8.html" title="i8"><code>i8</code></a> 和 <a href="https://doc.rust-lang.org/1.54.0/std/primitive.isize.html" title="isize"><code>isize</code></a>)。类型到 traits 的当前映射为:</p>
<ul>
<li><em>nothing</em> ⇒ <a href="trait.Display.html" title="Display"><code>Display</code></a></li>
<li><code>?</code> ⇒ <a href="trait.Debug.html" title="Debug"><code>Debug</code></a></li>
<li><code>x?</code> ⇒ <a href="trait.Debug.html" title="Debug"><code>Debug</code></a> 具有小写的十六进制整数</li>
<li><code>X?</code> ⇒ <a href="trait.Debug.html" title="Debug"><code>Debug</code></a> 具有大写的十六进制整数</li>
<li><code>o</code> ⇒ <a href="trait.Octal.html" title="Octal"><code>Octal</code></a></li>
<li><code>x</code> ⇒ <a href="trait.LowerHex.html" title="LowerHex"><code>LowerHex</code></a></li>
<li><code>X</code> ⇒ <a href="trait.UpperHex.html" title="UpperHex"><code>UpperHex</code></a></li>
<li><code>p</code> ⇒ <a href="trait.Pointer.html" title="Pointer"><code>Pointer</code></a></li>
<li><code>b</code> ⇒ <a href="trait.Binary.html" title="Binary"><code>Binary</code></a></li>
<li><code>e</code> ⇒ <a href="trait.LowerExp.html" title="LowerExp"><code>LowerExp</code></a></li>
<li><code>E</code> ⇒ <a href="trait.UpperExp.html" title="UpperExp"><code>UpperExp</code></a></li>
</ul>
<p>这意味着可以使用 <code>{:b}</code> 格式化实现 <a href="trait.Binary.html" title="Binary"><code>fmt::Binary</code></a> trait 的任何类型的参数。标准库还为许多原始类型提供了针对这些 traits 的实现。</p>
<p>如果未指定格式 (如 <code>{}</code> 或 <code>{:6}</code>)，则使用的格式 trait 为 <a href="trait.Display.html" title="Display"><code>Display</code></a> trait。</p>
<p>当为您自己的类型实现格式 trait 时，您将必须实现签名的方法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">fmt::Formatter</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">fmt::Result</span> {</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(dead_code)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Afmt%3B%0Astruct%20Foo%3B%20%2F%2F%20%E6%88%91%E4%BB%AC%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%0Aimpl%20fmt%3A%3ADisplay%20for%20Foo%20%7B%0Afn%20fmt(%26self%2C%20f%3A%20%26mut%20fmt%3A%3AFormatter)%20-%3E%20fmt%3A%3AResult%20%7B%0Awrite!(f%2C%20%22testing%2C%20testing%22)%0A%7D%20%7D%0A%7D&amp;edition=2018">Run</a></div>
<p>您的类型将作为 <code>self</code> by - 引用传递，然后函数应将输出发出到 <code>f.buf</code> 流中。正确遵守所请求的格式设置参数，取决于每种格式 trait 的实现。
这些参数的值将在 <a href="struct.Formatter.html" title="Formatter"><code>Formatter</code></a> 结构体的字段中列出。为了解决这个问题，<a href="struct.Formatter.html" title="Formatter"><code>Formatter</code></a> 结构体还提供了一些辅助方法。</p>
<p>另外，此函数的返回值为 <a href="type.Result.html"><code>fmt::Result</code></a>，它是 <a href="../../core/result/enum.Result.html"><code>Result</code></a><code>&lt; () 的类型别名， </code><a href="struct.Error.html"><code>std::fmt::Error</code></a><code>&gt;</code>.
格式化实现应确保它们传播来自 <a href="struct.Formatter.html" title="Formatter"><code>Formatter</code></a> 的错误 (例如，调用 <a href="../../core/macro.write.html"><code>write!</code></a> 时)。
但是，它们绝不能虚假地返回错误。
即，格式化实现必须并且仅在传入的 <a href="struct.Formatter.html" title="Formatter"><code>Formatter</code></a> 返回错误的情况下才返回错误。
这是因为，与函数签名可能暗示的相反，字符串格式是一项可靠的操作。
该函数仅返回结果，因为写入底层流可能会失败，并且它必须提供一种方法来将已发生错误的事实传播回栈。</p>
<p>实现格式 traits 的示例如下所示:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::fmt</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>)]</span>
<span class="kw">struct</span> <span class="ident">Vector2D</span> {
    <span class="ident">x</span>: <span class="ident">isize</span>,
    <span class="ident">y</span>: <span class="ident">isize</span>,
}

<span class="kw">impl</span> <span class="ident">fmt::Display</span> <span class="kw">for</span> <span class="ident">Vector2D</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">fmt::Formatter</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">fmt::Result</span> {
        <span class="comment">// `f` 值实现 `Write` trait，这就是写内容! 宏在期待。</span>
        <span class="comment">// 请注意，这种格式化将忽略为格式化字符串而提供的各种标志。</span>
        <span class="comment">//</span>
        <span class="macro">write!</span>(<span class="ident">f</span>, <span class="string">&quot;({}, {})&quot;</span>, <span class="self">self</span>.<span class="ident">x</span>, <span class="self">self</span>.<span class="ident">y</span>)
    }
}

<span class="comment">// 不同的 traits 允许类型的不同形式的输出。</span>
<span class="comment">// 此格式的含义是打印 vector 的大小。</span>
<span class="kw">impl</span> <span class="ident">fmt::Binary</span> <span class="kw">for</span> <span class="ident">Vector2D</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">fmt::Formatter</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">fmt::Result</span> {
        <span class="kw">let</span> <span class="ident">magnitude</span> <span class="op">=</span> (<span class="self">self</span>.<span class="ident">x</span> <span class="op">*</span> <span class="self">self</span>.<span class="ident">x</span> <span class="op">+</span> <span class="self">self</span>.<span class="ident">y</span> <span class="op">*</span> <span class="self">self</span>.<span class="ident">y</span>) <span class="kw">as</span> <span class="ident">f64</span>;
        <span class="kw">let</span> <span class="ident">magnitude</span> <span class="op">=</span> <span class="ident">magnitude</span>.<span class="ident">sqrt</span>();

        <span class="comment">// 通过使用 Formatter 对象上的帮助器方法 `pad_integral`，尊重格式设置标志。</span>
        <span class="comment">// 有关详细信息，请参见方法文档，并且函数 `pad` 可用于填充字符串。</span>
        <span class="comment">//</span>
        <span class="comment">//</span>
        <span class="kw">let</span> <span class="ident">decimals</span> <span class="op">=</span> <span class="ident">f</span>.<span class="ident">precision</span>().<span class="ident">unwrap_or</span>(<span class="number">3</span>);
        <span class="kw">let</span> <span class="ident">string</span> <span class="op">=</span> <span class="macro">format!</span>(<span class="string">&quot;{:.*}&quot;</span>, <span class="ident">decimals</span>, <span class="ident">magnitude</span>);
        <span class="ident">f</span>.<span class="ident">pad_integral</span>(<span class="bool-val">true</span>, <span class="string">&quot;&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">string</span>)
    }
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">myvector</span> <span class="op">=</span> <span class="ident">Vector2D</span> { <span class="ident">x</span>: <span class="number">3</span>, <span class="ident">y</span>: <span class="number">4</span> };

    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">myvector</span>);       <span class="comment">// =&gt; &quot;(3, 4)&quot;</span>
    <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">myvector</span>);     <span class="comment">// =&gt; &quot;Vector2D {x: 3, y:4}&quot;</span>
    <span class="macro">println!</span>(<span class="string">&quot;{:10.3b}&quot;</span>, <span class="ident">myvector</span>); <span class="comment">// =&gt; &quot;     5.000&quot;</span>
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Ause%20std%3A%3Afmt%3B%0A%0A%23%5Bderive(Debug)%5D%0Astruct%20Vector2D%20%7B%0A%20%20%20%20x%3A%20isize%2C%0A%20%20%20%20y%3A%20isize%2C%0A%7D%0A%0Aimpl%20fmt%3A%3ADisplay%20for%20Vector2D%20%7B%0A%20%20%20%20fn%20fmt(%26self%2C%20f%3A%20%26mut%20fmt%3A%3AFormatter)%20-%3E%20fmt%3A%3AResult%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20%60f%60%20%E5%80%BC%E5%AE%9E%E7%8E%B0%20%60Write%60%20trait%EF%BC%8C%E8%BF%99%E5%B0%B1%E6%98%AF%E5%86%99%E5%86%85%E5%AE%B9!%20%E5%AE%8F%E5%9C%A8%E6%9C%9F%E5%BE%85%E3%80%82%0A%20%20%20%20%20%20%20%20%2F%2F%20%E8%AF%B7%E6%B3%A8%E6%84%8F%EF%BC%8C%E8%BF%99%E7%A7%8D%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B0%86%E5%BF%BD%E7%95%A5%E4%B8%BA%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%80%8C%E6%8F%90%E4%BE%9B%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%87%E5%BF%97%E3%80%82%0A%20%20%20%20%20%20%20%20%2F%2F%0A%20%20%20%20%20%20%20%20write!(f%2C%20%22(%7B%7D%2C%20%7B%7D)%22%2C%20self.x%2C%20self.y)%0A%20%20%20%20%7D%0A%7D%0A%0A%2F%2F%20%E4%B8%8D%E5%90%8C%E7%9A%84%20traits%20%E5%85%81%E8%AE%B8%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%8D%E5%90%8C%E5%BD%A2%E5%BC%8F%E7%9A%84%E8%BE%93%E5%87%BA%E3%80%82%0A%2F%2F%20%E6%AD%A4%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%90%AB%E4%B9%89%E6%98%AF%E6%89%93%E5%8D%B0%20vector%20%E7%9A%84%E5%A4%A7%E5%B0%8F%E3%80%82%0Aimpl%20fmt%3A%3ABinary%20for%20Vector2D%20%7B%0A%20%20%20%20fn%20fmt(%26self%2C%20f%3A%20%26mut%20fmt%3A%3AFormatter)%20-%3E%20fmt%3A%3AResult%20%7B%0A%20%20%20%20%20%20%20%20let%20magnitude%20%3D%20(self.x%20*%20self.x%20%2B%20self.y%20*%20self.y)%20as%20f64%3B%0A%20%20%20%20%20%20%20%20let%20magnitude%20%3D%20magnitude.sqrt()%3B%0A%0A%20%20%20%20%20%20%20%20%2F%2F%20%E9%80%9A%E8%BF%87%E4%BD%BF%E7%94%A8%20Formatter%20%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%9A%84%E5%B8%AE%E5%8A%A9%E5%99%A8%E6%96%B9%E6%B3%95%20%60pad_integral%60%EF%BC%8C%E5%B0%8A%E9%87%8D%E6%A0%BC%E5%BC%8F%E8%AE%BE%E7%BD%AE%E6%A0%87%E5%BF%97%E3%80%82%0A%20%20%20%20%20%20%20%20%2F%2F%20%E6%9C%89%E5%85%B3%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%EF%BC%8C%E8%AF%B7%E5%8F%82%E8%A7%81%E6%96%B9%E6%B3%95%E6%96%87%E6%A1%A3%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%87%BD%E6%95%B0%20%60pad%60%20%E5%8F%AF%E7%94%A8%E4%BA%8E%E5%A1%AB%E5%85%85%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%82%0A%20%20%20%20%20%20%20%20%2F%2F%0A%20%20%20%20%20%20%20%20%2F%2F%0A%20%20%20%20%20%20%20%20let%20decimals%20%3D%20f.precision().unwrap_or(3)%3B%0A%20%20%20%20%20%20%20%20let%20string%20%3D%20format!(%22%7B%3A.*%7D%22%2C%20decimals%2C%20magnitude)%3B%0A%20%20%20%20%20%20%20%20f.pad_integral(true%2C%20%22%22%2C%20%26string)%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20myvector%20%3D%20Vector2D%20%7B%20x%3A%203%2C%20y%3A%204%20%7D%3B%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20myvector)%3B%20%20%20%20%20%20%20%2F%2F%20%3D%3E%20%22(3%2C%204)%22%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20myvector)%3B%20%20%20%20%20%2F%2F%20%3D%3E%20%22Vector2D%20%7Bx%3A%203%2C%20y%3A4%7D%22%0A%20%20%20%20println!(%22%7B%3A10.3b%7D%22%2C%20myvector)%3B%20%2F%2F%20%3D%3E%20%22%20%20%20%20%205.000%22%0A%7D&amp;edition=2018">Run</a></div>
<h3 id="fmtdisplay-与-fmtdebug" class="section-header"><a href="#fmtdisplay-与-fmtdebug"><code>fmt::Display</code> 与 <code>fmt::Debug</code></a></h3>
<p>这两种格式 traits 具有不同的用途:</p>
<ul>
<li><a href="trait.Display.html" title="Display"><code>fmt::Display</code></a> 实现断言该类型可以始终如实地表示为 UTF-8 字符串。并非所有类型都实现 <a href="trait.Display.html" title="Display"><code>Display</code></a> trait。</li>
<li><a href="trait.Debug.html" title="Debug"><code>fmt::Debug</code></a> 应该为 <strong>所有</strong> 公共类型实现实现。
输出通常会尽可能忠实地代表内部状态。
<a href="trait.Debug.html" title="Debug"><code>Debug</code></a> trait 的目的是方便调试 Rust 代码。在大多数情况下，建议使用 <code>#[derive(Debug)]</code> 就足够了。</li>
</ul>
<p>traits 的输出的一些示例:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{} {:?}&quot;</span>, <span class="number">3</span>, <span class="number">4</span>), <span class="string">&quot;3 4&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{} {:?}&quot;</span>, <span class="string">&#39;a&#39;</span>, <span class="string">&#39;b&#39;</span>), <span class="string">&quot;a &#39;b&#39;&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">&quot;{} {:?}&quot;</span>, <span class="string">&quot;foo\n&quot;</span>, <span class="string">&quot;bar\n&quot;</span>), <span class="string">&quot;foo\n \&quot;bar\\n\&quot;&quot;</span>);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(format!(%22%7B%7D%20%7B%3A%3F%7D%22%2C%203%2C%204)%2C%20%223%204%22)%3B%0Aassert_eq!(format!(%22%7B%7D%20%7B%3A%3F%7D%22%2C%20'a'%2C%20'b')%2C%20%22a%20'b'%22)%3B%0Aassert_eq!(format!(%22%7B%7D%20%7B%3A%3F%7D%22%2C%20%22foo%5Cn%22%2C%20%22bar%5Cn%22)%2C%20%22foo%5Cn%20%5C%22bar%5C%5Cn%5C%22%22)%3B%0A%7D&amp;edition=2018">Run</a></div>
<h1 id="相关宏" class="section-header"><a href="#相关宏">相关宏</a></h1>
<p><a href="../macro.format.html"><code>format!</code></a> 系列中有许多相关的宏。当前实现的是:</p>

<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="macro">format!</span>      <span class="comment">// 如上所述</span>
<span class="macro">write!</span>       <span class="comment">// 第一个参数是 &amp;mut io::Write，目的地</span>
<span class="macro">writeln!</span>     <span class="comment">// 与 write 相同，但附加一个换行符</span>
<span class="macro">print!</span>       <span class="comment">// 格式字符串被打印到标准输出</span>
<span class="macro">println!</span>     <span class="comment">// 与 print 相同，但附加换行符</span>
<span class="macro">eprint!</span>      <span class="comment">// 格式字符串被打印到标准错误</span>
<span class="macro">eprintln!</span>    <span class="comment">// 与 eprint 相同，但附加换行符</span>
<span class="macro">format_args!</span> <span class="comment">// 如下面所描述的。</span></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aformat!%20%20%20%20%20%20%2F%2F%20%E5%A6%82%E4%B8%8A%E6%89%80%E8%BF%B0%0Awrite!%20%20%20%20%20%20%20%2F%2F%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E6%98%AF%20%26mut%20io%3A%3AWrite%EF%BC%8C%E7%9B%AE%E7%9A%84%E5%9C%B0%0Awriteln!%20%20%20%20%20%2F%2F%20%E4%B8%8E%20write%20%E7%9B%B8%E5%90%8C%EF%BC%8C%E4%BD%86%E9%99%84%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%8D%A2%E8%A1%8C%E7%AC%A6%0Aprint!%20%20%20%20%20%20%20%2F%2F%20%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A2%AB%E6%89%93%E5%8D%B0%E5%88%B0%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%0Aprintln!%20%20%20%20%20%2F%2F%20%E4%B8%8E%20print%20%E7%9B%B8%E5%90%8C%EF%BC%8C%E4%BD%86%E9%99%84%E5%8A%A0%E6%8D%A2%E8%A1%8C%E7%AC%A6%0Aeprint!%20%20%20%20%20%20%2F%2F%20%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A2%AB%E6%89%93%E5%8D%B0%E5%88%B0%E6%A0%87%E5%87%86%E9%94%99%E8%AF%AF%0Aeprintln!%20%20%20%20%2F%2F%20%E4%B8%8E%20eprint%20%E7%9B%B8%E5%90%8C%EF%BC%8C%E4%BD%86%E9%99%84%E5%8A%A0%E6%8D%A2%E8%A1%8C%E7%AC%A6%0Aformat_args!%20%2F%2F%20%E5%A6%82%E4%B8%8B%E9%9D%A2%E6%89%80%E6%8F%8F%E8%BF%B0%E7%9A%84%E3%80%82%0A%7D&amp;edition=2018">Run</a></div>
<h3 id="write" class="section-header"><a href="#write"><code>write!</code></a></h3>
<p>这和 <a href="../../core/macro.writeln.html"><code>writeln!</code></a> 是两个宏，用于将格式字符串发射到指定的流。这用于防止格式字符串的中间分配，而是直接写入输出。
在后台，此函数实际上是在 <a href="../../std/io/trait.Write.html"><code>std::io::Write</code></a> trait 上定义的 <a href="../../std/io/trait.Write.html#method.write_fmt"><code>write_fmt</code></a> 函数。
用法示例是:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::io::Write</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">w</span> <span class="op">=</span> <span class="ident">Vec::new</span>();
<span class="macro">write!</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">w</span>, <span class="string">&quot;Hello {}!&quot;</span>, <span class="string">&quot;world&quot;</span>);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(unused_must_use)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Aio%3A%3AWrite%3B%0Alet%20mut%20w%20%3D%20Vec%3A%3Anew()%3B%0Awrite!(%26mut%20w%2C%20%22Hello%20%7B%7D!%22%2C%20%22world%22)%3B%0A%7D&amp;edition=2018">Run</a></div>
<h3 id="print" class="section-header"><a href="#print"><code>print!</code></a></h3>
<p>此和 <a href="../../std/macro.println.html"><code>println!</code></a> 将其输出发送到 stdout。与 <a href="../../core/macro.write.html"><code>write!</code></a> 宏类似，这些宏的目标是避免在打印输出时进行中间分配。用法示例是:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">print!</span>(<span class="string">&quot;Hello {}!&quot;</span>, <span class="string">&quot;world&quot;</span>);
<span class="macro">println!</span>(<span class="string">&quot;I have a newline {}&quot;</span>, <span class="string">&quot;character at the end&quot;</span>);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aprint!(%22Hello%20%7B%7D!%22%2C%20%22world%22)%3B%0Aprintln!(%22I%20have%20a%20newline%20%7B%7D%22%2C%20%22character%20at%20the%20end%22)%3B%0A%7D&amp;edition=2018">Run</a></div>
<h3 id="eprint" class="section-header"><a href="#eprint"><code>eprint!</code></a></h3>
<p><a href="../../std/macro.eprint.html"><code>eprint!</code></a> 和 <a href="../../std/macro.eprintln.html"><code>eprintln!</code></a> 宏分别与 <a href="../../std/macro.print.html"><code>print!</code></a> 和 <a href="../../std/macro.println.html"><code>println!</code></a> 相同，只不过它们将其输出发送到 stderr。</p>
<h3 id="format_args" class="section-header"><a href="#format_args"><code>format_args!</code></a></h3>
<p>这是一个奇怪的宏，用于安全地传递描述格式字符串的不透明对象。该对象不需要创建任何堆分配，并且仅引用栈上的信息。
在幕后，所有相关的宏都在此方面实现。
首先，一些示例用法是:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::fmt</span>;
<span class="kw">use</span> <span class="ident">std::io</span>::{<span class="self">self</span>, <span class="ident">Write</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">some_writer</span> <span class="op">=</span> <span class="ident">io::stdout</span>();
<span class="macro">write!</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">some_writer</span>, <span class="string">&quot;{}&quot;</span>, <span class="macro">format_args!</span>(<span class="string">&quot;print with a {}&quot;</span>, <span class="string">&quot;macro&quot;</span>));

<span class="kw">fn</span> <span class="ident">my_fmt_fn</span>(<span class="ident">args</span>: <span class="ident">fmt::Arguments</span>) {
    <span class="macro">write!</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">io::stdout</span>(), <span class="string">&quot;{}&quot;</span>, <span class="ident">args</span>);
}
<span class="ident">my_fmt_fn</span>(<span class="macro">format_args!</span>(<span class="string">&quot;, or a {} too&quot;</span>, <span class="string">&quot;function&quot;</span>));</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(unused_must_use)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Afmt%3B%0Ause%20std%3A%3Aio%3A%3A%7Bself%2C%20Write%7D%3B%0A%0Alet%20mut%20some_writer%20%3D%20io%3A%3Astdout()%3B%0Awrite!(%26mut%20some_writer%2C%20%22%7B%7D%22%2C%20format_args!(%22print%20with%20a%20%7B%7D%22%2C%20%22macro%22))%3B%0A%0Afn%20my_fmt_fn(args%3A%20fmt%3A%3AArguments)%20%7B%0A%20%20%20%20write!(%26mut%20io%3A%3Astdout()%2C%20%22%7B%7D%22%2C%20args)%3B%0A%7D%0Amy_fmt_fn(format_args!(%22%2C%20or%20a%20%7B%7D%20too%22%2C%20%22function%22))%3B%0A%7D&amp;edition=2018">Run</a></div>
<p><a href="../../core/macro.format_args.html"><code>format_args!</code></a> 宏的结果是 <a href="struct.Arguments.html"><code>fmt::Arguments</code></a> 类型的值。
然后可以将此结构体传递到此模块内部的 <a href="../../core/macro.write.html"><code>write</code></a> 和 <a href="../macro.format.html"><code>format</code></a> 函数，以处理格式字符串。
该宏的目的是在处理格式化字符串时甚至进一步防止中间分配。</p>
<p>例如，日志记录库可以使用标准格式语法，但是它将在内部绕过此结构体，直到确定了输出应该到达的位置为止。</p>
</div></details><h2 id="macros" class="section-header"><a href="#macros">Macros</a></h2>
<table><tr class="module-item"><td><a class="macro" href="macro.Debug.html" title="alloc::fmt::Debug macro">Debug</a></td><td class="docblock-short"><p>派生宏，生成 trait <code>Debug</code> 的 impl。</p>
</td></tr></table><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<table><tr class="module-item"><td><a class="struct" href="struct.Arguments.html" title="alloc::fmt::Arguments struct">Arguments</a></td><td class="docblock-short"><p>该结构体表示格式字符串及其参数的安全预编译版本。
由于无法安全地完成此操作，因此无法在运行时生成该文件，因此未提供任何构造函数，并且该字段为私有字段以防止修改。</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.DebugList.html" title="alloc::fmt::DebugList struct">DebugList</a></td><td class="docblock-short"><p>一个有助于 <a href="trait.Debug.html"><code>fmt::Debug</code></a> 实现的结构体。</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.DebugMap.html" title="alloc::fmt::DebugMap struct">DebugMap</a></td><td class="docblock-short"><p>一个有助于 <a href="trait.Debug.html"><code>fmt::Debug</code></a> 实现的结构体。</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.DebugSet.html" title="alloc::fmt::DebugSet struct">DebugSet</a></td><td class="docblock-short"><p>一个有助于 <a href="trait.Debug.html"><code>fmt::Debug</code></a> 实现的结构体。</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.DebugStruct.html" title="alloc::fmt::DebugStruct struct">DebugStruct</a></td><td class="docblock-short"><p>一个有助于 <a href="trait.Debug.html"><code>fmt::Debug</code></a> 实现的结构体。</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.DebugTuple.html" title="alloc::fmt::DebugTuple struct">DebugTuple</a></td><td class="docblock-short"><p>一个有助于 <a href="trait.Debug.html"><code>fmt::Debug</code></a> 实现的结构体。</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Error.html" title="alloc::fmt::Error struct">Error</a></td><td class="docblock-short"><p>将消息格式化为流后返回的错误类型。</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Formatter.html" title="alloc::fmt::Formatter struct">Formatter</a></td><td class="docblock-short"><p>格式化配置。</p>
</td></tr></table><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2>
<table><tr class="module-item"><td><a class="enum" href="enum.Alignment.html" title="alloc::fmt::Alignment enum">Alignment</a></td><td class="docblock-short"><p><code>Formatter::align</code> 返回的可能的对齐方式</p>
</td></tr></table><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2>
<table><tr class="module-item"><td><a class="trait" href="trait.Binary.html" title="alloc::fmt::Binary trait">Binary</a></td><td class="docblock-short"><p><code>b</code> formatting.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.Debug.html" title="alloc::fmt::Debug trait">Debug</a></td><td class="docblock-short"><p><code>?</code> formatting.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.Display.html" title="alloc::fmt::Display trait">Display</a></td><td class="docblock-short"><p>格式化 trait 为空格式， <code>{}</code>.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.LowerExp.html" title="alloc::fmt::LowerExp trait">LowerExp</a></td><td class="docblock-short"><p><code>e</code> formatting.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.LowerHex.html" title="alloc::fmt::LowerHex trait">LowerHex</a></td><td class="docblock-short"><p><code>x</code> formatting.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.Octal.html" title="alloc::fmt::Octal trait">Octal</a></td><td class="docblock-short"><p><code>o</code> formatting.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.Pointer.html" title="alloc::fmt::Pointer trait">Pointer</a></td><td class="docblock-short"><p><code>p</code> formatting.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.UpperExp.html" title="alloc::fmt::UpperExp trait">UpperExp</a></td><td class="docblock-short"><p><code>E</code> formatting.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.UpperHex.html" title="alloc::fmt::UpperHex trait">UpperHex</a></td><td class="docblock-short"><p><code>X</code> formatting.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.Write.html" title="alloc::fmt::Write trait">Write</a></td><td class="docblock-short"><p>trait，用于写入或格式化为 Unicode 接受的缓冲区或流。</p>
</td></tr></table><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<table><tr class="module-item"><td><a class="fn" href="fn.format.html" title="alloc::fmt::format fn">format</a></td><td class="docblock-short"><p><code>format</code> 函数采用 <a href="struct.Arguments.html" title="Arguments"><code>Arguments</code></a> 结构体，并返回生成的格式化字符串。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.write.html" title="alloc::fmt::write fn">write</a></td><td class="docblock-short"><p><code>write</code> 函数接受一个输出流，以及一个可以与 <code>format_args!</code> 宏预编译的 <code>Arguments</code> 结构体。</p>
</td></tr></table><h2 id="types" class="section-header"><a href="#types">Type Definitions</a></h2>
<table><tr class="module-item"><td><a class="type" href="type.Result.html" title="alloc::fmt::Result type">Result</a></td><td class="docblock-short"><p>格式化程序方法返回的类型。</p>
</td></tr></table></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="alloc" data-search-index-js="../../search-index1.55.0.js" data-search-js="../../search1.55.0.js"></div><script src="../../main1.55.0.js"></script></body></html>