<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="原始，不安全的指针 `*const T` 和 `* mut T`。"><meta name="keywords" content="rust, rustlang, rust-lang, pointer"><title>pointer - Rust</title><link rel="stylesheet" type="text/css" href="../normalize1.55.0.css"><link rel="stylesheet" type="text/css" href="../rustdoc1.55.0.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light1.55.0.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark1.55.0.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu1.55.0.css" disabled ><script id="default-settings"></script><script src="../storage1.55.0.js"></script><script src="../crates1.55.0.js"></script><noscript><link rel="stylesheet" href="../noscript1.55.0.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon1.55.0.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x161.55.0.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x321.55.0.png"><style type="text/css">#crate-search{background-image:url("../down-arrow1.55.0.svg");}</style></head><body class="rustdoc primitive"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../std/index.html'><div class='logo-container rust-logo'><img src='../rust-logo1.55.0.png' alt='logo'></div></a><h2 class="location">Primitive Type pointer</h2><div class="sidebar-elems"><div class="block items"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><div class="sidebar-links"><a href="#method.add">add</a><a href="#method.add-1">add</a><a href="#method.align_offset">align_offset</a><a href="#method.align_offset-1">align_offset</a><a href="#method.as_mut">as_mut</a><a href="#method.as_mut_ptr">as_mut_ptr</a><a href="#method.as_ptr">as_ptr</a><a href="#method.as_ref">as_ref</a><a href="#method.as_ref-1">as_ref</a><a href="#method.as_uninit_mut">as_uninit_mut</a><a href="#method.as_uninit_ref">as_uninit_ref</a><a href="#method.as_uninit_ref-1">as_uninit_ref</a><a href="#method.as_uninit_slice">as_uninit_slice</a><a href="#method.as_uninit_slice-1">as_uninit_slice</a><a href="#method.as_uninit_slice_mut">as_uninit_slice_mut</a><a href="#method.cast">cast</a><a href="#method.cast-1">cast</a><a href="#method.copy_from">copy_from</a><a href="#method.copy_from_nonoverlapping">copy_from_nonoverlapping</a><a href="#method.copy_to">copy_to</a><a href="#method.copy_to-1">copy_to</a><a href="#method.copy_to_nonoverlapping">copy_to_nonoverlapping</a><a href="#method.copy_to_nonoverlapping-1">copy_to_nonoverlapping</a><a href="#method.drop_in_place">drop_in_place</a><a href="#method.get_unchecked">get_unchecked</a><a href="#method.get_unchecked_mut">get_unchecked_mut</a><a href="#method.guaranteed_eq">guaranteed_eq</a><a href="#method.guaranteed_eq-1">guaranteed_eq</a><a href="#method.guaranteed_ne">guaranteed_ne</a><a href="#method.guaranteed_ne-1">guaranteed_ne</a><a href="#method.is_null">is_null</a><a href="#method.is_null-1">is_null</a><a href="#method.len">len</a><a href="#method.len-1">len</a><a href="#method.offset">offset</a><a href="#method.offset-1">offset</a><a href="#method.offset_from">offset_from</a><a href="#method.offset_from-1">offset_from</a><a href="#method.read">read</a><a href="#method.read-1">read</a><a href="#method.read_unaligned">read_unaligned</a><a href="#method.read_unaligned-1">read_unaligned</a><a href="#method.read_volatile">read_volatile</a><a href="#method.read_volatile-1">read_volatile</a><a href="#method.replace">replace</a><a href="#method.set_ptr_value">set_ptr_value</a><a href="#method.set_ptr_value-1">set_ptr_value</a><a href="#method.sub">sub</a><a href="#method.sub-1">sub</a><a href="#method.swap">swap</a><a href="#method.to_raw_parts">to_raw_parts</a><a href="#method.to_raw_parts-1">to_raw_parts</a><a href="#method.wrapping_add">wrapping_add</a><a href="#method.wrapping_add-1">wrapping_add</a><a href="#method.wrapping_offset">wrapping_offset</a><a href="#method.wrapping_offset-1">wrapping_offset</a><a href="#method.wrapping_sub">wrapping_sub</a><a href="#method.wrapping_sub-1">wrapping_sub</a><a href="#method.write">write</a><a href="#method.write_bytes">write_bytes</a><a href="#method.write_unaligned">write_unaligned</a><a href="#method.write_volatile">write_volatile</a></div><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-Clone">Clone</a><a href="#impl-CoerceUnsized%3C*const%20U%3E">CoerceUnsized&lt;*const U&gt;</a><a href="#impl-CoerceUnsized%3C*mut%20U%3E">CoerceUnsized&lt;*mut U&gt;</a><a href="#impl-Copy">Copy</a><a href="#impl-Debug">Debug</a><a href="#impl-DispatchFromDyn%3C*const%20U%3E">DispatchFromDyn&lt;*const U&gt;</a><a href="#impl-DispatchFromDyn%3C*mut%20U%3E">DispatchFromDyn&lt;*mut U&gt;</a><a href="#impl-Eq">Eq</a><a href="#impl-Hash">Hash</a><a href="#impl-Ord">Ord</a><a href="#impl-PartialEq%3C*const%20T%3E">PartialEq&lt;*const T&gt;</a><a href="#impl-PartialEq%3C*mut%20T%3E">PartialEq&lt;*mut T&gt;</a><a href="#impl-PartialOrd%3C*const%20T%3E">PartialOrd&lt;*const T&gt;</a><a href="#impl-PartialOrd%3C*mut%20T%3E">PartialOrd&lt;*mut T&gt;</a><a href="#impl-Pointer">Pointer</a><a href="#impl-Send">!Send</a><a href="#impl-Sync">!Sync</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">UnwindSafe</a></div><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-RefUnwindSafe">RefUnwindSafe</a></div><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-ToOwned">ToOwned</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></div></div><h2 class="location">Other items in<br><a href="index.html">std</a></h2><div id="sidebar-vars" data-name="pointer" data-ty="primitive" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img src="../brush1.55.0.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img src="../wheel1.55.0.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Primitive Type <a class="primitive" href="#">pointer</a><button id="copy-path" onclick="copy_path(this)" title="copy path"><img src="../clipboard1.55.0.svg" width="19" height="18" alt="Copy item import" title="Copy item import to clipboard"></button></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>原始，不安全的指针 <code>*const T</code> 和 <code>* mut T</code>。</p>
<p><em><a href="ptr/index.html">See also the <code>std::ptr</code> module</a>.</em></p>
<p>在 Rust 中使用裸指针并不常见，通常仅限于几种模式。
裸指针可以是未对齐的或 <a href="ptr/fn.null.html"><code>null</code></a>。但是，当解引用裸指针 (使用 <code>*</code> 运算符) 时，它必须为非 null 并对齐。</p>
<p>使用 <code>*ptr = data</code> 通过裸指针存储会在旧值上调用 <code>drop</code>，因此，如果该类型具有 drop glue 并且尚未初始化内存，则必须使用 <a href="ptr/fn.write.html"><code>write</code></a>; 否则，将在未初始化的内存上调用 <code>drop</code>。</p>
<p>使用 <a href="ptr/fn.null.html"><code>null</code></a> 和 <a href="ptr/fn.null_mut.html"><code>null_mut</code></a> 函数创建空指针，并使用 <code>*const T</code> 和 <code>* mut T</code> 类型的 <a href="https://doc.rust-lang.org/1.54.0/std/primitive.pointer.html#method.is_null"><code>is_null</code></a> 方法检查空值。
<code>*const T</code> 和 <code>* mut T</code> 类型还定义了用于指针数学的 <a href="https://doc.rust-lang.org/1.54.0/std/primitive.pointer.html#method.offset"><code>offset</code></a> 方法。</p>
<h1 id="创建裸指针的常用方法" class="section-header"><a href="#创建裸指针的常用方法">创建裸指针的常用方法</a></h1><h2 id="1-强制引用-t-或可变引用-mut-t" class="section-header"><a href="#1-强制引用-t-或可变引用-mut-t">1. 强制引用 (<code>&amp;T</code>) 或可变引用 (<code>&amp;mut T</code>)。</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">my_num</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="number">10</span>;
<span class="kw">let</span> <span class="ident">my_num_ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">my_num</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">my_speed</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="number">88</span>;
<span class="kw">let</span> <span class="ident">my_speed_ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">my_speed</span>;</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20my_num%3A%20i32%20%3D%2010%3B%0Alet%20my_num_ptr%3A%20*const%20i32%20%3D%20%26my_num%3B%0Alet%20mut%20my_speed%3A%20i32%20%3D%2088%3B%0Alet%20my_speed_ptr%3A%20*mut%20i32%20%3D%20%26mut%20my_speed%3B%0A%7D&amp;edition=2018">Run</a></div>
<p>要获得指向 boxed 值的指针，请解引用 box:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">my_num</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Box::new</span>(<span class="number">10</span>);
<span class="kw">let</span> <span class="ident">my_num_ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">my_num</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">my_speed</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Box::new</span>(<span class="number">88</span>);
<span class="kw">let</span> <span class="ident">my_speed_ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="kw-2">*</span><span class="ident">my_speed</span>;</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20my_num%3A%20Box%3Ci32%3E%20%3D%20Box%3A%3Anew(10)%3B%0Alet%20my_num_ptr%3A%20*const%20i32%20%3D%20%26*my_num%3B%0Alet%20mut%20my_speed%3A%20Box%3Ci32%3E%20%3D%20Box%3A%3Anew(88)%3B%0Alet%20my_speed_ptr%3A%20*mut%20i32%20%3D%20%26mut%20*my_speed%3B%0A%7D&amp;edition=2018">Run</a></div>
<p>这不会获得原始分配的所有权，并且以后不需要任何资源管理，但是您一定不能在其生命周期之后使用该指针。</p>
<h2 id="2-消费-box-boxt" class="section-header"><a href="#2-消费-box-boxt">2. 消费 box (<code>Box&lt;T&gt;</code>)。</a></h2>
<p><a href="boxed/struct.Box.html#method.into_raw"><code>into_raw</code></a> 函数使用 box 并返回裸指针。它不会销毁 <code>T</code> 或释放任何内存。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">my_speed</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Box::new</span>(<span class="number">88</span>);
<span class="kw">let</span> <span class="ident">my_speed</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span> <span class="op">=</span> <span class="ident">Box::into_raw</span>(<span class="ident">my_speed</span>);

<span class="comment">// 通过拥有原始 `Box&lt;T&gt;` 的所有权，我们有义务稍后将其放在一起销毁。</span>
<span class="kw">unsafe</span> {
    <span class="ident">drop</span>(<span class="ident">Box::from_raw</span>(<span class="ident">my_speed</span>));
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20my_speed%3A%20Box%3Ci32%3E%20%3D%20Box%3A%3Anew(88)%3B%0Alet%20my_speed%3A%20*mut%20i32%20%3D%20Box%3A%3Ainto_raw(my_speed)%3B%0A%0A%2F%2F%20%E9%80%9A%E8%BF%87%E6%8B%A5%E6%9C%89%E5%8E%9F%E5%A7%8B%20%60Box%3CT%3E%60%20%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%EF%BC%8C%E6%88%91%E4%BB%AC%E6%9C%89%E4%B9%89%E5%8A%A1%E7%A8%8D%E5%90%8E%E5%B0%86%E5%85%B6%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7%E9%94%80%E6%AF%81%E3%80%82%0Aunsafe%20%7B%0A%20%20%20%20drop(Box%3A%3Afrom_raw(my_speed))%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<p>请注意，此处对 <a href="mem/fn.drop.html"><code>drop</code></a> 的调用是为了清楚起见 - 表示我们已经完成了给定值的操作，应将其销毁。</p>
<h2 id="3-使用-ptraddr_of-创建它" class="section-header"><a href="#3-使用-ptraddr_of-创建它">3. 使用 <code>ptr::addr_of!</code> 创建它</a></h2>
<p>您可以使用宏 <a href="ptr/macro.addr_of.html" title="ptr::addr_of!"><code>ptr::addr_of!</code></a> (对于 <code>*const T</code>) 和 <a href="ptr/macro.addr_of_mut.html" title="ptr::addr_of_mut!"><code>ptr::addr_of_mut!</code></a> (对于 <code>*mut T</code>)，而不是强制引用裸指针。
这些宏允许您创建裸指针指向您无法创建引用的字段 (不会导致未定义的行为)，例如未对齐的字段。
如果涉及包装的结构或未初始化的内存，这可能是必要的。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Default</span>, <span class="ident">Copy</span>, <span class="ident">Clone</span>)]</span>
<span class="attribute">#[<span class="ident">repr</span>(<span class="ident">C</span>, <span class="ident">packed</span>)]</span>
<span class="kw">struct</span> <span class="ident">S</span> {
    <span class="ident">aligned</span>: <span class="ident">u8</span>,
    <span class="ident">unaligned</span>: <span class="ident">u32</span>,
}
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">S::default</span>();
<span class="kw">let</span> <span class="ident">p</span> <span class="op">=</span> <span class="macro">std::ptr::addr_of!</span>(<span class="ident">s</span>.<span class="ident">unaligned</span>); <span class="comment">// 不允许强制</span></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0A%23%5Bderive(Debug%2C%20Default%2C%20Copy%2C%20Clone)%5D%0A%23%5Brepr(C%2C%20packed)%5D%0Astruct%20S%20%7B%0A%20%20%20%20aligned%3A%20u8%2C%0A%20%20%20%20unaligned%3A%20u32%2C%0A%7D%0Alet%20s%20%3D%20S%3A%3Adefault()%3B%0Alet%20p%20%3D%20std%3A%3Aptr%3A%3Aaddr_of!(s.unaligned)%3B%20%2F%2F%20%E4%B8%8D%E5%85%81%E8%AE%B8%E5%BC%BA%E5%88%B6%0A%7D&amp;edition=2018">Run</a></div>
<h2 id="4-从-c-获取它" class="section-header"><a href="#4-从-c-获取它">4. 从 C 获取它。</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">libc</span>;

<span class="kw">use</span> <span class="ident">std::mem</span>;

<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="ident">my_num</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span> <span class="op">=</span> <span class="ident">libc::malloc</span>(<span class="ident">mem::size_of</span>::<span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>()) <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span>;
    <span class="kw">if</span> <span class="ident">my_num</span>.<span class="ident">is_null</span>() {
        <span class="macro">panic!</span>(<span class="string">&quot;failed to allocate memory&quot;</span>);
    }
    <span class="ident">libc::free</span>(<span class="ident">my_num</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">libc::c_void</span>);
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(rustc_private)%5D%0Aextern%20crate%20libc%3B%0A%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20let%20my_num%3A%20*mut%20i32%20%3D%20libc%3A%3Amalloc(mem%3A%3Asize_of%3A%3A%3Ci32%3E())%20as%20*mut%20i32%3B%0A%20%20%20%20if%20my_num.is_null()%20%7B%0A%20%20%20%20%20%20%20%20panic!(%22failed%20to%20allocate%20memory%22)%3B%0A%20%20%20%20%7D%0A%20%20%20%20libc%3A%3Afree(my_num%20as%20*mut%20libc%3A%3Ac_void)%3B%0A%7D%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
<p>通常，您实际上不会使用 Rust 中的 <code>malloc</code> 和 <code>free</code>，但是 C API 通常会发出很多指针，因此 Rust 中的裸指针常见来源。</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#8-892" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.is_null" class="method has-srclink"><h4 class="code-header">pub const fn <a href="#method.is_null" class="fnname">is_null</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4><a href="#method.is_null" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#37" title="goto source code">[src]</a></div></summary><div class="docblock"><p>如果指针为空，则返回 <code>true</code>。</p>
<p>请注意，未定义大小的类型具有许多可能的空指针，因为仅考虑原始数据指针，而不考虑其长度，vtable 等。
因此，两个为空的指针可能仍不能相互比较相等。</p>
<h2 id="常量评估期间的行为" class="section-header"><a href="#常量评估期间的行为">常量评估期间的行为</a></h2>
<p>在 const 评估期间使用此函数时，对于在运行时结果为空的指针，它可能返回 <code>false</code>。
具体来说，当指向某个内存的指针超出其范围的偏移量 (使结果指针为空) 时，函数仍将返回 <code>false</code>。</p>
<p>CTFE 无法知道该内存的绝对位置，因此我们无法确定指针是否为空。</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>基本用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;Follow the rabbit&quot;</span>;
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_ptr</span>();
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">ptr</span>.<span class="ident">is_null</span>());</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%3A%20%26str%20%3D%20%22Follow%20the%20rabbit%22%3B%0Alet%20ptr%3A%20*const%20u8%20%3D%20s.as_ptr()%3B%0Aassert!(!ptr.is_null())%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.cast" class="method has-srclink"><h4 class="code-header">pub const fn <a href="#method.cast" class="fnname">cast</a>&lt;U&gt;(self) -&gt; <a class="primitive" href="primitive.pointer.html">*const U</a></h4><span class="since" title="Stable since Rust version 1.38.0, const since 1.38.0">1.38.0 (const: 1.38.0)</span><a href="#method.cast" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#47" title="goto source code">[src]</a></div></summary><div class="docblock"><p>强制转换为另一种类型的指针。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.to_raw_parts" class="method has-srclink"><h4 class="code-header">pub const fn <a href="#method.to_raw_parts" class="fnname">to_raw_parts</a>(self) -&gt; <a class="primitive" href="primitive.tuple.html">(</a><a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.unit.html">()</a>, &lt;T as <a class="trait" href="ptr/trait.Pointee.html" title="trait std::ptr::Pointee">Pointee</a>&gt;::<a class="type" href="ptr/trait.Pointee.html#associatedtype.Metadata" title="type std::ptr::Pointee::Metadata">Metadata</a><a class="primitive" href="primitive.tuple.html">)</a></h4><a href="#method.to_raw_parts" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#57" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>ptr_metadata</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/81513">#81513</a>)</div></div></summary><div class="docblock"><p>将 (可能是很宽的) 指针分解为地址和元数据组件。</p>
<p>以后可以使用 <a href="ptr/fn.from_raw_parts.html" title="from_raw_parts"><code>from_raw_parts</code></a> 重建指针。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_ref" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.as_ref" class="fnname">as_ref</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;'a </a>T&gt;</h4><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span><a href="#method.as_ref" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#119" title="goto source code">[src]</a></div></summary><div class="docblock"><p>如果指针为空，则返回 <code>None</code>，否则返回 <code>Some</code> 中包装的值的共享引用。如果该值可能未初始化，则必须改用 <a href="#method.as_uninit_ref"><code>as_uninit_ref</code></a>。</p>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p>调用此方法时，您必须确保要么指针是空的，要么以下所有内容都为真::</p>
<ul>
<li>
<p>指针必须正确对齐。</p>
</li>
<li>
<p>在 <a href="ptr/index.html#safety">the module documentation</a> 中定义的意义上，它必须是 “dereferencable”。</p>
</li>
<li>
<p>指针必须指向 <code>T</code> 的初始化实例。</p>
</li>
<li>
<p>您必须执行 Rust 的别名规则，因为返回的生命周期 <code>'a</code> 是任意选择的，不一定反映数据的实际生命周期。
特别是，在此生命周期的持续时间内，指针所指向的内存一定不能被可变的 (<code>UnsafeCell</code> 内部除外)。</p>
</li>
</ul>
<p>即使未使用此方法的结果也是如此!
(关于初始化的部分尚未完全决定，但是直到确定之前，唯一安全的方法是确保它们确实被初始化。)</p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<p>基本用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="number">10u8</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>;

<span class="kw">unsafe</span> {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">val_back</span>) <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">as_ref</span>() {
        <span class="macro">println!</span>(<span class="string">&quot;We got back the value: {}!&quot;</span>, <span class="ident">val_back</span>);
    }
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20ptr%3A%20*const%20u8%20%3D%20%2610u8%20as%20*const%20u8%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20if%20let%20Some(val_back)%20%3D%20ptr.as_ref()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22We%20got%20back%20the%20value%3A%20%7B%7D!%22%2C%20val_back)%3B%0A%20%20%20%20%7D%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<h1 id="空未经检查的版本" class="section-header"><a href="#空未经检查的版本">空未经检查的版本</a></h1>
<p>如果确定指针永远不会为空，并且正在寻找某种返回 <code>&amp;T</code> 而不是 <code>Option&lt;&amp;T&gt;</code> 的 <code>as_ref_unchecked</code>，请知道您可以直接引用该指针。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="number">10u8</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>;

<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="ident">val_back</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">ptr</span>;
    <span class="macro">println!</span>(<span class="string">&quot;We got back the value: {}!&quot;</span>, <span class="ident">val_back</span>);
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20ptr%3A%20*const%20u8%20%3D%20%2610u8%20as%20*const%20u8%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20let%20val_back%20%3D%20%26*ptr%3B%0A%20%20%20%20println!(%22We%20got%20back%20the%20value%3A%20%7B%7D!%22%2C%20val_back)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_uninit_ref" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.as_uninit_ref" class="fnname">as_uninit_ref</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;'a <a class="union" href="mem/union.MaybeUninit.html" title="union std::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;&gt;</h4><a href="#method.as_uninit_ref" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#166-168" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>ptr_as_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75402">#75402</a>)</div></div></summary><div class="docblock"><p>如果指针为空，则返回 <code>None</code>，否则返回 <code>Some</code> 中包装的值的共享引用。
与 <a href="#method.as_ref"><code>as_ref</code></a> 相比，这不需要将该值初始化。</p>
<h1 id="safety-1" class="section-header"><a href="#safety-1">Safety</a></h1>
<p>调用此方法时，您必须确保要么指针是空的，要么以下所有内容都为真::</p>
<ul>
<li>
<p>指针必须正确对齐。</p>
</li>
<li>
<p>在 <a href="ptr/index.html#safety">the module documentation</a> 中定义的意义上，它必须是 “dereferencable”。</p>
</li>
<li>
<p>您必须执行 Rust 的别名规则，因为返回的生命周期 <code>'a</code> 是任意选择的，不一定反映数据的实际生命周期。</p>
<p>特别是，在此生命周期的持续时间内，指针所指向的内存一定不能被可变的 (<code>UnsafeCell</code> 内部除外)。</p>
</li>
</ul>
<p>即使未使用此方法的结果也是如此!</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<p>基本用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">ptr_as_uninit</span>)]</span>

<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="number">10u8</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>;

<span class="kw">unsafe</span> {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">val_back</span>) <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">as_uninit_ref</span>() {
        <span class="macro">println!</span>(<span class="string">&quot;We got back the value: {}!&quot;</span>, <span class="ident">val_back</span>.<span class="ident">assume_init</span>());
    }
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_as_uninit)%5D%0A%0Afn%20main()%20%7B%0Alet%20ptr%3A%20*const%20u8%20%3D%20%2610u8%20as%20*const%20u8%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20if%20let%20Some(val_back)%20%3D%20ptr.as_uninit_ref()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22We%20got%20back%20the%20value%3A%20%7B%7D!%22%2C%20val_back.assume_init())%3B%0A%20%20%20%20%7D%0A%7D%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.offset" class="method has-srclink"><h4 class="code-header"><div class="code-attribute">#[must_use = "returns a new pointer rather than modifying its argument"]</div>pub const unsafe fn <a href="#method.offset" class="fnname">offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4><a href="#method.offset" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#230-232" title="goto source code">[src]</a></div></summary><div class="docblock"><p>计算与指针的偏移量。</p>
<p><code>count</code> 以 T 为单位; 例如，<code>count</code> 为 3 表示 <code>3 * size_of::&lt;T&gt;()</code> 字节的指针偏移量。</p>
<h1 id="safety-2" class="section-header"><a href="#safety-2">Safety</a></h1>
<p>如果违反以下任一条件，则结果为未定义行为:</p>
<ul>
<li>
<p>起始指针和结果指针都必须在边界内或在同一个 <a href="ptr/index.html#allocated-object">allocated object</a> 的末尾之后一个字节。</p>
</li>
<li>
<p>计算的偏移量 (以字节为单位 **) 不会使 <code>isize</code> 溢出。</p>
</li>
<li>
<p>偏移量不能依赖 “wrapping around” 地址空间。也就是说，无限精度总和 (以字节为单位) 必须适合于 usize。</p>
</li>
</ul>
<p>编译器和标准库通常会尝试确保分配永远不会达到需要考虑偏移量的大小。
例如，<code>Vec</code> 和 <code>Box</code> 确保它们分配的字节数永远不会超过 <code>isize::MAX</code> 字节，因此 <code>vec.as_ptr().add(vec.len())</code> 始终是安全的。</p>
<p>从根本上说，大多数平台甚至都无法构造这样的分配。
例如，由于页表的限制或地址空间的分割，没有已知的 64 位平台可以满足 2 <sup>63</sup> 字节的请求。
但是，某些 32 位和 16 位平台可能通过物理地址扩展之类的东西成功地为超过 <code>isize::MAX</code> 字节的请求提供服务。</p>
<p>因此，直接从分配器获取的内存或内存映射文件 <em>可能</em> 太大而无法使用此函数进行处理。</p>
<p>如果这些约束难以满足，请考虑使用 <a href="#method.wrapping_offset"><code>wrapping_offset</code></a>。
此方法的唯一优点是，它可以实现更积极的编译器优化。</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<p>基本用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;123&quot;</span>;
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_ptr</span>();

<span class="kw">unsafe</span> {
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>.<span class="ident">offset</span>(<span class="number">1</span>) <span class="kw">as</span> <span class="ident">char</span>);
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>.<span class="ident">offset</span>(<span class="number">2</span>) <span class="kw">as</span> <span class="ident">char</span>);
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%3A%20%26str%20%3D%20%22123%22%3B%0Alet%20ptr%3A%20*const%20u8%20%3D%20s.as_ptr()%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.offset(1)%20as%20char)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.offset(2)%20as%20char)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.wrapping_offset" class="method has-srclink"><h4 class="code-header"><div class="code-attribute">#[must_use = "returns a new pointer rather than modifying its argument"]</div>pub const fn <a href="#method.wrapping_offset" class="fnname">wrapping_offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span><a href="#method.wrapping_offset" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#292-294" title="goto source code">[src]</a></div></summary><div class="docblock"><p>使用换行算法计算与指针的偏移量。</p>
<p><code>count</code> 以 T 为单位; 例如，<code>count</code> 为 3 表示 <code>3 * size_of::&lt;T&gt;()</code> 字节的指针偏移量。</p>
<h1 id="safety-3" class="section-header"><a href="#safety-3">Safety</a></h1>
<p>此操作本身始终是安全的，但使用结果指针则不安全。</p>
<p>结果指针 “remembers” 是 <code>self</code> 指向的 <a href="ptr/index.html#allocated-object">allocated object</a>; 它不能用于读取或写入其他分配的对象。</p>
<p>换句话说，即使我们假设 <code>T</code> 的大小为 <code>1</code> 并且没有溢出，<code>let z = x.wrapping_offset((y as isize) - (x as isize))</code> 不会使 <code>z</code> 与 <code>y</code> 相同: <code>z</code> 仍附加到对象 <code>x</code> 所附加的对象，并且解引用它是 Undefined Behavior，除非 <code>x</code> 和 <code>y</code> 指向同一分配的对象。</p>
<p>与 <a href="#method.offset"><code>offset</code></a> 相比，此方法从根本上延迟了留在同一分配对象内的需求: <a href="#method.offset"><code>offset</code></a> 是跨越对象边界时的立即未定义行为; <code>wrapping_offset</code> 产生一个指针，但如果指针超出其附加对象的范围而被解引用，则仍会导致未定义行为。
<a href="#method.offset"><code>offset</code></a> 可以更好地进行优化，因此在对性能敏感的代码中更可取。</p>
<p>延迟检查仅考虑解引用的指针的值，而不考虑最终结果计算期间使用的中间值。
例如，<code>x.wrapping_offset(o).wrapping_offset(o.wrapping_neg())</code> 始终与 <code>x</code> 相同。换句话说，允许离开已分配的对象，然后在以后重新输入它。</p>
<h1 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h1>
<p>基本用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// 使用裸指针以两个元素为增量进行迭代</span>
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">as_ptr</span>();
<span class="kw">let</span> <span class="ident">step</span> <span class="op">=</span> <span class="number">2</span>;
<span class="kw">let</span> <span class="ident">end_rounded_up</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_offset</span>(<span class="number">6</span>);

<span class="comment">// 此循环打印 &quot;1, 3, 5, &quot;</span>
<span class="kw">while</span> <span class="ident">ptr</span> <span class="op">!</span><span class="op">=</span> <span class="ident">end_rounded_up</span> {
    <span class="kw">unsafe</span> {
        <span class="macro">print!</span>(<span class="string">&quot;{}, &quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>);
    }
    <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_offset</span>(<span class="ident">step</span>);
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%2F%2F%20%E4%BD%BF%E7%94%A8%E8%A3%B8%E6%8C%87%E9%92%88%E4%BB%A5%E4%B8%A4%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B8%BA%E5%A2%9E%E9%87%8F%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3%0Afn%20main()%20%7B%0Alet%20data%20%3D%20%5B1u8%2C%202%2C%203%2C%204%2C%205%5D%3B%0Alet%20mut%20ptr%3A%20*const%20u8%20%3D%20data.as_ptr()%3B%0Alet%20step%20%3D%202%3B%0Alet%20end_rounded_up%20%3D%20ptr.wrapping_offset(6)%3B%0A%0A%2F%2F%20%E6%AD%A4%E5%BE%AA%E7%8E%AF%E6%89%93%E5%8D%B0%20%221%2C%203%2C%205%2C%20%22%0Awhile%20ptr%20!%3D%20end_rounded_up%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20print!(%22%7B%7D%2C%20%22%2C%20*ptr)%3B%0A%20%20%20%20%7D%0A%20%20%20%20ptr%20%3D%20ptr.wrapping_offset(step)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.offset_from" class="method has-srclink"><h4 class="code-header">pub const unsafe fn <a href="#method.offset_from" class="fnname">offset_from</a>(self, origin: <a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.isize.html">isize</a></h4><span class="since" title="Stable since Rust version 1.47.0">1.47.0</span><a href="#method.offset_from" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#384-386" title="goto source code">[src]</a></div></summary><div class="docblock"><p>计算两个指针之间的距离。返回的值以 T 为单位: 以字节为单位的距离除以 <code>mem::size_of::&lt;T&gt;()</code>。</p>
<p>该函数是 <a href="#method.offset"><code>offset</code></a> 的逆函数。</p>
<h1 id="safety-4" class="section-header"><a href="#safety-4">Safety</a></h1>
<p>如果违反以下任一条件，则结果为未定义行为:</p>
<ul>
<li>
<p>起始指针和其他指针都必须在边界内或在同一个 <a href="ptr/index.html#allocated-object">allocated object</a> 的末尾之后一个字节。</p>
</li>
<li>
<p>两个指针必须是指向同一对象的指针的 *derived。
(请参见下面的示例。)</p>
</li>
<li>
<p>指针之间的距离 (以字节为单位) 必须是 <code>T</code> 大小的精确倍数。</p>
</li>
<li>
<p>指针之间的距离 (以字节为单位) 不会溢出 <code>isize</code>。</p>
</li>
<li>
<p>该距离不能依赖于 “wrapping around” 地址空间。</p>
</li>
</ul>
<p>Rust 类型从不大于 <code>isize::MAX</code>，并且 Rust 分配从不环绕地址空间，因此，任何 Rust 类型 <code>T</code> 的某个值内的两个指针将始终满足最后两个条件。</p>
<p>标准库通常还确保分配永远不会达到需要考虑偏移量的大小。
例如，<code>Vec</code> 和 <code>Box</code> 确保它们分配的字节数永远不超过 <code>isize::MAX</code> 字节，因此 <code>ptr_into_vec.offset_from(vec.as_ptr())</code> 始终满足最后两个条件。</p>
<p>从根本上说，大多数平台甚至都无法构建如此大的分配。
例如，由于页表的限制或地址空间的分割，没有已知的 64 位平台可以满足 2 <sup>63</sup> 字节的请求。
但是，某些 32 位和 16 位平台可能通过物理地址扩展之类的东西成功地为超过 <code>isize::MAX</code> 字节的请求提供服务。
因此，直接从分配器获取的内存或内存映射文件 <em>可能</em> 太大而无法使用此函数进行处理。
(请注意，<a href="#method.offset"><code>offset</code></a> 和 <a href="#method.add"><code>add</code></a> 也具有类似的限制，因此也不能在如此大的分配上使用。)</p>
<h1 id="panics" class="section-header"><a href="#panics">Panics</a></h1>
<p>如果 <code>T</code> 是零大小类型 (“ZST”)，则此函数 panics。</p>
<h1 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h1>
<p>基本用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> [<span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let</span> <span class="ident">ptr1</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">a</span>[<span class="number">1</span>];
<span class="kw">let</span> <span class="ident">ptr2</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">a</span>[<span class="number">3</span>];
<span class="kw">unsafe</span> {
    <span class="macro">assert_eq!</span>(<span class="ident">ptr2</span>.<span class="ident">offset_from</span>(<span class="ident">ptr1</span>), <span class="number">2</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">ptr1</span>.<span class="ident">offset_from</span>(<span class="ident">ptr2</span>), <span class="op">-</span><span class="number">2</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">ptr1</span>.<span class="ident">offset</span>(<span class="number">2</span>), <span class="ident">ptr2</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">ptr2</span>.<span class="ident">offset</span>(<span class="op">-</span><span class="number">2</span>), <span class="ident">ptr1</span>);
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20a%20%3D%20%5B0%3B%205%5D%3B%0Alet%20ptr1%3A%20*const%20i32%20%3D%20%26a%5B1%5D%3B%0Alet%20ptr2%3A%20*const%20i32%20%3D%20%26a%5B3%5D%3B%0Aunsafe%20%7B%0A%20%20%20%20assert_eq!(ptr2.offset_from(ptr1)%2C%202)%3B%0A%20%20%20%20assert_eq!(ptr1.offset_from(ptr2)%2C%20-2)%3B%0A%20%20%20%20assert_eq!(ptr1.offset(2)%2C%20ptr2)%3B%0A%20%20%20%20assert_eq!(ptr2.offset(-2)%2C%20ptr1)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<p><em>不正确</em> 用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">ptr1</span> <span class="op">=</span> <span class="ident">Box::into_raw</span>(<span class="ident">Box::new</span>(<span class="number">0u8</span>)) <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>;
<span class="kw">let</span> <span class="ident">ptr2</span> <span class="op">=</span> <span class="ident">Box::into_raw</span>(<span class="ident">Box::new</span>(<span class="number">1u8</span>)) <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>;
<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">ptr2</span> <span class="kw">as</span> <span class="ident">isize</span>).<span class="ident">wrapping_sub</span>(<span class="ident">ptr1</span> <span class="kw">as</span> <span class="ident">isize</span>);
<span class="comment">// 将 ptr2_other 设置为 ptr2 的 &quot;alias&quot;，但从 ptr1 派生。</span>
<span class="kw">let</span> <span class="ident">ptr2_other</span> <span class="op">=</span> (<span class="ident">ptr1</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>).<span class="ident">wrapping_offset</span>(<span class="ident">diff</span>);
<span class="macro">assert_eq!</span>(<span class="ident">ptr2</span> <span class="kw">as</span> <span class="ident">usize</span>, <span class="ident">ptr2_other</span> <span class="kw">as</span> <span class="ident">usize</span>);
<span class="comment">// 由于 ptr2_other 和 ptr2 是从指向不同对象的指针派生的，因此即使它们指向相同的地址，计算其偏移量也是未定义的行为!</span>
<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="ident">zero</span> <span class="op">=</span> <span class="ident">ptr2_other</span>.<span class="ident">offset_from</span>(<span class="ident">ptr2</span>); <span class="comment">// 未定义的行为</span>
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20ptr1%20%3D%20Box%3A%3Ainto_raw(Box%3A%3Anew(0u8))%20as%20*const%20u8%3B%0Alet%20ptr2%20%3D%20Box%3A%3Ainto_raw(Box%3A%3Anew(1u8))%20as%20*const%20u8%3B%0Alet%20diff%20%3D%20(ptr2%20as%20isize).wrapping_sub(ptr1%20as%20isize)%3B%0A%2F%2F%20%E5%B0%86%20ptr2_other%20%E8%AE%BE%E7%BD%AE%E4%B8%BA%20ptr2%20%E7%9A%84%20%22alias%22%EF%BC%8C%E4%BD%86%E4%BB%8E%20ptr1%20%E6%B4%BE%E7%94%9F%E3%80%82%0Alet%20ptr2_other%20%3D%20(ptr1%20as%20*const%20u8).wrapping_offset(diff)%3B%0Aassert_eq!(ptr2%20as%20usize%2C%20ptr2_other%20as%20usize)%3B%0A%2F%2F%20%E7%94%B1%E4%BA%8E%20ptr2_other%20%E5%92%8C%20ptr2%20%E6%98%AF%E4%BB%8E%E6%8C%87%E5%90%91%E4%B8%8D%E5%90%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8C%87%E9%92%88%E6%B4%BE%E7%94%9F%E7%9A%84%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%8D%B3%E4%BD%BF%E5%AE%83%E4%BB%AC%E6%8C%87%E5%90%91%E7%9B%B8%E5%90%8C%E7%9A%84%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%AE%A1%E7%AE%97%E5%85%B6%E5%81%8F%E7%A7%BB%E9%87%8F%E4%B9%9F%E6%98%AF%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA!%0Aunsafe%20%7B%0A%20%20%20%20let%20zero%20%3D%20ptr2_other.offset_from(ptr2)%3B%20%2F%2F%20%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.guaranteed_eq" class="method has-srclink"><h4 class="code-header">pub const fn <a href="#method.guaranteed_eq" class="fnname">guaranteed_eq</a>(self, other: <a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4><a href="#method.guaranteed_eq" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#418-420" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>const_raw_ptr_comparison</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/53020">#53020</a>)</div></div></summary><div class="docblock"><p>返回两个指针是否保证相等。</p>
<p>在运行时，此函数的行为类似于 <code>self == other</code>。
但是，在某些情况下 (例如，编译时评估)，并非总是可以确定两个指针是否相等，因此此函数可能会虚假地返回 <code>false</code> 来表示后来实际上相等的指针。</p>
<p>但是，当它返回 <code>true</code> 时，保证指针是相等的。</p>
<p>该函数是 <a href="#method.guaranteed_ne"><code>guaranteed_ne</code></a> 的镜像，但不是其反函数。有两个指针返回 <code>false</code> 的指针比较。</p>
<p>返回值可能会有所不同，具体取决于编译器版本，并且不安全的代码可能不依赖于此函数的结果来确保完整性。
建议仅将此函数用于性能优化，在这种情况下，此函数的虚假 <code>false</code> 返回值不会影响结果，而只会影响性能。
尚未探讨使用此方法使运行时和编译时代码表现不同的后果。
不应使用这种方法来引入这种差异，并且在我们对这个问题有更好的理解之前，也不应使其稳定。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.guaranteed_ne" class="method has-srclink"><h4 class="code-header">pub const fn <a href="#method.guaranteed_ne" class="fnname">guaranteed_ne</a>(self, other: <a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4><a href="#method.guaranteed_ne" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#449-451" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>const_raw_ptr_comparison</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/53020">#53020</a>)</div></div></summary><div class="docblock"><p>返回两个指针是否保证不相等。</p>
<p>在运行时，此函数的行为类似于 <code>self != other</code>。
但是，在某些情况下 (例如，编译时评估)，并非总是可以确定两个指针的不相等性，因此此函数可能会虚假地返回 <code>false</code> 来表示后来实际上不相等的指针。</p>
<p>但是，当它返回 <code>true</code> 时，保证指针是不相等的。</p>
<p>该函数是 <a href="#method.guaranteed_eq"><code>guaranteed_eq</code></a> 的镜像，但不是其反函数。有两个指针返回 <code>false</code> 的指针比较。</p>
<p>返回值可能会有所不同，具体取决于编译器版本，并且不安全的代码可能不依赖于此函数的结果来确保完整性。
建议仅将此函数用于性能优化，在这种情况下，此函数的虚假 <code>false</code> 返回值不会影响结果，而只会影响性能。
尚未探讨使用此方法使运行时和编译时代码表现不同的后果。
不应使用这种方法来引入这种差异，并且在我们对这个问题有更好的理解之前，也不应使其稳定。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.add" class="method has-srclink"><h4 class="code-header"><div class="code-attribute">#[must_use = "returns a new pointer rather than modifying its argument"]</div>pub const unsafe fn <a href="#method.add" class="fnname">add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.add" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#511-513" title="goto source code">[src]</a></div></summary><div class="docblock"><p>计算与指针的偏移量 (<code>.offset(count as isize)</code> 的便利性)。</p>
<p><code>count</code> 以 T 为单位; 例如，<code>count</code> 为 3 表示 <code>3 * size_of::&lt;T&gt;()</code> 字节的指针偏移量。</p>
<h1 id="safety-5" class="section-header"><a href="#safety-5">Safety</a></h1>
<p>如果违反以下任一条件，则结果为未定义行为:</p>
<ul>
<li>
<p>起始指针和结果指针都必须在边界内或在同一个 <a href="ptr/index.html#allocated-object">allocated object</a> 的末尾之后一个字节。</p>
</li>
<li>
<p>计算的偏移量 (以字节为单位 **) 不会使 <code>isize</code> 溢出。</p>
</li>
<li>
<p>偏移量不能依赖 “wrapping around” 地址空间。也就是说，无限精度和必须适合 <code>usize</code>。</p>
</li>
</ul>
<p>编译器和标准库通常会尝试确保分配永远不会达到需要考虑偏移量的大小。
例如，<code>Vec</code> 和 <code>Box</code> 确保它们分配的字节数永远不会超过 <code>isize::MAX</code> 字节，因此 <code>vec.as_ptr().add(vec.len())</code> 始终是安全的。</p>
<p>从根本上说，大多数平台甚至都无法构造这样的分配。
例如，由于页表的限制或地址空间的分割，没有已知的 64 位平台可以满足 2 <sup>63</sup> 字节的请求。
但是，某些 32 位和 16 位平台可能通过物理地址扩展之类的东西成功地为超过 <code>isize::MAX</code> 字节的请求提供服务。</p>
<p>因此，直接从分配器获取的内存或内存映射文件 <em>可能</em> 太大而无法使用此函数进行处理。</p>
<p>如果这些约束难以满足，请考虑使用 <a href="#method.wrapping_add"><code>wrapping_add</code></a>。
此方法的唯一优点是，它可以实现更积极的编译器优化。</p>
<h1 id="examples-6" class="section-header"><a href="#examples-6">Examples</a></h1>
<p>基本用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;123&quot;</span>;
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_ptr</span>();

<span class="kw">unsafe</span> {
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>.<span class="ident">add</span>(<span class="number">1</span>) <span class="kw">as</span> <span class="ident">char</span>);
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>.<span class="ident">add</span>(<span class="number">2</span>) <span class="kw">as</span> <span class="ident">char</span>);
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%3A%20%26str%20%3D%20%22123%22%3B%0Alet%20ptr%3A%20*const%20u8%20%3D%20s.as_ptr()%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.add(1)%20as%20char)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.add(2)%20as%20char)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.sub" class="method has-srclink"><h4 class="code-header"><div class="code-attribute">#[must_use = "returns a new pointer rather than modifying its argument"]</div>pub const unsafe fn <a href="#method.sub" class="fnname">sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.sub" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#575-577" title="goto source code">[src]</a></div></summary><div class="docblock"><p>计算与指针的偏移量 (<code>.offset((count as isize).wrapping_neg())</code> 的便利性)。</p>
<p><code>count</code> 以 T 为单位; 例如，<code>count</code> 为 3 表示 <code>3 * size_of::&lt;T&gt;()</code> 字节的指针偏移量。</p>
<h1 id="safety-6" class="section-header"><a href="#safety-6">Safety</a></h1>
<p>如果违反以下任一条件，则结果为未定义行为:</p>
<ul>
<li>
<p>起始指针和结果指针都必须在边界内或在同一个 <a href="ptr/index.html#allocated-object">allocated object</a> 的末尾之后一个字节。</p>
</li>
<li>
<p>计算的偏移量不能超过 <code>isize::MAX</code> 个 <strong>字节</strong>。</p>
</li>
<li>
<p>偏移量不能依赖 “wrapping around” 地址空间。也就是说，无限精度的总和必须适合使用大小。</p>
</li>
</ul>
<p>编译器和标准库通常会尝试确保分配永远不会达到需要考虑偏移量的大小。
例如，<code>Vec</code> 和 <code>Box</code> 确保它们分配的字节数永远不会超过 <code>isize::MAX</code> 字节，因此 <code>vec.as_ptr().add(vec.len()).sub(vec.len())</code> 始终是安全的。</p>
<p>从根本上说，大多数平台甚至都无法构造这样的分配。
例如，由于页表的限制或地址空间的分割，没有已知的 64 位平台可以满足 2 <sup>63</sup> 字节的请求。
但是，某些 32 位和 16 位平台可能通过物理地址扩展之类的东西成功地为超过 <code>isize::MAX</code> 字节的请求提供服务。</p>
<p>因此，直接从分配器获取的内存或内存映射文件 <em>可能</em> 太大而无法使用此函数进行处理。</p>
<p>如果这些约束难以满足，请考虑使用 <a href="#method.wrapping_sub"><code>wrapping_sub</code></a>。
此方法的唯一优点是，它可以实现更积极的编译器优化。</p>
<h1 id="examples-7" class="section-header"><a href="#examples-7">Examples</a></h1>
<p>基本用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;123&quot;</span>;

<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="ident">end</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_ptr</span>().<span class="ident">add</span>(<span class="number">3</span>);
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">end</span>.<span class="ident">sub</span>(<span class="number">1</span>) <span class="kw">as</span> <span class="ident">char</span>);
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">end</span>.<span class="ident">sub</span>(<span class="number">2</span>) <span class="kw">as</span> <span class="ident">char</span>);
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%3A%20%26str%20%3D%20%22123%22%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20let%20end%3A%20*const%20u8%20%3D%20s.as_ptr().add(3)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*end.sub(1)%20as%20char)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*end.sub(2)%20as%20char)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.wrapping_add" class="method has-srclink"><h4 class="code-header"><div class="code-attribute">#[must_use = "returns a new pointer rather than modifying its argument"]</div>pub const fn <a href="#method.wrapping_add" class="fnname">wrapping_add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.wrapping_add" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#638-640" title="goto source code">[src]</a></div></summary><div class="docblock"><p>使用换行算法计算与指针的偏移量。
(为 <code>.wrapping_offset(count as isize)</code> 带来的便利)</p>
<p><code>count</code> 以 T 为单位; 例如，<code>count</code> 为 3 表示 <code>3 * size_of::&lt;T&gt;()</code> 字节的指针偏移量。</p>
<h1 id="safety-7" class="section-header"><a href="#safety-7">Safety</a></h1>
<p>此操作本身始终是安全的，但使用结果指针则不安全。</p>
<p>结果指针 “remembers” 是 <code>self</code> 指向的 <a href="ptr/index.html#allocated-object">allocated object</a>; 它不能用于读取或写入其他分配的对象。</p>
<p>换句话说，即使我们假设 <code>T</code> 的大小为 <code>1</code> 并且没有溢出，<code>let z = x.wrapping_add((y as usize) - (x as usize))</code> 不会使 <code>z</code> 与 <code>y</code> 相同: <code>z</code> 仍附加到对象 <code>x</code> 所附加的对象，并且解引用它是 Undefined Behavior，除非 <code>x</code> 和 <code>y</code> 指向同一分配的对象。</p>
<p>与 <a href="#method.add"><code>add</code></a> 相比，此方法从根本上延迟了留在同一分配对象内的需求: <a href="#method.add"><code>add</code></a> 是跨越对象边界时的立即未定义行为; <code>wrapping_add</code> 产生一个指针，但如果指针超出其附加对象的范围而被解引用，则仍会导致未定义行为。
<a href="#method.add"><code>add</code></a> 可以更好地进行优化，因此在对性能敏感的代码中更可取。</p>
<p>延迟检查仅考虑解引用的指针的值，而不考虑最终结果计算期间使用的中间值。
例如，<code>x.wrapping_add(o).wrapping_sub(o)</code> 始终与 <code>x</code> 相同。换句话说，允许离开已分配的对象，然后在以后重新输入它。</p>
<h1 id="examples-8" class="section-header"><a href="#examples-8">Examples</a></h1>
<p>基本用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// 使用裸指针以两个元素为增量进行迭代</span>
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">as_ptr</span>();
<span class="kw">let</span> <span class="ident">step</span> <span class="op">=</span> <span class="number">2</span>;
<span class="kw">let</span> <span class="ident">end_rounded_up</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_add</span>(<span class="number">6</span>);

<span class="comment">// 此循环打印 &quot;1, 3, 5, &quot;</span>
<span class="kw">while</span> <span class="ident">ptr</span> <span class="op">!</span><span class="op">=</span> <span class="ident">end_rounded_up</span> {
    <span class="kw">unsafe</span> {
        <span class="macro">print!</span>(<span class="string">&quot;{}, &quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>);
    }
    <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_add</span>(<span class="ident">step</span>);
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%2F%2F%20%E4%BD%BF%E7%94%A8%E8%A3%B8%E6%8C%87%E9%92%88%E4%BB%A5%E4%B8%A4%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B8%BA%E5%A2%9E%E9%87%8F%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3%0Afn%20main()%20%7B%0Alet%20data%20%3D%20%5B1u8%2C%202%2C%203%2C%204%2C%205%5D%3B%0Alet%20mut%20ptr%3A%20*const%20u8%20%3D%20data.as_ptr()%3B%0Alet%20step%20%3D%202%3B%0Alet%20end_rounded_up%20%3D%20ptr.wrapping_add(6)%3B%0A%0A%2F%2F%20%E6%AD%A4%E5%BE%AA%E7%8E%AF%E6%89%93%E5%8D%B0%20%221%2C%203%2C%205%2C%20%22%0Awhile%20ptr%20!%3D%20end_rounded_up%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20print!(%22%7B%7D%2C%20%22%2C%20*ptr)%3B%0A%20%20%20%20%7D%0A%20%20%20%20ptr%20%3D%20ptr.wrapping_add(step)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.wrapping_sub" class="method has-srclink"><h4 class="code-header"><div class="code-attribute">#[must_use = "returns a new pointer rather than modifying its argument"]</div>pub const fn <a href="#method.wrapping_sub" class="fnname">wrapping_sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.wrapping_sub" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#700-702" title="goto source code">[src]</a></div></summary><div class="docblock"><p>使用换行算法计算与指针的偏移量。
(为 <code>.wrapping_offset((count as isize).wrapping_neg())</code> 带来的便利)</p>
<p><code>count</code> 以 T 为单位; 例如，<code>count</code> 为 3 表示 <code>3 * size_of::&lt;T&gt;()</code> 字节的指针偏移量。</p>
<h1 id="safety-8" class="section-header"><a href="#safety-8">Safety</a></h1>
<p>此操作本身始终是安全的，但使用结果指针则不安全。</p>
<p>结果指针 “remembers” 是 <code>self</code> 指向的 <a href="ptr/index.html#allocated-object">allocated object</a>; 它不能用于读取或写入其他分配的对象。</p>
<p>换句话说，即使我们假设 <code>T</code> 的大小为 <code>1</code> 并且没有溢出，<code>let z = x.wrapping_sub((x as usize) - (y as usize))</code> 不会使 <code>z</code> 与 <code>y</code> 相同: <code>z</code> 仍附加到对象 <code>x</code> 所附加的对象，并且解引用它是 Undefined Behavior，除非 <code>x</code> 和 <code>y</code> 指向同一分配的对象。</p>
<p>与 <a href="#method.sub"><code>sub</code></a> 相比，此方法从根本上延迟了留在同一分配对象内的需求: <a href="#method.sub"><code>sub</code></a> 是跨越对象边界时的立即未定义行为; <code>wrapping_sub</code> 产生一个指针，但如果指针超出其附加对象的范围而被解引用，则仍会导致未定义行为。
<a href="#method.sub"><code>sub</code></a> 可以更好地进行优化，因此在对性能敏感的代码中更可取。</p>
<p>延迟检查仅考虑解引用的指针的值，而不考虑最终结果计算期间使用的中间值。
例如，<code>x.wrapping_add(o).wrapping_sub(o)</code> 始终与 <code>x</code> 相同。换句话说，允许离开已分配的对象，然后在以后重新输入它。</p>
<h1 id="examples-9" class="section-header"><a href="#examples-9">Examples</a></h1>
<p>基本用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// 使用裸指针以两个元素 (backwards) 为增量进行迭代</span>
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">as_ptr</span>();
<span class="kw">let</span> <span class="ident">start_rounded_down</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_sub</span>(<span class="number">2</span>);
<span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_add</span>(<span class="number">4</span>);
<span class="kw">let</span> <span class="ident">step</span> <span class="op">=</span> <span class="number">2</span>;
<span class="comment">// 此循环打印 &quot;5, 3, 1, &quot;</span>
<span class="kw">while</span> <span class="ident">ptr</span> <span class="op">!</span><span class="op">=</span> <span class="ident">start_rounded_down</span> {
    <span class="kw">unsafe</span> {
        <span class="macro">print!</span>(<span class="string">&quot;{}, &quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>);
    }
    <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_sub</span>(<span class="ident">step</span>);
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%2F%2F%20%E4%BD%BF%E7%94%A8%E8%A3%B8%E6%8C%87%E9%92%88%E4%BB%A5%E4%B8%A4%E4%B8%AA%E5%85%83%E7%B4%A0%20(backwards)%20%E4%B8%BA%E5%A2%9E%E9%87%8F%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3%0Afn%20main()%20%7B%0Alet%20data%20%3D%20%5B1u8%2C%202%2C%203%2C%204%2C%205%5D%3B%0Alet%20mut%20ptr%3A%20*const%20u8%20%3D%20data.as_ptr()%3B%0Alet%20start_rounded_down%20%3D%20ptr.wrapping_sub(2)%3B%0Aptr%20%3D%20ptr.wrapping_add(4)%3B%0Alet%20step%20%3D%202%3B%0A%2F%2F%20%E6%AD%A4%E5%BE%AA%E7%8E%AF%E6%89%93%E5%8D%B0%20%225%2C%203%2C%201%2C%20%22%0Awhile%20ptr%20!%3D%20start_rounded_down%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20print!(%22%7B%7D%2C%20%22%2C%20*ptr)%3B%0A%20%20%20%20%7D%0A%20%20%20%20ptr%20%3D%20ptr.wrapping_sub(step)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.set_ptr_value" class="method has-srclink"><h4 class="code-header"><div class="code-attribute">#[must_use = "returns a new pointer rather than modifying its argument"]</div>pub fn <a href="#method.set_ptr_value" class="fnname">set_ptr_value</a>(self, val: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.u8.html">u8</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4><a href="#method.set_ptr_value" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#738" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>set_ptr_value</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75091">#75091</a>)</div></div></summary><div class="docblock"><p>将指针值设置为 <code>ptr</code>。</p>
<p>如果 <code>self</code> 是指向未定义大小类型的 (fat) 指针，则此操作将仅影响指针部分，而对于指向已确定大小类型的 (thin) 指针，其作用与简单分配相同。</p>
<p>生成的指针将具有 <code>val</code> 的出处，即对于胖指针，此操作在语义上与使用 <code>val</code> 的数据指针值但 <code>self</code> 的元数据创建新的胖指针相同。</p>
<h1 id="examples-10" class="section-header"><a href="#examples-10">Examples</a></h1>
<p>此函数主要用于允许对潜在的胖指针进行按字节指针算术运算:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">set_ptr_value</span>)]</span>
<span class="kw">let</span> <span class="ident">arr</span>: [<span class="ident">i32</span>; <span class="number">3</span>] <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">arr</span>.<span class="ident">as_ptr</span>() <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="kw">dyn</span> <span class="ident">Debug</span>;
<span class="kw">let</span> <span class="ident">thin</span> <span class="op">=</span> <span class="ident">ptr</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>;
<span class="kw">unsafe</span> {
    <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">set_ptr_value</span>(<span class="ident">thin</span>.<span class="ident">add</span>(<span class="number">8</span>));
    <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">ptr</span>); <span class="comment">// 将打印 &quot;3&quot;</span>
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(set_ptr_value)%5D%0Afn%20main()%20%7B%0Ause%20core%3A%3Afmt%3A%3ADebug%3B%0Alet%20arr%3A%20%5Bi32%3B%203%5D%20%3D%20%5B1%2C%202%2C%203%5D%3B%0Alet%20mut%20ptr%20%3D%20arr.as_ptr()%20as%20*const%20dyn%20Debug%3B%0Alet%20thin%20%3D%20ptr%20as%20*const%20u8%3B%0Aunsafe%20%7B%0A%20%20%20%20ptr%20%3D%20ptr.set_ptr_value(thin.add(8))%3B%0Aassert_eq!(*(ptr%20as%20*const%20i32)%2C%203)%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20%26*ptr)%3B%20%2F%2F%20%E5%B0%86%E6%89%93%E5%8D%B0%20%223%22%0A%7D%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.read" class="method has-srclink"><h4 class="code-header">pub const unsafe fn <a href="#method.read" class="fnname">read</a>(self) -&gt; T</h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.read" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#757-759" title="goto source code">[src]</a></div></summary><div class="docblock"><p>从 <code>self</code> 读取值而不移动它。
这将使 <code>self</code> 中的内存保持不变。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.read.html"><code>ptr::read</code></a>。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.read_volatile" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.read_volatile" class="fnname">read_volatile</a>(self) -&gt; T</h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.read_volatile" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#777-779" title="goto source code">[src]</a></div></summary><div class="docblock"><p>对 <code>self</code> 的值进行易失性读取，而无需移动它。这将使 <code>self</code> 中的内存保持不变。</p>
<p>易失性操作旨在作用于 I/O 存储器，并保证编译器不会在其他易失性操作中对易失性操作进行清除或重新排序。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.read_volatile.html"><code>ptr::read_volatile</code></a>。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.read_unaligned" class="method has-srclink"><h4 class="code-header">pub const unsafe fn <a href="#method.read_unaligned" class="fnname">read_unaligned</a>(self) -&gt; T</h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.read_unaligned" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#796-798" title="goto source code">[src]</a></div></summary><div class="docblock"><p>从 <code>self</code> 读取值而不移动它。
这将使 <code>self</code> 中的内存保持不变。</p>
<p>与 <code>read</code> 不同，指针可能未对齐。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.read_unaligned.html"><code>ptr::read_unaligned</code></a>。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.copy_to" class="method has-srclink"><h4 class="code-header">pub const unsafe fn <a href="#method.copy_to" class="fnname">copy_to</a>(self, dest: <a class="primitive" href="primitive.pointer.html">*mut T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.copy_to" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#815-817" title="goto source code">[src]</a></div></summary><div class="docblock"><p>将 <code>count * size_of&lt;T&gt;</code> 字节从 <code>self</code> 复制到 <code>dest</code>。
源和目标可能会重叠。</p>
<p>NOTE: 这与 <a href="ptr/fn.copy.html"><code>ptr::copy</code></a> 具有相同的参数顺序。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.copy.html"><code>ptr::copy</code></a>。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.copy_to_nonoverlapping" class="method has-srclink"><h4 class="code-header">pub const unsafe fn <a href="#method.copy_to_nonoverlapping" class="fnname">copy_to_nonoverlapping</a>(self, dest: <a class="primitive" href="primitive.pointer.html">*mut T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.copy_to_nonoverlapping" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#834-836" title="goto source code">[src]</a></div></summary><div class="docblock"><p>将 <code>count * size_of&lt;T&gt;</code> 字节从 <code>self</code> 复制到 <code>dest</code>。
源和目标可能 <em>不</em> 重叠。</p>
<p>NOTE: 这与 <a href="ptr/fn.copy_nonoverlapping.html"><code>ptr::copy_nonoverlapping</code></a> 具有相同的参数顺序。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.copy_nonoverlapping.html"><code>ptr::copy_nonoverlapping</code></a>。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.align_offset" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.align_offset" class="fnname">align_offset</a>(self, align: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span><a href="#method.align_offset" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#882-884" title="goto source code">[src]</a></div></summary><div class="docblock"><p>计算为使其与 <code>align</code> 对齐而需要应用到指针的偏移量。</p>
<p>如果无法对齐指针，则实现将返回 <code>usize::MAX</code>。
允许实现 <em>始终</em> 返回 <code>usize::MAX</code>。
只有算法的性能可以取决于此处是否可获得可用的偏移量，而不取决于其正确性。</p>
<p>偏移量以 <code>T</code> 元素的数量表示，而不是以字节表示。返回的值可以与 <code>wrapping_add</code> 方法一起使用。</p>
<p>不能保证偏移指针不会溢出或超出指针所指向的分配范围。</p>
<p>调用者应确保返回的偏移量在对齐方式以外的所有方面都是正确的。</p>
<h1 id="panics-1" class="section-header"><a href="#panics-1">Panics</a></h1>
<p>如果 <code>align</code> 不是 2 的幂，则函数 panics。</p>
<h1 id="examples-11" class="section-header"><a href="#examples-11">Examples</a></h1>
<p>将相邻的 <code>u8</code> 作为 <code>u16</code> 进行访问</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> [<span class="number">5u8</span>, <span class="number">6u8</span>, <span class="number">7u8</span>, <span class="number">8u8</span>, <span class="number">9u8</span>];
<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">as_ptr</span>().<span class="ident">add</span>(<span class="ident">n</span>) <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>;
<span class="kw">let</span> <span class="ident">offset</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">align_offset</span>(<span class="ident">align_of</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>());
<span class="kw">if</span> <span class="ident">offset</span> <span class="op">&lt;</span> <span class="ident">x</span>.<span class="ident">len</span>() <span class="op">-</span> <span class="ident">n</span> <span class="op">-</span> <span class="number">1</span> {
    <span class="kw">let</span> <span class="ident">u16_ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">add</span>(<span class="ident">offset</span>) <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u16</span>;
    <span class="macro">assert_ne!</span>(<span class="kw-2">*</span><span class="ident">u16_ptr</span>, <span class="number">500</span>);
} <span class="kw">else</span> {
    <span class="comment">// 虽然指针可以通过 `offset` 对齐，但它会指向分配之外</span>
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Afn%20foo(n%3A%20usize)%20%7B%0Ause%20std%3A%3Amem%3A%3Aalign_of%3B%0Aunsafe%20%7B%0Alet%20x%20%3D%20%5B5u8%2C%206u8%2C%207u8%2C%208u8%2C%209u8%5D%3B%0Alet%20ptr%20%3D%20x.as_ptr().add(n)%20as%20*const%20u8%3B%0Alet%20offset%20%3D%20ptr.align_offset(align_of%3A%3A%3Cu16%3E())%3B%0Aif%20offset%20%3C%20x.len()%20-%20n%20-%201%20%7B%0A%20%20%20%20let%20u16_ptr%20%3D%20ptr.add(offset)%20as%20*const%20u16%3B%0A%20%20%20%20assert_ne!(*u16_ptr%2C%20500)%3B%0A%7D%20else%20%7B%0A%20%20%20%20%2F%2F%20%E8%99%BD%E7%84%B6%E6%8C%87%E9%92%88%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%20%60offset%60%20%E5%AF%B9%E9%BD%90%EF%BC%8C%E4%BD%86%E5%AE%83%E4%BC%9A%E6%8C%87%E5%90%91%E5%88%86%E9%85%8D%E4%B9%8B%E5%A4%96%0A%7D%0A%7D%20%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-1" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#7-1153" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.is_null-1" class="method has-srclink"><h4 class="code-header">pub const fn <a href="#method.is_null-1" class="fnname">is_null</a>(self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4><a href="#method.is_null-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#36" title="goto source code">[src]</a></div></summary><div class="docblock"><p>如果指针为空，则返回 <code>true</code>。</p>
<p>请注意，未定义大小的类型具有许多可能的空指针，因为仅考虑原始数据指针，而不考虑其长度，vtable 等。
因此，两个为空的指针可能仍不能相互比较相等。</p>
<h2 id="常量评估期间的行为-1" class="section-header"><a href="#常量评估期间的行为-1">常量评估期间的行为</a></h2>
<p>在 const 评估期间使用此函数时，对于在运行时结果为空的指针，它可能返回 <code>false</code>。
具体来说，当指向某个内存的指针超出其范围的偏移量 (使结果指针为空) 时，函数仍将返回 <code>false</code>。</p>
<p>CTFE 无法知道该内存的绝对位置，因此我们无法确定指针是否为空。</p>
<h1 id="examples-12" class="section-header"><a href="#examples-12">Examples</a></h1>
<p>基本用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u32</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_mut_ptr</span>();
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">ptr</span>.<span class="ident">is_null</span>());</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20s%20%3D%20%5B1%2C%202%2C%203%5D%3B%0Alet%20ptr%3A%20*mut%20u32%20%3D%20s.as_mut_ptr()%3B%0Aassert!(!ptr.is_null())%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.cast-1" class="method has-srclink"><h4 class="code-header">pub const fn <a href="#method.cast-1" class="fnname">cast</a>&lt;U&gt;(self) -&gt; <a class="primitive" href="primitive.pointer.html">*mut U</a></h4><span class="since" title="Stable since Rust version 1.38.0, const since 1.38.0">1.38.0 (const: 1.38.0)</span><a href="#method.cast-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#46" title="goto source code">[src]</a></div></summary><div class="docblock"><p>强制转换为另一种类型的指针。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.to_raw_parts-1" class="method has-srclink"><h4 class="code-header">pub const fn <a href="#method.to_raw_parts-1" class="fnname">to_raw_parts</a>(self) -&gt; <a class="primitive" href="primitive.tuple.html">(</a><a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.unit.html">()</a>, &lt;T as <a class="trait" href="ptr/trait.Pointee.html" title="trait std::ptr::Pointee">Pointee</a>&gt;::<a class="type" href="ptr/trait.Pointee.html#associatedtype.Metadata" title="type std::ptr::Pointee::Metadata">Metadata</a><a class="primitive" href="primitive.tuple.html">)</a></h4><a href="#method.to_raw_parts-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#56" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>ptr_metadata</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/81513">#81513</a>)</div></div></summary><div class="docblock"><p>将 (可能是很宽的) 指针分解为地址和元数据组件。</p>
<p>以后可以使用 <a href="ptr/fn.from_raw_parts_mut.html" title="from_raw_parts_mut"><code>from_raw_parts_mut</code></a> 重建指针。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_ref-1" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.as_ref-1" class="fnname">as_ref</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;'a </a>T&gt;</h4><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span><a href="#method.as_ref-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#121" title="goto source code">[src]</a></div></summary><div class="docblock"><p>如果指针为空，则返回 <code>None</code>，否则返回 <code>Some</code> 中包装的值的共享引用。如果该值可能未初始化，则必须改用 <a href="#method.as_uninit_ref-1"><code>as_uninit_ref</code></a>。</p>
<p>对于可变的对应物，请参见 <a href="#method.as_mut"><code>as_mut</code></a>。</p>
<h1 id="safety-9" class="section-header"><a href="#safety-9">Safety</a></h1>
<p>调用此方法时，您必须确保要么指针是空的，要么以下所有内容都为真::</p>
<ul>
<li>
<p>指针必须正确对齐。</p>
</li>
<li>
<p>在 <a href="ptr/index.html#safety">the module documentation</a> 中定义的意义上，它必须是 “dereferencable”。</p>
</li>
<li>
<p>指针必须指向 <code>T</code> 的初始化实例。</p>
</li>
<li>
<p>您必须执行 Rust 的别名规则，因为返回的生命周期 <code>'a</code> 是任意选择的，不一定反映数据的实际生命周期。
特别是，在此生命周期的持续时间内，指针所指向的内存一定不能被可变的 (<code>UnsafeCell</code> 内部除外)。</p>
</li>
</ul>
<p>即使未使用此方法的结果也是如此!
(关于初始化的部分尚未完全决定，但是直到确定之前，唯一安全的方法是确保它们确实被初始化。)</p>
<h1 id="examples-13" class="section-header"><a href="#examples-13">Examples</a></h1>
<p>基本用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="number">10u8</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span>;

<span class="kw">unsafe</span> {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">val_back</span>) <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">as_ref</span>() {
        <span class="macro">println!</span>(<span class="string">&quot;We got back the value: {}!&quot;</span>, <span class="ident">val_back</span>);
    }
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20ptr%3A%20*mut%20u8%20%3D%20%26mut%2010u8%20as%20*mut%20u8%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20if%20let%20Some(val_back)%20%3D%20ptr.as_ref()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22We%20got%20back%20the%20value%3A%20%7B%7D!%22%2C%20val_back)%3B%0A%20%20%20%20%7D%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<h1 id="空未经检查的版本-1" class="section-header"><a href="#空未经检查的版本-1">空未经检查的版本</a></h1>
<p>如果确定指针永远不会为空，并且正在寻找某种返回 <code>&amp;T</code> 而不是 <code>Option&lt;&amp;T&gt;</code> 的 <code>as_ref_unchecked</code>，请知道您可以直接引用该指针。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="number">10u8</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span>;

<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="ident">val_back</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">ptr</span>;
    <span class="macro">println!</span>(<span class="string">&quot;We got back the value: {}!&quot;</span>, <span class="ident">val_back</span>);
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20ptr%3A%20*mut%20u8%20%3D%20%26mut%2010u8%20as%20*mut%20u8%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20let%20val_back%20%3D%20%26*ptr%3B%0A%20%20%20%20println!(%22We%20got%20back%20the%20value%3A%20%7B%7D!%22%2C%20val_back)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_uninit_ref-1" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.as_uninit_ref-1" class="fnname">as_uninit_ref</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;'a <a class="union" href="mem/union.MaybeUninit.html" title="union std::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;&gt;</h4><a href="#method.as_uninit_ref-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#171-173" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>ptr_as_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75402">#75402</a>)</div></div></summary><div class="docblock"><p>如果指针为空，则返回 <code>None</code>，否则返回 <code>Some</code> 中包装的值的共享引用。
与 <a href="#method.as_ref-1"><code>as_ref</code></a> 相比，这不需要将该值初始化。</p>
<p>对于可变的对应物，请参见 <a href="#method.as_uninit_mut"><code>as_uninit_mut</code></a>。</p>
<h1 id="safety-10" class="section-header"><a href="#safety-10">Safety</a></h1>
<p>调用此方法时，您必须确保要么指针是空的，要么以下所有内容都为真::</p>
<ul>
<li>
<p>指针必须正确对齐。</p>
</li>
<li>
<p>在 <a href="ptr/index.html#safety">the module documentation</a> 中定义的意义上，它必须是 “dereferencable”。</p>
</li>
<li>
<p>您必须执行 Rust 的别名规则，因为返回的生命周期 <code>'a</code> 是任意选择的，不一定反映数据的实际生命周期。</p>
<p>特别是，在此生命周期的持续时间内，指针所指向的内存一定不能被可变的 (<code>UnsafeCell</code> 内部除外)。</p>
</li>
</ul>
<p>即使未使用此方法的结果也是如此!</p>
<h1 id="examples-14" class="section-header"><a href="#examples-14">Examples</a></h1>
<p>基本用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">ptr_as_uninit</span>)]</span>

<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="number">10u8</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span>;

<span class="kw">unsafe</span> {
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">val_back</span>) <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">as_uninit_ref</span>() {
        <span class="macro">println!</span>(<span class="string">&quot;We got back the value: {}!&quot;</span>, <span class="ident">val_back</span>.<span class="ident">assume_init</span>());
    }
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(ptr_as_uninit)%5D%0A%0Afn%20main()%20%7B%0Alet%20ptr%3A%20*mut%20u8%20%3D%20%26mut%2010u8%20as%20*mut%20u8%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20if%20let%20Some(val_back)%20%3D%20ptr.as_uninit_ref()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22We%20got%20back%20the%20value%3A%20%7B%7D!%22%2C%20val_back.assume_init())%3B%0A%20%20%20%20%7D%0A%7D%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.offset-1" class="method has-srclink"><h4 class="code-header"><div class="code-attribute">#[must_use = "returns a new pointer rather than modifying its argument"]</div>pub const unsafe fn <a href="#method.offset-1" class="fnname">offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4><a href="#method.offset-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#235-237" title="goto source code">[src]</a></div></summary><div class="docblock"><p>计算与指针的偏移量。</p>
<p><code>count</code> 以 T 为单位; 例如，<code>count</code> 为 3 表示 <code>3 * size_of::&lt;T&gt;()</code> 字节的指针偏移量。</p>
<h1 id="safety-11" class="section-header"><a href="#safety-11">Safety</a></h1>
<p>如果违反以下任一条件，则结果为未定义行为:</p>
<ul>
<li>
<p>起始指针和结果指针都必须在边界内或在同一个 <a href="ptr/index.html#allocated-object">allocated object</a> 的末尾之后一个字节。</p>
</li>
<li>
<p>计算的偏移量 (以字节为单位 **) 不会使 <code>isize</code> 溢出。</p>
</li>
<li>
<p>偏移量不能依赖 “wrapping around” 地址空间。也就是说，无限精度总和 (以字节为单位) 必须适合于 usize。</p>
</li>
</ul>
<p>编译器和标准库通常会尝试确保分配永远不会达到需要考虑偏移量的大小。
例如，<code>Vec</code> 和 <code>Box</code> 确保它们分配的字节数永远不会超过 <code>isize::MAX</code> 字节，因此 <code>vec.as_ptr().add(vec.len())</code> 始终是安全的。</p>
<p>从根本上说，大多数平台甚至都无法构造这样的分配。
例如，由于页表的限制或地址空间的分割，没有已知的 64 位平台可以满足 2 <sup>63</sup> 字节的请求。
但是，某些 32 位和 16 位平台可能通过物理地址扩展之类的东西成功地为超过 <code>isize::MAX</code> 字节的请求提供服务。</p>
<p>因此，直接从分配器获取的内存或内存映射文件 <em>可能</em> 太大而无法使用此函数进行处理。</p>
<p>如果这些约束难以满足，请考虑使用 <a href="#method.wrapping_offset"><code>wrapping_offset</code></a>。
此方法的唯一优点是，它可以实现更积极的编译器优化。</p>
<h1 id="examples-15" class="section-header"><a href="#examples-15">Examples</a></h1>
<p>基本用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u32</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_mut_ptr</span>();

<span class="kw">unsafe</span> {
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>.<span class="ident">offset</span>(<span class="number">1</span>));
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>.<span class="ident">offset</span>(<span class="number">2</span>));
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20s%20%3D%20%5B1%2C%202%2C%203%5D%3B%0Alet%20ptr%3A%20*mut%20u32%20%3D%20s.as_mut_ptr()%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.offset(1))%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.offset(2))%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.wrapping_offset-1" class="method has-srclink"><h4 class="code-header"><div class="code-attribute">#[must_use = "returns a new pointer rather than modifying its argument"]</div>pub const fn <a href="#method.wrapping_offset-1" class="fnname">wrapping_offset</a>(self, count: <a class="primitive" href="primitive.isize.html">isize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span><a href="#method.wrapping_offset-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#298-300" title="goto source code">[src]</a></div></summary><div class="docblock"><p>使用换行算法计算与指针的偏移量。
<code>count</code> 以 T 为单位; 例如，<code>count</code> 为 3 表示 <code>3 * size_of::&lt;T&gt;()</code> 字节的指针偏移量。</p>
<h1 id="safety-12" class="section-header"><a href="#safety-12">Safety</a></h1>
<p>此操作本身始终是安全的，但使用结果指针则不安全。</p>
<p>结果指针 “remembers” 是 <code>self</code> 指向的 <a href="ptr/index.html#allocated-object">allocated object</a>; 它不能用于读取或写入其他分配的对象。</p>
<p>换句话说，即使我们假设 <code>T</code> 的大小为 <code>1</code> 并且没有溢出，<code>let z = x.wrapping_offset((y as isize) - (x as isize))</code> 不会使 <code>z</code> 与 <code>y</code> 相同: <code>z</code> 仍附加到对象 <code>x</code> 所附加的对象，并且解引用它是 Undefined Behavior，除非 <code>x</code> 和 <code>y</code> 指向同一分配的对象。</p>
<p>与 <a href="#method.offset"><code>offset</code></a> 相比，此方法从根本上延迟了留在同一分配对象内的需求: <a href="#method.offset"><code>offset</code></a> 是跨越对象边界时的立即未定义行为; <code>wrapping_offset</code> 产生一个指针，但如果指针超出其附加对象的范围而被解引用，则仍会导致未定义行为。
<a href="#method.offset"><code>offset</code></a> 可以更好地进行优化，因此在对性能敏感的代码中更可取。</p>
<p>延迟检查仅考虑解引用的指针的值，而不考虑最终结果计算期间使用的中间值。
例如，<code>x.wrapping_offset(o).wrapping_offset(o.wrapping_neg())</code> 始终与 <code>x</code> 相同。换句话说，允许离开已分配的对象，然后在以后重新输入它。</p>
<h1 id="examples-16" class="section-header"><a href="#examples-16">Examples</a></h1>
<p>基本用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// 使用裸指针以两个元素为增量进行迭代</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">as_mut_ptr</span>();
<span class="kw">let</span> <span class="ident">step</span> <span class="op">=</span> <span class="number">2</span>;
<span class="kw">let</span> <span class="ident">end_rounded_up</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_offset</span>(<span class="number">6</span>);

<span class="kw">while</span> <span class="ident">ptr</span> <span class="op">!</span><span class="op">=</span> <span class="ident">end_rounded_up</span> {
    <span class="kw">unsafe</span> {
        <span class="kw-2">*</span><span class="ident">ptr</span> <span class="op">=</span> <span class="number">0</span>;
    }
    <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_offset</span>(<span class="ident">step</span>);
}
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">data</span>, <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>]);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%2F%2F%20%E4%BD%BF%E7%94%A8%E8%A3%B8%E6%8C%87%E9%92%88%E4%BB%A5%E4%B8%A4%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B8%BA%E5%A2%9E%E9%87%8F%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3%0Afn%20main()%20%7B%0Alet%20mut%20data%20%3D%20%5B1u8%2C%202%2C%203%2C%204%2C%205%5D%3B%0Alet%20mut%20ptr%3A%20*mut%20u8%20%3D%20data.as_mut_ptr()%3B%0Alet%20step%20%3D%202%3B%0Alet%20end_rounded_up%20%3D%20ptr.wrapping_offset(6)%3B%0A%0Awhile%20ptr%20!%3D%20end_rounded_up%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20*ptr%20%3D%200%3B%0A%20%20%20%20%7D%0A%20%20%20%20ptr%20%3D%20ptr.wrapping_offset(step)%3B%0A%7D%0Aassert_eq!(%26data%2C%20%26%5B0%2C%202%2C%200%2C%204%2C%200%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_mut" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.as_mut" class="fnname">as_mut</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.reference.html">&amp;'a mut </a>T&gt;</h4><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span><a href="#method.as_mut" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#366" title="goto source code">[src]</a></div></summary><div class="docblock"><p>如果指针为 null，则返回 <code>None</code>，否则返回 <code>Some</code> 中包装的值的唯一引用。如果该值可能未初始化，则必须改用 <a href="#method.as_uninit_mut"><code>as_uninit_mut</code></a>。</p>
<p>有关共享副本，请参见 <a href="#method.as_ref-1"><code>as_ref</code></a>。</p>
<h1 id="safety-13" class="section-header"><a href="#safety-13">Safety</a></h1>
<p>调用此方法时，您必须确保要么指针是空的，要么以下所有内容都为真::</p>
<ul>
<li>
<p>指针必须正确对齐。</p>
</li>
<li>
<p>在 <a href="ptr/index.html#safety">the module documentation</a> 中定义的意义上，它必须是 “dereferencable”。</p>
</li>
<li>
<p>指针必须指向 <code>T</code> 的初始化实例。</p>
</li>
<li>
<p>您必须执行 Rust 的别名规则，因为返回的生命周期 <code>'a</code> 是任意选择的，不一定反映数据的实际生命周期。
特别是，在此生命周期的持续时间内，指针所指向的内存一定不能通过任何其他指针进行访问 (读取或写入)。</p>
</li>
</ul>
<p>即使未使用此方法的结果也是如此!
(关于初始化的部分尚未完全决定，但是直到确定之前，唯一安全的方法是确保它们确实被初始化。)</p>
<h1 id="examples-17" class="section-header"><a href="#examples-17">Examples</a></h1>
<p>基本用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u32</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_mut_ptr</span>();
<span class="kw">let</span> <span class="ident">first_value</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">ptr</span>.<span class="ident">as_mut</span>().<span class="ident">unwrap</span>() };
<span class="kw-2">*</span><span class="ident">first_value</span> <span class="op">=</span> <span class="number">4</span>;
<span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">s</span>); <span class="comment">// 它会打印: &quot;[4, 2, 3]&quot;.</span></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20s%20%3D%20%5B1%2C%202%2C%203%5D%3B%0Alet%20ptr%3A%20*mut%20u32%20%3D%20s.as_mut_ptr()%3B%0Alet%20first_value%20%3D%20unsafe%20%7B%20ptr.as_mut().unwrap()%20%7D%3B%0A*first_value%20%3D%204%3B%0Aassert_eq!(s%2C%20%5B4%2C%202%2C%203%5D)%3B%0Aprintln!(%22%7B%3A%3F%7D%22%2C%20s)%3B%20%2F%2F%20%E5%AE%83%E4%BC%9A%E6%89%93%E5%8D%B0%3A%20%22%5B4%2C%202%2C%203%5D%22.%0A%7D&amp;edition=2018">Run</a></div>
<h1 id="空未经检查的版本-2" class="section-header"><a href="#空未经检查的版本-2">空未经检查的版本</a></h1>
<p>如果确定指针永远不会为空，并且正在寻找某种返回 <code>&amp;mut T</code> 而不是 <code>Option&lt;&amp;mut T&gt;</code> 的 <code>as_mut_unchecked</code>，请知道您可以直接引用该指针。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u32</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_mut_ptr</span>();
<span class="kw">let</span> <span class="ident">first_value</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="kw-2">*</span><span class="ident">ptr</span> };
<span class="kw-2">*</span><span class="ident">first_value</span> <span class="op">=</span> <span class="number">4</span>;
<span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">s</span>); <span class="comment">// 它会打印: &quot;[4, 2, 3]&quot;.</span></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20s%20%3D%20%5B1%2C%202%2C%203%5D%3B%0Alet%20ptr%3A%20*mut%20u32%20%3D%20s.as_mut_ptr()%3B%0Alet%20first_value%20%3D%20unsafe%20%7B%20%26mut%20*ptr%20%7D%3B%0A*first_value%20%3D%204%3B%0Aassert_eq!(s%2C%20%5B4%2C%202%2C%203%5D)%3B%0Aprintln!(%22%7B%3A%3F%7D%22%2C%20s)%3B%20%2F%2F%20%E5%AE%83%E4%BC%9A%E6%89%93%E5%8D%B0%3A%20%22%5B4%2C%202%2C%203%5D%22.%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_uninit_mut" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.as_uninit_mut" class="fnname">as_uninit_mut</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;'a mut <a class="union" href="mem/union.MaybeUninit.html" title="union std::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;&gt;</h4><a href="#method.as_uninit_mut" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#400-402" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>ptr_as_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75402">#75402</a>)</div></div></summary><div class="docblock"><p>如果指针为 null，则返回 <code>None</code>，否则返回 <code>Some</code> 中包装的值的唯一引用。
与 <a href="#method.as_mut"><code>as_mut</code></a> 相比，这不需要将该值初始化。</p>
<p>有关共享副本，请参见 <a href="#method.as_uninit_ref-1"><code>as_uninit_ref</code></a>。</p>
<h1 id="safety-14" class="section-header"><a href="#safety-14">Safety</a></h1>
<p>调用此方法时，您必须确保要么指针是空的，要么以下所有内容都为真::</p>
<ul>
<li>
<p>指针必须正确对齐。</p>
</li>
<li>
<p>在 <a href="ptr/index.html#safety">the module documentation</a> 中定义的意义上，它必须是 “dereferencable”。</p>
</li>
<li>
<p>您必须执行 Rust 的别名规则，因为返回的生命周期 <code>'a</code> 是任意选择的，不一定反映数据的实际生命周期。</p>
<p>特别是，在此生命周期的持续时间内，指针所指向的内存一定不能通过任何其他指针进行访问 (读取或写入)。</p>
</li>
</ul>
<p>即使未使用此方法的结果也是如此!</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.guaranteed_eq-1" class="method has-srclink"><h4 class="code-header">pub const fn <a href="#method.guaranteed_eq-1" class="fnname">guaranteed_eq</a>(self, other: <a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4><a href="#method.guaranteed_eq-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#433-435" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>const_raw_ptr_comparison</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/53020">#53020</a>)</div></div></summary><div class="docblock"><p>返回两个指针是否保证相等。</p>
<p>在运行时，此函数的行为类似于 <code>self == other</code>。
但是，在某些情况下 (例如，编译时评估)，并非总是可以确定两个指针是否相等，因此此函数可能会虚假地返回 <code>false</code> 来表示后来实际上相等的指针。</p>
<p>但是，当它返回 <code>true</code> 时，保证指针是相等的。</p>
<p>该函数是 <a href="#method.guaranteed_ne"><code>guaranteed_ne</code></a> 的镜像，但不是其反函数。有两个指针返回 <code>false</code> 的指针比较。</p>
<p>返回值可能会有所不同，具体取决于编译器版本，并且不安全的代码可能不依赖于此函数的结果来确保完整性。
建议仅将此函数用于性能优化，在这种情况下，此函数的虚假 <code>false</code> 返回值不会影响结果，而只会影响性能。
尚未探讨使用此方法使运行时和编译时代码表现不同的后果。
不应使用这种方法来引入这种差异，并且在我们对这个问题有更好的理解之前，也不应使其稳定。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.guaranteed_ne-1" class="method has-srclink"><h4 class="code-header">pub const unsafe fn <a href="#method.guaranteed_ne-1" class="fnname">guaranteed_ne</a>(self, other: <a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4><a href="#method.guaranteed_ne-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#464-466" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>const_raw_ptr_comparison</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/53020">#53020</a>)</div></div></summary><div class="docblock"><p>返回两个指针是否保证不相等。</p>
<p>在运行时，此函数的行为类似于 <code>self != other</code>。
但是，在某些情况下 (例如，编译时评估)，并非总是可以确定两个指针的不相等性，因此此函数可能会虚假地返回 <code>false</code> 来表示后来实际上不相等的指针。</p>
<p>但是，当它返回 <code>true</code> 时，保证指针是不相等的。</p>
<p>该函数是 <a href="#method.guaranteed_eq"><code>guaranteed_eq</code></a> 的镜像，但不是其反函数。有两个指针返回 <code>false</code> 的指针比较。</p>
<p>返回值可能会有所不同，具体取决于编译器版本，并且不安全的代码可能不依赖于此函数的结果来确保完整性。
建议仅将此函数用于性能优化，在这种情况下，此函数的虚假 <code>false</code> 返回值不会影响结果，而只会影响性能。
尚未探讨使用此方法使运行时和编译时代码表现不同的后果。
不应使用这种方法来引入这种差异，并且在我们对这个问题有更好的理解之前，也不应使其稳定。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.offset_from-1" class="method has-srclink"><h4 class="code-header">pub const unsafe fn <a href="#method.offset_from-1" class="fnname">offset_from</a>(self, origin: <a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.isize.html">isize</a></h4><span class="since" title="Stable since Rust version 1.47.0">1.47.0</span><a href="#method.offset_from-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#555-557" title="goto source code">[src]</a></div></summary><div class="docblock"><p>计算两个指针之间的距离。返回的值以 T 为单位: 以字节为单位的距离除以 <code>mem::size_of::&lt;T&gt;()</code>。</p>
<p>该函数是 <a href="#method.offset-1"><code>offset</code></a> 的逆函数。</p>
<h1 id="safety-15" class="section-header"><a href="#safety-15">Safety</a></h1>
<p>如果违反以下任一条件，则结果为未定义行为:</p>
<ul>
<li>
<p>起始指针和其他指针都必须在边界内或在同一个 <a href="ptr/index.html#allocated-object">allocated object</a> 的末尾之后一个字节。</p>
</li>
<li>
<p>两个指针必须是指向同一对象的指针的 *derived。
(请参见下面的示例。)</p>
</li>
<li>
<p>指针之间的距离 (以字节为单位) 必须是 <code>T</code> 大小的精确倍数。</p>
</li>
<li>
<p>指针之间的距离 (以字节为单位) 不会溢出 <code>isize</code>。</p>
</li>
<li>
<p>该距离不能依赖于 “wrapping around” 地址空间。</p>
</li>
</ul>
<p>Rust 类型从不大于 <code>isize::MAX</code>，并且 Rust 分配从不环绕地址空间，因此，任何 Rust 类型 <code>T</code> 的某个值内的两个指针将始终满足最后两个条件。</p>
<p>标准库通常还确保分配永远不会达到需要考虑偏移量的大小。
例如，<code>Vec</code> 和 <code>Box</code> 确保它们分配的字节数永远不超过 <code>isize::MAX</code> 字节，因此 <code>ptr_into_vec.offset_from(vec.as_ptr())</code> 始终满足最后两个条件。</p>
<p>从根本上说，大多数平台甚至都无法构建如此大的分配。
例如，由于页表的限制或地址空间的分割，没有已知的 64 位平台可以满足 2 <sup>63</sup> 字节的请求。
但是，某些 32 位和 16 位平台可能通过物理地址扩展之类的东西成功地为超过 <code>isize::MAX</code> 字节的请求提供服务。
因此，直接从分配器获取的内存或内存映射文件 <em>可能</em> 太大而无法使用此函数进行处理。
(请注意，<a href="#method.offset-1"><code>offset</code></a> 和 <a href="#method.add"><code>add</code></a> 也具有类似的限制，因此也不能在如此大的分配上使用。)</p>
<h1 id="panics-2" class="section-header"><a href="#panics-2">Panics</a></h1>
<p>如果 <code>T</code> 是零大小类型 (“ZST”)，则此函数 panics。</p>
<h1 id="examples-18" class="section-header"><a href="#examples-18">Examples</a></h1>
<p>基本用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> [<span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let</span> <span class="ident">ptr1</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">a</span>[<span class="number">1</span>];
<span class="kw">let</span> <span class="ident">ptr2</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i32</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">a</span>[<span class="number">3</span>];
<span class="kw">unsafe</span> {
    <span class="macro">assert_eq!</span>(<span class="ident">ptr2</span>.<span class="ident">offset_from</span>(<span class="ident">ptr1</span>), <span class="number">2</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">ptr1</span>.<span class="ident">offset_from</span>(<span class="ident">ptr2</span>), <span class="op">-</span><span class="number">2</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">ptr1</span>.<span class="ident">offset</span>(<span class="number">2</span>), <span class="ident">ptr2</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">ptr2</span>.<span class="ident">offset</span>(<span class="op">-</span><span class="number">2</span>), <span class="ident">ptr1</span>);
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20a%20%3D%20%5B0%3B%205%5D%3B%0Alet%20ptr1%3A%20*mut%20i32%20%3D%20%26mut%20a%5B1%5D%3B%0Alet%20ptr2%3A%20*mut%20i32%20%3D%20%26mut%20a%5B3%5D%3B%0Aunsafe%20%7B%0A%20%20%20%20assert_eq!(ptr2.offset_from(ptr1)%2C%202)%3B%0A%20%20%20%20assert_eq!(ptr1.offset_from(ptr2)%2C%20-2)%3B%0A%20%20%20%20assert_eq!(ptr1.offset(2)%2C%20ptr2)%3B%0A%20%20%20%20assert_eq!(ptr2.offset(-2)%2C%20ptr1)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<p><em>不正确</em> 用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">ptr1</span> <span class="op">=</span> <span class="ident">Box::into_raw</span>(<span class="ident">Box::new</span>(<span class="number">0u8</span>));
<span class="kw">let</span> <span class="ident">ptr2</span> <span class="op">=</span> <span class="ident">Box::into_raw</span>(<span class="ident">Box::new</span>(<span class="number">1u8</span>));
<span class="kw">let</span> <span class="ident">diff</span> <span class="op">=</span> (<span class="ident">ptr2</span> <span class="kw">as</span> <span class="ident">isize</span>).<span class="ident">wrapping_sub</span>(<span class="ident">ptr1</span> <span class="kw">as</span> <span class="ident">isize</span>);
<span class="comment">// 将 ptr2_other 设置为 ptr2 的 &quot;alias&quot;，但从 ptr1 派生。</span>
<span class="kw">let</span> <span class="ident">ptr2_other</span> <span class="op">=</span> (<span class="ident">ptr1</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span>).<span class="ident">wrapping_offset</span>(<span class="ident">diff</span>);
<span class="macro">assert_eq!</span>(<span class="ident">ptr2</span> <span class="kw">as</span> <span class="ident">usize</span>, <span class="ident">ptr2_other</span> <span class="kw">as</span> <span class="ident">usize</span>);
<span class="comment">// 由于 ptr2_other 和 ptr2 是从指向不同对象的指针派生的，因此即使它们指向相同的地址，计算其偏移量也是未定义的行为!</span>
<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="ident">zero</span> <span class="op">=</span> <span class="ident">ptr2_other</span>.<span class="ident">offset_from</span>(<span class="ident">ptr2</span>); <span class="comment">// 未定义的行为</span>
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20ptr1%20%3D%20Box%3A%3Ainto_raw(Box%3A%3Anew(0u8))%3B%0Alet%20ptr2%20%3D%20Box%3A%3Ainto_raw(Box%3A%3Anew(1u8))%3B%0Alet%20diff%20%3D%20(ptr2%20as%20isize).wrapping_sub(ptr1%20as%20isize)%3B%0A%2F%2F%20%E5%B0%86%20ptr2_other%20%E8%AE%BE%E7%BD%AE%E4%B8%BA%20ptr2%20%E7%9A%84%20%22alias%22%EF%BC%8C%E4%BD%86%E4%BB%8E%20ptr1%20%E6%B4%BE%E7%94%9F%E3%80%82%0Alet%20ptr2_other%20%3D%20(ptr1%20as%20*mut%20u8).wrapping_offset(diff)%3B%0Aassert_eq!(ptr2%20as%20usize%2C%20ptr2_other%20as%20usize)%3B%0A%2F%2F%20%E7%94%B1%E4%BA%8E%20ptr2_other%20%E5%92%8C%20ptr2%20%E6%98%AF%E4%BB%8E%E6%8C%87%E5%90%91%E4%B8%8D%E5%90%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8C%87%E9%92%88%E6%B4%BE%E7%94%9F%E7%9A%84%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%8D%B3%E4%BD%BF%E5%AE%83%E4%BB%AC%E6%8C%87%E5%90%91%E7%9B%B8%E5%90%8C%E7%9A%84%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%AE%A1%E7%AE%97%E5%85%B6%E5%81%8F%E7%A7%BB%E9%87%8F%E4%B9%9F%E6%98%AF%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA!%0Aunsafe%20%7B%0A%20%20%20%20let%20zero%20%3D%20ptr2_other.offset_from(ptr2)%3B%20%2F%2F%20%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.add-1" class="method has-srclink"><h4 class="code-header"><div class="code-attribute">#[must_use = "returns a new pointer rather than modifying its argument"]</div>pub const unsafe fn <a href="#method.add-1" class="fnname">add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.add-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#617-619" title="goto source code">[src]</a></div></summary><div class="docblock"><p>计算与指针的偏移量 (<code>.offset(count as isize)</code> 的便利性)。</p>
<p><code>count</code> 以 T 为单位; 例如，<code>count</code> 为 3 表示 <code>3 * size_of::&lt;T&gt;()</code> 字节的指针偏移量。</p>
<h1 id="safety-16" class="section-header"><a href="#safety-16">Safety</a></h1>
<p>如果违反以下任一条件，则结果为未定义行为:</p>
<ul>
<li>
<p>起始指针和结果指针都必须在边界内或在同一个 [allocated object] 的末尾之后一个字节。</p>
</li>
<li>
<p>计算的偏移量 (以字节为单位 **) 不会使 <code>isize</code> 溢出。</p>
</li>
<li>
<p>偏移量不能依赖 “wrapping around” 地址空间。也就是说，无限精度和必须适合 <code>usize</code>。</p>
</li>
</ul>
<p>编译器和标准库通常会尝试确保分配永远不会达到需要考虑偏移量的大小。
例如，<code>Vec</code> 和 <code>Box</code> 确保它们分配的字节数永远不会超过 <code>isize::MAX</code> 字节，因此 <code>vec.as_ptr().add(vec.len())</code> 始终是安全的。</p>
<p>从根本上说，大多数平台甚至都无法构造这样的分配。
例如，由于页表的限制或地址空间的分割，没有已知的 64 位平台可以满足 2 <sup>63</sup> 字节的请求。
但是，某些 32 位和 16 位平台可能通过物理地址扩展之类的东西成功地为超过 <code>isize::MAX</code> 字节的请求提供服务。</p>
<p>因此，直接从分配器获取的内存或内存映射文件 <em>可能</em> 太大而无法使用此函数进行处理。</p>
<p>如果这些约束难以满足，请考虑使用 <a href="#method.wrapping_add"><code>wrapping_add</code></a>。
此方法的唯一优点是，它可以实现更积极的编译器优化。</p>
<h1 id="examples-19" class="section-header"><a href="#examples-19">Examples</a></h1>
<p>基本用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;123&quot;</span>;
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_ptr</span>();

<span class="kw">unsafe</span> {
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>.<span class="ident">add</span>(<span class="number">1</span>) <span class="kw">as</span> <span class="ident">char</span>);
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>.<span class="ident">add</span>(<span class="number">2</span>) <span class="kw">as</span> <span class="ident">char</span>);
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%3A%20%26str%20%3D%20%22123%22%3B%0Alet%20ptr%3A%20*const%20u8%20%3D%20s.as_ptr()%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.add(1)%20as%20char)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*ptr.add(2)%20as%20char)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.sub-1" class="method has-srclink"><h4 class="code-header"><div class="code-attribute">#[must_use = "returns a new pointer rather than modifying its argument"]</div>pub const unsafe fn <a href="#method.sub-1" class="fnname">sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.sub-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#681-683" title="goto source code">[src]</a></div></summary><div class="docblock"><p>计算与指针的偏移量 (<code>.offset((count as isize).wrapping_neg())</code> 的便利性)。</p>
<p><code>count</code> 以 T 为单位; 例如，<code>count</code> 为 3 表示 <code>3 * size_of::&lt;T&gt;()</code> 字节的指针偏移量。</p>
<h1 id="safety-17" class="section-header"><a href="#safety-17">Safety</a></h1>
<p>如果违反以下任一条件，则结果为未定义行为:</p>
<ul>
<li>
<p>起始指针和结果指针都必须在边界内或在同一个 <a href="ptr/index.html#allocated-object">allocated object</a> 的末尾之后一个字节。</p>
</li>
<li>
<p>计算的偏移量不能超过 <code>isize::MAX</code> 个 <strong>字节</strong>。</p>
</li>
<li>
<p>偏移量不能依赖 “wrapping around” 地址空间。也就是说，无限精度的总和必须适合使用大小。</p>
</li>
</ul>
<p>编译器和标准库通常会尝试确保分配永远不会达到需要考虑偏移量的大小。
例如，<code>Vec</code> 和 <code>Box</code> 确保它们分配的字节数永远不会超过 <code>isize::MAX</code> 字节，因此 <code>vec.as_ptr().add(vec.len()).sub(vec.len())</code> 始终是安全的。</p>
<p>从根本上说，大多数平台甚至都无法构造这样的分配。
例如，由于页表的限制或地址空间的分割，没有已知的 64 位平台可以满足 2 <sup>63</sup> 字节的请求。
但是，某些 32 位和 16 位平台可能通过物理地址扩展之类的东西成功地为超过 <code>isize::MAX</code> 字节的请求提供服务。</p>
<p>因此，直接从分配器获取的内存或内存映射文件 <em>可能</em> 太大而无法使用此函数进行处理。</p>
<p>如果这些约束难以满足，请考虑使用 <a href="#method.wrapping_sub"><code>wrapping_sub</code></a>。
此方法的唯一优点是，它可以实现更积极的编译器优化。</p>
<h1 id="examples-20" class="section-header"><a href="#examples-20">Examples</a></h1>
<p>基本用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;123&quot;</span>;

<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="ident">end</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_ptr</span>().<span class="ident">add</span>(<span class="number">3</span>);
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">end</span>.<span class="ident">sub</span>(<span class="number">1</span>) <span class="kw">as</span> <span class="ident">char</span>);
    <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="kw-2">*</span><span class="ident">end</span>.<span class="ident">sub</span>(<span class="number">2</span>) <span class="kw">as</span> <span class="ident">char</span>);
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%3A%20%26str%20%3D%20%22123%22%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20let%20end%3A%20*const%20u8%20%3D%20s.as_ptr().add(3)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*end.sub(1)%20as%20char)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20*end.sub(2)%20as%20char)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.wrapping_add-1" class="method has-srclink"><h4 class="code-header"><div class="code-attribute">#[must_use = "returns a new pointer rather than modifying its argument"]</div>pub const fn <a href="#method.wrapping_add-1" class="fnname">wrapping_add</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.wrapping_add-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#744-746" title="goto source code">[src]</a></div></summary><div class="docblock"><p>使用换行算法计算与指针的偏移量。
(为 <code>.wrapping_offset(count as isize)</code> 带来的便利)</p>
<p><code>count</code> 以 T 为单位; 例如，<code>count</code> 为 3 表示 <code>3 * size_of::&lt;T&gt;()</code> 字节的指针偏移量。</p>
<h1 id="safety-18" class="section-header"><a href="#safety-18">Safety</a></h1>
<p>此操作本身始终是安全的，但使用结果指针则不安全。</p>
<p>结果指针 “remembers” 是 <code>self</code> 指向的 <a href="ptr/index.html#allocated-object">allocated object</a>; 它不能用于读取或写入其他分配的对象。</p>
<p>换句话说，即使我们假设 <code>T</code> 的大小为 <code>1</code> 并且没有溢出，<code>let z = x.wrapping_add((y as usize) - (x as usize))</code> 不会使 <code>z</code> 与 <code>y</code> 相同: <code>z</code> 仍附加到对象 <code>x</code> 所附加的对象，并且解引用它是 Undefined Behavior，除非 <code>x</code> 和 <code>y</code> 指向同一分配的对象。</p>
<p>与 <a href="#method.add"><code>add</code></a> 相比，此方法从根本上延迟了留在同一分配对象内的需求: <a href="#method.add"><code>add</code></a> 是跨越对象边界时的立即未定义行为; <code>wrapping_add</code> 产生一个指针，但如果指针超出其附加对象的范围而被解引用，则仍会导致未定义行为。
<a href="#method.add"><code>add</code></a> 可以更好地进行优化，因此在对性能敏感的代码中更可取。</p>
<p>延迟检查仅考虑解引用的指针的值，而不考虑最终结果计算期间使用的中间值。
例如，<code>x.wrapping_add(o).wrapping_sub(o)</code> 始终与 <code>x</code> 相同。换句话说，允许离开已分配的对象，然后在以后重新输入它。</p>
<h1 id="examples-21" class="section-header"><a href="#examples-21">Examples</a></h1>
<p>基本用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// 使用裸指针以两个元素为增量进行迭代</span>
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">as_ptr</span>();
<span class="kw">let</span> <span class="ident">step</span> <span class="op">=</span> <span class="number">2</span>;
<span class="kw">let</span> <span class="ident">end_rounded_up</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_add</span>(<span class="number">6</span>);

<span class="comment">// 此循环打印 &quot;1, 3, 5, &quot;</span>
<span class="kw">while</span> <span class="ident">ptr</span> <span class="op">!</span><span class="op">=</span> <span class="ident">end_rounded_up</span> {
    <span class="kw">unsafe</span> {
        <span class="macro">print!</span>(<span class="string">&quot;{}, &quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>);
    }
    <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_add</span>(<span class="ident">step</span>);
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%2F%2F%20%E4%BD%BF%E7%94%A8%E8%A3%B8%E6%8C%87%E9%92%88%E4%BB%A5%E4%B8%A4%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B8%BA%E5%A2%9E%E9%87%8F%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3%0Afn%20main()%20%7B%0Alet%20data%20%3D%20%5B1u8%2C%202%2C%203%2C%204%2C%205%5D%3B%0Alet%20mut%20ptr%3A%20*const%20u8%20%3D%20data.as_ptr()%3B%0Alet%20step%20%3D%202%3B%0Alet%20end_rounded_up%20%3D%20ptr.wrapping_add(6)%3B%0A%0A%2F%2F%20%E6%AD%A4%E5%BE%AA%E7%8E%AF%E6%89%93%E5%8D%B0%20%221%2C%203%2C%205%2C%20%22%0Awhile%20ptr%20!%3D%20end_rounded_up%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20print!(%22%7B%7D%2C%20%22%2C%20*ptr)%3B%0A%20%20%20%20%7D%0A%20%20%20%20ptr%20%3D%20ptr.wrapping_add(step)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.wrapping_sub-1" class="method has-srclink"><h4 class="code-header"><div class="code-attribute">#[must_use = "returns a new pointer rather than modifying its argument"]</div>pub const fn <a href="#method.wrapping_sub-1" class="fnname">wrapping_sub</a>(self, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.wrapping_sub-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#806-808" title="goto source code">[src]</a></div></summary><div class="docblock"><p>使用换行算法计算与指针的偏移量。
(为 <code>.wrapping_offset((count as isize).wrapping_neg())</code> 带来的便利)</p>
<p><code>count</code> 以 T 为单位; 例如，<code>count</code> 为 3 表示 <code>3 * size_of::&lt;T&gt;()</code> 字节的指针偏移量。</p>
<h1 id="safety-19" class="section-header"><a href="#safety-19">Safety</a></h1>
<p>此操作本身始终是安全的，但使用结果指针则不安全。</p>
<p>结果指针 “remembers” 是 <code>self</code> 指向的 <a href="ptr/index.html#allocated-object">allocated object</a>; 它不能用于读取或写入其他分配的对象。</p>
<p>换句话说，即使我们假设 <code>T</code> 的大小为 <code>1</code> 并且没有溢出，<code>let z = x.wrapping_sub((x as usize) - (y as usize))</code> 不会使 <code>z</code> 与 <code>y</code> 相同: <code>z</code> 仍附加到对象 <code>x</code> 所附加的对象，并且解引用它是 Undefined Behavior，除非 <code>x</code> 和 <code>y</code> 指向同一分配的对象。</p>
<p>与 <a href="#method.sub"><code>sub</code></a> 相比，此方法从根本上延迟了留在同一分配对象内的需求: <a href="#method.sub"><code>sub</code></a> 是跨越对象边界时的立即未定义行为; <code>wrapping_sub</code> 产生一个指针，但如果指针超出其附加对象的范围而被解引用，则仍会导致未定义行为。
<a href="#method.sub"><code>sub</code></a> 可以更好地进行优化，因此在对性能敏感的代码中更可取。</p>
<p>延迟检查仅考虑解引用的指针的值，而不考虑最终结果计算期间使用的中间值。
例如，<code>x.wrapping_add(o).wrapping_sub(o)</code> 始终与 <code>x</code> 相同。换句话说，允许离开已分配的对象，然后在以后重新输入它。</p>
<h1 id="examples-22" class="section-header"><a href="#examples-22">Examples</a></h1>
<p>基本用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="comment">// 使用裸指针以两个元素 (backwards) 为增量进行迭代</span>
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> [<span class="number">1u8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">as_ptr</span>();
<span class="kw">let</span> <span class="ident">start_rounded_down</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_sub</span>(<span class="number">2</span>);
<span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_add</span>(<span class="number">4</span>);
<span class="kw">let</span> <span class="ident">step</span> <span class="op">=</span> <span class="number">2</span>;
<span class="comment">// 此循环打印 &quot;5, 3, 1, &quot;</span>
<span class="kw">while</span> <span class="ident">ptr</span> <span class="op">!</span><span class="op">=</span> <span class="ident">start_rounded_down</span> {
    <span class="kw">unsafe</span> {
        <span class="macro">print!</span>(<span class="string">&quot;{}, &quot;</span>, <span class="kw-2">*</span><span class="ident">ptr</span>);
    }
    <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">wrapping_sub</span>(<span class="ident">step</span>);
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%2F%2F%20%E4%BD%BF%E7%94%A8%E8%A3%B8%E6%8C%87%E9%92%88%E4%BB%A5%E4%B8%A4%E4%B8%AA%E5%85%83%E7%B4%A0%20(backwards)%20%E4%B8%BA%E5%A2%9E%E9%87%8F%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3%0Afn%20main()%20%7B%0Alet%20data%20%3D%20%5B1u8%2C%202%2C%203%2C%204%2C%205%5D%3B%0Alet%20mut%20ptr%3A%20*const%20u8%20%3D%20data.as_ptr()%3B%0Alet%20start_rounded_down%20%3D%20ptr.wrapping_sub(2)%3B%0Aptr%20%3D%20ptr.wrapping_add(4)%3B%0Alet%20step%20%3D%202%3B%0A%2F%2F%20%E6%AD%A4%E5%BE%AA%E7%8E%AF%E6%89%93%E5%8D%B0%20%225%2C%203%2C%201%2C%20%22%0Awhile%20ptr%20!%3D%20start_rounded_down%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20print!(%22%7B%7D%2C%20%22%2C%20*ptr)%3B%0A%20%20%20%20%7D%0A%20%20%20%20ptr%20%3D%20ptr.wrapping_sub(step)%3B%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.set_ptr_value-1" class="method has-srclink"><h4 class="code-header"><div class="code-attribute">#[must_use = "returns a new pointer rather than modifying its argument"]</div>pub fn <a href="#method.set_ptr_value-1" class="fnname">set_ptr_value</a>(self, val: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.u8.html">u8</a>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4><a href="#method.set_ptr_value-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#844" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>set_ptr_value</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75091">#75091</a>)</div></div></summary><div class="docblock"><p>将指针值设置为 <code>ptr</code>。</p>
<p>如果 <code>self</code> 是指向未定义大小类型的 (fat) 指针，则此操作将仅影响指针部分，而对于指向已确定大小类型的 (thin) 指针，其作用与简单分配相同。</p>
<p>生成的指针将具有 <code>val</code> 的出处，即对于胖指针，此操作在语义上与使用 <code>val</code> 的数据指针值但 <code>self</code> 的元数据创建新的胖指针相同。</p>
<h1 id="examples-23" class="section-header"><a href="#examples-23">Examples</a></h1>
<p>此函数主要用于允许对潜在的胖指针进行按字节指针算术运算:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">set_ptr_value</span>)]</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">arr</span>: [<span class="ident">i32</span>; <span class="number">3</span>] <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">arr</span>.<span class="ident">as_mut_ptr</span>() <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="kw">dyn</span> <span class="ident">Debug</span>;
<span class="kw">let</span> <span class="ident">thin</span> <span class="op">=</span> <span class="ident">ptr</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span>;
<span class="kw">unsafe</span> {
    <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">set_ptr_value</span>(<span class="ident">thin</span>.<span class="ident">add</span>(<span class="number">8</span>));
    <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">ptr</span>); <span class="comment">// 将打印 &quot;3&quot;</span>
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(set_ptr_value)%5D%0Afn%20main()%20%7B%0Ause%20core%3A%3Afmt%3A%3ADebug%3B%0Alet%20mut%20arr%3A%20%5Bi32%3B%203%5D%20%3D%20%5B1%2C%202%2C%203%5D%3B%0Alet%20mut%20ptr%20%3D%20arr.as_mut_ptr()%20as%20*mut%20dyn%20Debug%3B%0Alet%20thin%20%3D%20ptr%20as%20*mut%20u8%3B%0Aunsafe%20%7B%0A%20%20%20%20ptr%20%3D%20ptr.set_ptr_value(thin.add(8))%3B%0Aassert_eq!(*(ptr%20as%20*mut%20i32)%2C%203)%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20%26*ptr)%3B%20%2F%2F%20%E5%B0%86%E6%89%93%E5%8D%B0%20%223%22%0A%7D%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.read-1" class="method has-srclink"><h4 class="code-header">pub const unsafe fn <a href="#method.read-1" class="fnname">read</a>(self) -&gt; T</h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.read-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#863-865" title="goto source code">[src]</a></div></summary><div class="docblock"><p>从 <code>self</code> 读取值而不移动它。
这将使 <code>self</code> 中的内存保持不变。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.read.html"><code>ptr::read</code></a>。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.read_volatile-1" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.read_volatile-1" class="fnname">read_volatile</a>(self) -&gt; T</h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.read_volatile-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#883-885" title="goto source code">[src]</a></div></summary><div class="docblock"><p>对 <code>self</code> 的值进行易失性读取，而无需移动它。这将使 <code>self</code> 中的内存保持不变。</p>
<p>易失性操作旨在作用于 I/O 存储器，并保证编译器不会在其他易失性操作中对易失性操作进行清除或重新排序。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.read_volatile.html"><code>ptr::read_volatile</code></a>。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.read_unaligned-1" class="method has-srclink"><h4 class="code-header">pub const unsafe fn <a href="#method.read_unaligned-1" class="fnname">read_unaligned</a>(self) -&gt; T</h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.read_unaligned-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#902-904" title="goto source code">[src]</a></div></summary><div class="docblock"><p>从 <code>self</code> 读取值而不移动它。
这将使 <code>self</code> 中的内存保持不变。</p>
<p>与 <code>read</code> 不同，指针可能未对齐。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.read_unaligned.html"><code>ptr::read_unaligned</code></a>。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.copy_to-1" class="method has-srclink"><h4 class="code-header">pub const unsafe fn <a href="#method.copy_to-1" class="fnname">copy_to</a>(self, dest: <a class="primitive" href="primitive.pointer.html">*mut T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.copy_to-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#921-923" title="goto source code">[src]</a></div></summary><div class="docblock"><p>将 <code>count * size_of&lt;T&gt;</code> 字节从 <code>self</code> 复制到 <code>dest</code>。
源和目标可能会重叠。</p>
<p>NOTE: 这与 <a href="ptr/fn.copy.html"><code>ptr::copy</code></a> 具有相同的参数顺序。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.copy.html"><code>ptr::copy</code></a>。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.copy_to_nonoverlapping-1" class="method has-srclink"><h4 class="code-header">pub const unsafe fn <a href="#method.copy_to_nonoverlapping-1" class="fnname">copy_to_nonoverlapping</a>(self, dest: <a class="primitive" href="primitive.pointer.html">*mut T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.copy_to_nonoverlapping-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#940-942" title="goto source code">[src]</a></div></summary><div class="docblock"><p>将 <code>count * size_of&lt;T&gt;</code> 字节从 <code>self</code> 复制到 <code>dest</code>。
源和目标可能 <em>不</em> 重叠。</p>
<p>NOTE: 这与 <a href="ptr/fn.copy_nonoverlapping.html"><code>ptr::copy_nonoverlapping</code></a> 具有相同的参数顺序。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.copy_nonoverlapping.html"><code>ptr::copy_nonoverlapping</code></a>。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.copy_from" class="method has-srclink"><h4 class="code-header">pub const unsafe fn <a href="#method.copy_from" class="fnname">copy_from</a>(self, src: <a class="primitive" href="primitive.pointer.html">*const T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.copy_from" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#959-961" title="goto source code">[src]</a></div></summary><div class="docblock"><p>将 <code>count * size_of&lt;T&gt;</code> 字节从 <code>src</code> 复制到 <code>self</code>。
源和目标可能会重叠。</p>
<p>NOTE: 这具有 <a href="ptr/fn.copy.html"><code>ptr::copy</code></a> 的 <em>相反</em> 参数顺序。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.copy.html"><code>ptr::copy</code></a>。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.copy_from_nonoverlapping" class="method has-srclink"><h4 class="code-header">pub const unsafe fn <a href="#method.copy_from_nonoverlapping" class="fnname">copy_from_nonoverlapping</a>(self, src: <a class="primitive" href="primitive.pointer.html">*const T</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.copy_from_nonoverlapping" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#978-980" title="goto source code">[src]</a></div></summary><div class="docblock"><p>将 <code>count * size_of&lt;T&gt;</code> 字节从 <code>src</code> 复制到 <code>self</code>。
源和目标可能 <em>不</em> 重叠。</p>
<p>NOTE: 这具有 <a href="ptr/fn.copy_nonoverlapping.html"><code>ptr::copy_nonoverlapping</code></a> 的 <em>相反</em> 参数顺序。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.copy_nonoverlapping.html"><code>ptr::copy_nonoverlapping</code></a>。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.drop_in_place" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.drop_in_place" class="fnname">drop_in_place</a>(self)</h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.drop_in_place" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#993" title="goto source code">[src]</a></div></summary><div class="docblock"><p>执行指向值的析构函数 (如果有)。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.drop_in_place.html"><code>ptr::drop_in_place</code></a>。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.write" class="method has-srclink"><h4 class="code-header">pub const unsafe fn <a href="#method.write" class="fnname">write</a>(self, val: T)</h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.write" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1007-1009" title="goto source code">[src]</a></div></summary><div class="docblock"><p>用给定值覆盖存储位置，而无需读取或丢弃旧值。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.write.html"><code>ptr::write</code></a>。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.write_bytes" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.write_bytes" class="fnname">write_bytes</a>(self, val: <a class="primitive" href="primitive.u8.html">u8</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>)</h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.write_bytes" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1023-1025" title="goto source code">[src]</a></div></summary><div class="docblock"><p>在指定的指针上调用 memset，将 <code>self</code> 开始的 <code>count * size_of::&lt;T&gt;()</code> 内存字节设置为 <code>val</code>。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.write_bytes.html"><code>ptr::write_bytes</code></a>。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.write_volatile" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.write_volatile" class="fnname">write_volatile</a>(self, val: T)</h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.write_volatile" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1043-1045" title="goto source code">[src]</a></div></summary><div class="docblock"><p>使用给定值对存储单元执行易失性写操作，而无需读取或丢弃旧值。</p>
<p>易失性操作旨在作用于 I/O 存储器，并保证编译器不会在其他易失性操作中对易失性操作进行清除或重新排序。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.write_volatile.html"><code>ptr::write_volatile</code></a>。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.write_unaligned" class="method has-srclink"><h4 class="code-header">pub const unsafe fn <a href="#method.write_unaligned" class="fnname">write_unaligned</a>(self, val: T)</h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.write_unaligned" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1062-1064" title="goto source code">[src]</a></div></summary><div class="docblock"><p>用给定值覆盖存储位置，而无需读取或丢弃旧值。</p>
<p>与 <code>write</code> 不同，指针可能未对齐。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.write_unaligned.html"><code>ptr::write_unaligned</code></a>。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.replace" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.replace" class="fnname">replace</a>(self, src: T) -&gt; T</h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.replace" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1078-1080" title="goto source code">[src]</a></div></summary><div class="docblock"><p>用 <code>src</code> 替换 <code>self</code> 处的值，返回旧值，但不丢弃任何一个。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.replace.html"><code>ptr::replace</code></a>。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.swap" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.swap" class="fnname">swap</a>(self, with: <a class="primitive" href="primitive.pointer.html">*mut T</a>)</h4><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span><a href="#method.swap" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1095-1097" title="goto source code">[src]</a></div></summary><div class="docblock"><p>在相同类型的两个可变位置交换值，而无需取消初始化任何一个。
它们可能重叠，这与 <code>mem::swap</code> 不同，后者在其他方面是等效的。</p>
<p>有关安全性问题和示例，请参见 <a href="ptr/fn.swap.html"><code>ptr::swap</code></a>。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.align_offset-1" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.align_offset-1" class="fnname">align_offset</a>(self, align: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span><a href="#method.align_offset-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1143-1145" title="goto source code">[src]</a></div></summary><div class="docblock"><p>计算为使其与 <code>align</code> 对齐而需要应用到指针的偏移量。</p>
<p>如果无法对齐指针，则实现将返回 <code>usize::MAX</code>。
允许实现 <em>始终</em> 返回 <code>usize::MAX</code>。
只有算法的性能可以取决于此处是否可获得可用的偏移量，而不取决于其正确性。</p>
<p>偏移量以 <code>T</code> 元素的数量表示，而不是以字节表示。返回的值可以与 <code>wrapping_add</code> 方法一起使用。</p>
<p>不能保证偏移指针不会溢出或超出指针所指向的分配范围。</p>
<p>调用者应确保返回的偏移量在对齐方式以外的所有方面都是正确的。</p>
<h1 id="panics-3" class="section-header"><a href="#panics-3">Panics</a></h1>
<p>如果 <code>align</code> 不是 2 的幂，则函数 panics。</p>
<h1 id="examples-24" class="section-header"><a href="#examples-24">Examples</a></h1>
<p>将相邻的 <code>u8</code> 作为 <code>u16</code> 进行访问</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> [<span class="number">5u8</span>, <span class="number">6u8</span>, <span class="number">7u8</span>, <span class="number">8u8</span>, <span class="number">9u8</span>];
<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">as_ptr</span>().<span class="ident">add</span>(<span class="ident">n</span>) <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u8</span>;
<span class="kw">let</span> <span class="ident">offset</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">align_offset</span>(<span class="ident">align_of</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>());
<span class="kw">if</span> <span class="ident">offset</span> <span class="op">&lt;</span> <span class="ident">x</span>.<span class="ident">len</span>() <span class="op">-</span> <span class="ident">n</span> <span class="op">-</span> <span class="number">1</span> {
    <span class="kw">let</span> <span class="ident">u16_ptr</span> <span class="op">=</span> <span class="ident">ptr</span>.<span class="ident">add</span>(<span class="ident">offset</span>) <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">u16</span>;
    <span class="macro">assert_ne!</span>(<span class="kw-2">*</span><span class="ident">u16_ptr</span>, <span class="number">500</span>);
} <span class="kw">else</span> {
    <span class="comment">// 虽然指针可以通过 `offset` 对齐，但它会指向分配之外</span>
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Afn%20foo(n%3A%20usize)%20%7B%0Ause%20std%3A%3Amem%3A%3Aalign_of%3B%0Aunsafe%20%7B%0Alet%20x%20%3D%20%5B5u8%2C%206u8%2C%207u8%2C%208u8%2C%209u8%5D%3B%0Alet%20ptr%20%3D%20x.as_ptr().add(n)%20as%20*const%20u8%3B%0Alet%20offset%20%3D%20ptr.align_offset(align_of%3A%3A%3Cu16%3E())%3B%0Aif%20offset%20%3C%20x.len()%20-%20n%20-%201%20%7B%0A%20%20%20%20let%20u16_ptr%20%3D%20ptr.add(offset)%20as%20*const%20u16%3B%0A%20%20%20%20assert_ne!(*u16_ptr%2C%20500)%3B%0A%7D%20else%20%7B%0A%20%20%20%20%2F%2F%20%E8%99%BD%E7%84%B6%E6%8C%87%E9%92%88%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%20%60offset%60%20%E5%AF%B9%E9%BD%90%EF%BC%8C%E4%BD%86%E5%AE%83%E4%BC%9A%E6%8C%87%E5%90%91%E5%88%86%E9%85%8D%E4%B9%8B%E5%A4%96%0A%7D%0A%7D%20%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-2" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.slice.html">[</a>T<a class="primitive" href="primitive.slice.html">]</a></h3><a href="#impl-2" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#895-1016" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.len" class="method has-srclink"><h4 class="code-header">pub const fn <a href="#method.len" class="fnname">len</a>(self) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4><a href="#method.len" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#916" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>slice_ptr_len</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/71146">#71146</a>)</div></div></summary><div class="docblock"><p>返回原始切片的长度。</p>
<p>返回的值是 <strong>elements</strong> 的数量，而不是字节数。</p>
<p>即使原始切片由于指针为空或未对齐而无法转换为切片引用，此函数也是安全的。</p>
<h1 id="examples-25" class="section-header"><a href="#examples-25">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">slice_ptr_len</span>)]</span>

<span class="kw">use</span> <span class="ident">std::ptr</span>;

<span class="kw">let</span> <span class="ident">slice</span>: <span class="kw-2">*</span><span class="kw">const</span> [<span class="ident">i8</span>] <span class="op">=</span> <span class="ident">ptr::slice_from_raw_parts</span>(<span class="ident">ptr::null</span>(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="ident">slice</span>.<span class="ident">len</span>(), <span class="number">3</span>);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(slice_ptr_len)%5D%0A%0Afn%20main()%20%7B%0Ause%20std%3A%3Aptr%3B%0A%0Alet%20slice%3A%20*const%20%5Bi8%5D%20%3D%20ptr%3A%3Aslice_from_raw_parts(ptr%3A%3Anull()%2C%203)%3B%0Aassert_eq!(slice.len()%2C%203)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_ptr" class="method has-srclink"><h4 class="code-header">pub const fn <a href="#method.as_ptr" class="fnname">as_ptr</a>(self) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4><a href="#method.as_ptr" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#936" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>slice_ptr_get</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/74265">#74265</a>)</div></div></summary><div class="docblock"><p>将裸指针返回到切片的缓冲区。</p>
<p>这等效于将 <code>self</code> 强制转换为 <code>*const T</code>，但类型安全性更高。</p>
<h1 id="examples-26" class="section-header"><a href="#examples-26">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">slice_ptr_get</span>)]</span>
<span class="kw">use</span> <span class="ident">std::ptr</span>;

<span class="kw">let</span> <span class="ident">slice</span>: <span class="kw-2">*</span><span class="kw">const</span> [<span class="ident">i8</span>] <span class="op">=</span> <span class="ident">ptr::slice_from_raw_parts</span>(<span class="ident">ptr::null</span>(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="ident">slice</span>.<span class="ident">as_ptr</span>(), <span class="number">0</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="ident">i8</span>);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(slice_ptr_get)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Aptr%3B%0A%0Alet%20slice%3A%20*const%20%5Bi8%5D%20%3D%20ptr%3A%3Aslice_from_raw_parts(ptr%3A%3Anull()%2C%203)%3B%0Aassert_eq!(slice.as_ptr()%2C%200%20as%20*const%20i8)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_unchecked" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked" class="fnname">get_unchecked</a>&lt;I&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;index: I<br>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>&lt;I as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice.html">[</a>T<a class="primitive" href="primitive.slice.html">]</a>&gt;&gt;::<a class="type" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice.html">[</a>T<a class="primitive" href="primitive.slice.html">]</a>&gt;,&nbsp;</span></h4><a href="#method.get_unchecked" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#961-963" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>slice_ptr_get</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/74265">#74265</a>)</div></div></summary><div class="docblock"><p>将裸指针返回到元素或子切片，而不进行边界检查。</p>
<p>即使未使用生成的指针，使用越界索引或无法使用 <code>self</code> 调用此方法也是 [<em>[undefined 行为]</em>。</p>
<h1 id="examples-27" class="section-header"><a href="#examples-27">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">slice_ptr_get</span>)]</span>

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> [<span class="ident">i32</span>];

<span class="kw">unsafe</span> {
    <span class="macro">assert_eq!</span>(<span class="ident">x</span>.<span class="ident">get_unchecked</span>(<span class="number">1</span>), <span class="ident">x</span>.<span class="ident">as_ptr</span>().<span class="ident">add</span>(<span class="number">1</span>));
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(slice_ptr_get)%5D%0A%0Afn%20main()%20%7B%0Alet%20x%20%3D%20%26%5B1%2C%202%2C%204%5D%20as%20*const%20%5Bi32%5D%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20assert_eq!(x.get_unchecked(1)%2C%20x.as_ptr().add(1))%3B%0A%7D%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_uninit_slice" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.as_uninit_slice" class="fnname">as_uninit_slice</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.slice.html">&amp;'a [</a><a class="union" href="mem/union.MaybeUninit.html" title="union std::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;<a class="primitive" href="primitive.slice.html">]</a>&gt;</h4><a href="#method.as_uninit_slice" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1008" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>ptr_as_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75402">#75402</a>)</div></div></summary><div class="docblock"><p>如果指针为空，则返回 <code>None</code>，否则返回共享切片到 <code>Some</code> 中包装的值。
与 <a href="#method.as_ref"><code>as_ref</code></a> 相比，这不需要将该值初始化。</p>
<h1 id="safety-20" class="section-header"><a href="#safety-20">Safety</a></h1>
<p>调用此方法时，您必须确保要么指针是空的，要么以下所有内容都为真::</p>
<ul>
<li>
<p>指针必须为 <a href="ptr/index.html#safety">有效</a> 的，才能读取许多字节的 <code>ptr.len() * mem::size_of::&lt;T&gt;()</code>，并且必须正确对齐。这尤其意味着:</p>
<ul>
<li>
<p>整个内存范围必须包含在单个 <a href="ptr/index.html#allocated-object">allocated object</a> 内!
切片永远不能跨越多个分配的对象。</p>
</li>
<li>
<p>即使对于零长度的切片，指针也必须对齐。
这样做的一个原因是，枚举布局优化可能依赖于对齐的引用 (包括任何长度的切片) 和非空值，以将它们与其他数据区分开。</p>
</li>
</ul>
<p>您可以使用 <a href="ptr/struct.NonNull.html#method.dangling" title="NonNull::dangling()"><code>NonNull::dangling()</code></a> 获得可用作零长度切片的 <code>data</code> 的指针。</p>
</li>
<li>
<p>切片的总大小 <code>ptr.len() * mem::size_of::&lt;T&gt;()</code> 不能大于 <code>isize::MAX</code>。
请参见 <a href="primitive.pointer.html#method.offset" title="pointer::offset"><code>pointer::offset</code></a> 的安全文档。</p>
</li>
<li>
<p>您必须执行 Rust 的别名规则，因为返回的生命周期 <code>'a</code> 是任意选择的，不一定反映数据的实际生命周期。
特别是，在此生命周期的持续时间内，指针所指向的内存一定不能被可变的 (<code>UnsafeCell</code> 内部除外)。</p>
</li>
</ul>
<p>即使未使用此方法的结果也是如此!</p>
<p>另请参见 <a href="slice/fn.from_raw_parts.html" title="slice::from_raw_parts"><code>slice::from_raw_parts</code></a>。</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-3" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.slice.html">[</a>T<a class="primitive" href="primitive.slice.html">]</a></h3><a href="#impl-3" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1156-1330" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.len-1" class="method has-srclink"><h4 class="code-header">pub const fn <a href="#method.len-1" class="fnname">len</a>(self) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4><a href="#method.len-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1176" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>slice_ptr_len</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/71146">#71146</a>)</div></div></summary><div class="docblock"><p>返回原始切片的长度。</p>
<p>返回的值是 <strong>elements</strong> 的数量，而不是字节数。</p>
<p>即使原始切片由于指针为空或未对齐而无法转换为切片引用，此函数也是安全的。</p>
<h1 id="examples-28" class="section-header"><a href="#examples-28">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">slice_ptr_len</span>)]</span>
<span class="kw">use</span> <span class="ident">std::ptr</span>;

<span class="kw">let</span> <span class="ident">slice</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> [<span class="ident">i8</span>] <span class="op">=</span> <span class="ident">ptr::slice_from_raw_parts_mut</span>(<span class="ident">ptr::null_mut</span>(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="ident">slice</span>.<span class="ident">len</span>(), <span class="number">3</span>);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(slice_ptr_len)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Aptr%3B%0A%0Alet%20slice%3A%20*mut%20%5Bi8%5D%20%3D%20ptr%3A%3Aslice_from_raw_parts_mut(ptr%3A%3Anull_mut()%2C%203)%3B%0Aassert_eq!(slice.len()%2C%203)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_mut_ptr" class="method has-srclink"><h4 class="code-header">pub const fn <a href="#method.as_mut_ptr" class="fnname">as_mut_ptr</a>(self) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4><a href="#method.as_mut_ptr" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1196" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>slice_ptr_get</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/74265">#74265</a>)</div></div></summary><div class="docblock"><p>将裸指针返回到切片的缓冲区。</p>
<p>这等效于将 <code>self</code> 强制转换为 <code>*mut T</code>，但类型安全性更高。</p>
<h1 id="examples-29" class="section-header"><a href="#examples-29">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">slice_ptr_get</span>)]</span>
<span class="kw">use</span> <span class="ident">std::ptr</span>;

<span class="kw">let</span> <span class="ident">slice</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> [<span class="ident">i8</span>] <span class="op">=</span> <span class="ident">ptr::slice_from_raw_parts_mut</span>(<span class="ident">ptr::null_mut</span>(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="ident">slice</span>.<span class="ident">as_mut_ptr</span>(), <span class="number">0</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">i8</span>);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(slice_ptr_get)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Aptr%3B%0A%0Alet%20slice%3A%20*mut%20%5Bi8%5D%20%3D%20ptr%3A%3Aslice_from_raw_parts_mut(ptr%3A%3Anull_mut()%2C%203)%3B%0Aassert_eq!(slice.as_mut_ptr()%2C%200%20as%20*mut%20i8)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_unchecked_mut" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked_mut" class="fnname">get_unchecked_mut</a>&lt;I&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;index: I<br>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>&lt;I as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice.html">[</a>T<a class="primitive" href="primitive.slice.html">]</a>&gt;&gt;::<a class="type" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.slice.html">[</a>T<a class="primitive" href="primitive.slice.html">]</a>&gt;,&nbsp;</span></h4><a href="#method.get_unchecked_mut" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1221-1223" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>slice_ptr_get</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/74265">#74265</a>)</div></div></summary><div class="docblock"><p>将裸指针返回到元素或子切片，而不进行边界检查。</p>
<p>即使未使用生成的指针，使用越界索引或无法使用 <code>self</code> 调用此方法也是 [<em>[undefined 行为]</em>。</p>
<h1 id="examples-30" class="section-header"><a href="#examples-30">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">slice_ptr_get</span>)]</span>

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> [<span class="ident">i32</span>];

<span class="kw">unsafe</span> {
    <span class="macro">assert_eq!</span>(<span class="ident">x</span>.<span class="ident">get_unchecked_mut</span>(<span class="number">1</span>), <span class="ident">x</span>.<span class="ident">as_mut_ptr</span>().<span class="ident">add</span>(<span class="number">1</span>));
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(slice_ptr_get)%5D%0A%0Afn%20main()%20%7B%0Alet%20x%20%3D%20%26mut%20%5B1%2C%202%2C%204%5D%20as%20*mut%20%5Bi32%5D%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20assert_eq!(x.get_unchecked_mut(1)%2C%20x.as_mut_ptr().add(1))%3B%0A%7D%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_uninit_slice-1" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.as_uninit_slice-1" class="fnname">as_uninit_slice</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.slice.html">&amp;'a [</a><a class="union" href="mem/union.MaybeUninit.html" title="union std::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;<a class="primitive" href="primitive.slice.html">]</a>&gt;</h4><a href="#method.as_uninit_slice-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1271" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>ptr_as_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75402">#75402</a>)</div></div></summary><div class="docblock"><p>如果指针为空，则返回 <code>None</code>，否则返回共享切片到 <code>Some</code> 中包装的值。
与 <a href="#method.as_ref-1"><code>as_ref</code></a> 相比，这不需要将该值初始化。</p>
<p>对于可变的对应物，请参见 <a href="#method.as_uninit_slice_mut"><code>as_uninit_slice_mut</code></a>。</p>
<h1 id="safety-21" class="section-header"><a href="#safety-21">Safety</a></h1>
<p>调用此方法时，您必须确保要么指针是空的，要么以下所有内容都为真::</p>
<ul>
<li>
<p>指针必须为 <a href="ptr/index.html#safety">有效</a> 的，才能读取许多字节的 <code>ptr.len() * mem::size_of::&lt;T&gt;()</code>，并且必须正确对齐。这尤其意味着:</p>
<ul>
<li>
<p>整个内存范围必须包含在单个 <a href="ptr/index.html#allocated-object">allocated object</a> 内!
切片永远不能跨越多个分配的对象。</p>
</li>
<li>
<p>即使对于零长度的切片，指针也必须对齐。
这样做的一个原因是，枚举布局优化可能依赖于对齐的引用 (包括任何长度的切片) 和非空值，以将它们与其他数据区分开。</p>
</li>
</ul>
<p>您可以使用 <a href="ptr/struct.NonNull.html#method.dangling" title="NonNull::dangling()"><code>NonNull::dangling()</code></a> 获得可用作零长度切片的 <code>data</code> 的指针。</p>
</li>
<li>
<p>切片的总大小 <code>ptr.len() * mem::size_of::&lt;T&gt;()</code> 不能大于 <code>isize::MAX</code>。
请参见 <a href="primitive.pointer.html#method.offset" title="pointer::offset"><code>pointer::offset</code></a> 的安全文档。</p>
</li>
<li>
<p>您必须执行 Rust 的别名规则，因为返回的生命周期 <code>'a</code> 是任意选择的，不一定反映数据的实际生命周期。
特别是，在此生命周期的持续时间内，指针所指向的内存一定不能被可变的 (<code>UnsafeCell</code> 内部除外)。</p>
</li>
</ul>
<p>即使未使用此方法的结果也是如此!</p>
<p>另请参见 <a href="slice/fn.from_raw_parts.html" title="slice::from_raw_parts"><code>slice::from_raw_parts</code></a>。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_uninit_slice_mut" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.as_uninit_slice_mut" class="fnname">as_uninit_slice_mut</a>&lt;'a&gt;(self) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.slice.html">&amp;'a mut [</a><a class="union" href="mem/union.MaybeUninit.html" title="union std::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;<a class="primitive" href="primitive.slice.html">]</a>&gt;</h4><a href="#method.as_uninit_slice_mut" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1322" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>ptr_as_uninit</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/75402">#75402</a>)</div></div></summary><div class="docblock"><p>如果指针为空，则返回 <code>None</code>，否则返回一个唯一的切片到 <code>Some</code> 中包装的值。
与 <a href="#method.as_mut"><code>as_mut</code></a> 相比，这不需要将该值初始化。</p>
<p>有关共享副本，请参见 <a href="#method.as_uninit_slice-1"><code>as_uninit_slice</code></a>。</p>
<h1 id="safety-22" class="section-header"><a href="#safety-22">Safety</a></h1>
<p>调用此方法时，您必须确保要么指针是空的，要么以下所有内容都为真::</p>
<ul>
<li>
<p>指针必须是 <a href="ptr/index.html#safety">有效</a> 的才能进行 <code>ptr.len() * mem::size_of::&lt;T&gt;()</code> 多个字节的读取和写入，并且必须正确对齐。这尤其意味着:</p>
<ul>
<li>
<p>整个内存范围必须包含在单个 <a href="ptr/index.html#allocated-object">allocated object</a> 内!
切片永远不能跨越多个分配的对象。</p>
</li>
<li>
<p>即使对于零长度的切片，指针也必须对齐。
这样做的一个原因是，枚举布局优化可能依赖于对齐的引用 (包括任何长度的切片) 和非空值，以将它们与其他数据区分开。</p>
</li>
</ul>
<p>您可以使用 <a href="ptr/struct.NonNull.html#method.dangling" title="NonNull::dangling()"><code>NonNull::dangling()</code></a> 获得可用作零长度切片的 <code>data</code> 的指针。</p>
</li>
<li>
<p>切片的总大小 <code>ptr.len() * mem::size_of::&lt;T&gt;()</code> 不能大于 <code>isize::MAX</code>。
请参见 <a href="primitive.pointer.html#method.offset" title="pointer::offset"><code>pointer::offset</code></a> 的安全文档。</p>
</li>
<li>
<p>您必须执行 Rust 的别名规则，因为返回的生命周期 <code>'a</code> 是任意选择的，不一定反映数据的实际生命周期。
特别是，在此生命周期的持续时间内，指针所指向的内存一定不能通过任何其他指针进行访问 (读取或写入)。</p>
</li>
</ul>
<p>即使未使用此方法的结果也是如此!</p>
<p>另请参见 <a href="slice/fn.from_raw_parts_mut.html" title="slice::from_raw_parts_mut"><code>slice::from_raw_parts_mut</code></a>。</p>
</div></details></div></details><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Clone" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Clone" class="anchor"></a><a class="srclink" href="../src/core/clone.rs.html#215-220" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="primitive" href="primitive.pointer.html">*mut T</a></h4><a href="#method.clone" class="anchor"></a><a class="srclink" href="../src/core/clone.rs.html#217" title="goto source code">[src]</a></div></summary><div class='docblock'><p>返回值的副本。 <a href="clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone_from" class="method trait-impl has-srclink"><h4 class="code-header">fn <a href="clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="primitive.reference.html">&amp;</a>Self)</h4><a href="#method.clone_from" class="anchor"></a><a class="srclink" href="../src/core/clone.rs.html#130" title="goto source code">[src]</a></div></summary><div class='docblock'><p>从 <code>source</code> 执行复制分配。 <a href="clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Clone-1" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Clone-1" class="anchor"></a><a class="srclink" href="../src/core/clone.rs.html#207-212" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone-1" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="primitive" href="primitive.pointer.html">*const T</a></h4><a href="#method.clone-1" class="anchor"></a><a class="srclink" href="../src/core/clone.rs.html#209" title="goto source code">[src]</a></div></summary><div class='docblock'><p>返回值的副本。 <a href="clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone_from-1" class="method trait-impl has-srclink"><h4 class="code-header">fn <a href="clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="primitive.reference.html">&amp;</a>Self)</h4><a href="#method.clone_from-1" class="anchor"></a><a class="srclink" href="../src/core/clone.rs.html#130" title="goto source code">[src]</a></div></summary><div class='docblock'><p>从 <code>source</code> 执行复制分配。 <a href="clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Debug" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="fmt/trait.Debug.html" title="trait std::fmt::Debug">Debug</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Debug" class="anchor"></a><a class="srclink" href="../src/core/fmt/mod.rs.html#2193-2197" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.fmt-2" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</h4><a href="#method.fmt-2" class="anchor"></a><a class="srclink" href="../src/core/fmt/mod.rs.html#2194" title="goto source code">[src]</a></div></summary><div class='docblock'><p>使用给定的格式化程序格式化该值。 <a href="fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Debug-1" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="fmt/trait.Debug.html" title="trait std::fmt::Debug">Debug</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Debug-1" class="anchor"></a><a class="srclink" href="../src/core/fmt/mod.rs.html#2187-2191" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.fmt-3" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</h4><a href="#method.fmt-3" class="anchor"></a><a class="srclink" href="../src/core/fmt/mod.rs.html#2188" title="goto source code">[src]</a></div></summary><div class='docblock'><p>使用给定的格式化程序格式化该值。 <a href="fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Hash" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="hash/trait.Hash.html" title="trait std::hash::Hash">Hash</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Hash" class="anchor"></a><a class="srclink" href="../src/core/hash/mod.rs.html#775-782" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.hash" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="hash/trait.Hash.html#tymethod.hash" class="fnname">hash</a>&lt;H&gt;(&amp;self, state: <a class="primitive" href="primitive.reference.html">&amp;mut </a>H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="hash/trait.Hasher.html" title="trait std::hash::Hasher">Hasher</a>,&nbsp;</span></h4><a href="#method.hash" class="anchor"></a><a class="srclink" href="../src/core/hash/mod.rs.html#777" title="goto source code">[src]</a></div></summary><div class='docblock'><p>将该值输入给定的 <a href="hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a>。 <a href="hash/trait.Hash.html#tymethod.hash">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.hash_slice" class="method trait-impl has-srclink"><h4 class="code-header">fn <a href="hash/trait.Hash.html#method.hash_slice" class="fnname">hash_slice</a>&lt;H&gt;(data: <a class="primitive" href="primitive.slice.html">&amp;[Self]</a>, state: <a class="primitive" href="primitive.reference.html">&amp;mut </a>H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="hash/trait.Hasher.html" title="trait std::hash::Hasher">Hasher</a>,&nbsp;</span></h4><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span><a href="#method.hash_slice" class="anchor"></a><a class="srclink" href="../src/core/hash/mod.rs.html#211-213" title="goto source code">[src]</a></div></summary><div class='docblock'><p>将这种类型的切片送入给定的 <a href="hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a> 中。 <a href="hash/trait.Hash.html#method.hash_slice">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Hash-1" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="hash/trait.Hash.html" title="trait std::hash::Hash">Hash</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Hash-1" class="anchor"></a><a class="srclink" href="../src/core/hash/mod.rs.html#765-772" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.hash-1" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="hash/trait.Hash.html#tymethod.hash" class="fnname">hash</a>&lt;H&gt;(&amp;self, state: <a class="primitive" href="primitive.reference.html">&amp;mut </a>H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="hash/trait.Hasher.html" title="trait std::hash::Hasher">Hasher</a>,&nbsp;</span></h4><a href="#method.hash-1" class="anchor"></a><a class="srclink" href="../src/core/hash/mod.rs.html#767" title="goto source code">[src]</a></div></summary><div class='docblock'><p>将该值输入给定的 <a href="hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a>。 <a href="hash/trait.Hash.html#tymethod.hash">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.hash_slice-1" class="method trait-impl has-srclink"><h4 class="code-header">fn <a href="hash/trait.Hash.html#method.hash_slice" class="fnname">hash_slice</a>&lt;H&gt;(data: <a class="primitive" href="primitive.slice.html">&amp;[Self]</a>, state: <a class="primitive" href="primitive.reference.html">&amp;mut </a>H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="hash/trait.Hasher.html" title="trait std::hash::Hasher">Hasher</a>,&nbsp;</span></h4><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span><a href="#method.hash_slice-1" class="anchor"></a><a class="srclink" href="../src/core/hash/mod.rs.html#211-213" title="goto source code">[src]</a></div></summary><div class='docblock'><p>将这种类型的切片送入给定的 <a href="hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a> 中。 <a href="hash/trait.Hash.html#method.hash_slice">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Ord" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="cmp/trait.Ord.html" title="trait std::cmp::Ord">Ord</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Ord" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1032-1043" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.cmp" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="cmp/trait.Ord.html#tymethod.cmp" class="fnname">cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="enum" href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a></h4><a href="#method.cmp" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1034" title="goto source code">[src]</a></div></summary><div class='docblock'><p>此方法返回 <code>self</code> 和 <code>other</code> 之间的 <a href="cmp/enum.Ordering.html" title="Ordering"><code>Ordering</code></a>。 <a href="cmp/trait.Ord.html#tymethod.cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.max" class="method trait-impl has-srclink"><h4 class="code-header"><div class="code-attribute">#[must_use]</div>fn <a href="cmp/trait.Ord.html#method.max" class="fnname">max</a>(self, other: Self) -&gt; Self</h4><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a href="#method.max" class="anchor"></a><a class="srclink" href="../src/core/cmp.rs.html#751-753" title="goto source code">[src]</a></div></summary><div class='docblock'><p>比较并返回两个值中的最大值。 <a href="cmp/trait.Ord.html#method.max">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.min" class="method trait-impl has-srclink"><h4 class="code-header"><div class="code-attribute">#[must_use]</div>fn <a href="cmp/trait.Ord.html#method.min" class="fnname">min</a>(self, other: Self) -&gt; Self</h4><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a href="#method.min" class="anchor"></a><a class="srclink" href="../src/core/cmp.rs.html#771-773" title="goto source code">[src]</a></div></summary><div class='docblock'><p>比较并返回两个值中的最小值。 <a href="cmp/trait.Ord.html#method.min">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clamp" class="method trait-impl has-srclink"><h4 class="code-header"><div class="code-attribute">#[must_use]</div>fn <a href="cmp/trait.Ord.html#method.clamp" class="fnname">clamp</a>(self, min: Self, max: Self) -&gt; Self</h4><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span><a href="#method.clamp" class="anchor"></a><a class="srclink" href="../src/core/cmp.rs.html#796-798" title="goto source code">[src]</a></div></summary><div class='docblock'><p>将值限制为一定的时间间隔。 <a href="cmp/trait.Ord.html#method.clamp">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Ord-1" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="cmp/trait.Ord.html" title="trait std::cmp::Ord">Ord</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Ord-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1345-1356" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.cmp-1" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="cmp/trait.Ord.html#tymethod.cmp" class="fnname">cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="enum" href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a></h4><a href="#method.cmp-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1347" title="goto source code">[src]</a></div></summary><div class='docblock'><p>此方法返回 <code>self</code> 和 <code>other</code> 之间的 <a href="cmp/enum.Ordering.html" title="Ordering"><code>Ordering</code></a>。 <a href="cmp/trait.Ord.html#tymethod.cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.max-1" class="method trait-impl has-srclink"><h4 class="code-header"><div class="code-attribute">#[must_use]</div>fn <a href="cmp/trait.Ord.html#method.max" class="fnname">max</a>(self, other: Self) -&gt; Self</h4><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a href="#method.max-1" class="anchor"></a><a class="srclink" href="../src/core/cmp.rs.html#751-753" title="goto source code">[src]</a></div></summary><div class='docblock'><p>比较并返回两个值中的最大值。 <a href="cmp/trait.Ord.html#method.max">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.min-1" class="method trait-impl has-srclink"><h4 class="code-header"><div class="code-attribute">#[must_use]</div>fn <a href="cmp/trait.Ord.html#method.min" class="fnname">min</a>(self, other: Self) -&gt; Self</h4><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a href="#method.min-1" class="anchor"></a><a class="srclink" href="../src/core/cmp.rs.html#771-773" title="goto source code">[src]</a></div></summary><div class='docblock'><p>比较并返回两个值中的最小值。 <a href="cmp/trait.Ord.html#method.min">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clamp-1" class="method trait-impl has-srclink"><h4 class="code-header"><div class="code-attribute">#[must_use]</div>fn <a href="cmp/trait.Ord.html#method.clamp" class="fnname">clamp</a>(self, min: Self, max: Self) -&gt; Self</h4><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span><a href="#method.clamp-1" class="anchor"></a><a class="srclink" href="../src/core/cmp.rs.html#796-798" title="goto source code">[src]</a></div></summary><div class='docblock'><p>将值限制为一定的时间间隔。 <a href="cmp/trait.Ord.html#method.clamp">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-PartialEq%3C*const%20T%3E" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.pointer.html">*const T</a>&gt; for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-PartialEq%3C*const%20T%3E" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1020-1025" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.eq-1" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4><a href="#method.eq-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1022" title="goto source code">[src]</a></div></summary><div class='docblock'><p>此方法测试 <code>self</code> 和 <code>other</code> 值是否相等，并由 <code>==</code> 使用。 <a href="cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ne-1" class="method trait-impl has-srclink"><h4 class="code-header"><div class="code-attribute">#[must_use]</div>fn <a href="cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4><a href="#method.ne-1" class="anchor"></a><a class="srclink" href="../src/core/cmp.rs.html#217" title="goto source code">[src]</a></div></summary><div class='docblock'><p>此方法测试 <code>!=</code>。</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-PartialEq%3C*mut%20T%3E" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.pointer.html">*mut T</a>&gt; for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-PartialEq%3C*mut%20T%3E" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1334-1339" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.eq" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4><a href="#method.eq" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1336" title="goto source code">[src]</a></div></summary><div class='docblock'><p>此方法测试 <code>self</code> 和 <code>other</code> 值是否相等，并由 <code>==</code> 使用。 <a href="cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ne" class="method trait-impl has-srclink"><h4 class="code-header"><div class="code-attribute">#[must_use]</div>fn <a href="cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4><a href="#method.ne" class="anchor"></a><a class="srclink" href="../src/core/cmp.rs.html#217" title="goto source code">[src]</a></div></summary><div class='docblock'><p>此方法测试 <code>!=</code>。</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-PartialOrd%3C*const%20T%3E" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="cmp/trait.PartialOrd.html" title="trait std::cmp::PartialOrd">PartialOrd</a>&lt;<a class="primitive" href="primitive.pointer.html">*const T</a>&gt; for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-PartialOrd%3C*const%20T%3E" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1046-1071" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.partial_cmp-1" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="enum" href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a>&gt;</h4><a href="#method.partial_cmp-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1048" title="goto source code">[src]</a></div></summary><div class='docblock'><p>如果存在，则此方法返回 <code>self</code> 和 <code>other</code> 值之间的顺序。 <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.lt-1" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4><a href="#method.lt-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1053" title="goto source code">[src]</a></div></summary><div class='docblock'><p>此方法测试的内容少于 (对于 <code>self</code> 和 <code>other</code>)，并且由 <code>&lt;</code> 操作员使用。 <a href="cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.le-1" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4><a href="#method.le-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1058" title="goto source code">[src]</a></div></summary><div class='docblock'><p>此方法测试小于或等于 (对于 <code>self</code> 和 <code>other</code>)，并且由 <code>&lt;=</code> 运算符使用。 <a href="cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.gt-1" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4><a href="#method.gt-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1063" title="goto source code">[src]</a></div></summary><div class='docblock'><p>此方法测试大于 (对于 <code>self</code> 和 <code>other</code>)，并且由 <code>&gt;</code> 操作员使用。 <a href="cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ge-1" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*const T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4><a href="#method.ge-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1068" title="goto source code">[src]</a></div></summary><div class='docblock'><p>此方法测试是否大于或等于 (对于 <code>self</code> 和 <code>other</code>)，并且由 <code>&gt;=</code> 运算符使用。 <a href="cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-PartialOrd%3C*mut%20T%3E" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="cmp/trait.PartialOrd.html" title="trait std::cmp::PartialOrd">PartialOrd</a>&lt;<a class="primitive" href="primitive.pointer.html">*mut T</a>&gt; for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-PartialOrd%3C*mut%20T%3E" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1359-1384" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.partial_cmp" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="enum" href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a>&gt;</h4><a href="#method.partial_cmp" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1361" title="goto source code">[src]</a></div></summary><div class='docblock'><p>如果存在，则此方法返回 <code>self</code> 和 <code>other</code> 值之间的顺序。 <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.lt" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4><a href="#method.lt" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1366" title="goto source code">[src]</a></div></summary><div class='docblock'><p>此方法测试的内容少于 (对于 <code>self</code> 和 <code>other</code>)，并且由 <code>&lt;</code> 操作员使用。 <a href="cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.le" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4><a href="#method.le" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1371" title="goto source code">[src]</a></div></summary><div class='docblock'><p>此方法测试小于或等于 (对于 <code>self</code> 和 <code>other</code>)，并且由 <code>&lt;=</code> 运算符使用。 <a href="cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.gt" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4><a href="#method.gt" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1376" title="goto source code">[src]</a></div></summary><div class='docblock'><p>此方法测试大于 (对于 <code>self</code> 和 <code>other</code>)，并且由 <code>&gt;</code> 操作员使用。 <a href="cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ge" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.pointer.html">*mut T</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4><a href="#method.ge" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1381" title="goto source code">[src]</a></div></summary><div class='docblock'><p>此方法测试是否大于或等于 (对于 <code>self</code> 和 <code>other</code>)，并且由 <code>&gt;=</code> 运算符使用。 <a href="cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Pointer" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="fmt/trait.Pointer.html" title="trait std::fmt::Pointer">Pointer</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Pointer" class="anchor"></a><a class="srclink" href="../src/core/fmt/mod.rs.html#2164-2168" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.fmt" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="fmt/trait.Pointer.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</h4><a href="#method.fmt" class="anchor"></a><a class="srclink" href="../src/core/fmt/mod.rs.html#2165" title="goto source code">[src]</a></div></summary><div class='docblock'><p>使用给定的格式化程序格式化该值。</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Pointer-1" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="fmt/trait.Pointer.html" title="trait std::fmt::Pointer">Pointer</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Pointer-1" class="anchor"></a><a class="srclink" href="../src/core/fmt/mod.rs.html#2136-2161" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.fmt-1" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="fmt/trait.Pointer.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</h4><a href="#method.fmt-1" class="anchor"></a><a class="srclink" href="../src/core/fmt/mod.rs.html#2137" title="goto source code">[src]</a></div></summary><div class='docblock'><p>使用给定的格式化程序格式化该值。</p>
</div></details></div></details><div id="impl-CoerceUnsized%3C*const%20U%3E" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="ops/trait.CoerceUnsized.html" title="trait std::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="primitive" href="primitive.pointer.html">*const U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="marker/trait.Unsize.html" title="trait std::marker::Unsize">Unsize</a>&lt;U&gt; + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-CoerceUnsized%3C*const%20U%3E" class="anchor"></a><a class="srclink" href="../src/core/ops/unsize.rs.html#65" title="goto source code">[src]</a></div><div id="impl-CoerceUnsized%3C*const%20U%3E-1" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="ops/trait.CoerceUnsized.html" title="trait std::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="primitive" href="primitive.pointer.html">*const U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="marker/trait.Unsize.html" title="trait std::marker::Unsize">Unsize</a>&lt;U&gt; + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-CoerceUnsized%3C*const%20U%3E-1" class="anchor"></a><a class="srclink" href="../src/core/ops/unsize.rs.html#69" title="goto source code">[src]</a></div><div id="impl-CoerceUnsized%3C*mut%20U%3E" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="ops/trait.CoerceUnsized.html" title="trait std::ops::CoerceUnsized">CoerceUnsized</a>&lt;<a class="primitive" href="primitive.pointer.html">*mut U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="marker/trait.Unsize.html" title="trait std::marker::Unsize">Unsize</a>&lt;U&gt; + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-CoerceUnsized%3C*mut%20U%3E" class="anchor"></a><a class="srclink" href="../src/core/ops/unsize.rs.html#62" title="goto source code">[src]</a></div><div id="impl-Copy" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="marker/trait.Copy.html" title="trait std::marker::Copy">Copy</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Copy" class="anchor"></a><a class="srclink" href="../src/core/marker.rs.html#825" title="goto source code">[src]</a></div><div id="impl-Copy-1" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="marker/trait.Copy.html" title="trait std::marker::Copy">Copy</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Copy-1" class="anchor"></a><a class="srclink" href="../src/core/marker.rs.html#828" title="goto source code">[src]</a></div><div id="impl-DispatchFromDyn%3C*const%20U%3E" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="ops/trait.DispatchFromDyn.html" title="trait std::ops::DispatchFromDyn">DispatchFromDyn</a>&lt;<a class="primitive" href="primitive.pointer.html">*const U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="marker/trait.Unsize.html" title="trait std::marker::Unsize">Unsize</a>&lt;U&gt; + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-DispatchFromDyn%3C*const%20U%3E" class="anchor"></a><a class="srclink" href="../src/core/ops/unsize.rs.html#98" title="goto source code">[src]</a></div><div id="impl-DispatchFromDyn%3C*mut%20U%3E" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="ops/trait.DispatchFromDyn.html" title="trait std::ops::DispatchFromDyn">DispatchFromDyn</a>&lt;<a class="primitive" href="primitive.pointer.html">*mut U</a>&gt; for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="marker/trait.Unsize.html" title="trait std::marker::Unsize">Unsize</a>&lt;U&gt; + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-DispatchFromDyn%3C*mut%20U%3E" class="anchor"></a><a class="srclink" href="../src/core/ops/unsize.rs.html#101" title="goto source code">[src]</a></div><div id="impl-Eq" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="cmp/trait.Eq.html" title="trait std::cmp::Eq">Eq</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Eq" class="anchor"></a><a class="srclink" href="../src/core/ptr/mut_ptr.rs.html#1342" title="goto source code">[src]</a></div><div id="impl-Eq-1" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="cmp/trait.Eq.html" title="trait std::cmp::Eq">Eq</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Eq-1" class="anchor"></a><a class="srclink" href="../src/core/ptr/const_ptr.rs.html#1028" title="goto source code">[src]</a></div><div id="impl-Send" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; !<a class="trait" href="marker/trait.Send.html" title="trait std::marker::Send">Send</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Send" class="anchor"></a><a class="srclink" href="../src/core/marker.rs.html#45" title="goto source code">[src]</a></div><div id="impl-Send-1" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; !<a class="trait" href="marker/trait.Send.html" title="trait std::marker::Send">Send</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Send-1" class="anchor"></a><a class="srclink" href="../src/core/marker.rs.html#43" title="goto source code">[src]</a></div><div id="impl-Sync" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; !<a class="trait" href="marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Sync" class="anchor"></a><a class="srclink" href="../src/core/marker.rs.html#486" title="goto source code">[src]</a></div><div id="impl-Sync-1" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; !<a class="trait" href="marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Sync-1" class="anchor"></a><a class="srclink" href="../src/core/marker.rs.html#484" title="goto source code">[src]</a></div><div id="impl-Unpin" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Unpin" class="anchor"></a><span class="since" title="Stable since Rust version 1.38.0">1.38.0</span><a class="srclink" href="../src/core/marker.rs.html#794" title="goto source code">[src]</a></div><div id="impl-Unpin-1" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Unpin-1" class="anchor"></a><span class="since" title="Stable since Rust version 1.38.0">1.38.0</span><a class="srclink" href="../src/core/marker.rs.html#791" title="goto source code">[src]</a></div><div id="impl-UnwindSafe" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T:&nbsp;<a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="primitive" href="primitive.pointer.html">*const T</a></h3><a href="#impl-UnwindSafe" class="anchor"></a><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span><a class="srclink" href="../src/std/panic.rs.html#234" title="goto source code">[src]</a></div><div id="impl-UnwindSafe-1" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T:&nbsp;<a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a></h3><a href="#impl-UnwindSafe-1" class="anchor"></a><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span><a class="srclink" href="../src/std/panic.rs.html#236" title="goto source code">[src]</a></div></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><div id="impl-RefUnwindSafe" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T:&nbsp;?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="primitive" href="primitive.pointer.html">*const T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>,&nbsp;</span></h3><a href="#impl-RefUnwindSafe" class="anchor"></a></div><div id="impl-RefUnwindSafe-1" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T:&nbsp;?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="primitive" href="primitive.pointer.html">*mut T</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>,&nbsp;</span></h3><a href="#impl-RefUnwindSafe-1" class="anchor"></a></div><div id="impl-RefUnwindSafe-2" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.slice.html">[</a>T<a class="primitive" href="primitive.slice.html">]</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>,&nbsp;</span></h3><a href="#impl-RefUnwindSafe-2" class="anchor"></a></div><div id="impl-RefUnwindSafe-3" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.slice.html">[</a>T<a class="primitive" href="primitive.slice.html">]</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>,&nbsp;</span></h3><a href="#impl-RefUnwindSafe-3" class="anchor"></a></div></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Any" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="any/trait.Any.html" title="trait std::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Any" class="anchor"></a><a class="srclink" href="../src/core/any.rs.html#132-136" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.type_id" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="any/struct.TypeId.html" title="struct std::any::TypeId">TypeId</a></h4><a href="#method.type_id" class="anchor"></a><a class="srclink" href="../src/core/any.rs.html#133" title="goto source code">[src]</a></div></summary><div class='docblock'><p>获取 <code>self</code> 的 <code>TypeId</code>。 <a href="any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Any-1" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="any/trait.Any.html" title="trait std::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Any-1" class="anchor"></a><a class="srclink" href="../src/core/any.rs.html#132-136" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.type_id-1" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="any/struct.TypeId.html" title="struct std::any::TypeId">TypeId</a></h4><a href="#method.type_id-1" class="anchor"></a><a class="srclink" href="../src/core/any.rs.html#133" title="goto source code">[src]</a></div></summary><div class='docblock'><p>获取 <code>self</code> 的 <code>TypeId</code>。 <a href="any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Any-2" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="any/trait.Any.html" title="trait std::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Any-2" class="anchor"></a><a class="srclink" href="../src/core/any.rs.html#132-136" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.type_id-2" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="any/struct.TypeId.html" title="struct std::any::TypeId">TypeId</a></h4><a href="#method.type_id-2" class="anchor"></a><a class="srclink" href="../src/core/any.rs.html#133" title="goto source code">[src]</a></div></summary><div class='docblock'><p>获取 <code>self</code> 的 <code>TypeId</code>。 <a href="any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Any-3" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="any/trait.Any.html" title="trait std::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Any-3" class="anchor"></a><a class="srclink" href="../src/core/any.rs.html#132-136" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.type_id-3" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="any/struct.TypeId.html" title="struct std::any::TypeId">TypeId</a></h4><a href="#method.type_id-3" class="anchor"></a><a class="srclink" href="../src/core/any.rs.html#133" title="goto source code">[src]</a></div></summary><div class='docblock'><p>获取 <code>self</code> 的 <code>TypeId</code>。 <a href="any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Borrow%3CT%3E" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Borrow%3CT%3E" class="anchor"></a><a class="srclink" href="../src/core/borrow.rs.html#208-213" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;</a>T</h4><a href="#method.borrow" class="anchor"></a><a class="srclink" href="../src/core/borrow.rs.html#210" title="goto source code">[src]</a></div></summary><div class='docblock'><p>从拥有的值中一成不变地借用。 <a href="borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Borrow%3CT%3E-1" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Borrow%3CT%3E-1" class="anchor"></a><a class="srclink" href="../src/core/borrow.rs.html#208-213" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow-1" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;</a>T</h4><a href="#method.borrow-1" class="anchor"></a><a class="srclink" href="../src/core/borrow.rs.html#210" title="goto source code">[src]</a></div></summary><div class='docblock'><p>从拥有的值中一成不变地借用。 <a href="borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Borrow%3CT%3E-2" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Borrow%3CT%3E-2" class="anchor"></a><a class="srclink" href="../src/core/borrow.rs.html#208-213" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow-2" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;</a>T</h4><a href="#method.borrow-2" class="anchor"></a><a class="srclink" href="../src/core/borrow.rs.html#210" title="goto source code">[src]</a></div></summary><div class='docblock'><p>从拥有的值中一成不变地借用。 <a href="borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Borrow%3CT%3E-3" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Borrow%3CT%3E-3" class="anchor"></a><a class="srclink" href="../src/core/borrow.rs.html#208-213" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow-3" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;</a>T</h4><a href="#method.borrow-3" class="anchor"></a><a class="srclink" href="../src/core/borrow.rs.html#210" title="goto source code">[src]</a></div></summary><div class='docblock'><p>从拥有的值中一成不变地借用。 <a href="borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.BorrowMut.html" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><a class="srclink" href="../src/core/borrow.rs.html#216-220" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow_mut" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;mut </a>T</h4><a href="#method.borrow_mut" class="anchor"></a><a class="srclink" href="../src/core/borrow.rs.html#217" title="goto source code">[src]</a></div></summary><div class='docblock'><p>从拥有的值中借用。 <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-BorrowMut%3CT%3E-1" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.BorrowMut.html" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-BorrowMut%3CT%3E-1" class="anchor"></a><a class="srclink" href="../src/core/borrow.rs.html#216-220" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow_mut-1" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;mut </a>T</h4><a href="#method.borrow_mut-1" class="anchor"></a><a class="srclink" href="../src/core/borrow.rs.html#217" title="goto source code">[src]</a></div></summary><div class='docblock'><p>从拥有的值中借用。 <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-BorrowMut%3CT%3E-2" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.BorrowMut.html" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-BorrowMut%3CT%3E-2" class="anchor"></a><a class="srclink" href="../src/core/borrow.rs.html#216-220" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow_mut-2" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;mut </a>T</h4><a href="#method.borrow_mut-2" class="anchor"></a><a class="srclink" href="../src/core/borrow.rs.html#217" title="goto source code">[src]</a></div></summary><div class='docblock'><p>从拥有的值中借用。 <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-BorrowMut%3CT%3E-3" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.BorrowMut.html" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-BorrowMut%3CT%3E-3" class="anchor"></a><a class="srclink" href="../src/core/borrow.rs.html#216-220" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow_mut-3" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;mut </a>T</h4><a href="#method.borrow_mut-3" class="anchor"></a><a class="srclink" href="../src/core/borrow.rs.html#217" title="goto source code">[src]</a></div></summary><div class='docblock'><p>从拥有的值中借用。 <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-From%3CT%3E" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for T</h3><a href="#impl-From%3CT%3E" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#546-550" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4><a href="#method.from" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#547" title="goto source code">[src]</a></div></summary><div class='docblock'><p>执行转换。</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-From%3CT%3E-1" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for T</h3><a href="#impl-From%3CT%3E-1" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#546-550" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from-1" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4><a href="#method.from-1" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#547" title="goto source code">[src]</a></div></summary><div class='docblock'><p>执行转换。</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-From%3CT%3E-2" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for T</h3><a href="#impl-From%3CT%3E-2" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#546-550" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from-2" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4><a href="#method.from-2" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#547" title="goto source code">[src]</a></div></summary><div class='docblock'><p>执行转换。</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-From%3CT%3E-3" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for T</h3><a href="#impl-From%3CT%3E-3" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#546-550" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from-3" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4><a href="#method.from-3" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#547" title="goto source code">[src]</a></div></summary><div class='docblock'><p>执行转换。</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Into%3CU%3E" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3><a href="#impl-Into%3CU%3E" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#535-542" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.into" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4><a href="#method.into" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#539" title="goto source code">[src]</a></div></summary><div class='docblock'><p>执行转换。</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Into%3CU%3E-1" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3><a href="#impl-Into%3CU%3E-1" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#535-542" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.into-1" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4><a href="#method.into-1" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#539" title="goto source code">[src]</a></div></summary><div class='docblock'><p>执行转换。</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Into%3CU%3E-2" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3><a href="#impl-Into%3CU%3E-2" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#535-542" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.into-2" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4><a href="#method.into-2" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#539" title="goto source code">[src]</a></div></summary><div class='docblock'><p>执行转换。</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Into%3CU%3E-3" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3><a href="#impl-Into%3CU%3E-3" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#535-542" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.into-3" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4><a href="#method.into-3" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#539" title="goto source code">[src]</a></div></summary><div class='docblock'><p>执行转换。</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-ToOwned" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.ToOwned.html" title="trait std::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a>,&nbsp;</span></h3><a href="#impl-ToOwned" class="anchor"></a><a class="srclink" href="../src/alloc/borrow.rs.html#84-96" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Owned" class="type trait-impl has-srclink"><h4 class="code-header">type <a href="borrow/trait.ToOwned.html#associatedtype.Owned" class="type">Owned</a> = T</h4><a href="#associatedtype.Owned" class="anchor"></a></div></summary><div class='docblock'><p>获得所有权后的结果类型。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.to_owned" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4><a href="#method.to_owned" class="anchor"></a><a class="srclink" href="../src/alloc/borrow.rs.html#89" title="goto source code">[src]</a></div></summary><div class='docblock'><p>通常通过克隆从借用数据中创建拥有的数据。 <a href="borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone_into" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="primitive.reference.html">&amp;mut </a>T)</h4><a href="#method.clone_into" class="anchor"></a><a class="srclink" href="../src/alloc/borrow.rs.html#93" title="goto source code">[src]</a></div></summary><div class="item-info"><div class="stab unstable"><details><summary><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/41263">#41263</a>)</summary><p>recently added</p>
</details></div></div><div class='docblock'><p>使用借来的数据来替换拥有的数据，通常是通过克隆。 <a href="borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-ToOwned-1" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.ToOwned.html" title="trait std::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a>,&nbsp;</span></h3><a href="#impl-ToOwned-1" class="anchor"></a><a class="srclink" href="../src/alloc/borrow.rs.html#84-96" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Owned-1" class="type trait-impl has-srclink"><h4 class="code-header">type <a href="borrow/trait.ToOwned.html#associatedtype.Owned" class="type">Owned</a> = T</h4><a href="#associatedtype.Owned-1" class="anchor"></a></div></summary><div class='docblock'><p>获得所有权后的结果类型。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.to_owned-1" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4><a href="#method.to_owned-1" class="anchor"></a><a class="srclink" href="../src/alloc/borrow.rs.html#89" title="goto source code">[src]</a></div></summary><div class='docblock'><p>通常通过克隆从借用数据中创建拥有的数据。 <a href="borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone_into-1" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="primitive.reference.html">&amp;mut </a>T)</h4><a href="#method.clone_into-1" class="anchor"></a><a class="srclink" href="../src/alloc/borrow.rs.html#93" title="goto source code">[src]</a></div></summary><div class="item-info"><div class="stab unstable"><details><summary><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/41263">#41263</a>)</summary><p>recently added</p>
</details></div></div><div class='docblock'><p>使用借来的数据来替换拥有的数据，通常是通过克隆。 <a href="borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-ToOwned-2" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.ToOwned.html" title="trait std::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a>,&nbsp;</span></h3><a href="#impl-ToOwned-2" class="anchor"></a><a class="srclink" href="../src/alloc/borrow.rs.html#84-96" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Owned-2" class="type trait-impl has-srclink"><h4 class="code-header">type <a href="borrow/trait.ToOwned.html#associatedtype.Owned" class="type">Owned</a> = T</h4><a href="#associatedtype.Owned-2" class="anchor"></a></div></summary><div class='docblock'><p>获得所有权后的结果类型。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.to_owned-2" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4><a href="#method.to_owned-2" class="anchor"></a><a class="srclink" href="../src/alloc/borrow.rs.html#89" title="goto source code">[src]</a></div></summary><div class='docblock'><p>通常通过克隆从借用数据中创建拥有的数据。 <a href="borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone_into-2" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="primitive.reference.html">&amp;mut </a>T)</h4><a href="#method.clone_into-2" class="anchor"></a><a class="srclink" href="../src/alloc/borrow.rs.html#93" title="goto source code">[src]</a></div></summary><div class="item-info"><div class="stab unstable"><details><summary><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/41263">#41263</a>)</summary><p>recently added</p>
</details></div></div><div class='docblock'><p>使用借来的数据来替换拥有的数据，通常是通过克隆。 <a href="borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-ToOwned-3" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.ToOwned.html" title="trait std::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a>,&nbsp;</span></h3><a href="#impl-ToOwned-3" class="anchor"></a><a class="srclink" href="../src/alloc/borrow.rs.html#84-96" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Owned-3" class="type trait-impl has-srclink"><h4 class="code-header">type <a href="borrow/trait.ToOwned.html#associatedtype.Owned" class="type">Owned</a> = T</h4><a href="#associatedtype.Owned-3" class="anchor"></a></div></summary><div class='docblock'><p>获得所有权后的结果类型。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.to_owned-3" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4><a href="#method.to_owned-3" class="anchor"></a><a class="srclink" href="../src/alloc/borrow.rs.html#89" title="goto source code">[src]</a></div></summary><div class='docblock'><p>通常通过克隆从借用数据中创建拥有的数据。 <a href="borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone_into-3" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="primitive.reference.html">&amp;mut </a>T)</h4><a href="#method.clone_into-3" class="anchor"></a><a class="srclink" href="../src/alloc/borrow.rs.html#93" title="goto source code">[src]</a></div></summary><div class="item-info"><div class="stab unstable"><details><summary><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/41263">#41263</a>)</summary><p>recently added</p>
</details></div></div><div class='docblock'><p>使用借来的数据来替换拥有的数据，通常是通过克隆。 <a href="borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-TryFrom%3CU%3E" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#583-592" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Error" class="type trait-impl has-srclink"><h4 class="code-header">type <a href="convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="convert/enum.Infallible.html" title="enum std::convert::Infallible">Infallible</a></h4><a href="#associatedtype.Error" class="anchor"></a></div></summary><div class='docblock'><p>发生转换错误时返回的类型。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_from" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4><a href="#method.try_from" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#589" title="goto source code">[src]</a></div></summary><div class='docblock'><p>执行转换。</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-TryFrom%3CU%3E-1" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3><a href="#impl-TryFrom%3CU%3E-1" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#583-592" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Error-2" class="type trait-impl has-srclink"><h4 class="code-header">type <a href="convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="convert/enum.Infallible.html" title="enum std::convert::Infallible">Infallible</a></h4><a href="#associatedtype.Error-2" class="anchor"></a></div></summary><div class='docblock'><p>发生转换错误时返回的类型。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_from-1" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4><a href="#method.try_from-1" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#589" title="goto source code">[src]</a></div></summary><div class='docblock'><p>执行转换。</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-TryFrom%3CU%3E-2" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3><a href="#impl-TryFrom%3CU%3E-2" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#583-592" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Error-4" class="type trait-impl has-srclink"><h4 class="code-header">type <a href="convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="convert/enum.Infallible.html" title="enum std::convert::Infallible">Infallible</a></h4><a href="#associatedtype.Error-4" class="anchor"></a></div></summary><div class='docblock'><p>发生转换错误时返回的类型。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_from-2" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4><a href="#method.try_from-2" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#589" title="goto source code">[src]</a></div></summary><div class='docblock'><p>执行转换。</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-TryFrom%3CU%3E-3" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3><a href="#impl-TryFrom%3CU%3E-3" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#583-592" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Error-6" class="type trait-impl has-srclink"><h4 class="code-header">type <a href="convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="convert/enum.Infallible.html" title="enum std::convert::Infallible">Infallible</a></h4><a href="#associatedtype.Error-6" class="anchor"></a></div></summary><div class='docblock'><p>发生转换错误时返回的类型。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_from-3" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4><a href="#method.try_from-3" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#589" title="goto source code">[src]</a></div></summary><div class='docblock'><p>执行转换。</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-TryInto%3CU%3E" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryInto.html" title="trait std::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3><a href="#impl-TryInto%3CU%3E" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#569-578" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Error-1" class="type trait-impl has-srclink"><h4 class="code-header">type <a href="convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a></h4><a href="#associatedtype.Error-1" class="anchor"></a></div></summary><div class='docblock'><p>发生转换错误时返回的类型。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_into" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4><a href="#method.try_into" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#575" title="goto source code">[src]</a></div></summary><div class='docblock'><p>执行转换。</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-TryInto%3CU%3E-1" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryInto.html" title="trait std::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3><a href="#impl-TryInto%3CU%3E-1" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#569-578" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Error-3" class="type trait-impl has-srclink"><h4 class="code-header">type <a href="convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a></h4><a href="#associatedtype.Error-3" class="anchor"></a></div></summary><div class='docblock'><p>发生转换错误时返回的类型。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_into-1" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4><a href="#method.try_into-1" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#575" title="goto source code">[src]</a></div></summary><div class='docblock'><p>执行转换。</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-TryInto%3CU%3E-2" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryInto.html" title="trait std::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3><a href="#impl-TryInto%3CU%3E-2" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#569-578" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Error-5" class="type trait-impl has-srclink"><h4 class="code-header">type <a href="convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a></h4><a href="#associatedtype.Error-5" class="anchor"></a></div></summary><div class='docblock'><p>发生转换错误时返回的类型。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_into-2" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4><a href="#method.try_into-2" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#575" title="goto source code">[src]</a></div></summary><div class='docblock'><p>执行转换。</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-TryInto%3CU%3E-3" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="convert/trait.TryInto.html" title="trait std::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3><a href="#impl-TryInto%3CU%3E-3" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#569-578" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Error-7" class="type trait-impl has-srclink"><h4 class="code-header">type <a href="convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a></h4><a href="#associatedtype.Error-7" class="anchor"></a></div></summary><div class='docblock'><p>发生转换错误时返回的类型。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_into-3" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4><a href="#method.try_into-3" class="anchor"></a><a class="srclink" href="../src/core/convert/mod.rs.html#575" title="goto source code">[src]</a></div></summary><div class='docblock'><p>执行转换。</p>
</div></details></div></details></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="std" data-search-index-js="../search-index1.55.0.js" data-search-js="../search1.55.0.js"></div><script src="../main1.55.0.js"></script></body></html>