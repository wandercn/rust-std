initSidebarItems({"fn":[["copy","将 `count * size_of::<T>()` 字节从 `src` 复制到 `dst`。源和目标可能会重叠。"],["copy_nonoverlapping","将 `count * size_of::<T>()` 字节从 `src` 复制到 `dst`。源和目标必须不重叠。"],["drop_in_place","执行指向值的析构函数 (如果有)。"],["eq","比较裸指针是否相等。"],["from_raw_parts","根据数据地址和元数据形成 (possibly-wide) 裸指针。"],["from_raw_parts_mut","执行与 [`from_raw_parts`] 相同的功能，除了返回原始 `*mut` 指针 (与原始 `* const` 指针相反) 之外。"],["hash","散列一个裸指针。"],["metadata","提取指针的元数据组件。"],["null","创建一个空的裸指针。"],["null_mut","创建一个空的可变裸露指针。"],["read","从 `src` 读取值而不移动它。这将使 `src` 中的内存保持不变。"],["read_unaligned","从 `src` 读取值而不移动它。这将使 `src` 中的内存保持不变。"],["read_volatile","对 `src` 的值进行易失性读取，而无需移动它。这将使 `src` 中的内存保持不变。"],["replace","将 `src` 移至指定的 `dst`，返回先前的 `dst` 值。"],["slice_from_raw_parts","根据指针和长度形成原始切片。"],["slice_from_raw_parts_mut","执行与 [`slice_from_raw_parts`] 相同的功能，但返回的是原始可变切片，而不是原始的不可变切片。"],["swap","在相同类型的两个可变位置交换值，而无需取消初始化任何一个。"],["swap_nonoverlapping","从 `x` 和 `y` 开始在两个内存区域之间交换 `count * size_of::<T>()` 字节。 这两个区域必须 不能 重叠。"],["write","用给定值覆盖存储位置，而无需读取或丢弃旧值。"],["write_bytes","将从 `dst` 开始的 `count * size_of::<T>()` 内存字节设置为 `val`。"],["write_unaligned","用给定值覆盖存储位置，而无需读取或丢弃旧值。"],["write_volatile","使用给定值对存储单元执行易失性写操作，而无需读取或丢弃旧值。"]],"macro":[["addr_of","创建一个 `const` 裸指针到一个位置，而无需创建中间引用。"],["addr_of_mut","创建一个 `mut` 裸指针到一个位置，而无需创建中间引用。"]],"struct":[["DynMetadata","`Dyn = dyn SomeTrait` trait 对象类型的元数据。"],["NonNull","`*mut T` 但非零且协变。"]],"trait":[["Pointee","提供任何指向类型的指针元数据类型。"]]});