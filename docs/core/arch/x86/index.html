<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`x86` 平台的平台特定的内联函数。"><meta name="keywords" content="rust, rustlang, rust-lang, x86"><title>core::arch::x86 - Rust</title><link rel="stylesheet" type="text/css" href="../../../normalize1.55.0.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc1.55.0.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../light1.55.0.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../../dark1.55.0.css" disabled ><link rel="stylesheet" type="text/css" href="../../../ayu1.55.0.css" disabled ><script id="default-settings"></script><script src="../../../storage1.55.0.js"></script><script src="../../../crates1.55.0.js"></script><noscript><link rel="stylesheet" href="../../../noscript1.55.0.css"></noscript><link rel="icon" type="image/svg+xml" href="../../../favicon1.55.0.svg">
<link rel="alternate icon" type="image/png" href="../../../favicon-16x161.55.0.png">
<link rel="alternate icon" type="image/png" href="../../../favicon-32x321.55.0.png"><style type="text/css">#crate-search{background-image:url("../../../down-arrow1.55.0.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../../core/index.html'><div class='logo-container rust-logo'><img src='../../../rust-logo1.55.0.png' alt='logo'></div></a><h2 class="location">Module x86</h2><div class="sidebar-elems"><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#constants">Constants</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div><div id="sidebar-vars" data-name="x86" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img src="../../../brush1.55.0.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../settings.html" title="settings"><img src="../../../wheel1.55.0.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../../index.html">core</a>::<wbr><a href="../index.html">arch</a>::<wbr><a class="mod" href="#">x86</a><button id="copy-path" onclick="copy_path(this)" title="copy path"><img src="../../../clipboard1.55.0.svg" width="19" height="18" alt="Copy item import" title="Copy item import to clipboard"></button></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.27.0">1.27.0</span><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../../src/core/up/up/stdarch/crates/core_arch/src/mod.rs.html#20-23" title="goto source code">[src]</a></span></h1><div class="item-info"><div class="stab portability">This is supported on <strong>x86</strong> only.</div></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><code>x86</code> 平台的平台特定的内联函数。</p>
<p>有关更多详细信息，请参见 <a href="../index.html">module documentation</a>。</p>
</div></details><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<table><tr class="unstable module-item"><td><a class="struct" href="struct.__m128bh.html" title="core::arch::x86::__m128bh struct">__m128bh</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>128 位宽的一组 8 个 <code>u16</code> 类型，特定于 x86</p>
</td></tr><tr class="unstable module-item"><td><a class="struct" href="struct.__m256bh.html" title="core::arch::x86::__m256bh struct">__m256bh</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>256 位宽的 16 种 <code>u16</code> 类型集，特定于 x86</p>
</td></tr><tr class="unstable module-item"><td><a class="struct" href="struct.__m512.html" title="core::arch::x86::__m512 struct">__m512</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>512 位宽的十六种 <code>f32</code> 类型集，特定于 x86</p>
</td></tr><tr class="unstable module-item"><td><a class="struct" href="struct.__m512bh.html" title="core::arch::x86::__m512bh struct">__m512bh</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>512 位宽的 32 种 <code>u16</code> 类型集，特定于 x86</p>
</td></tr><tr class="unstable module-item"><td><a class="struct" href="struct.__m512d.html" title="core::arch::x86::__m512d struct">__m512d</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>八种 <code>f64</code> 类型的 512 位宽集，特定于 x86</p>
</td></tr><tr class="unstable module-item"><td><a class="struct" href="struct.__m512i.html" title="core::arch::x86::__m512i struct">__m512i</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>512 位宽的整数 vector 类型，特定于 x86</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.CpuidResult.html" title="core::arch::x86::CpuidResult struct">CpuidResult</a></td><td class="docblock-short"><p><code>cpuid</code> 指令的结果。</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.__m128.html" title="core::arch::x86::__m128 struct">__m128</a></td><td class="docblock-short"><p>四种 <code>f32</code> 类型的 128 位宽集，特定于 x86</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.__m128d.html" title="core::arch::x86::__m128d struct">__m128d</a></td><td class="docblock-short"><p>两种 <code>f64</code> 类型的 128 位宽集，特定于 x86</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.__m128i.html" title="core::arch::x86::__m128i struct">__m128i</a></td><td class="docblock-short"><p>128 位宽的整数 vector 类型，特定于 x86</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.__m256.html" title="core::arch::x86::__m256 struct">__m256</a></td><td class="docblock-short"><p>256 位宽的八种 <code>f32</code> 类型的集合，特定于 x86</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.__m256d.html" title="core::arch::x86::__m256d struct">__m256d</a></td><td class="docblock-short"><p>256 位宽的四种 <code>f64</code> 类型的集合，特定于 x86</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.__m256i.html" title="core::arch::x86::__m256i struct">__m256i</a></td><td class="docblock-short"><p>256 位宽的整数 vector 类型，特定于 x86</p>
</td></tr></table><h2 id="constants" class="section-header"><a href="#constants">Constants</a></h2>
<table><tr class="unstable module-item"><td><a class="constant" href="constant._MM_CMPINT_EQ.html" title="core::arch::x86::_MM_CMPINT_EQ constant">_MM_CMPINT_EQ</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>Equal</p>
</td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_CMPINT_FALSE.html" title="core::arch::x86::_MM_CMPINT_FALSE constant">_MM_CMPINT_FALSE</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>False</p>
</td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_CMPINT_LE.html" title="core::arch::x86::_MM_CMPINT_LE constant">_MM_CMPINT_LE</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>Less-than-or-equal</p>
</td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_CMPINT_LT.html" title="core::arch::x86::_MM_CMPINT_LT constant">_MM_CMPINT_LT</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>Less-than</p>
</td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_CMPINT_NE.html" title="core::arch::x86::_MM_CMPINT_NE constant">_MM_CMPINT_NE</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>Not-equal</p>
</td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_CMPINT_NLE.html" title="core::arch::x86::_MM_CMPINT_NLE constant">_MM_CMPINT_NLE</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>不小于等于</p>
</td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_CMPINT_NLT.html" title="core::arch::x86::_MM_CMPINT_NLT constant">_MM_CMPINT_NLT</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>不小于</p>
</td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_CMPINT_TRUE.html" title="core::arch::x86::_MM_CMPINT_TRUE constant">_MM_CMPINT_TRUE</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>True</p>
</td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_MANT_NORM_1_2.html" title="core::arch::x86::_MM_MANT_NORM_1_2 constant">_MM_MANT_NORM_1_2</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>间隔 [1，2)</p>
</td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_MANT_NORM_P5_1.html" title="core::arch::x86::_MM_MANT_NORM_P5_1 constant">_MM_MANT_NORM_P5_1</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>间隔 [0.5，1)</p>
</td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_MANT_NORM_P5_2.html" title="core::arch::x86::_MM_MANT_NORM_P5_2 constant">_MM_MANT_NORM_P5_2</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>间隔 [0.5，2)</p>
</td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_MANT_NORM_P75_1P5.html" title="core::arch::x86::_MM_MANT_NORM_P75_1P5 constant">_MM_MANT_NORM_P75_1P5</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>间隔 [0.75，1.5)</p>
</td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_MANT_SIGN_NAN.html" title="core::arch::x86::_MM_MANT_SIGN_NAN constant">_MM_MANT_SIGN_NAN</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>如果 sign(SRC) =1，则 DEST=NaN</p>
</td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_MANT_SIGN_SRC.html" title="core::arch::x86::_MM_MANT_SIGN_SRC constant">_MM_MANT_SIGN_SRC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>sign = sign(SRC)</p>
</td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_MANT_SIGN_ZERO.html" title="core::arch::x86::_MM_MANT_SIGN_ZERO constant">_MM_MANT_SIGN_ZERO</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>sign = 0</p>
</td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_AAAA.html" title="core::arch::x86::_MM_PERM_AAAA constant">_MM_PERM_AAAA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_AAAB.html" title="core::arch::x86::_MM_PERM_AAAB constant">_MM_PERM_AAAB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_AAAC.html" title="core::arch::x86::_MM_PERM_AAAC constant">_MM_PERM_AAAC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_AAAD.html" title="core::arch::x86::_MM_PERM_AAAD constant">_MM_PERM_AAAD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_AABA.html" title="core::arch::x86::_MM_PERM_AABA constant">_MM_PERM_AABA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_AABB.html" title="core::arch::x86::_MM_PERM_AABB constant">_MM_PERM_AABB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_AABC.html" title="core::arch::x86::_MM_PERM_AABC constant">_MM_PERM_AABC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_AABD.html" title="core::arch::x86::_MM_PERM_AABD constant">_MM_PERM_AABD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_AACA.html" title="core::arch::x86::_MM_PERM_AACA constant">_MM_PERM_AACA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_AACB.html" title="core::arch::x86::_MM_PERM_AACB constant">_MM_PERM_AACB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_AACC.html" title="core::arch::x86::_MM_PERM_AACC constant">_MM_PERM_AACC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_AACD.html" title="core::arch::x86::_MM_PERM_AACD constant">_MM_PERM_AACD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_AADA.html" title="core::arch::x86::_MM_PERM_AADA constant">_MM_PERM_AADA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_AADB.html" title="core::arch::x86::_MM_PERM_AADB constant">_MM_PERM_AADB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_AADC.html" title="core::arch::x86::_MM_PERM_AADC constant">_MM_PERM_AADC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_AADD.html" title="core::arch::x86::_MM_PERM_AADD constant">_MM_PERM_AADD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ABAA.html" title="core::arch::x86::_MM_PERM_ABAA constant">_MM_PERM_ABAA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ABAB.html" title="core::arch::x86::_MM_PERM_ABAB constant">_MM_PERM_ABAB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ABAC.html" title="core::arch::x86::_MM_PERM_ABAC constant">_MM_PERM_ABAC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ABAD.html" title="core::arch::x86::_MM_PERM_ABAD constant">_MM_PERM_ABAD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ABBA.html" title="core::arch::x86::_MM_PERM_ABBA constant">_MM_PERM_ABBA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ABBB.html" title="core::arch::x86::_MM_PERM_ABBB constant">_MM_PERM_ABBB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ABBC.html" title="core::arch::x86::_MM_PERM_ABBC constant">_MM_PERM_ABBC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ABBD.html" title="core::arch::x86::_MM_PERM_ABBD constant">_MM_PERM_ABBD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ABCA.html" title="core::arch::x86::_MM_PERM_ABCA constant">_MM_PERM_ABCA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ABCB.html" title="core::arch::x86::_MM_PERM_ABCB constant">_MM_PERM_ABCB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ABCC.html" title="core::arch::x86::_MM_PERM_ABCC constant">_MM_PERM_ABCC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ABCD.html" title="core::arch::x86::_MM_PERM_ABCD constant">_MM_PERM_ABCD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ABDA.html" title="core::arch::x86::_MM_PERM_ABDA constant">_MM_PERM_ABDA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ABDB.html" title="core::arch::x86::_MM_PERM_ABDB constant">_MM_PERM_ABDB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ABDC.html" title="core::arch::x86::_MM_PERM_ABDC constant">_MM_PERM_ABDC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ABDD.html" title="core::arch::x86::_MM_PERM_ABDD constant">_MM_PERM_ABDD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ACAA.html" title="core::arch::x86::_MM_PERM_ACAA constant">_MM_PERM_ACAA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ACAB.html" title="core::arch::x86::_MM_PERM_ACAB constant">_MM_PERM_ACAB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ACAC.html" title="core::arch::x86::_MM_PERM_ACAC constant">_MM_PERM_ACAC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ACAD.html" title="core::arch::x86::_MM_PERM_ACAD constant">_MM_PERM_ACAD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ACBA.html" title="core::arch::x86::_MM_PERM_ACBA constant">_MM_PERM_ACBA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ACBB.html" title="core::arch::x86::_MM_PERM_ACBB constant">_MM_PERM_ACBB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ACBC.html" title="core::arch::x86::_MM_PERM_ACBC constant">_MM_PERM_ACBC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ACBD.html" title="core::arch::x86::_MM_PERM_ACBD constant">_MM_PERM_ACBD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ACCA.html" title="core::arch::x86::_MM_PERM_ACCA constant">_MM_PERM_ACCA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ACCB.html" title="core::arch::x86::_MM_PERM_ACCB constant">_MM_PERM_ACCB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ACCC.html" title="core::arch::x86::_MM_PERM_ACCC constant">_MM_PERM_ACCC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ACCD.html" title="core::arch::x86::_MM_PERM_ACCD constant">_MM_PERM_ACCD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ACDA.html" title="core::arch::x86::_MM_PERM_ACDA constant">_MM_PERM_ACDA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ACDB.html" title="core::arch::x86::_MM_PERM_ACDB constant">_MM_PERM_ACDB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ACDC.html" title="core::arch::x86::_MM_PERM_ACDC constant">_MM_PERM_ACDC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ACDD.html" title="core::arch::x86::_MM_PERM_ACDD constant">_MM_PERM_ACDD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ADAA.html" title="core::arch::x86::_MM_PERM_ADAA constant">_MM_PERM_ADAA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ADAB.html" title="core::arch::x86::_MM_PERM_ADAB constant">_MM_PERM_ADAB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ADAC.html" title="core::arch::x86::_MM_PERM_ADAC constant">_MM_PERM_ADAC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ADAD.html" title="core::arch::x86::_MM_PERM_ADAD constant">_MM_PERM_ADAD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ADBA.html" title="core::arch::x86::_MM_PERM_ADBA constant">_MM_PERM_ADBA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ADBB.html" title="core::arch::x86::_MM_PERM_ADBB constant">_MM_PERM_ADBB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ADBC.html" title="core::arch::x86::_MM_PERM_ADBC constant">_MM_PERM_ADBC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ADBD.html" title="core::arch::x86::_MM_PERM_ADBD constant">_MM_PERM_ADBD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ADCA.html" title="core::arch::x86::_MM_PERM_ADCA constant">_MM_PERM_ADCA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ADCB.html" title="core::arch::x86::_MM_PERM_ADCB constant">_MM_PERM_ADCB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ADCC.html" title="core::arch::x86::_MM_PERM_ADCC constant">_MM_PERM_ADCC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ADCD.html" title="core::arch::x86::_MM_PERM_ADCD constant">_MM_PERM_ADCD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ADDA.html" title="core::arch::x86::_MM_PERM_ADDA constant">_MM_PERM_ADDA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ADDB.html" title="core::arch::x86::_MM_PERM_ADDB constant">_MM_PERM_ADDB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ADDC.html" title="core::arch::x86::_MM_PERM_ADDC constant">_MM_PERM_ADDC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_ADDD.html" title="core::arch::x86::_MM_PERM_ADDD constant">_MM_PERM_ADDD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BAAA.html" title="core::arch::x86::_MM_PERM_BAAA constant">_MM_PERM_BAAA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BAAB.html" title="core::arch::x86::_MM_PERM_BAAB constant">_MM_PERM_BAAB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BAAC.html" title="core::arch::x86::_MM_PERM_BAAC constant">_MM_PERM_BAAC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BAAD.html" title="core::arch::x86::_MM_PERM_BAAD constant">_MM_PERM_BAAD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BABA.html" title="core::arch::x86::_MM_PERM_BABA constant">_MM_PERM_BABA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BABB.html" title="core::arch::x86::_MM_PERM_BABB constant">_MM_PERM_BABB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BABC.html" title="core::arch::x86::_MM_PERM_BABC constant">_MM_PERM_BABC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BABD.html" title="core::arch::x86::_MM_PERM_BABD constant">_MM_PERM_BABD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BACA.html" title="core::arch::x86::_MM_PERM_BACA constant">_MM_PERM_BACA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BACB.html" title="core::arch::x86::_MM_PERM_BACB constant">_MM_PERM_BACB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BACC.html" title="core::arch::x86::_MM_PERM_BACC constant">_MM_PERM_BACC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BACD.html" title="core::arch::x86::_MM_PERM_BACD constant">_MM_PERM_BACD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BADA.html" title="core::arch::x86::_MM_PERM_BADA constant">_MM_PERM_BADA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BADB.html" title="core::arch::x86::_MM_PERM_BADB constant">_MM_PERM_BADB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BADC.html" title="core::arch::x86::_MM_PERM_BADC constant">_MM_PERM_BADC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BADD.html" title="core::arch::x86::_MM_PERM_BADD constant">_MM_PERM_BADD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BBAA.html" title="core::arch::x86::_MM_PERM_BBAA constant">_MM_PERM_BBAA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BBAB.html" title="core::arch::x86::_MM_PERM_BBAB constant">_MM_PERM_BBAB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BBAC.html" title="core::arch::x86::_MM_PERM_BBAC constant">_MM_PERM_BBAC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BBAD.html" title="core::arch::x86::_MM_PERM_BBAD constant">_MM_PERM_BBAD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BBBA.html" title="core::arch::x86::_MM_PERM_BBBA constant">_MM_PERM_BBBA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BBBB.html" title="core::arch::x86::_MM_PERM_BBBB constant">_MM_PERM_BBBB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BBBC.html" title="core::arch::x86::_MM_PERM_BBBC constant">_MM_PERM_BBBC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BBBD.html" title="core::arch::x86::_MM_PERM_BBBD constant">_MM_PERM_BBBD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BBCA.html" title="core::arch::x86::_MM_PERM_BBCA constant">_MM_PERM_BBCA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BBCB.html" title="core::arch::x86::_MM_PERM_BBCB constant">_MM_PERM_BBCB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BBCC.html" title="core::arch::x86::_MM_PERM_BBCC constant">_MM_PERM_BBCC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BBCD.html" title="core::arch::x86::_MM_PERM_BBCD constant">_MM_PERM_BBCD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BBDA.html" title="core::arch::x86::_MM_PERM_BBDA constant">_MM_PERM_BBDA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BBDB.html" title="core::arch::x86::_MM_PERM_BBDB constant">_MM_PERM_BBDB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BBDC.html" title="core::arch::x86::_MM_PERM_BBDC constant">_MM_PERM_BBDC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BBDD.html" title="core::arch::x86::_MM_PERM_BBDD constant">_MM_PERM_BBDD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BCAA.html" title="core::arch::x86::_MM_PERM_BCAA constant">_MM_PERM_BCAA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BCAB.html" title="core::arch::x86::_MM_PERM_BCAB constant">_MM_PERM_BCAB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BCAC.html" title="core::arch::x86::_MM_PERM_BCAC constant">_MM_PERM_BCAC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BCAD.html" title="core::arch::x86::_MM_PERM_BCAD constant">_MM_PERM_BCAD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BCBA.html" title="core::arch::x86::_MM_PERM_BCBA constant">_MM_PERM_BCBA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BCBB.html" title="core::arch::x86::_MM_PERM_BCBB constant">_MM_PERM_BCBB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BCBC.html" title="core::arch::x86::_MM_PERM_BCBC constant">_MM_PERM_BCBC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BCBD.html" title="core::arch::x86::_MM_PERM_BCBD constant">_MM_PERM_BCBD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BCCA.html" title="core::arch::x86::_MM_PERM_BCCA constant">_MM_PERM_BCCA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BCCB.html" title="core::arch::x86::_MM_PERM_BCCB constant">_MM_PERM_BCCB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BCCC.html" title="core::arch::x86::_MM_PERM_BCCC constant">_MM_PERM_BCCC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BCCD.html" title="core::arch::x86::_MM_PERM_BCCD constant">_MM_PERM_BCCD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BCDA.html" title="core::arch::x86::_MM_PERM_BCDA constant">_MM_PERM_BCDA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BCDB.html" title="core::arch::x86::_MM_PERM_BCDB constant">_MM_PERM_BCDB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BCDC.html" title="core::arch::x86::_MM_PERM_BCDC constant">_MM_PERM_BCDC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BCDD.html" title="core::arch::x86::_MM_PERM_BCDD constant">_MM_PERM_BCDD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BDAA.html" title="core::arch::x86::_MM_PERM_BDAA constant">_MM_PERM_BDAA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BDAB.html" title="core::arch::x86::_MM_PERM_BDAB constant">_MM_PERM_BDAB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BDAC.html" title="core::arch::x86::_MM_PERM_BDAC constant">_MM_PERM_BDAC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BDAD.html" title="core::arch::x86::_MM_PERM_BDAD constant">_MM_PERM_BDAD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BDBA.html" title="core::arch::x86::_MM_PERM_BDBA constant">_MM_PERM_BDBA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BDBB.html" title="core::arch::x86::_MM_PERM_BDBB constant">_MM_PERM_BDBB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BDBC.html" title="core::arch::x86::_MM_PERM_BDBC constant">_MM_PERM_BDBC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BDBD.html" title="core::arch::x86::_MM_PERM_BDBD constant">_MM_PERM_BDBD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BDCA.html" title="core::arch::x86::_MM_PERM_BDCA constant">_MM_PERM_BDCA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BDCB.html" title="core::arch::x86::_MM_PERM_BDCB constant">_MM_PERM_BDCB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BDCC.html" title="core::arch::x86::_MM_PERM_BDCC constant">_MM_PERM_BDCC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BDCD.html" title="core::arch::x86::_MM_PERM_BDCD constant">_MM_PERM_BDCD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BDDA.html" title="core::arch::x86::_MM_PERM_BDDA constant">_MM_PERM_BDDA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BDDB.html" title="core::arch::x86::_MM_PERM_BDDB constant">_MM_PERM_BDDB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BDDC.html" title="core::arch::x86::_MM_PERM_BDDC constant">_MM_PERM_BDDC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_BDDD.html" title="core::arch::x86::_MM_PERM_BDDD constant">_MM_PERM_BDDD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CAAA.html" title="core::arch::x86::_MM_PERM_CAAA constant">_MM_PERM_CAAA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CAAB.html" title="core::arch::x86::_MM_PERM_CAAB constant">_MM_PERM_CAAB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CAAC.html" title="core::arch::x86::_MM_PERM_CAAC constant">_MM_PERM_CAAC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CAAD.html" title="core::arch::x86::_MM_PERM_CAAD constant">_MM_PERM_CAAD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CABA.html" title="core::arch::x86::_MM_PERM_CABA constant">_MM_PERM_CABA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CABB.html" title="core::arch::x86::_MM_PERM_CABB constant">_MM_PERM_CABB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CABC.html" title="core::arch::x86::_MM_PERM_CABC constant">_MM_PERM_CABC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CABD.html" title="core::arch::x86::_MM_PERM_CABD constant">_MM_PERM_CABD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CACA.html" title="core::arch::x86::_MM_PERM_CACA constant">_MM_PERM_CACA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CACB.html" title="core::arch::x86::_MM_PERM_CACB constant">_MM_PERM_CACB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CACC.html" title="core::arch::x86::_MM_PERM_CACC constant">_MM_PERM_CACC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CACD.html" title="core::arch::x86::_MM_PERM_CACD constant">_MM_PERM_CACD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CADA.html" title="core::arch::x86::_MM_PERM_CADA constant">_MM_PERM_CADA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CADB.html" title="core::arch::x86::_MM_PERM_CADB constant">_MM_PERM_CADB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CADC.html" title="core::arch::x86::_MM_PERM_CADC constant">_MM_PERM_CADC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CADD.html" title="core::arch::x86::_MM_PERM_CADD constant">_MM_PERM_CADD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CBAA.html" title="core::arch::x86::_MM_PERM_CBAA constant">_MM_PERM_CBAA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CBAB.html" title="core::arch::x86::_MM_PERM_CBAB constant">_MM_PERM_CBAB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CBAC.html" title="core::arch::x86::_MM_PERM_CBAC constant">_MM_PERM_CBAC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CBAD.html" title="core::arch::x86::_MM_PERM_CBAD constant">_MM_PERM_CBAD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CBBA.html" title="core::arch::x86::_MM_PERM_CBBA constant">_MM_PERM_CBBA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CBBB.html" title="core::arch::x86::_MM_PERM_CBBB constant">_MM_PERM_CBBB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CBBC.html" title="core::arch::x86::_MM_PERM_CBBC constant">_MM_PERM_CBBC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CBBD.html" title="core::arch::x86::_MM_PERM_CBBD constant">_MM_PERM_CBBD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CBCA.html" title="core::arch::x86::_MM_PERM_CBCA constant">_MM_PERM_CBCA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CBCB.html" title="core::arch::x86::_MM_PERM_CBCB constant">_MM_PERM_CBCB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CBCC.html" title="core::arch::x86::_MM_PERM_CBCC constant">_MM_PERM_CBCC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CBCD.html" title="core::arch::x86::_MM_PERM_CBCD constant">_MM_PERM_CBCD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CBDA.html" title="core::arch::x86::_MM_PERM_CBDA constant">_MM_PERM_CBDA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CBDB.html" title="core::arch::x86::_MM_PERM_CBDB constant">_MM_PERM_CBDB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CBDC.html" title="core::arch::x86::_MM_PERM_CBDC constant">_MM_PERM_CBDC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CBDD.html" title="core::arch::x86::_MM_PERM_CBDD constant">_MM_PERM_CBDD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CCAA.html" title="core::arch::x86::_MM_PERM_CCAA constant">_MM_PERM_CCAA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CCAB.html" title="core::arch::x86::_MM_PERM_CCAB constant">_MM_PERM_CCAB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CCAC.html" title="core::arch::x86::_MM_PERM_CCAC constant">_MM_PERM_CCAC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CCAD.html" title="core::arch::x86::_MM_PERM_CCAD constant">_MM_PERM_CCAD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CCBA.html" title="core::arch::x86::_MM_PERM_CCBA constant">_MM_PERM_CCBA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CCBB.html" title="core::arch::x86::_MM_PERM_CCBB constant">_MM_PERM_CCBB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CCBC.html" title="core::arch::x86::_MM_PERM_CCBC constant">_MM_PERM_CCBC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CCBD.html" title="core::arch::x86::_MM_PERM_CCBD constant">_MM_PERM_CCBD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CCCA.html" title="core::arch::x86::_MM_PERM_CCCA constant">_MM_PERM_CCCA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CCCB.html" title="core::arch::x86::_MM_PERM_CCCB constant">_MM_PERM_CCCB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CCCC.html" title="core::arch::x86::_MM_PERM_CCCC constant">_MM_PERM_CCCC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CCCD.html" title="core::arch::x86::_MM_PERM_CCCD constant">_MM_PERM_CCCD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CCDA.html" title="core::arch::x86::_MM_PERM_CCDA constant">_MM_PERM_CCDA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CCDB.html" title="core::arch::x86::_MM_PERM_CCDB constant">_MM_PERM_CCDB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CCDC.html" title="core::arch::x86::_MM_PERM_CCDC constant">_MM_PERM_CCDC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CCDD.html" title="core::arch::x86::_MM_PERM_CCDD constant">_MM_PERM_CCDD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CDAA.html" title="core::arch::x86::_MM_PERM_CDAA constant">_MM_PERM_CDAA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CDAB.html" title="core::arch::x86::_MM_PERM_CDAB constant">_MM_PERM_CDAB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CDAC.html" title="core::arch::x86::_MM_PERM_CDAC constant">_MM_PERM_CDAC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CDAD.html" title="core::arch::x86::_MM_PERM_CDAD constant">_MM_PERM_CDAD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CDBA.html" title="core::arch::x86::_MM_PERM_CDBA constant">_MM_PERM_CDBA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CDBB.html" title="core::arch::x86::_MM_PERM_CDBB constant">_MM_PERM_CDBB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CDBC.html" title="core::arch::x86::_MM_PERM_CDBC constant">_MM_PERM_CDBC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CDBD.html" title="core::arch::x86::_MM_PERM_CDBD constant">_MM_PERM_CDBD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CDCA.html" title="core::arch::x86::_MM_PERM_CDCA constant">_MM_PERM_CDCA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CDCB.html" title="core::arch::x86::_MM_PERM_CDCB constant">_MM_PERM_CDCB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CDCC.html" title="core::arch::x86::_MM_PERM_CDCC constant">_MM_PERM_CDCC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CDCD.html" title="core::arch::x86::_MM_PERM_CDCD constant">_MM_PERM_CDCD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CDDA.html" title="core::arch::x86::_MM_PERM_CDDA constant">_MM_PERM_CDDA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CDDB.html" title="core::arch::x86::_MM_PERM_CDDB constant">_MM_PERM_CDDB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CDDC.html" title="core::arch::x86::_MM_PERM_CDDC constant">_MM_PERM_CDDC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_CDDD.html" title="core::arch::x86::_MM_PERM_CDDD constant">_MM_PERM_CDDD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DAAA.html" title="core::arch::x86::_MM_PERM_DAAA constant">_MM_PERM_DAAA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DAAB.html" title="core::arch::x86::_MM_PERM_DAAB constant">_MM_PERM_DAAB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DAAC.html" title="core::arch::x86::_MM_PERM_DAAC constant">_MM_PERM_DAAC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DAAD.html" title="core::arch::x86::_MM_PERM_DAAD constant">_MM_PERM_DAAD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DABA.html" title="core::arch::x86::_MM_PERM_DABA constant">_MM_PERM_DABA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DABB.html" title="core::arch::x86::_MM_PERM_DABB constant">_MM_PERM_DABB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DABC.html" title="core::arch::x86::_MM_PERM_DABC constant">_MM_PERM_DABC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DABD.html" title="core::arch::x86::_MM_PERM_DABD constant">_MM_PERM_DABD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DACA.html" title="core::arch::x86::_MM_PERM_DACA constant">_MM_PERM_DACA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DACB.html" title="core::arch::x86::_MM_PERM_DACB constant">_MM_PERM_DACB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DACC.html" title="core::arch::x86::_MM_PERM_DACC constant">_MM_PERM_DACC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DACD.html" title="core::arch::x86::_MM_PERM_DACD constant">_MM_PERM_DACD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DADA.html" title="core::arch::x86::_MM_PERM_DADA constant">_MM_PERM_DADA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DADB.html" title="core::arch::x86::_MM_PERM_DADB constant">_MM_PERM_DADB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DADC.html" title="core::arch::x86::_MM_PERM_DADC constant">_MM_PERM_DADC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DADD.html" title="core::arch::x86::_MM_PERM_DADD constant">_MM_PERM_DADD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DBAA.html" title="core::arch::x86::_MM_PERM_DBAA constant">_MM_PERM_DBAA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DBAB.html" title="core::arch::x86::_MM_PERM_DBAB constant">_MM_PERM_DBAB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DBAC.html" title="core::arch::x86::_MM_PERM_DBAC constant">_MM_PERM_DBAC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DBAD.html" title="core::arch::x86::_MM_PERM_DBAD constant">_MM_PERM_DBAD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DBBA.html" title="core::arch::x86::_MM_PERM_DBBA constant">_MM_PERM_DBBA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DBBB.html" title="core::arch::x86::_MM_PERM_DBBB constant">_MM_PERM_DBBB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DBBC.html" title="core::arch::x86::_MM_PERM_DBBC constant">_MM_PERM_DBBC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DBBD.html" title="core::arch::x86::_MM_PERM_DBBD constant">_MM_PERM_DBBD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DBCA.html" title="core::arch::x86::_MM_PERM_DBCA constant">_MM_PERM_DBCA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DBCB.html" title="core::arch::x86::_MM_PERM_DBCB constant">_MM_PERM_DBCB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DBCC.html" title="core::arch::x86::_MM_PERM_DBCC constant">_MM_PERM_DBCC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DBCD.html" title="core::arch::x86::_MM_PERM_DBCD constant">_MM_PERM_DBCD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DBDA.html" title="core::arch::x86::_MM_PERM_DBDA constant">_MM_PERM_DBDA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DBDB.html" title="core::arch::x86::_MM_PERM_DBDB constant">_MM_PERM_DBDB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DBDC.html" title="core::arch::x86::_MM_PERM_DBDC constant">_MM_PERM_DBDC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DBDD.html" title="core::arch::x86::_MM_PERM_DBDD constant">_MM_PERM_DBDD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DCAA.html" title="core::arch::x86::_MM_PERM_DCAA constant">_MM_PERM_DCAA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DCAB.html" title="core::arch::x86::_MM_PERM_DCAB constant">_MM_PERM_DCAB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DCAC.html" title="core::arch::x86::_MM_PERM_DCAC constant">_MM_PERM_DCAC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DCAD.html" title="core::arch::x86::_MM_PERM_DCAD constant">_MM_PERM_DCAD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DCBA.html" title="core::arch::x86::_MM_PERM_DCBA constant">_MM_PERM_DCBA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DCBB.html" title="core::arch::x86::_MM_PERM_DCBB constant">_MM_PERM_DCBB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DCBC.html" title="core::arch::x86::_MM_PERM_DCBC constant">_MM_PERM_DCBC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DCBD.html" title="core::arch::x86::_MM_PERM_DCBD constant">_MM_PERM_DCBD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DCCA.html" title="core::arch::x86::_MM_PERM_DCCA constant">_MM_PERM_DCCA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DCCB.html" title="core::arch::x86::_MM_PERM_DCCB constant">_MM_PERM_DCCB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DCCC.html" title="core::arch::x86::_MM_PERM_DCCC constant">_MM_PERM_DCCC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DCCD.html" title="core::arch::x86::_MM_PERM_DCCD constant">_MM_PERM_DCCD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DCDA.html" title="core::arch::x86::_MM_PERM_DCDA constant">_MM_PERM_DCDA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DCDB.html" title="core::arch::x86::_MM_PERM_DCDB constant">_MM_PERM_DCDB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DCDC.html" title="core::arch::x86::_MM_PERM_DCDC constant">_MM_PERM_DCDC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DCDD.html" title="core::arch::x86::_MM_PERM_DCDD constant">_MM_PERM_DCDD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DDAA.html" title="core::arch::x86::_MM_PERM_DDAA constant">_MM_PERM_DDAA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DDAB.html" title="core::arch::x86::_MM_PERM_DDAB constant">_MM_PERM_DDAB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DDAC.html" title="core::arch::x86::_MM_PERM_DDAC constant">_MM_PERM_DDAC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DDAD.html" title="core::arch::x86::_MM_PERM_DDAD constant">_MM_PERM_DDAD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DDBA.html" title="core::arch::x86::_MM_PERM_DDBA constant">_MM_PERM_DDBA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DDBB.html" title="core::arch::x86::_MM_PERM_DDBB constant">_MM_PERM_DDBB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DDBC.html" title="core::arch::x86::_MM_PERM_DDBC constant">_MM_PERM_DDBC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DDBD.html" title="core::arch::x86::_MM_PERM_DDBD constant">_MM_PERM_DDBD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DDCA.html" title="core::arch::x86::_MM_PERM_DDCA constant">_MM_PERM_DDCA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DDCB.html" title="core::arch::x86::_MM_PERM_DDCB constant">_MM_PERM_DDCB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DDCC.html" title="core::arch::x86::_MM_PERM_DDCC constant">_MM_PERM_DDCC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DDCD.html" title="core::arch::x86::_MM_PERM_DDCD constant">_MM_PERM_DDCD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DDDA.html" title="core::arch::x86::_MM_PERM_DDDA constant">_MM_PERM_DDDA</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DDDB.html" title="core::arch::x86::_MM_PERM_DDDB constant">_MM_PERM_DDDB</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DDDC.html" title="core::arch::x86::_MM_PERM_DDDC constant">_MM_PERM_DDDC</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._MM_PERM_DDDD.html" title="core::arch::x86::_MM_PERM_DDDD constant">_MM_PERM_DDDD</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span></td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._XABORT_CAPACITY.html" title="core::arch::x86::_XABORT_CAPACITY constant">_XABORT_CAPACITY</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>事务终止，因为事务使用了过多的内存。</p>
</td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._XABORT_CONFLICT.html" title="core::arch::x86::_XABORT_CONFLICT constant">_XABORT_CONFLICT</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>由于与另一个线程发生内存冲突而导致事务终止。</p>
</td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._XABORT_DEBUG.html" title="core::arch::x86::_XABORT_DEBUG constant">_XABORT_DEBUG</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>事务由于调试陷阱而终止。</p>
</td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._XABORT_EXPLICIT.html" title="core::arch::x86::_XABORT_EXPLICIT constant">_XABORT_EXPLICIT</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>使用 xabort 显式中止了事务。
传递给 xabort 的参数可用于 <code>_xabort_code(status)</code>。</p>
</td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._XABORT_NESTED.html" title="core::arch::x86::_XABORT_NESTED constant">_XABORT_NESTED</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>内部嵌套事务中的事务终止。</p>
</td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._XABORT_RETRY.html" title="core::arch::x86::_XABORT_RETRY constant">_XABORT_RETRY</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>事务重试是可能的。</p>
</td></tr><tr class="unstable module-item"><td><a class="constant" href="constant._XBEGIN_STARTED.html" title="core::arch::x86::_XBEGIN_STARTED constant">_XBEGIN_STARTED</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>事务成功开始。</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_EQ_OQ.html" title="core::arch::x86::_CMP_EQ_OQ constant">_CMP_EQ_OQ</a></td><td class="docblock-short"><p>相等 (有序，无信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_EQ_OS.html" title="core::arch::x86::_CMP_EQ_OS constant">_CMP_EQ_OS</a></td><td class="docblock-short"><p>相等 (有序，发信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_EQ_UQ.html" title="core::arch::x86::_CMP_EQ_UQ constant">_CMP_EQ_UQ</a></td><td class="docblock-short"><p>相等 (无序，无信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_EQ_US.html" title="core::arch::x86::_CMP_EQ_US constant">_CMP_EQ_US</a></td><td class="docblock-short"><p>相等 (无序，发信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_FALSE_OQ.html" title="core::arch::x86::_CMP_FALSE_OQ constant">_CMP_FALSE_OQ</a></td><td class="docblock-short"><p>错误 (有序，无信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_FALSE_OS.html" title="core::arch::x86::_CMP_FALSE_OS constant">_CMP_FALSE_OS</a></td><td class="docblock-short"><p>错误 (有序，发信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_GE_OQ.html" title="core::arch::x86::_CMP_GE_OQ constant">_CMP_GE_OQ</a></td><td class="docblock-short"><p>大于或等于 (有序，无信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_GE_OS.html" title="core::arch::x86::_CMP_GE_OS constant">_CMP_GE_OS</a></td><td class="docblock-short"><p>大于或等于 (有序，发信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_GT_OQ.html" title="core::arch::x86::_CMP_GT_OQ constant">_CMP_GT_OQ</a></td><td class="docblock-short"><p>大于 (有序，无信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_GT_OS.html" title="core::arch::x86::_CMP_GT_OS constant">_CMP_GT_OS</a></td><td class="docblock-short"><p>大于 (有序，发信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_LE_OQ.html" title="core::arch::x86::_CMP_LE_OQ constant">_CMP_LE_OQ</a></td><td class="docblock-short"><p>小于或等于 (有序，无信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_LE_OS.html" title="core::arch::x86::_CMP_LE_OS constant">_CMP_LE_OS</a></td><td class="docblock-short"><p>小于或等于 (有序，发信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_LT_OQ.html" title="core::arch::x86::_CMP_LT_OQ constant">_CMP_LT_OQ</a></td><td class="docblock-short"><p>小于 (有序，无信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_LT_OS.html" title="core::arch::x86::_CMP_LT_OS constant">_CMP_LT_OS</a></td><td class="docblock-short"><p>小于 (有序，发信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_NEQ_OQ.html" title="core::arch::x86::_CMP_NEQ_OQ constant">_CMP_NEQ_OQ</a></td><td class="docblock-short"><p>不相等 (有序，无信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_NEQ_OS.html" title="core::arch::x86::_CMP_NEQ_OS constant">_CMP_NEQ_OS</a></td><td class="docblock-short"><p>不相等 (有序，发信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_NEQ_UQ.html" title="core::arch::x86::_CMP_NEQ_UQ constant">_CMP_NEQ_UQ</a></td><td class="docblock-short"><p>不相等 (无序，无信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_NEQ_US.html" title="core::arch::x86::_CMP_NEQ_US constant">_CMP_NEQ_US</a></td><td class="docblock-short"><p>不相等 (无序，发信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_NGE_UQ.html" title="core::arch::x86::_CMP_NGE_UQ constant">_CMP_NGE_UQ</a></td><td class="docblock-short"><p>不大于等于 (无序，无信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_NGE_US.html" title="core::arch::x86::_CMP_NGE_US constant">_CMP_NGE_US</a></td><td class="docblock-short"><p>不大于等于 (无序，发信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_NGT_UQ.html" title="core::arch::x86::_CMP_NGT_UQ constant">_CMP_NGT_UQ</a></td><td class="docblock-short"><p>不大于 (无序，无信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_NGT_US.html" title="core::arch::x86::_CMP_NGT_US constant">_CMP_NGT_US</a></td><td class="docblock-short"><p>不大于 (无序，发信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_NLE_UQ.html" title="core::arch::x86::_CMP_NLE_UQ constant">_CMP_NLE_UQ</a></td><td class="docblock-short"><p>不小于等于 (无序，无信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_NLE_US.html" title="core::arch::x86::_CMP_NLE_US constant">_CMP_NLE_US</a></td><td class="docblock-short"><p>不小于等于 (无序，发信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_NLT_UQ.html" title="core::arch::x86::_CMP_NLT_UQ constant">_CMP_NLT_UQ</a></td><td class="docblock-short"><p>不少于 (无序，无信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_NLT_US.html" title="core::arch::x86::_CMP_NLT_US constant">_CMP_NLT_US</a></td><td class="docblock-short"><p>不少于 (无序，发信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_ORD_Q.html" title="core::arch::x86::_CMP_ORD_Q constant">_CMP_ORD_Q</a></td><td class="docblock-short"><p>订购 (无信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_ORD_S.html" title="core::arch::x86::_CMP_ORD_S constant">_CMP_ORD_S</a></td><td class="docblock-short"><p>订购 (发信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_TRUE_UQ.html" title="core::arch::x86::_CMP_TRUE_UQ constant">_CMP_TRUE_UQ</a></td><td class="docblock-short"><p>真 (无序，无信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_TRUE_US.html" title="core::arch::x86::_CMP_TRUE_US constant">_CMP_TRUE_US</a></td><td class="docblock-short"><p>真 (无序，发信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_UNORD_Q.html" title="core::arch::x86::_CMP_UNORD_Q constant">_CMP_UNORD_Q</a></td><td class="docblock-short"><p>无序 (无信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._CMP_UNORD_S.html" title="core::arch::x86::_CMP_UNORD_S constant">_CMP_UNORD_S</a></td><td class="docblock-short"><p>无序 (发信号)</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_EXCEPT_DENORM.html" title="core::arch::x86::_MM_EXCEPT_DENORM constant">_MM_EXCEPT_DENORM</a></td><td class="docblock-short"><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_EXCEPT_DIV_ZERO.html" title="core::arch::x86::_MM_EXCEPT_DIV_ZERO constant">_MM_EXCEPT_DIV_ZERO</a></td><td class="docblock-short"><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_EXCEPT_INEXACT.html" title="core::arch::x86::_MM_EXCEPT_INEXACT constant">_MM_EXCEPT_INEXACT</a></td><td class="docblock-short"><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_EXCEPT_INVALID.html" title="core::arch::x86::_MM_EXCEPT_INVALID constant">_MM_EXCEPT_INVALID</a></td><td class="docblock-short"><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_EXCEPT_MASK.html" title="core::arch::x86::_MM_EXCEPT_MASK constant">_MM_EXCEPT_MASK</a></td><td class="docblock-short"><p>请参见 <a href="fn._MM_GET_EXCEPTION_STATE.html"><code>_MM_GET_EXCEPTION_STATE</code></a></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_EXCEPT_OVERFLOW.html" title="core::arch::x86::_MM_EXCEPT_OVERFLOW constant">_MM_EXCEPT_OVERFLOW</a></td><td class="docblock-short"><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_EXCEPT_UNDERFLOW.html" title="core::arch::x86::_MM_EXCEPT_UNDERFLOW constant">_MM_EXCEPT_UNDERFLOW</a></td><td class="docblock-short"><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_FLUSH_ZERO_MASK.html" title="core::arch::x86::_MM_FLUSH_ZERO_MASK constant">_MM_FLUSH_ZERO_MASK</a></td><td class="docblock-short"><p>请参见 <a href="fn._MM_GET_FLUSH_ZERO_MODE.html"><code>_MM_GET_FLUSH_ZERO_MODE</code></a></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_FLUSH_ZERO_OFF.html" title="core::arch::x86::_MM_FLUSH_ZERO_OFF constant">_MM_FLUSH_ZERO_OFF</a></td><td class="docblock-short"><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_FLUSH_ZERO_ON.html" title="core::arch::x86::_MM_FLUSH_ZERO_ON constant">_MM_FLUSH_ZERO_ON</a></td><td class="docblock-short"><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_FROUND_CEIL.html" title="core::arch::x86::_MM_FROUND_CEIL constant">_MM_FROUND_CEIL</a></td><td class="docblock-short"><p>四舍五入，不抑制异常</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_FROUND_CUR_DIRECTION.html" title="core::arch::x86::_MM_FROUND_CUR_DIRECTION constant">_MM_FROUND_CUR_DIRECTION</a></td><td class="docblock-short"><p>使用 MXCSR.RC; 见 <code>vendor::_MM_SET_ROUNDING_MODE</code></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_FROUND_FLOOR.html" title="core::arch::x86::_MM_FROUND_FLOOR constant">_MM_FROUND_FLOOR</a></td><td class="docblock-short"><p>四舍五入，不抑制异常</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_FROUND_NEARBYINT.html" title="core::arch::x86::_MM_FROUND_NEARBYINT constant">_MM_FROUND_NEARBYINT</a></td><td class="docblock-short"><p>使用 MXCSR.RC 并抑制异常; 见 <code>vendor::_MM_SET_ROUNDING_MODE</code></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_FROUND_NINT.html" title="core::arch::x86::_MM_FROUND_NINT constant">_MM_FROUND_NINT</a></td><td class="docblock-short"><p>四舍五入到最接近，不排除异常</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_FROUND_NO_EXC.html" title="core::arch::x86::_MM_FROUND_NO_EXC constant">_MM_FROUND_NO_EXC</a></td><td class="docblock-short"><p>抑制异常</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_FROUND_RAISE_EXC.html" title="core::arch::x86::_MM_FROUND_RAISE_EXC constant">_MM_FROUND_RAISE_EXC</a></td><td class="docblock-short"><p>不要抑制异常</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_FROUND_RINT.html" title="core::arch::x86::_MM_FROUND_RINT constant">_MM_FROUND_RINT</a></td><td class="docblock-short"><p>使用 MXCSR.RC 且不抑制异常; see
<code>vendor::_MM_SET_ROUNDING_MODE</code></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_FROUND_TO_NEAREST_INT.html" title="core::arch::x86::_MM_FROUND_TO_NEAREST_INT constant">_MM_FROUND_TO_NEAREST_INT</a></td><td class="docblock-short"><p>四舍五入到最接近的</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_FROUND_TO_NEG_INF.html" title="core::arch::x86::_MM_FROUND_TO_NEG_INF constant">_MM_FROUND_TO_NEG_INF</a></td><td class="docblock-short"><p>四舍五入</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_FROUND_TO_POS_INF.html" title="core::arch::x86::_MM_FROUND_TO_POS_INF constant">_MM_FROUND_TO_POS_INF</a></td><td class="docblock-short"><p>围捕</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_FROUND_TO_ZERO.html" title="core::arch::x86::_MM_FROUND_TO_ZERO constant">_MM_FROUND_TO_ZERO</a></td><td class="docblock-short"><p>truncate</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_FROUND_TRUNC.html" title="core::arch::x86::_MM_FROUND_TRUNC constant">_MM_FROUND_TRUNC</a></td><td class="docblock-short"><p>截断并且不抑制异常</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_HINT_ET0.html" title="core::arch::x86::_MM_HINT_ET0 constant">_MM_HINT_ET0</a></td><td class="docblock-short"><p>请参见 <a href="fn._mm_prefetch.html"><code>_mm_prefetch</code></a>。</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_HINT_ET1.html" title="core::arch::x86::_MM_HINT_ET1 constant">_MM_HINT_ET1</a></td><td class="docblock-short"><p>请参见 <a href="fn._mm_prefetch.html"><code>_mm_prefetch</code></a>。</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_HINT_NTA.html" title="core::arch::x86::_MM_HINT_NTA constant">_MM_HINT_NTA</a></td><td class="docblock-short"><p>请参见 <a href="fn._mm_prefetch.html"><code>_mm_prefetch</code></a>。</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_HINT_T0.html" title="core::arch::x86::_MM_HINT_T0 constant">_MM_HINT_T0</a></td><td class="docblock-short"><p>请参见 <a href="fn._mm_prefetch.html"><code>_mm_prefetch</code></a>。</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_HINT_T1.html" title="core::arch::x86::_MM_HINT_T1 constant">_MM_HINT_T1</a></td><td class="docblock-short"><p>请参见 <a href="fn._mm_prefetch.html"><code>_mm_prefetch</code></a>。</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_HINT_T2.html" title="core::arch::x86::_MM_HINT_T2 constant">_MM_HINT_T2</a></td><td class="docblock-short"><p>请参见 <a href="fn._mm_prefetch.html"><code>_mm_prefetch</code></a>。</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_MASK_DENORM.html" title="core::arch::x86::_MM_MASK_DENORM constant">_MM_MASK_DENORM</a></td><td class="docblock-short"><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_MASK_DIV_ZERO.html" title="core::arch::x86::_MM_MASK_DIV_ZERO constant">_MM_MASK_DIV_ZERO</a></td><td class="docblock-short"><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_MASK_INEXACT.html" title="core::arch::x86::_MM_MASK_INEXACT constant">_MM_MASK_INEXACT</a></td><td class="docblock-short"><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_MASK_INVALID.html" title="core::arch::x86::_MM_MASK_INVALID constant">_MM_MASK_INVALID</a></td><td class="docblock-short"><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_MASK_MASK.html" title="core::arch::x86::_MM_MASK_MASK constant">_MM_MASK_MASK</a></td><td class="docblock-short"><p>请参见 <a href="fn._MM_GET_EXCEPTION_MASK.html"><code>_MM_GET_EXCEPTION_MASK</code></a></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_MASK_OVERFLOW.html" title="core::arch::x86::_MM_MASK_OVERFLOW constant">_MM_MASK_OVERFLOW</a></td><td class="docblock-short"><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_MASK_UNDERFLOW.html" title="core::arch::x86::_MM_MASK_UNDERFLOW constant">_MM_MASK_UNDERFLOW</a></td><td class="docblock-short"><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_ROUND_DOWN.html" title="core::arch::x86::_MM_ROUND_DOWN constant">_MM_ROUND_DOWN</a></td><td class="docblock-short"><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_ROUND_MASK.html" title="core::arch::x86::_MM_ROUND_MASK constant">_MM_ROUND_MASK</a></td><td class="docblock-short"><p>请参见 <a href="fn._MM_GET_ROUNDING_MODE.html"><code>_MM_GET_ROUNDING_MODE</code></a></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_ROUND_NEAREST.html" title="core::arch::x86::_MM_ROUND_NEAREST constant">_MM_ROUND_NEAREST</a></td><td class="docblock-short"><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_ROUND_TOWARD_ZERO.html" title="core::arch::x86::_MM_ROUND_TOWARD_ZERO constant">_MM_ROUND_TOWARD_ZERO</a></td><td class="docblock-short"><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._MM_ROUND_UP.html" title="core::arch::x86::_MM_ROUND_UP constant">_MM_ROUND_UP</a></td><td class="docblock-short"><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._SIDD_BIT_MASK.html" title="core::arch::x86::_SIDD_BIT_MASK constant">_SIDD_BIT_MASK</a></td><td class="docblock-short"><p><strong>仅掩码</strong>: 返回位掩码</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._SIDD_CMP_EQUAL_ANY.html" title="core::arch::x86::_SIDD_CMP_EQUAL_ANY constant">_SIDD_CMP_EQUAL_ANY</a></td><td class="docblock-short"><p>对于 <code>a</code> 中的每个字符，查找它是否在 <code>b</code> 中 <em>(默认)</em></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._SIDD_CMP_EQUAL_EACH.html" title="core::arch::x86::_SIDD_CMP_EQUAL_EACH constant">_SIDD_CMP_EQUAL_EACH</a></td><td class="docblock-short"><p><code>a</code> 和 <code>b</code> 定义的字符串相等</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._SIDD_CMP_EQUAL_ORDERED.html" title="core::arch::x86::_SIDD_CMP_EQUAL_ORDERED constant">_SIDD_CMP_EQUAL_ORDERED</a></td><td class="docblock-short"><p>在目标中搜索定义的子字符串</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._SIDD_CMP_RANGES.html" title="core::arch::x86::_SIDD_CMP_RANGES constant">_SIDD_CMP_RANGES</a></td><td class="docblock-short"><p>对于 <code>a</code> 中的每个字符，确定是否
<code>b[0] &lt;= c &lt;= b[1] or b[1] &lt;= c &lt;= b[2]...</code></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._SIDD_LEAST_SIGNIFICANT.html" title="core::arch::x86::_SIDD_LEAST_SIGNIFICANT constant">_SIDD_LEAST_SIGNIFICANT</a></td><td class="docblock-short"><p><strong>仅索引</strong>: 返回最低有效位 <em>(默认)</em></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._SIDD_MASKED_NEGATIVE_POLARITY.html" title="core::arch::x86::_SIDD_MASKED_NEGATIVE_POLARITY constant">_SIDD_MASKED_NEGATIVE_POLARITY</a></td><td class="docblock-short"><p>仅在字符串结尾之前取反结果</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._SIDD_MASKED_POSITIVE_POLARITY.html" title="core::arch::x86::_SIDD_MASKED_POSITIVE_POLARITY constant">_SIDD_MASKED_POSITIVE_POLARITY</a></td><td class="docblock-short"><p>不要在字符串结尾之前取反结果</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._SIDD_MOST_SIGNIFICANT.html" title="core::arch::x86::_SIDD_MOST_SIGNIFICANT constant">_SIDD_MOST_SIGNIFICANT</a></td><td class="docblock-short"><p><strong>仅索引</strong>: 返回最高有效位</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._SIDD_NEGATIVE_POLARITY.html" title="core::arch::x86::_SIDD_NEGATIVE_POLARITY constant">_SIDD_NEGATIVE_POLARITY</a></td><td class="docblock-short"><p>取反结果</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._SIDD_POSITIVE_POLARITY.html" title="core::arch::x86::_SIDD_POSITIVE_POLARITY constant">_SIDD_POSITIVE_POLARITY</a></td><td class="docblock-short"><p>不取消结果 <em>(默认)</em></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._SIDD_SBYTE_OPS.html" title="core::arch::x86::_SIDD_SBYTE_OPS constant">_SIDD_SBYTE_OPS</a></td><td class="docblock-short"><p>字符串包含带符号的 8 位字符</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._SIDD_SWORD_OPS.html" title="core::arch::x86::_SIDD_SWORD_OPS constant">_SIDD_SWORD_OPS</a></td><td class="docblock-short"><p>字符串包含无符号的 16 位字符</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._SIDD_UBYTE_OPS.html" title="core::arch::x86::_SIDD_UBYTE_OPS constant">_SIDD_UBYTE_OPS</a></td><td class="docblock-short"><p>字符串包含无符号的 8 位字符 <em>(默认)</em></p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._SIDD_UNIT_MASK.html" title="core::arch::x86::_SIDD_UNIT_MASK constant">_SIDD_UNIT_MASK</a></td><td class="docblock-short"><p><strong>仅掩码</strong>: 返回字节掩码</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._SIDD_UWORD_OPS.html" title="core::arch::x86::_SIDD_UWORD_OPS constant">_SIDD_UWORD_OPS</a></td><td class="docblock-short"><p>字符串包含无符号的 16 位字符</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant._XCR_XFEATURE_ENABLED_MASK.html" title="core::arch::x86::_XCR_XFEATURE_ENABLED_MASK constant">_XCR_XFEATURE_ENABLED_MASK</a></td><td class="docblock-short"><p><code>XFEATURE_ENABLED_MASK</code> 对于 <code>XCR</code></p>
</td></tr></table><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<table><tr class="unstable module-item"><td><a class="fn" href="fn._MM_SHUFFLE.html" title="core::arch::x86::_MM_SHUFFLE fn">_MM_SHUFFLE</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>一个实用程序函数，用于创建与 Intel 重排和置换内联函数一起使用的掩码。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._kadd_mask32.html" title="core::arch::x86::_kadd_mask32 fn">_kadd_mask32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>在 a 和 b 中添加 32 位掩码，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._kadd_mask64.html" title="core::arch::x86::_kadd_mask64 fn">_kadd_mask64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>在 a 和 b 中添加 64 位掩码，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._kand_mask16.html" title="core::arch::x86::_kand_mask16 fn">_kand_mask16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 16 位掩码 a 和 b 的按位与，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._kand_mask32.html" title="core::arch::x86::_kand_mask32 fn">_kand_mask32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 32 位掩码 a 和 b 的按位与，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._kand_mask64.html" title="core::arch::x86::_kand_mask64 fn">_kand_mask64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 64 位掩码 a 和 b 的按位与，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._kandn_mask16.html" title="core::arch::x86::_kandn_mask16 fn">_kandn_mask16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 16 位掩码 a 的按位非，然后与 b 计算 AND，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._kandn_mask32.html" title="core::arch::x86::_kandn_mask32 fn">_kandn_mask32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 32 位掩码 a 的按位非，然后与 b 计算 AND，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._kandn_mask64.html" title="core::arch::x86::_kandn_mask64 fn">_kandn_mask64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 64 位掩码 a 的按位非，然后与 b 进行与运算，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._knot_mask16.html" title="core::arch::x86::_knot_mask16 fn">_knot_mask16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 16 位掩码 a 的按位非，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._knot_mask32.html" title="core::arch::x86::_knot_mask32 fn">_knot_mask32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 32 位掩码 a 的按位非，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._knot_mask64.html" title="core::arch::x86::_knot_mask64 fn">_knot_mask64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 64 位掩码 a 的按位非，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._kor_mask16.html" title="core::arch::x86::_kor_mask16 fn">_kor_mask16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 16 位掩码 a 和 b 的按位或，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._kor_mask32.html" title="core::arch::x86::_kor_mask32 fn">_kor_mask32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 32 位掩码 a 和 b 的按位或，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._kor_mask64.html" title="core::arch::x86::_kor_mask64 fn">_kor_mask64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 64 位掩码 a 和 b 的按位或，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._kxnor_mask16.html" title="core::arch::x86::_kxnor_mask16 fn">_kxnor_mask16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 16 位掩码 a 和 b 的按位 XNOR，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._kxnor_mask32.html" title="core::arch::x86::_kxnor_mask32 fn">_kxnor_mask32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 32 位掩码 a 和 b 的按位 XNOR，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._kxnor_mask64.html" title="core::arch::x86::_kxnor_mask64 fn">_kxnor_mask64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 64 位掩码 a 和 b 的按位 XNOR，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._kxor_mask16.html" title="core::arch::x86::_kxor_mask16 fn">_kxor_mask16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 16 位掩码 a 和 b 的按位 XOR，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._kxor_mask32.html" title="core::arch::x86::_kxor_mask32 fn">_kxor_mask32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 32 位掩码 a 和 b 的按位 XOR，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._kxor_mask64.html" title="core::arch::x86::_kxor_mask64 fn">_kxor_mask64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 64 位掩码 a 和 b 的按位 XOR，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._load_mask32.html" title="core::arch::x86::_load_mask32 fn">_load_mask32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将内存中的 32 位掩码加载到 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._load_mask64.html" title="core::arch::x86::_load_mask64 fn">_load_mask64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将内存中的 64 位掩码加载到 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_abs_epi64.html" title="core::arch::x86::_mm256_abs_epi64 fn">_mm256_abs_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的带符号的 64 位整数的绝对值，并将无符号的结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_aesdec_epi128.html" title="core::arch::x86::_mm256_aesdec_epi128 fn">_mm256_aesdec_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vaes,avx512vl` only"><code>avx512vaes,avx512vl</code></span><p>使用 <code>round_key</code> 中的相应 128 位字 (key) 对 <code>a</code> 中的每个 128 位字 (state) 执行一轮 AES 解密流程。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_aesdeclast_epi128.html" title="core::arch::x86::_mm256_aesdeclast_epi128 fn">_mm256_aesdeclast_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vaes,avx512vl` only"><code>avx512vaes,avx512vl</code></span><p>使用 <code>round_key</code> 中的相应 128 位字 (key) 对 <code>a</code> 中的每个 128 位字 (state) 执行最后一轮 AES 解密流程。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_aesenc_epi128.html" title="core::arch::x86::_mm256_aesenc_epi128 fn">_mm256_aesenc_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vaes,avx512vl` only"><code>avx512vaes,avx512vl</code></span><p>使用 <code>round_key</code> 中的相应 128 位字 (key) 对 <code>a</code> 中的每个 128 位字 (state) 执行一轮 AES 加密流程。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_aesenclast_epi128.html" title="core::arch::x86::_mm256_aesenclast_epi128 fn">_mm256_aesenclast_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vaes,avx512vl` only"><code>avx512vaes,avx512vl</code></span><p>使用 <code>round_key</code> 中的相应 128 位字 (key) 对 <code>a</code> 中的每个 128 位字 (state) 执行最后一轮 AES 加密流程。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_alignr_epi32.html" title="core::arch::x86::_mm256_alignr_epi32 fn">_mm256_alignr_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 连接成一个 64 字节的 immediate 结果，将结果右移 imm8 个 32 位元素，并将低 32 字节 (8 个元素) 存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_alignr_epi64.html" title="core::arch::x86::_mm256_alignr_epi64 fn">_mm256_alignr_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 连接成 64 字节的 immediate 结果，将结果右移 imm8 个 64 位元素，并将低 32 字节 (4 个元素) 存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_bitshuffle_epi64_mask.html" title="core::arch::x86::_mm256_bitshuffle_epi64_mask fn">_mm256_bitshuffle_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span><p>将输入 <code>b</code> 视为包装的 64 位整数，并将 <code>c</code> 视为包装的 8 位整数。
然后将来自 <code>c</code> 的 8 个 8 位值作为索引分组到相应的 64 位整数的位中。
然后，选择这些位并将其包装到输出中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_broadcast_f32x4.html" title="core::arch::x86::_mm256_broadcast_f32x4 fn">_mm256_broadcast_f32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 广播 4 个包装的单精度 (32-bit) 浮点元素到 dst 的所有元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_broadcast_i32x4.html" title="core::arch::x86::_mm256_broadcast_i32x4 fn">_mm256_broadcast_i32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 4 个包装的 32 位整数从 a 广播到 dst 的所有元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_broadcastmb_epi64.html" title="core::arch::x86::_mm256_broadcastmb_epi64 fn">_mm256_broadcastmb_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>将输入掩码 k 的低 8 位广播到 dst 的所有 64 位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_broadcastmw_epi32.html" title="core::arch::x86::_mm256_broadcastmw_epi32 fn">_mm256_broadcastmw_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>将输入掩码 k 的低 16 位广播到 dst 的所有 32 位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_clmulepi64_epi128.html" title="core::arch::x86::_mm256_clmulepi64_epi128 fn">_mm256_clmulepi64_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpclmulqdq,avx512vl` only"><code>avx512vpclmulqdq,avx512vl</code></span><p>在 2 个 128 位通道中的每个通道中，在有限域 GF(2^k) 上执行两个 64 位多项式的无进位乘法。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmp_epi8_mask.html" title="core::arch::x86::_mm256_cmp_epi8_mask fn">_mm256_cmp_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装带符号 8 位整数，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmp_epi16_mask.html" title="core::arch::x86::_mm256_cmp_epi16_mask fn">_mm256_cmp_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号 16 位整数，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmp_epi32_mask.html" title="core::arch::x86::_mm256_cmp_epi32_mask fn">_mm256_cmp_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装有符号 32 位整数，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmp_epi64_mask.html" title="core::arch::x86::_mm256_cmp_epi64_mask fn">_mm256_cmp_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 64 位整数，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmp_epu8_mask.html" title="core::arch::x86::_mm256_cmp_epu8_mask fn">_mm256_cmp_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 8 位整数，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmp_epu16_mask.html" title="core::arch::x86::_mm256_cmp_epu16_mask fn">_mm256_cmp_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 16 位整数，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmp_epu32_mask.html" title="core::arch::x86::_mm256_cmp_epu32_mask fn">_mm256_cmp_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 32 位整数，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmp_epu64_mask.html" title="core::arch::x86::_mm256_cmp_epu64_mask fn">_mm256_cmp_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 64 位整数，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmp_pd_mask.html" title="core::arch::x86::_mm256_cmp_pd_mask fn">_mm256_cmp_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmp_ps_mask.html" title="core::arch::x86::_mm256_cmp_ps_mask fn">_mm256_cmp_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpeq_epi8_mask.html" title="core::arch::x86::_mm256_cmpeq_epi8_mask fn">_mm256_cmpeq_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpeq_epi16_mask.html" title="core::arch::x86::_mm256_cmpeq_epi16_mask fn">_mm256_cmpeq_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpeq_epi32_mask.html" title="core::arch::x86::_mm256_cmpeq_epi32_mask fn">_mm256_cmpeq_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的 32 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpeq_epi64_mask.html" title="core::arch::x86::_mm256_cmpeq_epi64_mask fn">_mm256_cmpeq_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的 64 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpeq_epu8_mask.html" title="core::arch::x86::_mm256_cmpeq_epu8_mask fn">_mm256_cmpeq_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpeq_epu16_mask.html" title="core::arch::x86::_mm256_cmpeq_epu16_mask fn">_mm256_cmpeq_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpeq_epu32_mask.html" title="core::arch::x86::_mm256_cmpeq_epu32_mask fn">_mm256_cmpeq_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpeq_epu64_mask.html" title="core::arch::x86::_mm256_cmpeq_epu64_mask fn">_mm256_cmpeq_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpge_epi8_mask.html" title="core::arch::x86::_mm256_cmpge_epi8_mask fn">_mm256_cmpge_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否大于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpge_epi16_mask.html" title="core::arch::x86::_mm256_cmpge_epi16_mask fn">_mm256_cmpge_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号 16 位整数是否大于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpge_epi32_mask.html" title="core::arch::x86::_mm256_cmpge_epi32_mask fn">_mm256_cmpge_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号 32 位整数是否大于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpge_epi64_mask.html" title="core::arch::x86::_mm256_cmpge_epi64_mask fn">_mm256_cmpge_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数是否大于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpge_epu8_mask.html" title="core::arch::x86::_mm256_cmpge_epu8_mask fn">_mm256_cmpge_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否大于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpge_epu16_mask.html" title="core::arch::x86::_mm256_cmpge_epu16_mask fn">_mm256_cmpge_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否大于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpge_epu32_mask.html" title="core::arch::x86::_mm256_cmpge_epu32_mask fn">_mm256_cmpge_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否大于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpge_epu64_mask.html" title="core::arch::x86::_mm256_cmpge_epu64_mask fn">_mm256_cmpge_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否大于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpgt_epi8_mask.html" title="core::arch::x86::_mm256_cmpgt_epi8_mask fn">_mm256_cmpgt_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否大于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpgt_epi16_mask.html" title="core::arch::x86::_mm256_cmpgt_epi16_mask fn">_mm256_cmpgt_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号 16 位整数是否大于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpgt_epi32_mask.html" title="core::arch::x86::_mm256_cmpgt_epi32_mask fn">_mm256_cmpgt_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数是否大于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpgt_epi64_mask.html" title="core::arch::x86::_mm256_cmpgt_epi64_mask fn">_mm256_cmpgt_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数是否大于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpgt_epu8_mask.html" title="core::arch::x86::_mm256_cmpgt_epu8_mask fn">_mm256_cmpgt_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否大于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpgt_epu16_mask.html" title="core::arch::x86::_mm256_cmpgt_epu16_mask fn">_mm256_cmpgt_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否大于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpgt_epu32_mask.html" title="core::arch::x86::_mm256_cmpgt_epu32_mask fn">_mm256_cmpgt_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否大于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpgt_epu64_mask.html" title="core::arch::x86::_mm256_cmpgt_epu64_mask fn">_mm256_cmpgt_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否大于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmple_epi8_mask.html" title="core::arch::x86::_mm256_cmple_epi8_mask fn">_mm256_cmple_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数 (小于等于)，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmple_epi16_mask.html" title="core::arch::x86::_mm256_cmple_epi16_mask fn">_mm256_cmple_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数 (小于等于)，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmple_epi32_mask.html" title="core::arch::x86::_mm256_cmple_epi32_mask fn">_mm256_cmple_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数 (小于等于)，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmple_epi64_mask.html" title="core::arch::x86::_mm256_cmple_epi64_mask fn">_mm256_cmple_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数 (小于等于)，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmple_epu8_mask.html" title="core::arch::x86::_mm256_cmple_epu8_mask fn">_mm256_cmple_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数以得出小于或等于的结果，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmple_epu16_mask.html" title="core::arch::x86::_mm256_cmple_epu16_mask fn">_mm256_cmple_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否小于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmple_epu32_mask.html" title="core::arch::x86::_mm256_cmple_epu32_mask fn">_mm256_cmple_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否小于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmple_epu64_mask.html" title="core::arch::x86::_mm256_cmple_epu64_mask fn">_mm256_cmple_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否小于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmplt_epi8_mask.html" title="core::arch::x86::_mm256_cmplt_epi8_mask fn">_mm256_cmplt_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数小于零，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmplt_epi16_mask.html" title="core::arch::x86::_mm256_cmplt_epi16_mask fn">_mm256_cmplt_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数 (小于)，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmplt_epi32_mask.html" title="core::arch::x86::_mm256_cmplt_epi32_mask fn">_mm256_cmplt_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数 (小于)，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmplt_epi64_mask.html" title="core::arch::x86::_mm256_cmplt_epi64_mask fn">_mm256_cmplt_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数小于零，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmplt_epu8_mask.html" title="core::arch::x86::_mm256_cmplt_epu8_mask fn">_mm256_cmplt_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数以得到小于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmplt_epu16_mask.html" title="core::arch::x86::_mm256_cmplt_epu16_mask fn">_mm256_cmplt_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装后的无符号 16 位整数 (小于)，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmplt_epu32_mask.html" title="core::arch::x86::_mm256_cmplt_epu32_mask fn">_mm256_cmplt_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否小于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmplt_epu64_mask.html" title="core::arch::x86::_mm256_cmplt_epu64_mask fn">_mm256_cmplt_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否小于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpneq_epi8_mask.html" title="core::arch::x86::_mm256_cmpneq_epi8_mask fn">_mm256_cmpneq_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否不相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpneq_epi16_mask.html" title="core::arch::x86::_mm256_cmpneq_epi16_mask fn">_mm256_cmpneq_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号 16 位整数是否不相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpneq_epi32_mask.html" title="core::arch::x86::_mm256_cmpneq_epi32_mask fn">_mm256_cmpneq_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的 32 位整数是否不相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpneq_epi64_mask.html" title="core::arch::x86::_mm256_cmpneq_epi64_mask fn">_mm256_cmpneq_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数是否不相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpneq_epu8_mask.html" title="core::arch::x86::_mm256_cmpneq_epu8_mask fn">_mm256_cmpneq_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpneq_epu16_mask.html" title="core::arch::x86::_mm256_cmpneq_epu16_mask fn">_mm256_cmpneq_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否不相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpneq_epu32_mask.html" title="core::arch::x86::_mm256_cmpneq_epu32_mask fn">_mm256_cmpneq_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否不相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cmpneq_epu64_mask.html" title="core::arch::x86::_mm256_cmpneq_epu64_mask fn">_mm256_cmpneq_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否不相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_conflict_epi32.html" title="core::arch::x86::_mm256_conflict_epi32 fn">_mm256_conflict_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_conflict_epi64.html" title="core::arch::x86::_mm256_conflict_epi64 fn">_mm256_conflict_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>测试 a 的每个 64 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtepi16_epi8.html" title="core::arch::x86::_mm256_cvtepi16_epi8 fn">_mm256_cvtepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的包装的 16 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtepi32_epi8.html" title="core::arch::x86::_mm256_cvtepi32_epi8 fn">_mm256_cvtepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将带有 a 的包装的 32 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtepi32_epi16.html" title="core::arch::x86::_mm256_cvtepi32_epi16 fn">_mm256_cvtepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtepi64_epi8.html" title="core::arch::x86::_mm256_cvtepi64_epi8 fn">_mm256_cvtepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将带有 a 的包装的 64 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtepi64_epi16.html" title="core::arch::x86::_mm256_cvtepi64_epi16 fn">_mm256_cvtepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将带有 a 的包装的 64 位整数转换为带有截断的包装的 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtepi64_epi32.html" title="core::arch::x86::_mm256_cvtepi64_epi32 fn">_mm256_cvtepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将带有 a 的包装的 64 位整数转换为带有截断的包装的 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtepu32_pd.html" title="core::arch::x86::_mm256_cvtepu32_pd fn">_mm256_cvtepu32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 A 中的包装的无符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtne2ps_pbh.html" title="core::arch::x86::_mm256_cvtne2ps_pbh fn">_mm256_cvtne2ps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span><p>将两个 256 位 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并将结果存入 a</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtneps_pbh.html" title="core::arch::x86::_mm256_cvtneps_pbh fn">_mm256_cvtneps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span><p>将包装在 a 中的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并将结果存储在 dst 中。
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm256_cvtneps_pbh">Intel’s documentation</a></p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtpd_epu32.html" title="core::arch::x86::_mm256_cvtpd_epu32 fn">_mm256_cvtpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtph_ps.html" title="core::arch::x86::_mm256_cvtph_ps fn">_mm256_cvtph_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `f16c` only"><code>f16c</code></span><p>将 128 位 vector <code>a</code> 中的 8 x 16 位半精度浮点值转换为存储在 256 位宽 vector 中的 8 x 32 位浮点值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtps_epu32.html" title="core::arch::x86::_mm256_cvtps_epu32 fn">_mm256_cvtps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtps_ph.html" title="core::arch::x86::_mm256_cvtps_ph fn">_mm256_cvtps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `f16c` only"><code>f16c</code></span><p>将 256 位 vector <code>a</code> 中的 8 x 32 位浮点值转换为 8 x
16 位半精度浮点值存储在 128 位宽的 vector 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtsepi16_epi8.html" title="core::arch::x86::_mm256_cvtsepi16_epi8 fn">_mm256_cvtsepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 A 中的包装有符号 16 位整数转换为带符号饱和的包装 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtsepi32_epi8.html" title="core::arch::x86::_mm256_cvtsepi32_epi8 fn">_mm256_cvtsepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtsepi32_epi16.html" title="core::arch::x86::_mm256_cvtsepi32_epi16 fn">_mm256_cvtsepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtsepi64_epi8.html" title="core::arch::x86::_mm256_cvtsepi64_epi8 fn">_mm256_cvtsepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的带符号的 64 位整数转换为带符号饱和的包装的 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtsepi64_epi16.html" title="core::arch::x86::_mm256_cvtsepi64_epi16 fn">_mm256_cvtsepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的带符号的 64 位整数转换为带符号饱和的包装的 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtsepi64_epi32.html" title="core::arch::x86::_mm256_cvtsepi64_epi32 fn">_mm256_cvtsepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvttpd_epu32.html" title="core::arch::x86::_mm256_cvttpd_epu32 fn">_mm256_cvttpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvttps_epu32.html" title="core::arch::x86::_mm256_cvttps_epu32 fn">_mm256_cvttps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtusepi16_epi8.html" title="core::arch::x86::_mm256_cvtusepi16_epi8 fn">_mm256_cvtusepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtusepi32_epi8.html" title="core::arch::x86::_mm256_cvtusepi32_epi8 fn">_mm256_cvtusepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtusepi32_epi16.html" title="core::arch::x86::_mm256_cvtusepi32_epi16 fn">_mm256_cvtusepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 A 中的包装无符号 32 位整数转换为具有无符号饱和度的包装无符号 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtusepi64_epi8.html" title="core::arch::x86::_mm256_cvtusepi64_epi8 fn">_mm256_cvtusepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtusepi64_epi16.html" title="core::arch::x86::_mm256_cvtusepi64_epi16 fn">_mm256_cvtusepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_cvtusepi64_epi32.html" title="core::arch::x86::_mm256_cvtusepi64_epi32 fn">_mm256_cvtusepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 A 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_dbsad_epu8.html" title="core::arch::x86::_mm256_dbsad_epu8 fn">_mm256_dbsad_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 中与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs)，并将 16 位结果存储在 dst 中。对于每个 64 位通道，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中通道的低 8 位四元组，而后两个 SAD 使用 a 中通道的较高 8 位四元组。根据 imm8 中的控件，从 128 位通道中选择 b 中的四元组，并且每个 64 位通道中的每个 SAD 使用 8 位偏移量的选定四元组。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_dpbf16_ps.html" title="core::arch::x86::_mm256_dpbf16_ps fn">_mm256_dpbf16_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span><p>计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间单精度 (32-bit) 浮点元素与 src 中的元素相加，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_dpbusd_epi32.html" title="core::arch::x86::_mm256_dpbusd_epi32 fn">_mm256_dpbusd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span><p>将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果存入 dst。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_dpbusds_epi32.html" title="core::arch::x86::_mm256_dpbusds_epi32 fn">_mm256_dpbusds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span><p>将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。使用有符号饱和将这 4 个结果与 src 中相应的 32 位整数相加，并将包装的 32 位结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_dpwssd_epi32.html" title="core::arch::x86::_mm256_dpwssd_epi32 fn">_mm256_dpwssd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span><p>将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果存入 dst。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_dpwssds_epi32.html" title="core::arch::x86::_mm256_dpwssds_epi32 fn">_mm256_dpwssds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span><p>将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并将包装的 32 位结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_extractf32x4_ps.html" title="core::arch::x86::_mm256_extractf32x4_ps fn">_mm256_extractf32x4_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 提取 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并用 imm8 进行选择，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_extracti32x4_epi32.html" title="core::arch::x86::_mm256_extracti32x4_epi32 fn">_mm256_extracti32x4_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中提取 128 位 (由 4 个包装的 32 位整数组成)，用 IMM1 选中，结果存入 dst。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_fixupimm_pd.html" title="core::arch::x86::_mm256_fixupimm_pd fn">_mm256_fixupimm_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 c 中的包装的 64 位整数修复 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_fixupimm_ps.html" title="core::arch::x86::_mm256_fixupimm_ps fn">_mm256_fixupimm_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 c 中的包装 32 位整数修复 a 和 b 中包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_getexp_pd.html" title="core::arch::x86::_mm256_getexp_pd fn">_mm256_getexp_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并将结果存储在 dst 中。本质上，此内联函数为每个元素计算 floor(log2(x))。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_getexp_ps.html" title="core::arch::x86::_mm256_getexp_ps fn">_mm256_getexp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，并将结果存储在 dst 中。本质上，此内联函数为每个元素计算 floor(log2(x))。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_getmant_pd.html" title="core::arch::x86::_mm256_getmant_pd fn">_mm256_getmant_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素的尾数规格化，并将结果存储在 dst 中。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_getmant_ps.html" title="core::arch::x86::_mm256_getmant_ps fn">_mm256_getmant_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素的尾数标准化，并将结果存储在 dst 中。
此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:
_MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) The sign is determined by sc which can take the following values:</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_gf2p8affine_epi64_epi8.html" title="core::arch::x86::_mm256_gf2p8affine_epi64_epi8 fn">_mm256_gf2p8affine_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span><p>对 x 中的包装字节执行仿射变换。
也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_gf2p8affineinv_epi64_epi8.html" title="core::arch::x86::_mm256_gf2p8affineinv_epi64_epi8 fn">_mm256_gf2p8affineinv_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span><p>对 x 中的反向包装的字节执行仿射变换。
也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_gf2p8mul_epi8.html" title="core::arch::x86::_mm256_gf2p8mul_epi8 fn">_mm256_gf2p8mul_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span><p>在包装的字节上执行 GF(2^8) 乘法。
该字段以多项式表示，具有约数多项式 x^8 + x^4 + x^3 + x + 1。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_insertf32x4.html" title="core::arch::x86::_mm256_insertf32x4 fn">_mm256_insertf32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 复制到 dst，然后在 x00X 指定的位置将 d 的 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成) 插入 dst。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_inserti32x4.html" title="core::arch::x86::_mm256_inserti32x4 fn">_mm256_inserti32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 复制到 dst，然后在 x00X 指定的位置将 d 的 128 位 (由 4 个包装的 32 位整数组成) 插入 dst。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_load_epi32.html" title="core::arch::x86::_mm256_load_epi32 fn">_mm256_load_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 256 位 (由 8 个包装的 32 位整数组成) 从内存加载到 dst 中。mem_addr 必须在 32 字节边界上对齐，否则可能会生成一般保护异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_load_epi64.html" title="core::arch::x86::_mm256_load_epi64 fn">_mm256_load_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 256 位 (由 4 个包装的 64 位整数组成) 从内存加载到 dst 中。mem_addr 必须在 32 字节边界上对齐，否则可能会生成一般保护异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_loadu_epi8.html" title="core::arch::x86::_mm256_loadu_epi8 fn">_mm256_loadu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 256 位 (由 32 个包装的 8 位整数组成) 从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_loadu_epi16.html" title="core::arch::x86::_mm256_loadu_epi16 fn">_mm256_loadu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 256 位 (由 16 个包装的 16 位整数组成) 从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_loadu_epi32.html" title="core::arch::x86::_mm256_loadu_epi32 fn">_mm256_loadu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 256 位 (由 8 个包装的 32 位整数组成) 从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_loadu_epi64.html" title="core::arch::x86::_mm256_loadu_epi64 fn">_mm256_loadu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 256 位 (由 4 个包装的 64 位整数组成) 从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_lzcnt_epi32.html" title="core::arch::x86::_mm256_lzcnt_epi32 fn">_mm256_lzcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>计算 a 中每个包装的 32 位整数中前导零位的数目，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_lzcnt_epi64.html" title="core::arch::x86::_mm256_lzcnt_epi64 fn">_mm256_lzcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>计算 a 中每个包装的 64 位整数中前导零位的数目，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_madd52hi_epu64.html" title="core::arch::x86::_mm256_madd52hi_epu64 fn">_mm256_madd52hi_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512ifma,avx512vl` only"><code>avx512ifma,avx512vl</code></span><p>将 <code>b</code> 和 <code>c</code> 的每个 64 位元素中的包装无符号 52 位整数相乘以形成 104 位中间结果。
将中间结果的高 52 位无符号整数与 <code>a</code> 中的相应无符号 64 位整数相加，并将结果存储在 <code>dst</code> 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_madd52lo_epu64.html" title="core::arch::x86::_mm256_madd52lo_epu64 fn">_mm256_madd52lo_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512ifma,avx512vl` only"><code>avx512ifma,avx512vl</code></span><p>将 <code>b</code> 和 <code>c</code> 的每个 64 位元素中的包装无符号 52 位整数相乘以形成 104 位中间结果。
将中间结果的低 52 位无符号整数与 <code>a</code> 中的相应无符号 64 位整数相加，并将结果存储在 <code>dst</code> 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask2_permutex2var_epi8.html" title="core::arch::x86::_mm256_mask2_permutex2var_epi8 fn">_mm256_mask2_permutex2var_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span><p>使用相应的选择器和 idx 中的索引将 a 和 b 中的 8 位整数跨通道打乱，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask2_permutex2var_epi16.html" title="core::arch::x86::_mm256_mask2_permutex2var_epi16 fn">_mm256_mask2_permutex2var_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用相应的选择器和 idx 中的索引在通道中的 a 和 b 中对 16 位整数进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 idx 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask2_permutex2var_epi32.html" title="core::arch::x86::_mm256_mask2_permutex2var_epi32 fn">_mm256_mask2_permutex2var_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用相应的选择器和 idx 中的索引在通道中的 a 和 b 中对 32 位整数进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 idx 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask2_permutex2var_epi64.html" title="core::arch::x86::_mm256_mask2_permutex2var_epi64 fn">_mm256_mask2_permutex2var_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中随机排列 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 idx 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask2_permutex2var_pd.html" title="core::arch::x86::_mm256_mask2_permutex2var_pd fn">_mm256_mask2_permutex2var_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 idx 复制元素)</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask2_permutex2var_ps.html" title="core::arch::x86::_mm256_mask2_permutex2var_ps fn">_mm256_mask2_permutex2var_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的对应选择器和索引在 a 和 b 中的通道中对 a 和 b 中的单精度 (32-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 idx 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask3_fmadd_pd.html" title="core::arch::x86::_mm256_mask3_fmadd_pd fn">_mm256_mask3_fmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask3_fmadd_ps.html" title="core::arch::x86::_mm256_mask3_fmadd_ps fn">_mm256_mask3_fmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask3_fmaddsub_pd.html" title="core::arch::x86::_mm256_mask3_fmaddsub_pd fn">_mm256_mask3_fmaddsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在 a 和 b 中分别乘以包装的单精度 (32-bit) 浮点元素，或者在 to/from 中将中间结果乘以包装的元素加减乘以 x，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 c 复制元素) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask3_fmaddsub_ps.html" title="core::arch::x86::_mm256_mask3_fmaddsub_ps fn">_mm256_mask3_fmaddsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在 a 和 b 中分别乘以包装的单精度 (32-bit) 浮点元素，或者在 to/from 中将中间结果乘以包装的元素加减乘以 x，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 c 复制元素) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask3_fmsub_pd.html" title="core::arch::x86::_mm256_mask3_fmsub_pd fn">_mm256_mask3_fmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask3_fmsub_ps.html" title="core::arch::x86::_mm256_mask3_fmsub_ps fn">_mm256_mask3_fmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask3_fmsubadd_pd.html" title="core::arch::x86::_mm256_mask3_fmsubadd_pd fn">_mm256_mask3_fmsubadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，并使用 writemask k 将结果存储在 dst 中 (当未使用相应的 mask 位时从 c 复制元素) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask3_fmsubadd_ps.html" title="core::arch::x86::_mm256_mask3_fmsubadd_ps fn">_mm256_mask3_fmsubadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在 a 和 b 中乘以包装的单精度 (32-bit) 浮点元素，或者在中间结果中减去并在 c from/to 中包装的元素相乘，然后使用 writemask k 将结果存储在 dst 中 (当未使用相应的 mask 位时从 c 复制元素) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask3_fnmadd_pd.html" title="core::arch::x86::_mm256_mask3_fnmadd_pd fn">_mm256_mask3_fnmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask3_fnmadd_ps.html" title="core::arch::x86::_mm256_mask3_fnmadd_ps fn">_mm256_mask3_fnmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 c 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask3_fnmsub_pd.html" title="core::arch::x86::_mm256_mask3_fnmsub_pd fn">_mm256_mask3_fnmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask3_fnmsub_ps.html" title="core::arch::x86::_mm256_mask3_fnmsub_ps fn">_mm256_mask3_fnmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_abs_epi8.html" title="core::arch::x86::_mm256_mask_abs_epi8 fn">_mm256_mask_abs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 中包装的带符号的 8 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_abs_epi16.html" title="core::arch::x86::_mm256_mask_abs_epi16 fn">_mm256_mask_abs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 中包装的带符号的 16 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_abs_epi32.html" title="core::arch::x86::_mm256_mask_abs_epi32 fn">_mm256_mask_abs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的有符号 32 位整数的绝对值，并使用 writemask k 将无符号结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_abs_epi64.html" title="core::arch::x86::_mm256_mask_abs_epi64 fn">_mm256_mask_abs_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的带符号的 64 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_add_epi8.html" title="core::arch::x86::_mm256_mask_add_epi8 fn">_mm256_mask_add_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>在 a 和 b 中添加包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_add_epi16.html" title="core::arch::x86::_mm256_mask_add_epi16 fn">_mm256_mask_add_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>在 a 和 b 中添加包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_add_epi32.html" title="core::arch::x86::_mm256_mask_add_epi32 fn">_mm256_mask_add_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在 a 和 b 中添加包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_add_epi64.html" title="core::arch::x86::_mm256_mask_add_epi64 fn">_mm256_mask_add_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在 a 和 b 中添加包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_add_pd.html" title="core::arch::x86::_mm256_mask_add_pd fn">_mm256_mask_add_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_add_ps.html" title="core::arch::x86::_mm256_mask_add_ps fn">_mm256_mask_add_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_adds_epi8.html" title="core::arch::x86::_mm256_mask_adds_epi8 fn">_mm256_mask_adds_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用饱和度在 a 和 b 中添加包装的带符号的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_adds_epi16.html" title="core::arch::x86::_mm256_mask_adds_epi16 fn">_mm256_mask_adds_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用饱和度在 a 和 b 中添加包装的带符号的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_adds_epu8.html" title="core::arch::x86::_mm256_mask_adds_epu8 fn">_mm256_mask_adds_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用饱和度在 a 和 b 中添加包装的无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_adds_epu16.html" title="core::arch::x86::_mm256_mask_adds_epu16 fn">_mm256_mask_adds_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用饱和度在 a 和 b 中添加包装的无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_alignr_epi8.html" title="core::arch::x86::_mm256_mask_alignr_epi8 fn">_mm256_mask_alignr_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 和 b 中的 16 字节块对连接成 32 字节的临时结果，将结果右移 imm8 字节，并使用写掩码 k 将低 16 个字节存储在 dst 中 (当相应的掩码位为 1 时，元素从 src 复制没有设置)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_alignr_epi32.html" title="core::arch::x86::_mm256_mask_alignr_epi32 fn">_mm256_mask_alignr_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 连接成 64 字节的 immediate 结果，将结果右移 imm8 个 32 位元素，并使用 writemask k 将低 32 字节 (8 个元素) 存储在 dst 中 (当相应的掩码位为没有设置)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_alignr_epi64.html" title="core::arch::x86::_mm256_mask_alignr_epi64 fn">_mm256_mask_alignr_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 连接成 64 字节的 immediate 结果，将结果右移 imm8 个 64 位元素，并使用 writemask k 将低 32 字节 (4 个元素) 存储在 dst 中 (当相应的掩码位为没有设置)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_and_epi32.html" title="core::arch::x86::_mm256_mask_and_epi32 fn">_mm256_mask_and_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在包装的 a 和 b 的 32 位整数元素之间执行逐个元素的按位 AND，使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_and_epi64.html" title="core::arch::x86::_mm256_mask_and_epi64 fn">_mm256_mask_and_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 64 位整数的按位与，并使用写掩码 k 将结果存储在 dst 中 (如果未设置相应的掩码位，则从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_andnot_epi32.html" title="core::arch::x86::_mm256_mask_andnot_epi32 fn">_mm256_mask_andnot_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的 32 位整数的按位 NOT，然后与 b 计算 AND，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_andnot_epi64.html" title="core::arch::x86::_mm256_mask_andnot_epi64 fn">_mm256_mask_andnot_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的 64 位整数的按位 NOT，然后与 b 计算 AND，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_avg_epu8.html" title="core::arch::x86::_mm256_mask_avg_epu8 fn">_mm256_mask_avg_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 和 b 中包装的无符号 8 位整数平均，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_avg_epu16.html" title="core::arch::x86::_mm256_mask_avg_epu16 fn">_mm256_mask_avg_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 和 b 中包装的无符号 16 位整数进行平均，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_bitshuffle_epi64_mask.html" title="core::arch::x86::_mm256_mask_bitshuffle_epi64_mask fn">_mm256_mask_bitshuffle_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span><p>将输入 <code>b</code> 视为包装的 64 位整数，并将 <code>c</code> 视为包装的 8 位整数。
然后将来自 <code>c</code> 的 8 个 8 位值作为索引分组到相应的 64 位整数的位中。
然后，选择这些位并将其包装到输出中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_blend_epi8.html" title="core::arch::x86::_mm256_mask_blend_epi8 fn">_mm256_mask_blend_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用控制掩码 k 混合 a 和 b 中的包装 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_blend_epi16.html" title="core::arch::x86::_mm256_mask_blend_epi16 fn">_mm256_mask_blend_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用控制掩码 k 混合来自 a 和 b 的包装的 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_blend_epi32.html" title="core::arch::x86::_mm256_mask_blend_epi32 fn">_mm256_mask_blend_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用控制掩码 k 混合 a 和 b 中的包装 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_blend_epi64.html" title="core::arch::x86::_mm256_mask_blend_epi64 fn">_mm256_mask_blend_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用控制掩码 k 混合 a 和 b 中的包装 64 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_blend_pd.html" title="core::arch::x86::_mm256_mask_blend_pd fn">_mm256_mask_blend_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用控制掩码 k 混合来自 a 和 b 的包装后的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_blend_ps.html" title="core::arch::x86::_mm256_mask_blend_ps fn">_mm256_mask_blend_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用控制掩码 k 混合来自 a 和 b 的包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_broadcast_f32x4.html" title="core::arch::x86::_mm256_mask_broadcast_f32x4 fn">_mm256_mask_broadcast_f32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用写掩码 k 将 4 个包装的单精度 (32-bit) 浮点元素从 a 广播到 dst 的所有元素 (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_broadcast_i32x4.html" title="core::arch::x86::_mm256_mask_broadcast_i32x4 fn">_mm256_mask_broadcast_i32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用写掩码 k 将 a 的 4 个包装的 32 位整数广播到 dst 的所有元素 (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_broadcastb_epi8.html" title="core::arch::x86::_mm256_mask_broadcastb_epi8 fn">_mm256_mask_broadcastb_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用写掩码 k 将 d 的低包装的 8 位整数广播到 dst 的所有元素 (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_broadcastd_epi32.html" title="core::arch::x86::_mm256_mask_broadcastd_epi32 fn">_mm256_mask_broadcastd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用写掩码 k 将低包装的 32 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_broadcastq_epi64.html" title="core::arch::x86::_mm256_mask_broadcastq_epi64 fn">_mm256_mask_broadcastq_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用写掩码 k 将低包装的 64 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_broadcastsd_pd.html" title="core::arch::x86::_mm256_mask_broadcastsd_pd fn">_mm256_mask_broadcastsd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用写掩码 k 将低双精度 (64-bit) 浮点型元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_broadcastss_ps.html" title="core::arch::x86::_mm256_mask_broadcastss_ps fn">_mm256_mask_broadcastss_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用写掩码 k 将低单精度 (32-bit) 浮点型元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将元素从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_broadcastw_epi16.html" title="core::arch::x86::_mm256_mask_broadcastw_epi16 fn">_mm256_mask_broadcastw_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用写掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmp_epi8_mask.html" title="core::arch::x86::_mm256_mask_cmp_epi8_mask fn">_mm256_mask_cmp_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmp_epi16_mask.html" title="core::arch::x86::_mm256_mask_cmp_epi16_mask fn">_mm256_mask_cmp_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmp_epi32_mask.html" title="core::arch::x86::_mm256_mask_cmp_epi32_mask fn">_mm256_mask_cmp_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 32 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmp_epi64_mask.html" title="core::arch::x86::_mm256_mask_cmp_epi64_mask fn">_mm256_mask_cmp_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmp_epu8_mask.html" title="core::arch::x86::_mm256_mask_cmp_epu8_mask fn">_mm256_mask_cmp_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 8 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmp_epu16_mask.html" title="core::arch::x86::_mm256_mask_cmp_epu16_mask fn">_mm256_mask_cmp_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmp_epu32_mask.html" title="core::arch::x86::_mm256_mask_cmp_epu32_mask fn">_mm256_mask_cmp_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 32 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmp_epu64_mask.html" title="core::arch::x86::_mm256_mask_cmp_epu64_mask fn">_mm256_mask_cmp_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmp_pd_mask.html" title="core::arch::x86::_mm256_mask_cmp_pd_mask fn">_mm256_mask_cmp_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmp_ps_mask.html" title="core::arch::x86::_mm256_mask_cmp_ps_mask fn">_mm256_mask_cmp_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpeq_epi8_mask.html" title="core::arch::x86::_mm256_mask_cmpeq_epi8_mask fn">_mm256_mask_cmpeq_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpeq_epi16_mask.html" title="core::arch::x86::_mm256_mask_cmpeq_epi16_mask fn">_mm256_mask_cmpeq_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数是否相等，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpeq_epi32_mask.html" title="core::arch::x86::_mm256_mask_cmpeq_epi32_mask fn">_mm256_mask_cmpeq_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的 32 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpeq_epi64_mask.html" title="core::arch::x86::_mm256_mask_cmpeq_epi64_mask fn">_mm256_mask_cmpeq_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的 64 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpeq_epu8_mask.html" title="core::arch::x86::_mm256_mask_cmpeq_epu8_mask fn">_mm256_mask_cmpeq_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpeq_epu16_mask.html" title="core::arch::x86::_mm256_mask_cmpeq_epu16_mask fn">_mm256_mask_cmpeq_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpeq_epu32_mask.html" title="core::arch::x86::_mm256_mask_cmpeq_epu32_mask fn">_mm256_mask_cmpeq_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpeq_epu64_mask.html" title="core::arch::x86::_mm256_mask_cmpeq_epu64_mask fn">_mm256_mask_cmpeq_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpge_epi8_mask.html" title="core::arch::x86::_mm256_mask_cmpge_epi8_mask fn">_mm256_mask_cmpge_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpge_epi16_mask.html" title="core::arch::x86::_mm256_mask_cmpge_epi16_mask fn">_mm256_mask_cmpge_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpge_epi32_mask.html" title="core::arch::x86::_mm256_mask_cmpge_epi32_mask fn">_mm256_mask_cmpge_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数是否等于或大于等于，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpge_epi64_mask.html" title="core::arch::x86::_mm256_mask_cmpge_epi64_mask fn">_mm256_mask_cmpge_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpge_epu8_mask.html" title="core::arch::x86::_mm256_mask_cmpge_epu8_mask fn">_mm256_mask_cmpge_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpge_epu16_mask.html" title="core::arch::x86::_mm256_mask_cmpge_epu16_mask fn">_mm256_mask_cmpge_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否大于等于，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpge_epu32_mask.html" title="core::arch::x86::_mm256_mask_cmpge_epu32_mask fn">_mm256_mask_cmpge_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpge_epu64_mask.html" title="core::arch::x86::_mm256_mask_cmpge_epu64_mask fn">_mm256_mask_cmpge_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpgt_epi8_mask.html" title="core::arch::x86::_mm256_mask_cmpgt_epi8_mask fn">_mm256_mask_cmpgt_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpgt_epi16_mask.html" title="core::arch::x86::_mm256_mask_cmpgt_epi16_mask fn">_mm256_mask_cmpgt_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpgt_epi32_mask.html" title="core::arch::x86::_mm256_mask_cmpgt_epi32_mask fn">_mm256_mask_cmpgt_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数是否大于，并将结果使用零掩码 k1 存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpgt_epi64_mask.html" title="core::arch::x86::_mm256_mask_cmpgt_epi64_mask fn">_mm256_mask_cmpgt_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpgt_epu8_mask.html" title="core::arch::x86::_mm256_mask_cmpgt_epu8_mask fn">_mm256_mask_cmpgt_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpgt_epu16_mask.html" title="core::arch::x86::_mm256_mask_cmpgt_epu16_mask fn">_mm256_mask_cmpgt_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpgt_epu32_mask.html" title="core::arch::x86::_mm256_mask_cmpgt_epu32_mask fn">_mm256_mask_cmpgt_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpgt_epu64_mask.html" title="core::arch::x86::_mm256_mask_cmpgt_epu64_mask fn">_mm256_mask_cmpgt_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmple_epi8_mask.html" title="core::arch::x86::_mm256_mask_cmple_epi8_mask fn">_mm256_mask_cmple_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmple_epi16_mask.html" title="core::arch::x86::_mm256_mask_cmple_epi16_mask fn">_mm256_mask_cmple_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数 (小于或等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmple_epi32_mask.html" title="core::arch::x86::_mm256_mask_cmple_epi32_mask fn">_mm256_mask_cmple_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmple_epi64_mask.html" title="core::arch::x86::_mm256_mask_cmple_epi64_mask fn">_mm256_mask_cmple_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数 (小于等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmple_epu8_mask.html" title="core::arch::x86::_mm256_mask_cmple_epu8_mask fn">_mm256_mask_cmple_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmple_epu16_mask.html" title="core::arch::x86::_mm256_mask_cmple_epu16_mask fn">_mm256_mask_cmple_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmple_epu32_mask.html" title="core::arch::x86::_mm256_mask_cmple_epu32_mask fn">_mm256_mask_cmple_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmple_epu64_mask.html" title="core::arch::x86::_mm256_mask_cmple_epu64_mask fn">_mm256_mask_cmple_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmplt_epi8_mask.html" title="core::arch::x86::_mm256_mask_cmplt_epi8_mask fn">_mm256_mask_cmplt_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmplt_epi16_mask.html" title="core::arch::x86::_mm256_mask_cmplt_epi16_mask fn">_mm256_mask_cmplt_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmplt_epi32_mask.html" title="core::arch::x86::_mm256_mask_cmplt_epi32_mask fn">_mm256_mask_cmplt_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数 (小于或等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmplt_epi64_mask.html" title="core::arch::x86::_mm256_mask_cmplt_epi64_mask fn">_mm256_mask_cmplt_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmplt_epu8_mask.html" title="core::arch::x86::_mm256_mask_cmplt_epu8_mask fn">_mm256_mask_cmplt_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmplt_epu16_mask.html" title="core::arch::x86::_mm256_mask_cmplt_epu16_mask fn">_mm256_mask_cmplt_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数以得到小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmplt_epu32_mask.html" title="core::arch::x86::_mm256_mask_cmplt_epu32_mask fn">_mm256_mask_cmplt_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmplt_epu64_mask.html" title="core::arch::x86::_mm256_mask_cmplt_epu64_mask fn">_mm256_mask_cmplt_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpneq_epi8_mask.html" title="core::arch::x86::_mm256_mask_cmpneq_epi8_mask fn">_mm256_mask_cmpneq_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpneq_epi16_mask.html" title="core::arch::x86::_mm256_mask_cmpneq_epi16_mask fn">_mm256_mask_cmpneq_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpneq_epi32_mask.html" title="core::arch::x86::_mm256_mask_cmpneq_epi32_mask fn">_mm256_mask_cmpneq_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的 32 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpneq_epi64_mask.html" title="core::arch::x86::_mm256_mask_cmpneq_epi64_mask fn">_mm256_mask_cmpneq_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpneq_epu8_mask.html" title="core::arch::x86::_mm256_mask_cmpneq_epu8_mask fn">_mm256_mask_cmpneq_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpneq_epu16_mask.html" title="core::arch::x86::_mm256_mask_cmpneq_epu16_mask fn">_mm256_mask_cmpneq_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpneq_epu32_mask.html" title="core::arch::x86::_mm256_mask_cmpneq_epu32_mask fn">_mm256_mask_cmpneq_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cmpneq_epu64_mask.html" title="core::arch::x86::_mm256_mask_cmpneq_epu64_mask fn">_mm256_mask_cmpneq_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_compress_epi8.html" title="core::arch::x86::_mm256_mask_compress_epi8 fn">_mm256_mask_compress_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 a 中的活动 8 位整数 (它们各自的位设置在写掩码 k 中) 连续存储到 dst，并通过 src 中的其余元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_compress_epi16.html" title="core::arch::x86::_mm256_mask_compress_epi16 fn">_mm256_mask_compress_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 a 中的活动 16 位整数 (它们各自的位设置在写掩码 k 中) 连续存储到 dst，并通过 src 中的其余元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_compress_epi32.html" title="core::arch::x86::_mm256_mask_compress_epi32 fn">_mm256_mask_compress_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将活动的 32 位整数连续存储在 dst 中 (它们各自的位在写掩码 k 中设置的整数) 到 dst，并通过 src 中的其余元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_compress_epi64.html" title="core::arch::x86::_mm256_mask_compress_epi64 fn">_mm256_mask_compress_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将活动的 64 位整数连续存储在 dst 中 (它们各自的位在写掩码 k 中设置的整数) 到 dst，并通过 src 中的其余元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_compress_pd.html" title="core::arch::x86::_mm256_mask_compress_pd fn">_mm256_mask_compress_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将活动的双精度 (64-bit) 浮点元素连续存储在 dst 中 (它们各自的位在写掩码 k 中设置) 到 dst，并通过 src 中的其余元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_compress_ps.html" title="core::arch::x86::_mm256_mask_compress_ps fn">_mm256_mask_compress_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将活动的单精度 (32-bit) 浮点元素连续存储在 dst 中 (将其各自的位设置在写掩码 k 中的那些元素中) 存储到 dst，并通过 src 中的其余元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_conflict_epi32.html" title="core::arch::x86::_mm256_mask_conflict_epi32 fn">_mm256_mask_conflict_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>使用写掩码 k (在未设置相应的掩码位时从 src 复制元素)，测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_conflict_epi64.html" title="core::arch::x86::_mm256_mask_conflict_epi64 fn">_mm256_mask_conflict_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>使用写掩码 k 测试 a 的每个 64 位元素是否与所有其他元素相等 (更接近最低有效位) (当未设置相应的掩码位时，从 src 复制元素)。每个元素的比较在 dst 中形成零扩展位 vector。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvt_roundps_ph.html" title="core::arch::x86::_mm256_mask_cvt_roundps_ph fn">_mm256_mask_cvt_roundps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepi8_epi16.html" title="core::arch::x86::_mm256_mask_cvtepi8_epi16 fn">_mm256_mask_cvtepi8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用符号将包装的 8 位整数从 a 扩展为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepi8_epi32.html" title="core::arch::x86::_mm256_mask_cvtepi8_epi32 fn">_mm256_mask_cvtepi8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>符号将包装的 8 位整数从 a 扩展为包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepi8_epi64.html" title="core::arch::x86::_mm256_mask_cvtepi8_epi64 fn">_mm256_mask_cvtepi8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 的低 4 字节中的 8 位整数符号扩展为包装的 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepi16_epi8.html" title="core::arch::x86::_mm256_mask_cvtepi16_epi8 fn">_mm256_mask_cvtepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将带有 a 的包装的 16 位整数转换为带截断的 8 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepi16_epi32.html" title="core::arch::x86::_mm256_mask_cvtepi16_epi32 fn">_mm256_mask_cvtepi16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>符号将包装后的 16 位整数从 a 扩展为包装后的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepi16_epi64.html" title="core::arch::x86::_mm256_mask_cvtepi16_epi64 fn">_mm256_mask_cvtepi16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用符号将包装的 16 位整数从 a 扩展为包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepi16_storeu_epi8.html" title="core::arch::x86::_mm256_mask_cvtepi16_storeu_epi8 fn">_mm256_mask_cvtepi16_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的包装的 16 位整数转换为带有截断的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepi32_epi8.html" title="core::arch::x86::_mm256_mask_cvtepi32_epi8 fn">_mm256_mask_cvtepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将带有 a 的包装的 32 位整数转换为带截断的包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepi32_epi16.html" title="core::arch::x86::_mm256_mask_cvtepi32_epi16 fn">_mm256_mask_cvtepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepi32_epi64.html" title="core::arch::x86::_mm256_mask_cvtepi32_epi64 fn">_mm256_mask_cvtepi32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用符号将包装的 32 位整数从 a 扩展为包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepi32_pd.html" title="core::arch::x86::_mm256_mask_cvtepi32_pd fn">_mm256_mask_cvtepi32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装有符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepi32_ps.html" title="core::arch::x86::_mm256_mask_cvtepi32_ps fn">_mm256_mask_cvtepi32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装有符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepi32_storeu_epi8.html" title="core::arch::x86::_mm256_mask_cvtepi32_storeu_epi8 fn">_mm256_mask_cvtepi32_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 32 位整数在 a 中转换为带有截断的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepi32_storeu_epi16.html" title="core::arch::x86::_mm256_mask_cvtepi32_storeu_epi16 fn">_mm256_mask_cvtepi32_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的 32 位整数转换为带截断的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepi64_epi8.html" title="core::arch::x86::_mm256_mask_cvtepi64_epi8 fn">_mm256_mask_cvtepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的 64 位整数转换为带有截断的包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepi64_epi16.html" title="core::arch::x86::_mm256_mask_cvtepi64_epi16 fn">_mm256_mask_cvtepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的 64 位整数转换为带截断的 16 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepi64_epi32.html" title="core::arch::x86::_mm256_mask_cvtepi64_epi32 fn">_mm256_mask_cvtepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的 64 位整数转换为带截断的 32 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepi64_storeu_epi8.html" title="core::arch::x86::_mm256_mask_cvtepi64_storeu_epi8 fn">_mm256_mask_cvtepi64_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中包装的 64 位整数转换为包装的 8 位整数并截断，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepi64_storeu_epi16.html" title="core::arch::x86::_mm256_mask_cvtepi64_storeu_epi16 fn">_mm256_mask_cvtepi64_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的 64 位整数转换为带截断的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepi64_storeu_epi32.html" title="core::arch::x86::_mm256_mask_cvtepi64_storeu_epi32 fn">_mm256_mask_cvtepi64_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的 64 位整数转换为带截断的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepu8_epi16.html" title="core::arch::x86::_mm256_mask_cvtepu8_epi16 fn">_mm256_mask_cvtepu8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的包装无符号 8 位整数零扩展为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepu8_epi32.html" title="core::arch::x86::_mm256_mask_cvtepu8_epi32 fn">_mm256_mask_cvtepu8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>零扩展包装的无符号 8 位整数在 a 的低 8 字节到包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepu8_epi64.html" title="core::arch::x86::_mm256_mask_cvtepu8_epi64 fn">_mm256_mask_cvtepu8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>零扩展包装的无符号 8 位整数在 a 的低 4 字节到包装的 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepu16_epi32.html" title="core::arch::x86::_mm256_mask_cvtepu16_epi32 fn">_mm256_mask_cvtepu16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 16 位整数零扩展为包装 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepu16_epi64.html" title="core::arch::x86::_mm256_mask_cvtepu16_epi64 fn">_mm256_mask_cvtepu16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>零扩展包装的无符号 16 位整数 a 的低 8 字节到包装的 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepu32_epi64.html" title="core::arch::x86::_mm256_mask_cvtepu32_epi64 fn">_mm256_mask_cvtepu32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 32 位整数零扩展为包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtepu32_pd.html" title="core::arch::x86::_mm256_mask_cvtepu32_pd fn">_mm256_mask_cvtepu32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 32 位整数转换为包装双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtne2ps_pbh.html" title="core::arch::x86::_mm256_mask_cvtne2ps_pbh fn">_mm256_mask_cvtne2ps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span><p>将两个 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 writemask k 将结果存储在单个 vector dst 中 (当相应的掩码位为没有设置)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtneps_pbh.html" title="core::arch::x86::_mm256_mask_cvtneps_pbh fn">_mm256_mask_cvtneps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span><p>将包装在 a 中的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtpd_epi32.html" title="core::arch::x86::_mm256_mask_cvtpd_epi32 fn">_mm256_mask_cvtpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtpd_epu32.html" title="core::arch::x86::_mm256_mask_cvtpd_epu32 fn">_mm256_mask_cvtpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtpd_ps.html" title="core::arch::x86::_mm256_mask_cvtpd_ps fn">_mm256_mask_cvtpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtph_ps.html" title="core::arch::x86::_mm256_mask_cvtph_ps fn">_mm256_mask_cvtph_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装后的半精度 (16-bit) 浮点元素转换为包装后的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtps_epi32.html" title="core::arch::x86::_mm256_mask_cvtps_epi32 fn">_mm256_mask_cvtps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtps_epu32.html" title="core::arch::x86::_mm256_mask_cvtps_epu32 fn">_mm256_mask_cvtps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtps_ph.html" title="core::arch::x86::_mm256_mask_cvtps_ph fn">_mm256_mask_cvtps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtsepi16_epi8.html" title="core::arch::x86::_mm256_mask_cvtsepi16_epi8 fn">_mm256_mask_cvtsepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的包装带符号的 16 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtsepi16_storeu_epi8.html" title="core::arch::x86::_mm256_mask_cvtsepi16_storeu_epi8 fn">_mm256_mask_cvtsepi16_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装在 a 中的有符号 16 位整数转换为有符号饱和的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtsepi32_epi8.html" title="core::arch::x86::_mm256_mask_cvtsepi32_epi8 fn">_mm256_mask_cvtsepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtsepi32_epi16.html" title="core::arch::x86::_mm256_mask_cvtsepi32_epi16 fn">_mm256_mask_cvtsepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtsepi32_storeu_epi8.html" title="core::arch::x86::_mm256_mask_cvtsepi32_storeu_epi8 fn">_mm256_mask_cvtsepi32_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装在 a 中的有符号 32 位整数转换为具有符号饱和的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtsepi32_storeu_epi16.html" title="core::arch::x86::_mm256_mask_cvtsepi32_storeu_epi16 fn">_mm256_mask_cvtsepi32_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装在 a 中的有符号 32 位整数转换为具有符号饱和的包装的 16 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtsepi64_epi8.html" title="core::arch::x86::_mm256_mask_cvtsepi64_epi8 fn">_mm256_mask_cvtsepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtsepi64_epi16.html" title="core::arch::x86::_mm256_mask_cvtsepi64_epi16 fn">_mm256_mask_cvtsepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtsepi64_epi32.html" title="core::arch::x86::_mm256_mask_cvtsepi64_epi32 fn">_mm256_mask_cvtsepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtsepi64_storeu_epi8.html" title="core::arch::x86::_mm256_mask_cvtsepi64_storeu_epi8 fn">_mm256_mask_cvtsepi64_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtsepi64_storeu_epi16.html" title="core::arch::x86::_mm256_mask_cvtsepi64_storeu_epi16 fn">_mm256_mask_cvtsepi64_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtsepi64_storeu_epi32.html" title="core::arch::x86::_mm256_mask_cvtsepi64_storeu_epi32 fn">_mm256_mask_cvtsepi64_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvttpd_epi32.html" title="core::arch::x86::_mm256_mask_cvttpd_epi32 fn">_mm256_mask_cvttpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvttpd_epu32.html" title="core::arch::x86::_mm256_mask_cvttpd_epu32 fn">_mm256_mask_cvttpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvttps_epi32.html" title="core::arch::x86::_mm256_mask_cvttps_epi32 fn">_mm256_mask_cvttps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvttps_epu32.html" title="core::arch::x86::_mm256_mask_cvttps_epu32 fn">_mm256_mask_cvttps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtusepi16_epi8.html" title="core::arch::x86::_mm256_mask_cvtusepi16_epi8 fn">_mm256_mask_cvtusepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtusepi16_storeu_epi8.html" title="core::arch::x86::_mm256_mask_cvtusepi16_storeu_epi8 fn">_mm256_mask_cvtusepi16_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装在 a 中的无符号 16 位整数转换为具有无符号饱和的包装的无符号 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtusepi32_epi8.html" title="core::arch::x86::_mm256_mask_cvtusepi32_epi8 fn">_mm256_mask_cvtusepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtusepi32_epi16.html" title="core::arch::x86::_mm256_mask_cvtusepi32_epi16 fn">_mm256_mask_cvtusepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtusepi32_storeu_epi8.html" title="core::arch::x86::_mm256_mask_cvtusepi32_storeu_epi8 fn">_mm256_mask_cvtusepi32_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装在 a 中的无符号 32 位整数转换为具有无符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtusepi32_storeu_epi16.html" title="core::arch::x86::_mm256_mask_cvtusepi32_storeu_epi16 fn">_mm256_mask_cvtusepi32_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装在 a 中的无符号 32 位整数转换为具有无符号饱和的包装的无符号 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtusepi64_epi8.html" title="core::arch::x86::_mm256_mask_cvtusepi64_epi8 fn">_mm256_mask_cvtusepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtusepi64_epi16.html" title="core::arch::x86::_mm256_mask_cvtusepi64_epi16 fn">_mm256_mask_cvtusepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtusepi64_epi32.html" title="core::arch::x86::_mm256_mask_cvtusepi64_epi32 fn">_mm256_mask_cvtusepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtusepi64_storeu_epi8.html" title="core::arch::x86::_mm256_mask_cvtusepi64_storeu_epi8 fn">_mm256_mask_cvtusepi64_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的无符号 64 位整数在 a 中转换为具有无符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtusepi64_storeu_epi16.html" title="core::arch::x86::_mm256_mask_cvtusepi64_storeu_epi16 fn">_mm256_mask_cvtusepi64_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装在 a 中的无符号 64 位整数转换为具有无符号饱和的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_cvtusepi64_storeu_epi32.html" title="core::arch::x86::_mm256_mask_cvtusepi64_storeu_epi32 fn">_mm256_mask_cvtusepi64_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的无符号 64 位整数在 a 中转换为具有无符号饱和的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_dbsad_epu8.html" title="core::arch::x86::_mm256_mask_dbsad_epu8 fn">_mm256_mask_dbsad_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 中的无符号 8 位整数与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs)，并使用写掩码 k 将 16 位结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。对于每个 64 位通道，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中通道的低 8 位四元组，而后两个 SAD 使用 a 中通道的较高 8 位四元组。根据 imm8 中的控件，从 128 位通道中选择 b 中的四元组，并且每个 64 位通道中的每个 SAD 使用 8 位偏移量的选定四元组。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_div_pd.html" title="core::arch::x86::_mm256_mask_div_pd fn">_mm256_mask_div_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_div_ps.html" title="core::arch::x86::_mm256_mask_div_ps fn">_mm256_mask_div_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素除以 b 中的包装的元素，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_dpbf16_ps.html" title="core::arch::x86::_mm256_mask_dpbf16_ps fn">_mm256_mask_dpbf16_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span><p>计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间的单精度 (32-bit) 浮点元素与 src 中的元素相加，并使用 writemask k 将结果存储在 dst 中 (当对应的元素从 src 复制时掩码位未设置)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_dpbusd_epi32.html" title="core::arch::x86::_mm256_mask_dpbusd_epi32 fn">_mm256_mask_dpbusd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span><p>将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (未设置相应掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_dpbusds_epi32.html" title="core::arch::x86::_mm256_mask_dpbusds_epi32 fn">_mm256_mask_dpbusds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span><p>将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。使用符号饱和将这 4 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_dpwssd_epi32.html" title="core::arch::x86::_mm256_mask_dpwssd_epi32 fn">_mm256_mask_dpwssd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span><p>将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_dpwssds_epi32.html" title="core::arch::x86::_mm256_mask_dpwssds_epi32 fn">_mm256_mask_dpwssds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span><p>将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_expand_epi8.html" title="core::arch::x86::_mm256_mask_expand_epi8 fn">_mm256_mask_expand_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>从 a 加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_expand_epi16.html" title="core::arch::x86::_mm256_mask_expand_epi16 fn">_mm256_mask_expand_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>从 a 加载连续的活动 16 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_expand_epi32.html" title="core::arch::x86::_mm256_mask_expand_epi32 fn">_mm256_mask_expand_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 加载连续的有效 32 位整数 (它们各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_expand_epi64.html" title="core::arch::x86::_mm256_mask_expand_epi64 fn">_mm256_mask_expand_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 加载连续的有效 64 位整数 (它们各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_expand_pd.html" title="core::arch::x86::_mm256_mask_expand_pd fn">_mm256_mask_expand_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 加载连续的活动双精度 (64-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_expand_ps.html" title="core::arch::x86::_mm256_mask_expand_ps fn">_mm256_mask_expand_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中加载连续的活动单精度 (32-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_extractf32x4_ps.html" title="core::arch::x86::_mm256_mask_extractf32x4_ps fn">_mm256_mask_extractf32x4_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 提取 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并用 imm8 进行选择，并使用写掩码 k 将结果存储在 dst 中 (如果未设置相应的掩码位，则从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_extracti32x4_epi32.html" title="core::arch::x86::_mm256_mask_extracti32x4_epi32 fn">_mm256_mask_extracti32x4_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中提取 128 位 (由 4 个包装的 32 位整数组成)，用 IMM1 选中，用 writemask k 将结果存入 dst 中 (未设置相应掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_fixupimm_pd.html" title="core::arch::x86::_mm256_mask_fixupimm_pd fn">_mm256_mask_fixupimm_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 c 中的包装 64 位整数修复 a 和 b 中的包装双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 a 复制元素)。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_fixupimm_ps.html" title="core::arch::x86::_mm256_mask_fixupimm_ps fn">_mm256_mask_fixupimm_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 c 中的包装 32 位整数修复 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 a 复制元素)。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_fmadd_pd.html" title="core::arch::x86::_mm256_mask_fmadd_pd fn">_mm256_mask_fmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_fmadd_ps.html" title="core::arch::x86::_mm256_mask_fmadd_ps fn">_mm256_mask_fmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_fmaddsub_pd.html" title="core::arch::x86::_mm256_mask_fmaddsub_pd fn">_mm256_mask_fmaddsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 a 中复制元素放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_fmaddsub_ps.html" title="core::arch::x86::_mm256_mask_fmaddsub_ps fn">_mm256_mask_fmaddsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位则从 a 复制元素放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_fmsub_pd.html" title="core::arch::x86::_mm256_mask_fmsub_pd fn">_mm256_mask_fmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (如果未设置相应的掩码位，则从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_fmsub_ps.html" title="core::arch::x86::_mm256_mask_fmsub_ps fn">_mm256_mask_fmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_fmsubadd_pd.html" title="core::arch::x86::_mm256_mask_fmsubadd_pd fn">_mm256_mask_fmsubadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，并使用 writemask k 将结果存储在 dst 中 (当未使用相应的掩码位时，元素将从 a 复制放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_fmsubadd_ps.html" title="core::arch::x86::_mm256_mask_fmsubadd_ps fn">_mm256_mask_fmsubadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 a 复制元素放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_fnmadd_pd.html" title="core::arch::x86::_mm256_mask_fnmadd_pd fn">_mm256_mask_fnmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_fnmadd_ps.html" title="core::arch::x86::_mm256_mask_fnmadd_ps fn">_mm256_mask_fnmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_fnmsub_pd.html" title="core::arch::x86::_mm256_mask_fnmsub_pd fn">_mm256_mask_fnmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_fnmsub_ps.html" title="core::arch::x86::_mm256_mask_fnmsub_ps fn">_mm256_mask_fnmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_getexp_pd.html" title="core::arch::x86::_mm256_mask_getexp_pd fn">_mm256_mask_getexp_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并使用 writemask k 将结果存储在 dst 中 (当相应的 mask 时，元素从 src 复制位未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_getexp_ps.html" title="core::arch::x86::_mm256_mask_getexp_ps fn">_mm256_mask_getexp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，并使用 writemask k 将结果存储在 dst 中 (当相应的 mask 时，元素从 src 复制位未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_getmant_pd.html" title="core::arch::x86::_mm256_mask_getmant_pd fn">_mm256_mask_getmant_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素的尾数标准化，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_getmant_ps.html" title="core::arch::x86::_mm256_mask_getmant_ps fn">_mm256_mask_getmant_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>标准化 a 中包装的单精度 (32-bit) 浮点元素的尾数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_gf2p8affine_epi64_epi8.html" title="core::arch::x86::_mm256_mask_gf2p8affine_epi64_epi8 fn">_mm256_mask_gf2p8affine_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span><p>对 x 中的包装字节执行仿射变换。
也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_gf2p8affineinv_epi64_epi8.html" title="core::arch::x86::_mm256_mask_gf2p8affineinv_epi64_epi8 fn">_mm256_mask_gf2p8affineinv_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span><p>对 x 中的反向包装的字节执行仿射变换。
也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_gf2p8mul_epi8.html" title="core::arch::x86::_mm256_mask_gf2p8mul_epi8 fn">_mm256_mask_gf2p8mul_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span><p>在包装的字节上执行 GF(2^8) 乘法。
该字段以多项式表示，具有约数多项式 x^8 + x^4 + x^3 + x + 1。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_insertf32x4.html" title="core::arch::x86::_mm256_mask_insertf32x4 fn">_mm256_mask_insertf32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 复制到 tmp，然后在 x00X 指定的位置将 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成) 插入 tmp。使用写掩码 k 将 tmp 存储到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_inserti32x4.html" title="core::arch::x86::_mm256_mask_inserti32x4 fn">_mm256_mask_inserti32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 复制到 tmp，然后在 imm8 指定的位置，将 b 中的 128 位 (由 4 个包装的 32 位整数组成) 插入 tmp。使用写掩码 k 将 tmp 存储到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_lzcnt_epi32.html" title="core::arch::x86::_mm256_mask_lzcnt_epi32 fn">_mm256_mask_lzcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>计算 a 中每个包装的 32 位整数中前导零位的数目，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_lzcnt_epi64.html" title="core::arch::x86::_mm256_mask_lzcnt_epi64 fn">_mm256_mask_lzcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>计算 a 中每个包装的 64 位整数中前导零位的数目，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_madd_epi16.html" title="core::arch::x86::_mm256_mask_madd_epi16 fn">_mm256_mask_madd_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。水平添加相邻的中间 32 位整数对，并使用 writemask k 将结果打包到 dst (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_maddubs_epi16.html" title="core::arch::x86::_mm256_mask_maddubs_epi16 fn">_mm256_mask_maddubs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的包装无符号 8 位整数与 b 中的包装有符号 8 位整数相乘，生成中间有符号的 16 位整数。水平相加相邻的中间带符号的 16 位整数对，并使用写掩码 k 将饱和结果包装到 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_max_epi8.html" title="core::arch::x86::_mm256_mask_max_epi8 fn">_mm256_mask_max_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_max_epi16.html" title="core::arch::x86::_mm256_mask_max_epi16 fn">_mm256_mask_max_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_max_epi32.html" title="core::arch::x86::_mm256_mask_max_epi32 fn">_mm256_mask_max_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_max_epi64.html" title="core::arch::x86::_mm256_mask_max_epi64 fn">_mm256_mask_max_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_max_epu8.html" title="core::arch::x86::_mm256_mask_max_epu8 fn">_mm256_mask_max_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_max_epu16.html" title="core::arch::x86::_mm256_mask_max_epu16 fn">_mm256_mask_max_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_max_epu32.html" title="core::arch::x86::_mm256_mask_max_epu32 fn">_mm256_mask_max_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_max_epu64.html" title="core::arch::x86::_mm256_mask_max_epu64 fn">_mm256_mask_max_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_max_pd.html" title="core::arch::x86::_mm256_mask_max_pd fn">_mm256_mask_max_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_max_ps.html" title="core::arch::x86::_mm256_mask_max_ps fn">_mm256_mask_max_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_min_epi8.html" title="core::arch::x86::_mm256_mask_min_epi8 fn">_mm256_mask_min_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_min_epi16.html" title="core::arch::x86::_mm256_mask_min_epi16 fn">_mm256_mask_min_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号 16 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_min_epi32.html" title="core::arch::x86::_mm256_mask_min_epi32 fn">_mm256_mask_min_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_min_epi64.html" title="core::arch::x86::_mm256_mask_min_epi64 fn">_mm256_mask_min_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_min_epu8.html" title="core::arch::x86::_mm256_mask_min_epu8 fn">_mm256_mask_min_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_min_epu16.html" title="core::arch::x86::_mm256_mask_min_epu16 fn">_mm256_mask_min_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_min_epu32.html" title="core::arch::x86::_mm256_mask_min_epu32 fn">_mm256_mask_min_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_min_epu64.html" title="core::arch::x86::_mm256_mask_min_epu64 fn">_mm256_mask_min_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_min_pd.html" title="core::arch::x86::_mm256_mask_min_pd fn">_mm256_mask_min_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_min_ps.html" title="core::arch::x86::_mm256_mask_min_ps fn">_mm256_mask_min_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_mov_epi8.html" title="core::arch::x86::_mm256_mask_mov_epi8 fn">_mm256_mask_mov_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用写掩码 k 将包装的 8 位整数从 a 移到 dst (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_mov_epi16.html" title="core::arch::x86::_mm256_mask_mov_epi16 fn">_mm256_mask_mov_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用写掩码 k 将包装的 16 位整数从 a 移到 dst (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_mov_epi32.html" title="core::arch::x86::_mm256_mask_mov_epi32 fn">_mm256_mask_mov_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用写掩码 k 将包装的 32 位整数从 a 移动到 dst (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_mov_epi64.html" title="core::arch::x86::_mm256_mask_mov_epi64 fn">_mm256_mask_mov_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用写掩码 k 将包装的 64 位整数从 a 移动到 dst (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_mov_pd.html" title="core::arch::x86::_mm256_mask_mov_pd fn">_mm256_mask_mov_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用写掩码 k 将包装的双精度 (64-bit) 浮点元素从 a 移动到 dst (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_mov_ps.html" title="core::arch::x86::_mm256_mask_mov_ps fn">_mm256_mask_mov_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用写掩码 k 将包装的单精度 (32-bit) 浮点元素从 a 移动到 dst (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_movedup_pd.html" title="core::arch::x86::_mm256_mask_movedup_pd fn">_mm256_mask_movedup_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 复制偶数索引的双精度 (64-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_movehdup_ps.html" title="core::arch::x86::_mm256_mask_movehdup_ps fn">_mm256_mask_movehdup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 复制奇数索引的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_moveldup_ps.html" title="core::arch::x86::_mm256_mask_moveldup_ps fn">_mm256_mask_moveldup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 复制偶数索引的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_mul_epi32.html" title="core::arch::x86::_mm256_mask_mul_epi32 fn">_mm256_mask_mul_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中每个包装的 64 位元素的低符号 32 位整数相乘，并使用写掩码 k 将有符号的 64 位结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_mul_epu32.html" title="core::arch::x86::_mm256_mask_mul_epu32 fn">_mm256_mask_mul_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中每个包装的 64 位元素的低无符号 32 位整数相乘，并使用写掩码 k 将无符号 64 位结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_mul_pd.html" title="core::arch::x86::_mm256_mask_mul_pd fn">_mm256_mask_mul_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_mul_ps.html" title="core::arch::x86::_mm256_mask_mul_ps fn">_mm256_mask_mul_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_mulhi_epi16.html" title="core::arch::x86::_mm256_mask_mulhi_epi16 fn">_mm256_mask_mulhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 和 b 中包装的带符号的 16 位整数相乘，生成 32 位中间整数，并使用写掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_mulhi_epu16.html" title="core::arch::x86::_mm256_mask_mulhi_epu16 fn">_mm256_mask_mulhi_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 和 b 中包装的无符号 16 位整数相乘，生成 32 位中间整数，并使用写掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_mulhrs_epi16.html" title="core::arch::x86::_mm256_mask_mulhrs_epi16 fn">_mm256_mask_mulhrs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。将每个中间整数截断为 18 个最高有效位，通过加 1 舍入，并使用 writemask k 将位 [16:1] 存储到 dst (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_mullo_epi16.html" title="core::arch::x86::_mm256_mask_mullo_epi16 fn">_mm256_mask_mullo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 和 b 中的包装的 16 位整数相乘，生成中间的 32 位整数，并使用写掩码 k 将中间整数的低 16 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_mullo_epi32.html" title="core::arch::x86::_mm256_mask_mullo_epi32 fn">_mm256_mask_mullo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装的 32 位整数相乘，生成中间 64 位整数，并使用写掩码 k 将中间整数的低 32 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_multishift_epi64_epi8.html" title="core::arch::x86::_mm256_mask_multishift_epi64_epi8 fn">_mm256_mask_multishift_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span><p>对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并使用 writemask k (元素当相应的屏蔽位未设置时，从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_or_epi32.html" title="core::arch::x86::_mm256_mask_or_epi32 fn">_mm256_mask_or_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 32 位整数的按位或，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_or_epi64.html" title="core::arch::x86::_mm256_mask_or_epi64 fn">_mm256_mask_or_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 64 位整数的按位或，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_packs_epi16.html" title="core::arch::x86::_mm256_mask_packs_epi16 fn">_mm256_mask_packs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用带符号的饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_packs_epi32.html" title="core::arch::x86::_mm256_mask_packs_epi32 fn">_mm256_mask_packs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用带符号的饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_packus_epi16.html" title="core::arch::x86::_mm256_mask_packus_epi16 fn">_mm256_mask_packus_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用无符号饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_packus_epi32.html" title="core::arch::x86::_mm256_mask_packus_epi32 fn">_mm256_mask_packus_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用无符号饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_permute_pd.html" title="core::arch::x86::_mm256_mask_permute_pd fn">_mm256_mask_permute_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件在 128 位通道内对双精度 (64-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_permute_ps.html" title="core::arch::x86::_mm256_mask_permute_ps fn">_mm256_mask_permute_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_permutevar_pd.html" title="core::arch::x86::_mm256_mask_permutevar_pd fn">_mm256_mask_permutevar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 b 中的控件在 128 位通道内将 a 的双精度 (64-bit) 浮点元素进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_permutevar_ps.html" title="core::arch::x86::_mm256_mask_permutevar_ps fn">_mm256_mask_permutevar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 b 中的控件在 128 位通道内将 a 的单精度 (32-bit) 浮点元素打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_permutex2var_epi8.html" title="core::arch::x86::_mm256_mask_permutex2var_epi8 fn">_mm256_mask_permutex2var_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span><p>使用相应的选择器和 idx 中的索引将 a 和 b 中的 8 位整数跨通道打乱，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_permutex2var_epi16.html" title="core::arch::x86::_mm256_mask_permutex2var_epi16 fn">_mm256_mask_permutex2var_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用相应的选择器和 idx 中的索引在通道中的 a 和 b 中对 16 位整数进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_permutex2var_epi32.html" title="core::arch::x86::_mm256_mask_permutex2var_epi32 fn">_mm256_mask_permutex2var_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中对 32 位整数进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_permutex2var_epi64.html" title="core::arch::x86::_mm256_mask_permutex2var_epi64 fn">_mm256_mask_permutex2var_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中随机排列 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_permutex2var_pd.html" title="core::arch::x86::_mm256_mask_permutex2var_pd fn">_mm256_mask_permutex2var_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_permutex2var_ps.html" title="core::arch::x86::_mm256_mask_permutex2var_ps fn">_mm256_mask_permutex2var_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用对应的选择器和 idx 中的索引在 a 和 b 中的通道上对 a 和 b 中的单精度 (32-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_permutex_epi64.html" title="core::arch::x86::_mm256_mask_permutex_epi64 fn">_mm256_mask_permutex_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件在 256 位通道内将 64 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_permutex_pd.html" title="core::arch::x86::_mm256_mask_permutex_pd fn">_mm256_mask_permutex_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件在 256 位通道内对双精度 (64-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_permutexvar_epi8.html" title="core::arch::x86::_mm256_mask_permutexvar_epi8 fn">_mm256_mask_permutexvar_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span><p>使用 idx 中的相应索引在跨通道的 a 中打乱 8 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_permutexvar_epi16.html" title="core::arch::x86::_mm256_mask_permutexvar_epi16 fn">_mm256_mask_permutexvar_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用 idx 中的相应索引在跨通道中对 16 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_permutexvar_epi32.html" title="core::arch::x86::_mm256_mask_permutexvar_epi32 fn">_mm256_mask_permutexvar_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的相应索引在跨通道中对 32 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_permutexvar_epi64.html" title="core::arch::x86::_mm256_mask_permutexvar_epi64 fn">_mm256_mask_permutexvar_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的相应索引在跨通道中随机排列 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_permutexvar_pd.html" title="core::arch::x86::_mm256_mask_permutexvar_pd fn">_mm256_mask_permutexvar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的相应索引对跨通道中的双精度 (64-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_permutexvar_ps.html" title="core::arch::x86::_mm256_mask_permutexvar_ps fn">_mm256_mask_permutexvar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的相应索引对跨通道中的单精度 (32-bit) 浮点元素进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_popcnt_epi8.html" title="core::arch::x86::_mm256_mask_popcnt_epi8 fn">_mm256_mask_popcnt_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span><p>对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_popcnt_epi16.html" title="core::arch::x86::_mm256_mask_popcnt_epi16 fn">_mm256_mask_popcnt_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span><p>对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_popcnt_epi32.html" title="core::arch::x86::_mm256_mask_popcnt_epi32 fn">_mm256_mask_popcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq,avx512vl` only"><code>avx512vpopcntdq,avx512vl</code></span><p>对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_popcnt_epi64.html" title="core::arch::x86::_mm256_mask_popcnt_epi64 fn">_mm256_mask_popcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq,avx512vl` only"><code>avx512vpopcntdq,avx512vl</code></span><p>对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_rcp14_pd.html" title="core::arch::x86::_mm256_mask_rcp14_pd fn">_mm256_mask_rcp14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_rcp14_ps.html" title="core::arch::x86::_mm256_mask_rcp14_ps fn">_mm256_mask_rcp14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_rol_epi32.html" title="core::arch::x86::_mm256_mask_rol_epi32 fn">_mm256_mask_rol_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_rol_epi64.html" title="core::arch::x86::_mm256_mask_rol_epi64 fn">_mm256_mask_rol_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_rolv_epi32.html" title="core::arch::x86::_mm256_mask_rolv_epi32 fn">_mm256_mask_rolv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的 32 位整数中的位向左旋转 b 对应元素 b 中指定的位数，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 src 复制元素放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_rolv_epi64.html" title="core::arch::x86::_mm256_mask_rolv_epi64 fn">_mm256_mask_rolv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的 64 位整数中的位向左旋转 b 的对应元素中指定的位数，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 src 复制元素放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_ror_epi32.html" title="core::arch::x86::_mm256_mask_ror_epi32 fn">_mm256_mask_ror_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 X 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_ror_epi64.html" title="core::arch::x86::_mm256_mask_ror_epi64 fn">_mm256_mask_ror_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 X 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_rorv_epi32.html" title="core::arch::x86::_mm256_mask_rorv_epi32 fn">_mm256_mask_rorv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的 32 位整数中的位向右旋转 b 的对应元素中指定的位数，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 src 复制元素放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_rorv_epi64.html" title="core::arch::x86::_mm256_mask_rorv_epi64 fn">_mm256_mask_rorv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 src 复制元素放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_roundscale_pd.html" title="core::arch::x86::_mm256_mask_roundscale_pd fn">_mm256_mask_roundscale_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_roundscale_ps.html" title="core::arch::x86::_mm256_mask_roundscale_ps fn">_mm256_mask_roundscale_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的小数位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_rsqrt14_pd.html" title="core::arch::x86::_mm256_mask_rsqrt14_pd fn">_mm256_mask_rsqrt14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_rsqrt14_ps.html" title="core::arch::x86::_mm256_mask_rsqrt14_ps fn">_mm256_mask_rsqrt14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_scalef_pd.html" title="core::arch::x86::_mm256_mask_scalef_pd fn">_mm256_mask_scalef_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_scalef_ps.html" title="core::arch::x86::_mm256_mask_scalef_ps fn">_mm256_mask_scalef_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_set1_epi8.html" title="core::arch::x86::_mm256_mask_set1_epi8 fn">_mm256_mask_set1_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用写掩码 k 将 8 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_set1_epi16.html" title="core::arch::x86::_mm256_mask_set1_epi16 fn">_mm256_mask_set1_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用写掩码 k 向 dst 的所有元素广播 16 位整数 a (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_set1_epi32.html" title="core::arch::x86::_mm256_mask_set1_epi32 fn">_mm256_mask_set1_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用写掩码 k 将 32 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_set1_epi64.html" title="core::arch::x86::_mm256_mask_set1_epi64 fn">_mm256_mask_set1_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用写掩码 k 将 64 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_shldi_epi16.html" title="core::arch::x86::_mm256_mask_shldi_epi16 fn">_mm256_mask_shldi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并使用 writemask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_shldi_epi32.html" title="core::arch::x86::_mm256_mask_shldi_epi32 fn">_mm256_mask_shldi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并使用 writemask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_shldi_epi64.html" title="core::arch::x86::_mm256_mask_shldi_epi64 fn">_mm256_mask_shldi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并使用 writemask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_shldv_epi16.html" title="core::arch::x86::_mm256_mask_shldv_epi16 fn">_mm256_mask_shldv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_shldv_epi32.html" title="core::arch::x86::_mm256_mask_shldv_epi32 fn">_mm256_mask_shldv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_shldv_epi64.html" title="core::arch::x86::_mm256_mask_shldv_epi64 fn">_mm256_mask_shldv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_shrdi_epi16.html" title="core::arch::x86::_mm256_mask_shrdi_epi16 fn">_mm256_mask_shrdi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并使用 writemask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_shrdi_epi32.html" title="core::arch::x86::_mm256_mask_shrdi_epi32 fn">_mm256_mask_shrdi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并使用 writemask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_shrdi_epi64.html" title="core::arch::x86::_mm256_mask_shrdi_epi64 fn">_mm256_mask_shrdi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并使用 writemask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，元素从 src` 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_shrdv_epi16.html" title="core::arch::x86::_mm256_mask_shrdv_epi16 fn">_mm256_mask_shrdv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_shrdv_epi32.html" title="core::arch::x86::_mm256_mask_shrdv_epi32 fn">_mm256_mask_shrdv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_shrdv_epi64.html" title="core::arch::x86::_mm256_mask_shrdv_epi64 fn">_mm256_mask_shrdv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_shuffle_epi8.html" title="core::arch::x86::_mm256_mask_shuffle_epi8 fn">_mm256_mask_shuffle_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用 b 中相应的 8 位元素中的控件在 128 位通道内对 a 中的 8 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_shuffle_epi32.html" title="core::arch::x86::_mm256_mask_shuffle_epi32 fn">_mm256_mask_shuffle_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件将 128 位通道中的 32 位整数随机排列，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_shuffle_f32x4.html" title="core::arch::x86::_mm256_mask_shuffle_f32x4 fn">_mm256_mask_shuffle_f32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 imm8 从 a 和 b 中选择的 128 位 (由 4 个单精度 (32-bit) 浮点元素组成) 混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_shuffle_f64x2.html" title="core::arch::x86::_mm256_mask_shuffle_f64x2 fn">_mm256_mask_shuffle_f64x2</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 imm8 从 a 和 b 中选择的 128 位 (由 2 个双精度 (64-bit) 浮点元素组成) 混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_shuffle_i32x4.html" title="core::arch::x86::_mm256_mask_shuffle_i32x4 fn">_mm256_mask_shuffle_i32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 imm8 从 a 和 b 中选择的 128 位 (由 4 个 32 位整数组成) 重排，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_shuffle_i64x2.html" title="core::arch::x86::_mm256_mask_shuffle_i64x2 fn">_mm256_mask_shuffle_i64x2</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 imm8 从 a 和 b 中选择的 128 位 (由 2 个 64 位整数组成) 进行混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_shuffle_pd.html" title="core::arch::x86::_mm256_mask_shuffle_pd fn">_mm256_mask_shuffle_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件对 128 位通道中的双精度 (64-bit) 浮点元素进行混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_shuffle_ps.html" title="core::arch::x86::_mm256_mask_shuffle_ps fn">_mm256_mask_shuffle_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_shufflehi_epi16.html" title="core::arch::x86::_mm256_mask_shufflehi_epi16 fn">_mm256_mask_shufflehi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用 imm8 中的控件在 a 的 128 位通道的高 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的高 64 位中，将 128 位通道的低 64 位从 a 复制到 dst，使用写掩码 k (当相应的掩码位不存在时，元素从 src 复制放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_shufflelo_epi16.html" title="core::arch::x86::_mm256_mask_shufflelo_epi16 fn">_mm256_mask_shufflelo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用 imm8 中的控件在 a 的 128 位通道的低 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的低 64 位中，并使用写掩码 k 将 128 位通道的高 64 位从 a 复制到 dst (当未使用相应的掩码位时，元素从 src 复制) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_sll_epi16.html" title="core::arch::x86::_mm256_mask_sll_epi16 fn">_mm256_mask_sll_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数按计数左移，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_sll_epi32.html" title="core::arch::x86::_mm256_mask_sll_epi32 fn">_mm256_mask_sll_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 32 位整数左移计数，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_sll_epi64.html" title="core::arch::x86::_mm256_mask_sll_epi64 fn">_mm256_mask_sll_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 64 位整数左移计数，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_slli_epi16.html" title="core::arch::x86::_mm256_mask_slli_epi16 fn">_mm256_mask_slli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数左移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_slli_epi32.html" title="core::arch::x86::_mm256_mask_slli_epi32 fn">_mm256_mask_slli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 32 位整数左移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_slli_epi64.html" title="core::arch::x86::_mm256_mask_slli_epi64 fn">_mm256_mask_slli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 64 位整数向左移动 imm8，同时向零移动，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_sllv_epi16.html" title="core::arch::x86::_mm256_mask_sllv_epi16 fn">_mm256_mask_sllv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数按 count 中相应元素指定的数量向左移位，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_sllv_epi32.html" title="core::arch::x86::_mm256_mask_sllv_epi32 fn">_mm256_mask_sllv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将填充的 32 位整数向左移动计数中相应元素指定的数量，同时将其移位为零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_sllv_epi64.html" title="core::arch::x86::_mm256_mask_sllv_epi64 fn">_mm256_mask_sllv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将填充的 64 位整数向左移动 count 中相应元素指定的数量，同时将其移位为零，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_sqrt_pd.html" title="core::arch::x86::_mm256_mask_sqrt_pd fn">_mm256_mask_sqrt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_sqrt_ps.html" title="core::arch::x86::_mm256_mask_sqrt_ps fn">_mm256_mask_sqrt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_sra_epi16.html" title="core::arch::x86::_mm256_mask_sra_epi16 fn">_mm256_mask_sra_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数按计数右移，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_sra_epi32.html" title="core::arch::x86::_mm256_mask_sra_epi32 fn">_mm256_mask_sra_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在移动符号位的同时右移计数包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_sra_epi64.html" title="core::arch::x86::_mm256_mask_sra_epi64 fn">_mm256_mask_sra_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在移动符号位的同时右移计数包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_srai_epi16.html" title="core::arch::x86::_mm256_mask_srai_epi16 fn">_mm256_mask_srai_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_srai_epi32.html" title="core::arch::x86::_mm256_mask_srai_epi32 fn">_mm256_mask_srai_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 32 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_srai_epi64.html" title="core::arch::x86::_mm256_mask_srai_epi64 fn">_mm256_mask_srai_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 64 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_srav_epi16.html" title="core::arch::x86::_mm256_mask_srav_epi16 fn">_mm256_mask_srav_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数右移 count 中相应元素指定的数量，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_srav_epi32.html" title="core::arch::x86::_mm256_mask_srav_epi32 fn">_mm256_mask_srav_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在将符号位移位的同时，将已包装的 32 位整数向右移动计数中相应元素指定的数量，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_srav_epi64.html" title="core::arch::x86::_mm256_mask_srav_epi64 fn">_mm256_mask_srav_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在移入符号位的同时，将包装的 64 位整数向右移动计数中相应元素指定的数量，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_srl_epi16.html" title="core::arch::x86::_mm256_mask_srl_epi16 fn">_mm256_mask_srl_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数右移，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_srl_epi32.html" title="core::arch::x86::_mm256_mask_srl_epi32 fn">_mm256_mask_srl_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 32 位整数右移，同时移零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_srl_epi64.html" title="core::arch::x86::_mm256_mask_srl_epi64 fn">_mm256_mask_srl_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 64 位整数右移，同时移零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_srli_epi16.html" title="core::arch::x86::_mm256_mask_srli_epi16 fn">_mm256_mask_srli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_srli_epi32.html" title="core::arch::x86::_mm256_mask_srli_epi32 fn">_mm256_mask_srli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 32 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_srli_epi64.html" title="core::arch::x86::_mm256_mask_srli_epi64 fn">_mm256_mask_srli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 64 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_srlv_epi16.html" title="core::arch::x86::_mm256_mask_srlv_epi16 fn">_mm256_mask_srlv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_srlv_epi32.html" title="core::arch::x86::_mm256_mask_srlv_epi32 fn">_mm256_mask_srlv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>向右移动包装的 32 位整数整数 (由 count 中相应元素指定的数量)，同时向零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_srlv_epi64.html" title="core::arch::x86::_mm256_mask_srlv_epi64 fn">_mm256_mask_srlv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>向右移位包装的 64 位整数，其数量为计数中相应元素指定的数量，同时向零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_sub_epi8.html" title="core::arch::x86::_mm256_mask_sub_epi8 fn">_mm256_mask_sub_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>从 a 中的包装 8 位整数中减去 b 中的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_sub_epi16.html" title="core::arch::x86::_mm256_mask_sub_epi16 fn">_mm256_mask_sub_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>从 a 中的包装的 16 位整数中减去 b 中的包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_sub_epi32.html" title="core::arch::x86::_mm256_mask_sub_epi32 fn">_mm256_mask_sub_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中的包装 32 位整数中减去 b 中的包装 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_sub_epi64.html" title="core::arch::x86::_mm256_mask_sub_epi64 fn">_mm256_mask_sub_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中的包装 64 位整数中减去 b 中的包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_sub_pd.html" title="core::arch::x86::_mm256_mask_sub_pd fn">_mm256_mask_sub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_sub_ps.html" title="core::arch::x86::_mm256_mask_sub_ps fn">_mm256_mask_sub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 b 中的包装后的单精度 (32-bit) 浮点元素减去 a 中的包装后的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_subs_epi8.html" title="core::arch::x86::_mm256_mask_subs_epi8 fn">_mm256_mask_subs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用饱和度将 b 中的包装 8 位整数减去 b 中的包装 8 位有符号整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_subs_epi16.html" title="core::arch::x86::_mm256_mask_subs_epi16 fn">_mm256_mask_subs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用饱和度将 b 中的包装 16 位整数减去 b 中的包装有符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_subs_epu8.html" title="core::arch::x86::_mm256_mask_subs_epu8 fn">_mm256_mask_subs_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用 a 饱和度将 b 中的包装无符号 8 位整数减去 b 中的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_subs_epu16.html" title="core::arch::x86::_mm256_mask_subs_epu16 fn">_mm256_mask_subs_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用 a 饱和度从 b 中的包装无符号 16 位整数减去 b 中的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_ternarylogic_epi32.html" title="core::arch::x86::_mm256_mask_ternarylogic_epi32 fn">_mm256_mask_ternarylogic_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 32 位整数中的每一位，使用 src、a 和 b 中的相应位形成 imm8 的 3 位索引，并使用 writemask 将 imm8 中该位的值写入 dst 中的相应位 k 在 32 位粒度 (当相应的掩码位未设置时，从 src 复制 32 位元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_ternarylogic_epi64.html" title="core::arch::x86::_mm256_mask_ternarylogic_epi64 fn">_mm256_mask_ternarylogic_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 64 位整数中的每一位，src、a 和 b 中的相应位用于形成 imm8 的 3 位索引，并使用 writemask 将 imm8 中该位的值写入 dst 中的相应位 k 在 64 位粒度 (当相应的掩码位未设置时，从 src 复制 64 位元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_test_epi8_mask.html" title="core::arch::x86::_mm256_mask_test_epi8_mask fn">_mm256_mask_test_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 和 b 中包装的 8 位整数的按位与，生成中间 8 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_test_epi16_mask.html" title="core::arch::x86::_mm256_mask_test_epi16_mask fn">_mm256_mask_test_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 和 b 中包装的 16 位整数的按位与，生成中间的 16 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_test_epi32_mask.html" title="core::arch::x86::_mm256_mask_test_epi32_mask fn">_mm256_mask_test_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 32 位整数的按位与，生成中间的 32 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_test_epi64_mask.html" title="core::arch::x86::_mm256_mask_test_epi64_mask fn">_mm256_mask_test_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 64 位整数的按位与，生成中间 64 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_testn_epi8_mask.html" title="core::arch::x86::_mm256_mask_testn_epi8_mask fn">_mm256_mask_testn_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 和 b 中包装的 8 位整数的按位 NAND，生成中间的 8 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_testn_epi16_mask.html" title="core::arch::x86::_mm256_mask_testn_epi16_mask fn">_mm256_mask_testn_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 和 b 中包装的 16 位整数的按位 NAND，生成中间的 16 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_testn_epi32_mask.html" title="core::arch::x86::_mm256_mask_testn_epi32_mask fn">_mm256_mask_testn_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 32 位整数的按位 NAND，生成中间的 32 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_testn_epi64_mask.html" title="core::arch::x86::_mm256_mask_testn_epi64_mask fn">_mm256_mask_testn_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 64 位整数的按位 NAND，生成中间 64 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_unpackhi_epi8.html" title="core::arch::x86::_mm256_mask_unpackhi_epi8 fn">_mm256_mask_unpackhi_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的高半部分拆包和交织 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_unpackhi_epi16.html" title="core::arch::x86::_mm256_mask_unpackhi_epi16 fn">_mm256_mask_unpackhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的高半部分拆包和交织 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_unpackhi_epi32.html" title="core::arch::x86::_mm256_mask_unpackhi_epi32 fn">_mm256_mask_unpackhi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_unpackhi_epi64.html" title="core::arch::x86::_mm256_mask_unpackhi_epi64 fn">_mm256_mask_unpackhi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_unpackhi_pd.html" title="core::arch::x86::_mm256_mask_unpackhi_pd fn">_mm256_mask_unpackhi_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_unpackhi_ps.html" title="core::arch::x86::_mm256_mask_unpackhi_ps fn">_mm256_mask_unpackhi_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_unpacklo_epi8.html" title="core::arch::x86::_mm256_mask_unpacklo_epi8 fn">_mm256_mask_unpacklo_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的下半部分拆包和交织 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_unpacklo_epi16.html" title="core::arch::x86::_mm256_mask_unpacklo_epi16 fn">_mm256_mask_unpacklo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的下半部分拆包和交织 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_unpacklo_epi32.html" title="core::arch::x86::_mm256_mask_unpacklo_epi32 fn">_mm256_mask_unpacklo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包和交织 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_unpacklo_epi64.html" title="core::arch::x86::_mm256_mask_unpacklo_epi64 fn">_mm256_mask_unpacklo_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包和交织 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_unpacklo_pd.html" title="core::arch::x86::_mm256_mask_unpacklo_pd fn">_mm256_mask_unpacklo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包并交织双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_unpacklo_ps.html" title="core::arch::x86::_mm256_mask_unpacklo_ps fn">_mm256_mask_unpacklo_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包并交织单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_xor_epi32.html" title="core::arch::x86::_mm256_mask_xor_epi32 fn">_mm256_mask_xor_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 32 位整数的按位 XOR，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_mask_xor_epi64.html" title="core::arch::x86::_mm256_mask_xor_epi64 fn">_mm256_mask_xor_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 64 位整数的按位 XOR，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_abs_epi8.html" title="core::arch::x86::_mm256_maskz_abs_epi8 fn">_mm256_maskz_abs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 中包装的带符号的 8 位整数的绝对值，并使用零掩码 k 将无符号结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_abs_epi16.html" title="core::arch::x86::_mm256_maskz_abs_epi16 fn">_mm256_maskz_abs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 中包装的带符号的 16 位整数的绝对值，并使用零掩码 k (将未设置相应掩码位的元素清零) 将无符号结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_abs_epi32.html" title="core::arch::x86::_mm256_maskz_abs_epi32 fn">_mm256_maskz_abs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的有符号 32 位整数的绝对值，并使用 zeromask k 将无符号结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_abs_epi64.html" title="core::arch::x86::_mm256_maskz_abs_epi64 fn">_mm256_maskz_abs_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的带符号的 64 位整数的绝对值，并使用零掩码 k (将未设置相应掩码位的元素清零) 将无符号结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_add_epi8.html" title="core::arch::x86::_mm256_maskz_add_epi8 fn">_mm256_maskz_add_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>在 a 和 b 中添加包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_add_epi16.html" title="core::arch::x86::_mm256_maskz_add_epi16 fn">_mm256_maskz_add_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数添加到 a 和 b 中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_add_epi32.html" title="core::arch::x86::_mm256_maskz_add_epi32 fn">_mm256_maskz_add_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 32 位整数添加到 a 和 b 中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_add_epi64.html" title="core::arch::x86::_mm256_maskz_add_epi64 fn">_mm256_maskz_add_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在 a 和 b 中添加包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_add_pd.html" title="core::arch::x86::_mm256_maskz_add_pd fn">_mm256_maskz_add_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_add_ps.html" title="core::arch::x86::_mm256_maskz_add_ps fn">_mm256_maskz_add_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_adds_epi8.html" title="core::arch::x86::_mm256_maskz_adds_epi8 fn">_mm256_maskz_adds_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用饱和度在 a 和 b 中添加包装的带符号的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_adds_epi16.html" title="core::arch::x86::_mm256_maskz_adds_epi16 fn">_mm256_maskz_adds_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用饱和度在 a 和 b 中添加包装的带符号的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_adds_epu8.html" title="core::arch::x86::_mm256_maskz_adds_epu8 fn">_mm256_maskz_adds_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用饱和度在 a 和 b 中添加包装的无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_adds_epu16.html" title="core::arch::x86::_mm256_maskz_adds_epu16 fn">_mm256_maskz_adds_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用饱和度在 a 和 b 中添加包装的无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_alignr_epi8.html" title="core::arch::x86::_mm256_maskz_alignr_epi8 fn">_mm256_maskz_alignr_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 和 b 中的 16 字节块对连接成一个 32 字节的临时结果，将结果右移 imm8 字节，并使用零掩码 k 将低 16 字节存储在 dst 中 (当未使用相应的掩码位时元素清零) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_alignr_epi32.html" title="core::arch::x86::_mm256_maskz_alignr_epi32 fn">_mm256_maskz_alignr_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 连接成一个 64 字节的 immediate 结果，将结果右移 imm8 个 32 位元素，并使用 zeromask k 将低 32 字节 (8 个元素) 存储在 dst 中 (当相应的掩码位不存在时，元素被清零放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_alignr_epi64.html" title="core::arch::x86::_mm256_maskz_alignr_epi64 fn">_mm256_maskz_alignr_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 连接成 64 字节的 immediate 结果，将结果右移 imm8 个 64 位元素，并使用 zeromask k 将低 32 字节 (4 个元素) 存储在 dst 中 (当相应的掩码位不存在时，元素被清零放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_and_epi32.html" title="core::arch::x86::_mm256_maskz_and_epi32 fn">_mm256_maskz_and_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 32 位整数的按位与，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_and_epi64.html" title="core::arch::x86::_mm256_maskz_and_epi64 fn">_mm256_maskz_and_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 64 位整数的按位与，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_andnot_epi32.html" title="core::arch::x86::_mm256_maskz_andnot_epi32 fn">_mm256_maskz_andnot_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的 32 位整数的按位 NOT，然后计算 b 中的 AND，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_andnot_epi64.html" title="core::arch::x86::_mm256_maskz_andnot_epi64 fn">_mm256_maskz_andnot_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的 64 位整数的按位 NOT，然后与 b 计算 AND，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_avg_epu8.html" title="core::arch::x86::_mm256_maskz_avg_epu8 fn">_mm256_maskz_avg_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 和 b 中包装的无符号 8 位整数进行平均，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_avg_epu16.html" title="core::arch::x86::_mm256_maskz_avg_epu16 fn">_mm256_maskz_avg_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 和 b 中包装的无符号 16 位整数进行平均，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_broadcast_f32x4.html" title="core::arch::x86::_mm256_maskz_broadcast_f32x4 fn">_mm256_maskz_broadcast_f32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用零掩码 k 将 4 个包装的单精度 (32-bit) 浮点元素从 a 广播到 dst 的所有元素 (未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_broadcast_i32x4.html" title="core::arch::x86::_mm256_maskz_broadcast_i32x4 fn">_mm256_maskz_broadcast_i32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用零掩码 k 将 4 的包装的 32 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_broadcastb_epi8.html" title="core::arch::x86::_mm256_maskz_broadcastb_epi8 fn">_mm256_maskz_broadcastb_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用零掩码 k 将低包装的 8 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_broadcastd_epi32.html" title="core::arch::x86::_mm256_maskz_broadcastd_epi32 fn">_mm256_maskz_broadcastd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用零掩码 k 将低包装的 32 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_broadcastq_epi64.html" title="core::arch::x86::_mm256_maskz_broadcastq_epi64 fn">_mm256_maskz_broadcastq_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用零掩码 k 将低包装的 64 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_broadcastsd_pd.html" title="core::arch::x86::_mm256_maskz_broadcastsd_pd fn">_mm256_maskz_broadcastsd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用零掩码 k 将低双精度 (64-bit) 浮点元素从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_broadcastss_ps.html" title="core::arch::x86::_mm256_maskz_broadcastss_ps fn">_mm256_maskz_broadcastss_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用零掩码 k 将低单精度 (32-bit) 浮点元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_broadcastw_epi16.html" title="core::arch::x86::_mm256_maskz_broadcastw_epi16 fn">_mm256_maskz_broadcastw_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用零掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_compress_epi8.html" title="core::arch::x86::_mm256_maskz_compress_epi8 fn">_mm256_maskz_compress_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 a 中的活动 8 位整数 (它们各自的位设置在 zeromask k 中) 连续存储到 dst，并将其余元素设置为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_compress_epi16.html" title="core::arch::x86::_mm256_maskz_compress_epi16 fn">_mm256_maskz_compress_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 a 中的活动 16 位整数 (它们各自的位设置在 zeromask k 中) 连续存储到 dst，并将其余元素设置为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_compress_epi32.html" title="core::arch::x86::_mm256_maskz_compress_epi32 fn">_mm256_maskz_compress_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将活动的 32 位整数连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的整数) 为 dst，并将其余元素设置为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_compress_epi64.html" title="core::arch::x86::_mm256_maskz_compress_epi64 fn">_mm256_maskz_compress_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将活动的 64 位整数连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的整数) 为 dst，并将其余元素设置为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_compress_pd.html" title="core::arch::x86::_mm256_maskz_compress_pd fn">_mm256_maskz_compress_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将活动的双精度 (64-bit) 浮点元素连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的那些元素) 为 dst，并将其余元素设置为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_compress_ps.html" title="core::arch::x86::_mm256_maskz_compress_ps fn">_mm256_maskz_compress_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将活动的单精度 (32-bit) 浮点元素连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的那些元素) 为 dst，并将其余元素设置为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_conflict_epi32.html" title="core::arch::x86::_mm256_maskz_conflict_epi32 fn">_mm256_maskz_conflict_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>使用零掩码 k (在未设置相应的掩码位时将元素清零)，测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_conflict_epi64.html" title="core::arch::x86::_mm256_maskz_conflict_epi64 fn">_mm256_maskz_conflict_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>使用零掩码 k (在未设置相应的掩码位时将元素清零)，测试 a 的每个 64 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvt_roundps_ph.html" title="core::arch::x86::_mm256_maskz_cvt_roundps_ph fn">_mm256_maskz_cvt_roundps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtepi8_epi16.html" title="core::arch::x86::_mm256_maskz_cvtepi8_epi16 fn">_mm256_maskz_cvtepi8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用符号将包装的 8 位整数从 a 扩展为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtepi8_epi32.html" title="core::arch::x86::_mm256_maskz_cvtepi8_epi32 fn">_mm256_maskz_cvtepi8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用符号将包装的 8 位整数从 a 扩展为包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtepi8_epi64.html" title="core::arch::x86::_mm256_maskz_cvtepi8_epi64 fn">_mm256_maskz_cvtepi8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 的低 4 字节中的 8 位整数符号扩展为包装的 64 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtepi16_epi8.html" title="core::arch::x86::_mm256_maskz_cvtepi16_epi8 fn">_mm256_maskz_cvtepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将带有 a 的包装的 16 位整数转换为带截断的 8 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtepi16_epi32.html" title="core::arch::x86::_mm256_maskz_cvtepi16_epi32 fn">_mm256_maskz_cvtepi16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>符号将包装的 16 位整数从 a 扩展为包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtepi16_epi64.html" title="core::arch::x86::_mm256_maskz_cvtepi16_epi64 fn">_mm256_maskz_cvtepi16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用符号将包装的 16 位整数从 a 扩展为包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtepi32_epi8.html" title="core::arch::x86::_mm256_maskz_cvtepi32_epi8 fn">_mm256_maskz_cvtepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将带有 a 的包装的 32 位整数转换为带有截断的包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtepi32_epi16.html" title="core::arch::x86::_mm256_maskz_cvtepi32_epi16 fn">_mm256_maskz_cvtepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtepi32_epi64.html" title="core::arch::x86::_mm256_maskz_cvtepi32_epi64 fn">_mm256_maskz_cvtepi32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用符号将包装的 32 位整数从 a 扩展为包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtepi32_pd.html" title="core::arch::x86::_mm256_maskz_cvtepi32_pd fn">_mm256_maskz_cvtepi32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装有符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtepi32_ps.html" title="core::arch::x86::_mm256_maskz_cvtepi32_ps fn">_mm256_maskz_cvtepi32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装有符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用零掩码 k (未设置相应的掩码位时将元素清零) 将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtepi64_epi8.html" title="core::arch::x86::_mm256_maskz_cvtepi64_epi8 fn">_mm256_maskz_cvtepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将带有 a 的包装的 64 位整数转换为带截断的 8 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtepi64_epi16.html" title="core::arch::x86::_mm256_maskz_cvtepi64_epi16 fn">_mm256_maskz_cvtepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将带有 a 的包装的 64 位整数转换为带截断的 16 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtepi64_epi32.html" title="core::arch::x86::_mm256_maskz_cvtepi64_epi32 fn">_mm256_maskz_cvtepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的 64 位整数转换为带截断的 32 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtepu8_epi16.html" title="core::arch::x86::_mm256_maskz_cvtepu8_epi16 fn">_mm256_maskz_cvtepu8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的包装无符号 8 位整数零扩展为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtepu8_epi32.html" title="core::arch::x86::_mm256_maskz_cvtepu8_epi32 fn">_mm256_maskz_cvtepu8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>零扩展包装的无符号 8 位整数 a 的低 8 字节到包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtepu8_epi64.html" title="core::arch::x86::_mm256_maskz_cvtepu8_epi64 fn">_mm256_maskz_cvtepu8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>零扩展包装的无符号 8 位整数在 a 的低 4 字节到包装的 64 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtepu16_epi32.html" title="core::arch::x86::_mm256_maskz_cvtepu16_epi32 fn">_mm256_maskz_cvtepu16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 16 位整数零扩展为包装 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtepu16_epi64.html" title="core::arch::x86::_mm256_maskz_cvtepu16_epi64 fn">_mm256_maskz_cvtepu16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>零扩展包装的无符号 16 位整数 a 的低 8 字节到包装的 64 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtepu32_epi64.html" title="core::arch::x86::_mm256_maskz_cvtepu32_epi64 fn">_mm256_maskz_cvtepu32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 32 位整数零扩展为包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtepu32_pd.html" title="core::arch::x86::_mm256_maskz_cvtepu32_pd fn">_mm256_maskz_cvtepu32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtne2ps_pbh.html" title="core::arch::x86::_mm256_maskz_cvtne2ps_pbh fn">_mm256_maskz_cvtne2ps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span><p>将两个 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在单个 vector dst 中 (当对应的掩码位不存在时，元素归零放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtneps_pbh.html" title="core::arch::x86::_mm256_maskz_cvtneps_pbh fn">_mm256_maskz_cvtneps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span><p>将包装的单精度 (32-bit) 浮点元素在 a 中转换为包装的 BF16 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtpd_epi32.html" title="core::arch::x86::_mm256_maskz_cvtpd_epi32 fn">_mm256_maskz_cvtpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtpd_epu32.html" title="core::arch::x86::_mm256_maskz_cvtpd_epu32 fn">_mm256_maskz_cvtpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtpd_ps.html" title="core::arch::x86::_mm256_maskz_cvtpd_ps fn">_mm256_maskz_cvtpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtph_ps.html" title="core::arch::x86::_mm256_maskz_cvtph_ps fn">_mm256_maskz_cvtph_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装后的半精度 (16-bit) 浮点元素转换为包装后的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtps_epi32.html" title="core::arch::x86::_mm256_maskz_cvtps_epi32 fn">_mm256_maskz_cvtps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtps_epu32.html" title="core::arch::x86::_mm256_maskz_cvtps_epu32 fn">_mm256_maskz_cvtps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtps_ph.html" title="core::arch::x86::_mm256_maskz_cvtps_ph fn">_mm256_maskz_cvtps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtsepi16_epi8.html" title="core::arch::x86::_mm256_maskz_cvtsepi16_epi8 fn">_mm256_maskz_cvtsepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的包装有符号 16 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtsepi32_epi8.html" title="core::arch::x86::_mm256_maskz_cvtsepi32_epi8 fn">_mm256_maskz_cvtsepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtsepi32_epi16.html" title="core::arch::x86::_mm256_maskz_cvtsepi32_epi16 fn">_mm256_maskz_cvtsepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtsepi64_epi8.html" title="core::arch::x86::_mm256_maskz_cvtsepi64_epi8 fn">_mm256_maskz_cvtsepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装有符号 64 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtsepi64_epi16.html" title="core::arch::x86::_mm256_maskz_cvtsepi64_epi16 fn">_mm256_maskz_cvtsepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtsepi64_epi32.html" title="core::arch::x86::_mm256_maskz_cvtsepi64_epi32 fn">_mm256_maskz_cvtsepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvttpd_epi32.html" title="core::arch::x86::_mm256_maskz_cvttpd_epi32 fn">_mm256_maskz_cvttpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvttpd_epu32.html" title="core::arch::x86::_mm256_maskz_cvttpd_epu32 fn">_mm256_maskz_cvttpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvttps_epi32.html" title="core::arch::x86::_mm256_maskz_cvttps_epi32 fn">_mm256_maskz_cvttps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将带有 a 的包装的单精度 (32-bit) 浮点元素转换为带有截断的包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvttps_epu32.html" title="core::arch::x86::_mm256_maskz_cvttps_epu32 fn">_mm256_maskz_cvttps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtusepi16_epi8.html" title="core::arch::x86::_mm256_maskz_cvtusepi16_epi8 fn">_mm256_maskz_cvtusepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtusepi32_epi8.html" title="core::arch::x86::_mm256_maskz_cvtusepi32_epi8 fn">_mm256_maskz_cvtusepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtusepi32_epi16.html" title="core::arch::x86::_mm256_maskz_cvtusepi32_epi16 fn">_mm256_maskz_cvtusepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtusepi64_epi8.html" title="core::arch::x86::_mm256_maskz_cvtusepi64_epi8 fn">_mm256_maskz_cvtusepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtusepi64_epi16.html" title="core::arch::x86::_mm256_maskz_cvtusepi64_epi16 fn">_mm256_maskz_cvtusepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_cvtusepi64_epi32.html" title="core::arch::x86::_mm256_maskz_cvtusepi64_epi32 fn">_mm256_maskz_cvtusepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_dbsad_epu8.html" title="core::arch::x86::_mm256_maskz_dbsad_epu8 fn">_mm256_maskz_dbsad_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 中与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs) 的总和，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将 16 位结果存储在 dst 中。对于每个 64 位通道，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中通道的低 8 位四元组，而后两个 SAD 使用 a 中通道的较高 8 位四元组。根据 imm8 中的控件，从 128 位通道中选择 b 中的四元组，并且每个 64 位通道中的每个 SAD 使用 8 位偏移量的选定四元组。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_div_pd.html" title="core::arch::x86::_mm256_maskz_div_pd fn">_mm256_maskz_div_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_div_ps.html" title="core::arch::x86::_mm256_maskz_div_ps fn">_mm256_maskz_div_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素除以 b 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_dpbf16_ps.html" title="core::arch::x86::_mm256_maskz_dpbf16_ps fn">_mm256_maskz_dpbf16_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span><p>计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间单精度 (32-bit) 浮点元素与 src 中的元素进行累加，并将结果存储在 dst 中使用 zeromask k (当对应的掩码为位未设置)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_dpbusd_epi32.html" title="core::arch::x86::_mm256_maskz_dpbusd_epi32 fn">_mm256_maskz_dpbusd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span><p>将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果使用 zeromask k 存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_dpbusds_epi32.html" title="core::arch::x86::_mm256_maskz_dpbusds_epi32 fn">_mm256_maskz_dpbusds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span><p>将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数用带符号饱和求和，并将包装的 32 位结果用 zeromask k 存储在 dst 中 (当对应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_dpwssd_epi32.html" title="core::arch::x86::_mm256_maskz_dpwssd_epi32 fn">_mm256_maskz_dpwssd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span><p>将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中对应的 32 位整数相加，并使用 zeromask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_dpwssds_epi32.html" title="core::arch::x86::_mm256_maskz_dpwssds_epi32 fn">_mm256_maskz_dpwssds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span><p>将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并使用 zeromask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_expand_epi8.html" title="core::arch::x86::_mm256_maskz_expand_epi8 fn">_mm256_maskz_expand_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>从 a 加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_expand_epi16.html" title="core::arch::x86::_mm256_maskz_expand_epi16 fn">_mm256_maskz_expand_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>从 a 加载连续的活动 16 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_expand_epi32.html" title="core::arch::x86::_mm256_maskz_expand_epi32 fn">_mm256_maskz_expand_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中加载连续的有效 32 位整数 (它们各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_expand_epi64.html" title="core::arch::x86::_mm256_maskz_expand_epi64 fn">_mm256_maskz_expand_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中加载连续的有效 64 位整数 (它们各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_expand_pd.html" title="core::arch::x86::_mm256_maskz_expand_pd fn">_mm256_maskz_expand_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中加载连续的活动双精度 (64-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_expand_ps.html" title="core::arch::x86::_mm256_maskz_expand_ps fn">_mm256_maskz_expand_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中加载连续的活动单精度 (32-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_extractf32x4_ps.html" title="core::arch::x86::_mm256_maskz_extractf32x4_ps fn">_mm256_maskz_extractf32x4_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 提取 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并用 imm8 进行选择，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_extracti32x4_epi32.html" title="core::arch::x86::_mm256_maskz_extracti32x4_epi32 fn">_mm256_maskz_extracti32x4_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中提取 128 位 (由 4 个包装的 32 位整数组成)，用 IMM1 选择，结果用 zeromask k 存储在 dst 中 (当相应的掩码位未设置时，元素归零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_fixupimm_pd.html" title="core::arch::x86::_mm256_maskz_fixupimm_pd fn">_mm256_maskz_fixupimm_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 c 中的包装 64 位整数修复 a 和 b 中的包装双精度 (64-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_fixupimm_ps.html" title="core::arch::x86::_mm256_maskz_fixupimm_ps fn">_mm256_maskz_fixupimm_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 c 中的包装 32 位整数修复 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_fmadd_pd.html" title="core::arch::x86::_mm256_maskz_fmadd_pd fn">_mm256_maskz_fmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_fmadd_ps.html" title="core::arch::x86::_mm256_maskz_fmadd_ps fn">_mm256_maskz_fmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_fmaddsub_pd.html" title="core::arch::x86::_mm256_maskz_fmaddsub_pd fn">_mm256_maskz_fmaddsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或减去，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_fmaddsub_ps.html" title="core::arch::x86::_mm256_maskz_fmaddsub_ps fn">_mm256_maskz_fmaddsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_fmsub_pd.html" title="core::arch::x86::_mm256_maskz_fmsub_pd fn">_mm256_maskz_fmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_fmsub_ps.html" title="core::arch::x86::_mm256_maskz_fmsub_ps fn">_mm256_maskz_fmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_fmsubadd_pd.html" title="core::arch::x86::_mm256_maskz_fmsubadd_pd fn">_mm256_maskz_fmsubadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或减去，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_fmsubadd_ps.html" title="core::arch::x86::_mm256_maskz_fmsubadd_ps fn">_mm256_maskz_fmsubadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，或者将 C from/to 中的包装元素相减并相加，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_fnmadd_pd.html" title="core::arch::x86::_mm256_maskz_fnmadd_pd fn">_mm256_maskz_fnmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_fnmadd_ps.html" title="core::arch::x86::_mm256_maskz_fnmadd_ps fn">_mm256_maskz_fnmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_fnmsub_pd.html" title="core::arch::x86::_mm256_maskz_fnmsub_pd fn">_mm256_maskz_fnmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_fnmsub_ps.html" title="core::arch::x86::_mm256_maskz_fnmsub_ps fn">_mm256_maskz_fnmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_getexp_pd.html" title="core::arch::x86::_mm256_maskz_getexp_pd fn">_mm256_maskz_getexp_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并使用 zeromask k 将结果存储在 dst 中 (当相应的 mask 位为零时，元素被清零未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_getexp_ps.html" title="core::arch::x86::_mm256_maskz_getexp_ps fn">_mm256_maskz_getexp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为代表整数指数的单精度 (32-bit) 浮点数，并使用 zeromask k 将结果存储在 dst 中 (当相应的 mask 位为零时，元素被清零未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_getmant_pd.html" title="core::arch::x86::_mm256_maskz_getmant_pd fn">_mm256_maskz_getmant_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素的尾数标准化，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_getmant_ps.html" title="core::arch::x86::_mm256_maskz_getmant_ps fn">_mm256_maskz_getmant_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素的尾数规格化，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_gf2p8affine_epi64_epi8.html" title="core::arch::x86::_mm256_maskz_gf2p8affine_epi64_epi8 fn">_mm256_maskz_gf2p8affine_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span><p>对 x 中的包装字节执行仿射变换。
也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_gf2p8affineinv_epi64_epi8.html" title="core::arch::x86::_mm256_maskz_gf2p8affineinv_epi64_epi8 fn">_mm256_maskz_gf2p8affineinv_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span><p>对 x 中的反向包装的字节执行仿射变换。
也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_gf2p8mul_epi8.html" title="core::arch::x86::_mm256_maskz_gf2p8mul_epi8 fn">_mm256_maskz_gf2p8mul_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span><p>在包装的字节上执行 GF(2^8) 乘法。
该字段以多项式表示，具有约数多项式 x^8 + x^4 + x^3 + x + 1。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_insertf32x4.html" title="core::arch::x86::_mm256_maskz_insertf32x4 fn">_mm256_maskz_insertf32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 复制到 tmp，然后在 x00X 指定的位置将 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成) 插入 tmp。使用 zeromask k 将 tmp 存储到 dst (当未设置相应的掩码位时，元素会被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_inserti32x4.html" title="core::arch::x86::_mm256_maskz_inserti32x4 fn">_mm256_maskz_inserti32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 复制到 tmp，然后在 imm8 指定的位置，将 b 中的 128 位 (由 4 个包装的 32 位整数组成) 插入 tmp。使用 zeromask k 将 tmp 存储到 dst (当未设置相应的掩码位时，元素会被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_lzcnt_epi32.html" title="core::arch::x86::_mm256_maskz_lzcnt_epi32 fn">_mm256_maskz_lzcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>计算 a 中每个包装的 32 位整数中前导零位的数目，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_lzcnt_epi64.html" title="core::arch::x86::_mm256_maskz_lzcnt_epi64 fn">_mm256_maskz_lzcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>计算 a 中每个包装的 64 位整数中前导零位的数目，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_madd_epi16.html" title="core::arch::x86::_mm256_maskz_madd_epi16 fn">_mm256_maskz_madd_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。水平添加相邻的中间 32 位整数对，并使用 zeromask k 将结果打包到 dst (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_maddubs_epi16.html" title="core::arch::x86::_mm256_maskz_maddubs_epi16 fn">_mm256_maskz_maddubs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的包装无符号 8 位整数与 b 中的包装有符号 8 位整数相乘，生成中间有符号的 16 位整数。水平添加相邻的中间有符号 16 位整数对，并使用 zeromask k 将饱和结果打包到 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_max_epi8.html" title="core::arch::x86::_mm256_maskz_max_epi8 fn">_mm256_maskz_max_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_max_epi16.html" title="core::arch::x86::_mm256_maskz_max_epi16 fn">_mm256_maskz_max_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_max_epi32.html" title="core::arch::x86::_mm256_maskz_max_epi32 fn">_mm256_maskz_max_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_max_epi64.html" title="core::arch::x86::_mm256_maskz_max_epi64 fn">_mm256_maskz_max_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_max_epu8.html" title="core::arch::x86::_mm256_maskz_max_epu8 fn">_mm256_maskz_max_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_max_epu16.html" title="core::arch::x86::_mm256_maskz_max_epu16 fn">_mm256_maskz_max_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_max_epu32.html" title="core::arch::x86::_mm256_maskz_max_epu32 fn">_mm256_maskz_max_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_max_epu64.html" title="core::arch::x86::_mm256_maskz_max_epu64 fn">_mm256_maskz_max_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_max_pd.html" title="core::arch::x86::_mm256_maskz_max_pd fn">_mm256_maskz_max_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_max_ps.html" title="core::arch::x86::_mm256_maskz_max_ps fn">_mm256_maskz_max_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_min_epi8.html" title="core::arch::x86::_mm256_maskz_min_epi8 fn">_mm256_maskz_min_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_min_epi16.html" title="core::arch::x86::_mm256_maskz_min_epi16 fn">_mm256_maskz_min_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_min_epi32.html" title="core::arch::x86::_mm256_maskz_min_epi32 fn">_mm256_maskz_min_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号 32 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_min_epi64.html" title="core::arch::x86::_mm256_maskz_min_epi64 fn">_mm256_maskz_min_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_min_epu8.html" title="core::arch::x86::_mm256_maskz_min_epu8 fn">_mm256_maskz_min_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_min_epu16.html" title="core::arch::x86::_mm256_maskz_min_epu16 fn">_mm256_maskz_min_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_min_epu32.html" title="core::arch::x86::_mm256_maskz_min_epu32 fn">_mm256_maskz_min_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_min_epu64.html" title="core::arch::x86::_mm256_maskz_min_epu64 fn">_mm256_maskz_min_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_min_pd.html" title="core::arch::x86::_mm256_maskz_min_pd fn">_mm256_maskz_min_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_min_ps.html" title="core::arch::x86::_mm256_maskz_min_ps fn">_mm256_maskz_min_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_mov_epi8.html" title="core::arch::x86::_mm256_maskz_mov_epi8 fn">_mm256_maskz_mov_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用零掩码 k 将包装的 8 位整数从 a 移到 dst (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_mov_epi16.html" title="core::arch::x86::_mm256_maskz_mov_epi16 fn">_mm256_maskz_mov_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用零掩码 k 将包装的 16 位整数从 a 移到 dst (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_mov_epi32.html" title="core::arch::x86::_mm256_maskz_mov_epi32 fn">_mm256_maskz_mov_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用零掩码 k 将包装的 32 位整数从 a 移至 dst (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_mov_epi64.html" title="core::arch::x86::_mm256_maskz_mov_epi64 fn">_mm256_maskz_mov_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用零掩码 k 将包装的 64 位整数从 a 移到 dst (未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_mov_pd.html" title="core::arch::x86::_mm256_maskz_mov_pd fn">_mm256_maskz_mov_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用零掩码 k 将包装的双精度 (64-bit) 浮点元素从 a 移到 dst (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_mov_ps.html" title="core::arch::x86::_mm256_maskz_mov_ps fn">_mm256_maskz_mov_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用零掩码 k 将包装的单精度 (32-bit) 浮点元素从 a 移到 dst (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_movedup_pd.html" title="core::arch::x86::_mm256_maskz_movedup_pd fn">_mm256_maskz_movedup_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 复制偶数索引的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_movehdup_ps.html" title="core::arch::x86::_mm256_maskz_movehdup_ps fn">_mm256_maskz_movehdup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 复制奇数索引的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_moveldup_ps.html" title="core::arch::x86::_mm256_maskz_moveldup_ps fn">_mm256_maskz_moveldup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 复制偶数索引的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_mul_epi32.html" title="core::arch::x86::_mm256_maskz_mul_epi32 fn">_mm256_maskz_mul_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中每个包装的 64 位元素的低位有符号 32 位整数相乘，并使用零掩码 k 将有符号的 64 位结果存储在 dst 中 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_mul_epu32.html" title="core::arch::x86::_mm256_maskz_mul_epu32 fn">_mm256_maskz_mul_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中每个包装的 64 位元素的低无符号 32 位整数相乘，并使用零掩码 k 将无符号 64 位结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_mul_pd.html" title="core::arch::x86::_mm256_maskz_mul_pd fn">_mm256_maskz_mul_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_mul_ps.html" title="core::arch::x86::_mm256_maskz_mul_ps fn">_mm256_maskz_mul_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_mulhi_epi16.html" title="core::arch::x86::_mm256_maskz_mulhi_epi16 fn">_mm256_maskz_mulhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 和 b 中包装的带符号的 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_mulhi_epu16.html" title="core::arch::x86::_mm256_maskz_mulhi_epu16 fn">_mm256_maskz_mulhi_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 和 b 中包装的无符号 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_mulhrs_epi16.html" title="core::arch::x86::_mm256_maskz_mulhrs_epi16 fn">_mm256_maskz_mulhrs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。将每个中间整数截断为 18 个最高有效位，通过加 1 舍入，并使用 zeromask k 将位 [16:1] 存储到 dst (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_mullo_epi16.html" title="core::arch::x86::_mm256_maskz_mullo_epi16 fn">_mm256_maskz_mullo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 和 b 中的包装的 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的低 16 位存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_mullo_epi32.html" title="core::arch::x86::_mm256_maskz_mullo_epi32 fn">_mm256_maskz_mullo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装的 32 位整数相乘，生成中间 64 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将中间整数的低 32 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_multishift_epi64_epi8.html" title="core::arch::x86::_mm256_maskz_multishift_epi64_epi8 fn">_mm256_maskz_multishift_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span><p>对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并使用 zeromask k (元素当相应的屏蔽位未设置时被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_or_epi32.html" title="core::arch::x86::_mm256_maskz_or_epi32 fn">_mm256_maskz_or_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 32 位整数的按位或，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_or_epi64.html" title="core::arch::x86::_mm256_maskz_or_epi64 fn">_mm256_maskz_or_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 64 位整数的按位或，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_packs_epi16.html" title="core::arch::x86::_mm256_maskz_packs_epi16 fn">_mm256_maskz_packs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用带符号的饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_packs_epi32.html" title="core::arch::x86::_mm256_maskz_packs_epi32 fn">_mm256_maskz_packs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用带符号的饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_packus_epi16.html" title="core::arch::x86::_mm256_maskz_packus_epi16 fn">_mm256_maskz_packus_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用无符号饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_packus_epi32.html" title="core::arch::x86::_mm256_maskz_packus_epi32 fn">_mm256_maskz_packus_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用无符号饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_permute_pd.html" title="core::arch::x86::_mm256_maskz_permute_pd fn">_mm256_maskz_permute_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件在 128 位通道内对双精度 (64-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_permute_ps.html" title="core::arch::x86::_mm256_maskz_permute_ps fn">_mm256_maskz_permute_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_permutevar_pd.html" title="core::arch::x86::_mm256_maskz_permutevar_pd fn">_mm256_maskz_permutevar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 b 中的控件在 128 位通道内将 a 中的双精度 (64-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_permutevar_ps.html" title="core::arch::x86::_mm256_maskz_permutevar_ps fn">_mm256_maskz_permutevar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 b 中的控件在 128 位通道内将 a 的单精度 (32-bit) 浮点元素打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_permutex2var_epi8.html" title="core::arch::x86::_mm256_maskz_permutex2var_epi8 fn">_mm256_maskz_permutex2var_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span><p>使用 idx 中的相应选择器和索引将 a 和 b 中的 8 位整数跨通道打乱，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_permutex2var_epi16.html" title="core::arch::x86::_mm256_maskz_permutex2var_epi16 fn">_mm256_maskz_permutex2var_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用相应的选择器和 idx 中的索引在通道中的 a 和 b 中对 16 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_permutex2var_epi32.html" title="core::arch::x86::_mm256_maskz_permutex2var_epi32 fn">_mm256_maskz_permutex2var_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中对 32 位整数进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_permutex2var_epi64.html" title="core::arch::x86::_mm256_maskz_permutex2var_epi64 fn">_mm256_maskz_permutex2var_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中对 64 位整数进行混洗，并使用 zeromask k (未设置相应的 mask 位时将元素清零) 将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_permutex2var_pd.html" title="core::arch::x86::_mm256_maskz_permutex2var_pd fn">_mm256_maskz_permutex2var_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用对应的选择器和 idx 中的索引在通道中的通道 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_permutex2var_ps.html" title="core::arch::x86::_mm256_maskz_permutex2var_ps fn">_mm256_maskz_permutex2var_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对单精度 (32-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_permutex_epi64.html" title="core::arch::x86::_mm256_maskz_permutex_epi64 fn">_mm256_maskz_permutex_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件在 256 位通道内将 64 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_permutex_pd.html" title="core::arch::x86::_mm256_maskz_permutex_pd fn">_mm256_maskz_permutex_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件在 256 位通道内将双精度 (64-bit) 浮点元素打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_permutexvar_epi8.html" title="core::arch::x86::_mm256_maskz_permutexvar_epi8 fn">_mm256_maskz_permutexvar_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span><p>使用 idx 中的相应索引在跨通道的 a 中打乱 8 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_permutexvar_epi16.html" title="core::arch::x86::_mm256_maskz_permutexvar_epi16 fn">_mm256_maskz_permutexvar_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用 idx 中的相应索引在跨通道中对 16 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_permutexvar_epi32.html" title="core::arch::x86::_mm256_maskz_permutexvar_epi32 fn">_mm256_maskz_permutexvar_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的相应索引在跨通道中对 32 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_permutexvar_epi64.html" title="core::arch::x86::_mm256_maskz_permutexvar_epi64 fn">_mm256_maskz_permutexvar_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的相应索引在跨通道中对 64 位整数进行打乱，并使用零掩码 k (未设置相应的掩码位时将元素清零) 将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_permutexvar_pd.html" title="core::arch::x86::_mm256_maskz_permutexvar_pd fn">_mm256_maskz_permutexvar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的相应索引在跨通道中对双精度 (64-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_permutexvar_ps.html" title="core::arch::x86::_mm256_maskz_permutexvar_ps fn">_mm256_maskz_permutexvar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的相应索引在跨通道中对单精度 (32-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_popcnt_epi8.html" title="core::arch::x86::_mm256_maskz_popcnt_epi8 fn">_mm256_maskz_popcnt_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span><p>对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_popcnt_epi16.html" title="core::arch::x86::_mm256_maskz_popcnt_epi16 fn">_mm256_maskz_popcnt_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span><p>对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_popcnt_epi32.html" title="core::arch::x86::_mm256_maskz_popcnt_epi32 fn">_mm256_maskz_popcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq,avx512vl` only"><code>avx512vpopcntdq,avx512vl</code></span><p>对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_popcnt_epi64.html" title="core::arch::x86::_mm256_maskz_popcnt_epi64 fn">_mm256_maskz_popcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq,avx512vl` only"><code>avx512vpopcntdq,avx512vl</code></span><p>对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_rcp14_pd.html" title="core::arch::x86::_mm256_maskz_rcp14_pd fn">_mm256_maskz_rcp14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_rcp14_ps.html" title="core::arch::x86::_mm256_maskz_rcp14_ps fn">_mm256_maskz_rcp14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_rol_epi32.html" title="core::arch::x86::_mm256_maskz_rol_epi32 fn">_mm256_maskz_rol_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_rol_epi64.html" title="core::arch::x86::_mm256_maskz_rol_epi64 fn">_mm256_maskz_rol_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_rolv_epi32.html" title="core::arch::x86::_mm256_maskz_rolv_epi32 fn">_mm256_maskz_rolv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的 32 位整数中的位向左旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_rolv_epi64.html" title="core::arch::x86::_mm256_maskz_rolv_epi64 fn">_mm256_maskz_rolv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的 64 位整数中的位向左旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_ror_epi32.html" title="core::arch::x86::_mm256_maskz_ror_epi32 fn">_mm256_maskz_ror_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 X 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_ror_epi64.html" title="core::arch::x86::_mm256_maskz_ror_epi64 fn">_mm256_maskz_ror_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 X 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_rorv_epi32.html" title="core::arch::x86::_mm256_maskz_rorv_epi32 fn">_mm256_maskz_rorv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的 32 位整数中的位向右旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_rorv_epi64.html" title="core::arch::x86::_mm256_maskz_rorv_epi64 fn">_mm256_maskz_rorv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_roundscale_pd.html" title="core::arch::x86::_mm256_maskz_roundscale_pd fn">_mm256_maskz_roundscale_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 x 中的包装双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_roundscale_ps.html" title="core::arch::x86::_mm256_maskz_roundscale_ps fn">_mm256_maskz_roundscale_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_rsqrt14_pd.html" title="core::arch::x86::_mm256_maskz_rsqrt14_pd fn">_mm256_maskz_rsqrt14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中的包装的双精度 (64-bit) 浮点元素的近似倒数平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_rsqrt14_ps.html" title="core::arch::x86::_mm256_maskz_rsqrt14_ps fn">_mm256_maskz_rsqrt14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_scalef_pd.html" title="core::arch::x86::_mm256_maskz_scalef_pd fn">_mm256_maskz_scalef_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_scalef_ps.html" title="core::arch::x86::_mm256_maskz_scalef_ps fn">_mm256_maskz_scalef_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_set1_epi8.html" title="core::arch::x86::_mm256_maskz_set1_epi8 fn">_mm256_maskz_set1_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用零掩码 k 将 8 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_set1_epi16.html" title="core::arch::x86::_mm256_maskz_set1_epi16 fn">_mm256_maskz_set1_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用零掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_set1_epi32.html" title="core::arch::x86::_mm256_maskz_set1_epi32 fn">_mm256_maskz_set1_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用零掩码 k 将 32 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_set1_epi64.html" title="core::arch::x86::_mm256_maskz_set1_epi64 fn">_mm256_maskz_set1_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用零掩码 k 将 64 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_shldi_epi16.html" title="core::arch::x86::_mm256_maskz_shldi_epi16 fn">_mm256_maskz_shldi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_shldi_epi32.html" title="core::arch::x86::_mm256_maskz_shldi_epi32 fn">_mm256_maskz_shldi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_shldi_epi64.html" title="core::arch::x86::_mm256_maskz_shldi_epi64 fn">_mm256_maskz_shldi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_shldv_epi16.html" title="core::arch::x86::_mm256_maskz_shldv_epi16 fn">_mm256_maskz_shldv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_shldv_epi32.html" title="core::arch::x86::_mm256_maskz_shldv_epi32 fn">_mm256_maskz_shldv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_shldv_epi64.html" title="core::arch::x86::_mm256_maskz_shldv_epi64 fn">_mm256_maskz_shldv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_shrdi_epi16.html" title="core::arch::x86::_mm256_maskz_shrdi_epi16 fn">_mm256_maskz_shrdi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_shrdi_epi32.html" title="core::arch::x86::_mm256_maskz_shrdi_epi32 fn">_mm256_maskz_shrdi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_shrdi_epi64.html" title="core::arch::x86::_mm256_maskz_shrdi_epi64 fn">_mm256_maskz_shrdi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_shrdv_epi16.html" title="core::arch::x86::_mm256_maskz_shrdv_epi16 fn">_mm256_maskz_shrdv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_shrdv_epi32.html" title="core::arch::x86::_mm256_maskz_shrdv_epi32 fn">_mm256_maskz_shrdv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_shrdv_epi64.html" title="core::arch::x86::_mm256_maskz_shrdv_epi64 fn">_mm256_maskz_shrdv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_shuffle_epi8.html" title="core::arch::x86::_mm256_maskz_shuffle_epi8 fn">_mm256_maskz_shuffle_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 b 的相应 8 位元素中的打乱控制掩码对 a 中的包装 8 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_shuffle_epi32.html" title="core::arch::x86::_mm256_maskz_shuffle_epi32 fn">_mm256_maskz_shuffle_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件在 128 位通道中的 32 位整数中混洗 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_shuffle_f32x4.html" title="core::arch::x86::_mm256_maskz_shuffle_f32x4 fn">_mm256_maskz_shuffle_f32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 imm8 从 a 和 b 中选择的 128 位 (由 4 个单精度 (32-bit) 浮点元素组成) 混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_shuffle_f64x2.html" title="core::arch::x86::_mm256_maskz_shuffle_f64x2 fn">_mm256_maskz_shuffle_f64x2</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 imm8 从 a 和 b 中选择的 128 位 (由 2 个双精度 (64-bit) 浮点元素组成) 混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_shuffle_i32x4.html" title="core::arch::x86::_mm256_maskz_shuffle_i32x4 fn">_mm256_maskz_shuffle_i32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 imm8 从 a 和 b 中选择的 128 位 (由 4 个 32 位整数组成) 混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_shuffle_i64x2.html" title="core::arch::x86::_mm256_maskz_shuffle_i64x2 fn">_mm256_maskz_shuffle_i64x2</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 imm8 从 a 和 b 中选择的 128 位 (由 2 个 64 位整数组成) 混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_shuffle_pd.html" title="core::arch::x86::_mm256_maskz_shuffle_pd fn">_mm256_maskz_shuffle_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件对 128 位通道内的双精度 (64-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_shuffle_ps.html" title="core::arch::x86::_mm256_maskz_shuffle_ps fn">_mm256_maskz_shuffle_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_shufflehi_epi16.html" title="core::arch::x86::_mm256_maskz_shufflehi_epi16 fn">_mm256_maskz_shufflehi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用 imm8 中的控件在 a 的 128 位通道的高 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的高 64 位中，将 128 位通道的低 64 位从 a 复制到 dst，使用 zeromask k (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_shufflelo_epi16.html" title="core::arch::x86::_mm256_maskz_shufflelo_epi16 fn">_mm256_maskz_shufflelo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用 imm8 中的控件在 a 的 128 位通道的低 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的低 64 位中，并使用写掩码 k 将 128 位通道的高 64 位从 a 复制到 dst (当未使用相应的掩码位时，元素从 src 复制) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_sll_epi16.html" title="core::arch::x86::_mm256_maskz_sll_epi16 fn">_mm256_maskz_sll_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数按计数左移，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_sll_epi32.html" title="core::arch::x86::_mm256_maskz_sll_epi32 fn">_mm256_maskz_sll_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 32 位整数左移计数，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_sll_epi64.html" title="core::arch::x86::_mm256_maskz_sll_epi64 fn">_mm256_maskz_sll_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将填充的 64 位整数左移计数，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_slli_epi16.html" title="core::arch::x86::_mm256_maskz_slli_epi16 fn">_mm256_maskz_slli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_slli_epi32.html" title="core::arch::x86::_mm256_maskz_slli_epi32 fn">_mm256_maskz_slli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 32 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_slli_epi64.html" title="core::arch::x86::_mm256_maskz_slli_epi64 fn">_mm256_maskz_slli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 64 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_sllv_epi16.html" title="core::arch::x86::_mm256_maskz_sllv_epi16 fn">_mm256_maskz_sllv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数左移由 count 中的相应元素指定的数量，同时移入零，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_sllv_epi32.html" title="core::arch::x86::_mm256_maskz_sllv_epi32 fn">_mm256_maskz_sllv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在将移位的 32 位整数左移零时，将其对应计数指定的数量左移，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_sllv_epi64.html" title="core::arch::x86::_mm256_maskz_sllv_epi64 fn">_mm256_maskz_sllv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在将移位的 64 位整数左移零时，将其对应计数指定的数量左移，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_sqrt_pd.html" title="core::arch::x86::_mm256_maskz_sqrt_pd fn">_mm256_maskz_sqrt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并使用零掩码 k (将结果置零，当未设置相应的掩码位时将元素清零) 将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_sqrt_ps.html" title="core::arch::x86::_mm256_maskz_sqrt_ps fn">_mm256_maskz_sqrt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_sra_epi16.html" title="core::arch::x86::_mm256_maskz_sra_epi16 fn">_mm256_maskz_sra_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数按计数右移，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_sra_epi32.html" title="core::arch::x86::_mm256_maskz_sra_epi32 fn">_mm256_maskz_sra_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在移动符号位的同时右移计数包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_sra_epi64.html" title="core::arch::x86::_mm256_maskz_sra_epi64 fn">_mm256_maskz_sra_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在移动符号位的同时右移计数包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_srai_epi16.html" title="core::arch::x86::_mm256_maskz_srai_epi16 fn">_mm256_maskz_srai_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_srai_epi32.html" title="core::arch::x86::_mm256_maskz_srai_epi32 fn">_mm256_maskz_srai_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 32 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_srai_epi64.html" title="core::arch::x86::_mm256_maskz_srai_epi64 fn">_mm256_maskz_srai_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 64 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_srav_epi16.html" title="core::arch::x86::_mm256_maskz_srav_epi16 fn">_mm256_maskz_srav_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数右移由 count 中的相应元素指定的数量，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_srav_epi32.html" title="core::arch::x86::_mm256_maskz_srav_epi32 fn">_mm256_maskz_srav_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在将符号位移位的同时，将已包装的 32 位整数向右移动计数中相应元素指定的数量，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_srav_epi64.html" title="core::arch::x86::_mm256_maskz_srav_epi64 fn">_mm256_maskz_srav_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在移入符号位的同时，将包装的 64 位整数右移由 count 中相应元素指定的数量，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_srl_epi16.html" title="core::arch::x86::_mm256_maskz_srl_epi16 fn">_mm256_maskz_srl_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数右移，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_srl_epi32.html" title="core::arch::x86::_mm256_maskz_srl_epi32 fn">_mm256_maskz_srl_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将移位的 32 位整数右移，同时移零，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_srl_epi64.html" title="core::arch::x86::_mm256_maskz_srl_epi64 fn">_mm256_maskz_srl_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 64 位整数右移计数，同时移入零，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_srli_epi16.html" title="core::arch::x86::_mm256_maskz_srli_epi16 fn">_mm256_maskz_srli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_srli_epi32.html" title="core::arch::x86::_mm256_maskz_srli_epi32 fn">_mm256_maskz_srli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 32 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_srli_epi64.html" title="core::arch::x86::_mm256_maskz_srli_epi64 fn">_mm256_maskz_srli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 64 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_srlv_epi16.html" title="core::arch::x86::_mm256_maskz_srlv_epi16 fn">_mm256_maskz_srlv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_srlv_epi32.html" title="core::arch::x86::_mm256_maskz_srlv_epi32 fn">_mm256_maskz_srlv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>向右移动已包装的 32 位整数，偏移量为相应元素在计数中指定的数量，同时向零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_srlv_epi64.html" title="core::arch::x86::_mm256_maskz_srlv_epi64 fn">_mm256_maskz_srlv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>向右移位包装的 64 位整数，其数量为计数中相应元素指定的数量，同时移位为零，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_sub_epi8.html" title="core::arch::x86::_mm256_maskz_sub_epi8 fn">_mm256_maskz_sub_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>从 a 中的包装 8 位整数中减去 b 中的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_sub_epi16.html" title="core::arch::x86::_mm256_maskz_sub_epi16 fn">_mm256_maskz_sub_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>从 a 中的包装的 16 位整数中减去 b 中的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_sub_epi32.html" title="core::arch::x86::_mm256_maskz_sub_epi32 fn">_mm256_maskz_sub_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中的包装 32 位整数中减去 b 中的包装 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_sub_epi64.html" title="core::arch::x86::_mm256_maskz_sub_epi64 fn">_mm256_maskz_sub_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中的包装 64 位整数中减去 b 中的包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_sub_pd.html" title="core::arch::x86::_mm256_maskz_sub_pd fn">_mm256_maskz_sub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_sub_ps.html" title="core::arch::x86::_mm256_maskz_sub_ps fn">_mm256_maskz_sub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 b 中的包装后的单精度 (32-bit) 浮点元素减去 a 中的包装后的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_subs_epi8.html" title="core::arch::x86::_mm256_maskz_subs_epi8 fn">_mm256_maskz_subs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用饱和度从包装的 8 位整数中减去 b 中的包装有符号的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_subs_epi16.html" title="core::arch::x86::_mm256_maskz_subs_epi16 fn">_mm256_maskz_subs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用饱和度将 b 中的包装 16 位整数减去 b 中的包装有符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_subs_epu8.html" title="core::arch::x86::_mm256_maskz_subs_epu8 fn">_mm256_maskz_subs_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用 a 饱和度从 b 中的包装无符号 8 位整数减去 b 中的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_subs_epu16.html" title="core::arch::x86::_mm256_maskz_subs_epu16 fn">_mm256_maskz_subs_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用 a 饱和度将 b 中的包装无符号 16 位整数减去 b 中的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_ternarylogic_epi32.html" title="core::arch::x86::_mm256_maskz_ternarylogic_epi32 fn">_mm256_maskz_ternarylogic_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 32 位整数中的每一位，来自 a、b 和 c 的相应位用于形成 imm8 的 3 位索引，并使用零掩码将 imm8 中该位的值写入 dst 中的相应位 k 在 32 位粒度 (当未设置相应的掩码位时，32 位元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_ternarylogic_epi64.html" title="core::arch::x86::_mm256_maskz_ternarylogic_epi64 fn">_mm256_maskz_ternarylogic_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 64 位整数中的每一位，来自 a、b 和 c 的相应位用于在 imm8 中形成 3 位索引，并使用零掩码将 imm8 中该位的值写入 dst 中的相应位 k 在 64 位粒度 (当未设置相应的掩码位时，64 位元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_unpackhi_epi8.html" title="core::arch::x86::_mm256_maskz_unpackhi_epi8 fn">_mm256_maskz_unpackhi_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的高半部分拆包和交织 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_unpackhi_epi16.html" title="core::arch::x86::_mm256_maskz_unpackhi_epi16 fn">_mm256_maskz_unpackhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的高半部分拆包和交织 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_unpackhi_epi32.html" title="core::arch::x86::_mm256_maskz_unpackhi_epi32 fn">_mm256_maskz_unpackhi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_unpackhi_epi64.html" title="core::arch::x86::_mm256_maskz_unpackhi_epi64 fn">_mm256_maskz_unpackhi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_unpackhi_pd.html" title="core::arch::x86::_mm256_maskz_unpackhi_pd fn">_mm256_maskz_unpackhi_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_unpackhi_ps.html" title="core::arch::x86::_mm256_maskz_unpackhi_ps fn">_mm256_maskz_unpackhi_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_unpacklo_epi8.html" title="core::arch::x86::_mm256_maskz_unpacklo_epi8 fn">_mm256_maskz_unpacklo_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的下半部分拆包和交织 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_unpacklo_epi16.html" title="core::arch::x86::_mm256_maskz_unpacklo_epi16 fn">_mm256_maskz_unpacklo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的下半部分拆包和交织 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_unpacklo_epi32.html" title="core::arch::x86::_mm256_maskz_unpacklo_epi32 fn">_mm256_maskz_unpacklo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包和交织 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_unpacklo_epi64.html" title="core::arch::x86::_mm256_maskz_unpacklo_epi64 fn">_mm256_maskz_unpacklo_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包和交织 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_unpacklo_pd.html" title="core::arch::x86::_mm256_maskz_unpacklo_pd fn">_mm256_maskz_unpacklo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包和交织双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_unpacklo_ps.html" title="core::arch::x86::_mm256_maskz_unpacklo_ps fn">_mm256_maskz_unpacklo_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包和交织单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_xor_epi32.html" title="core::arch::x86::_mm256_maskz_xor_epi32 fn">_mm256_maskz_xor_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 32 位整数的按位 XOR，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_maskz_xor_epi64.html" title="core::arch::x86::_mm256_maskz_xor_epi64 fn">_mm256_maskz_xor_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 64 位整数的按位 XOR，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_max_epi64.html" title="core::arch::x86::_mm256_max_epi64 fn">_mm256_max_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数，并将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_max_epu64.html" title="core::arch::x86::_mm256_max_epu64 fn">_mm256_max_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数，并将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_min_epi64.html" title="core::arch::x86::_mm256_min_epi64 fn">_mm256_min_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数，并将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_min_epu64.html" title="core::arch::x86::_mm256_min_epu64 fn">_mm256_min_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数，并将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_movepi8_mask.html" title="core::arch::x86::_mm256_movepi8_mask fn">_mm256_movepi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 a 中相应包装的 8 位整数的最高有效位设置掩码寄存器 k 的每个位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_movepi16_mask.html" title="core::arch::x86::_mm256_movepi16_mask fn">_mm256_movepi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 a 中相应的包装的 16 位整数的最高有效位设置掩码寄存器 k 的每一位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_movm_epi8.html" title="core::arch::x86::_mm256_movm_epi8 fn">_mm256_movm_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 k 中相应位的值，将 dst 中每个包装的 8 位整数设置为全 1 或全 0。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_movm_epi16.html" title="core::arch::x86::_mm256_movm_epi16 fn">_mm256_movm_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 k 中相应位的值，将 dst 中每个包装的 16 位整数设置为全 1 或全 0。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_multishift_epi64_epi8.html" title="core::arch::x86::_mm256_multishift_epi64_epi8 fn">_mm256_multishift_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span><p>对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并将 8 个组装字节存储到 dst 的相应 64 位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_or_epi32.html" title="core::arch::x86::_mm256_or_epi32 fn">_mm256_or_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 32 位整数的按位或，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_or_epi64.html" title="core::arch::x86::_mm256_or_epi64 fn">_mm256_or_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 64 位整数的按位或，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_permutex2var_epi8.html" title="core::arch::x86::_mm256_permutex2var_epi8 fn">_mm256_permutex2var_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span><p>使用 idx 中的相应选择器和索引将 a 和 b 中的 8 位整数跨通道打乱，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_permutex2var_epi16.html" title="core::arch::x86::_mm256_permutex2var_epi16 fn">_mm256_permutex2var_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中对 16 位整数进行打乱，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_permutex2var_epi32.html" title="core::arch::x86::_mm256_permutex2var_epi32 fn">_mm256_permutex2var_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中随机排列 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_permutex2var_epi64.html" title="core::arch::x86::_mm256_permutex2var_epi64 fn">_mm256_permutex2var_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的相应选择器和索引在通道中的 a 和 b 中随机排列 64 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_permutex2var_pd.html" title="core::arch::x86::_mm256_permutex2var_pd fn">_mm256_permutex2var_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_permutex2var_ps.html" title="core::arch::x86::_mm256_permutex2var_ps fn">_mm256_permutex2var_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对单精度 (32-bit) 浮点元素进行混洗，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_permutex_epi64.html" title="core::arch::x86::_mm256_permutex_epi64 fn">_mm256_permutex_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件在 256 位通道中的 a 内随机排列 64 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_permutex_pd.html" title="core::arch::x86::_mm256_permutex_pd fn">_mm256_permutex_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件在 256 位通道内对双精度 (64-bit) 浮点元素进行打乱，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_permutexvar_epi8.html" title="core::arch::x86::_mm256_permutexvar_epi8 fn">_mm256_permutexvar_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span><p>使用 idx 中的相应索引将 a 中的 8 位整数打乱到通道中，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_permutexvar_epi16.html" title="core::arch::x86::_mm256_permutexvar_epi16 fn">_mm256_permutexvar_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用 idx 中的相应索引在跨通道中对 16 位整数进行打乱，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_permutexvar_epi32.html" title="core::arch::x86::_mm256_permutexvar_epi32 fn">_mm256_permutexvar_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的相应索引在跨通道中随机排列 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_permutexvar_epi64.html" title="core::arch::x86::_mm256_permutexvar_epi64 fn">_mm256_permutexvar_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的相应索引在跨通道中随机排列 64 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_permutexvar_pd.html" title="core::arch::x86::_mm256_permutexvar_pd fn">_mm256_permutexvar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的相应索引在跨通道中对双精度 (64-bit) 浮点元素进行混洗，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_permutexvar_ps.html" title="core::arch::x86::_mm256_permutexvar_ps fn">_mm256_permutexvar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的相应索引对跨通道中的单精度 (32-bit) 浮点元素进行打乱。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_popcnt_epi8.html" title="core::arch::x86::_mm256_popcnt_epi8 fn">_mm256_popcnt_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span><p>对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_popcnt_epi16.html" title="core::arch::x86::_mm256_popcnt_epi16 fn">_mm256_popcnt_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span><p>对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_popcnt_epi32.html" title="core::arch::x86::_mm256_popcnt_epi32 fn">_mm256_popcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq,avx512vl` only"><code>avx512vpopcntdq,avx512vl</code></span><p>对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_popcnt_epi64.html" title="core::arch::x86::_mm256_popcnt_epi64 fn">_mm256_popcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq,avx512vl` only"><code>avx512vpopcntdq,avx512vl</code></span><p>对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_rcp14_pd.html" title="core::arch::x86::_mm256_rcp14_pd fn">_mm256_rcp14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并将结果存储在 dst 中。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_rcp14_ps.html" title="core::arch::x86::_mm256_rcp14_ps fn">_mm256_rcp14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并将结果存储在 dst 中。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_rol_epi32.html" title="core::arch::x86::_mm256_rol_epi32 fn">_mm256_rol_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 X 中每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_rol_epi64.html" title="core::arch::x86::_mm256_rol_epi64 fn">_mm256_rol_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 X 中每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_rolv_epi32.html" title="core::arch::x86::_mm256_rolv_epi32 fn">_mm256_rolv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的 32 位整数中的位向左旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_rolv_epi64.html" title="core::arch::x86::_mm256_rolv_epi64 fn">_mm256_rolv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的 64 位整数中的位向左旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_ror_epi32.html" title="core::arch::x86::_mm256_ror_epi32 fn">_mm256_ror_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 X 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_ror_epi64.html" title="core::arch::x86::_mm256_ror_epi64 fn">_mm256_ror_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 X 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_rorv_epi32.html" title="core::arch::x86::_mm256_rorv_epi32 fn">_mm256_rorv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的 32 位整数中的位向右旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_rorv_epi64.html" title="core::arch::x86::_mm256_rorv_epi64 fn">_mm256_rorv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_roundscale_pd.html" title="core::arch::x86::_mm256_roundscale_pd fn">_mm256_roundscale_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 x 中的包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并将结果存储在 dst 中。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_roundscale_ps.html" title="core::arch::x86::_mm256_roundscale_ps fn">_mm256_roundscale_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的小数位数，然后将结果存储在 dst 中。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_scalef_pd.html" title="core::arch::x86::_mm256_scalef_pd fn">_mm256_scalef_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_scalef_ps.html" title="core::arch::x86::_mm256_scalef_ps fn">_mm256_scalef_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_shldi_epi16.html" title="core::arch::x86::_mm256_shldi_epi16 fn">_mm256_shldi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并将高 16 位存储在 dst 中)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_shldi_epi32.html" title="core::arch::x86::_mm256_shldi_epi32 fn">_mm256_shldi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并将高 32 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_shldi_epi64.html" title="core::arch::x86::_mm256_shldi_epi64 fn">_mm256_shldi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并将高 64 位存储在 dst 中)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_shldv_epi16.html" title="core::arch::x86::_mm256_shldv_epi16 fn">_mm256_shldv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的对应元素中指定的量，并将高 16 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_shldv_epi32.html" title="core::arch::x86::_mm256_shldv_epi32 fn">_mm256_shldv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的对应元素中指定的量，并将高 32 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_shldv_epi64.html" title="core::arch::x86::_mm256_shldv_epi64 fn">_mm256_shldv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的对应元素中指定的量，并将高 64 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_shrdi_epi16.html" title="core::arch::x86::_mm256_shrdi_epi16 fn">_mm256_shrdi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并将低 16 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_shrdi_epi32.html" title="core::arch::x86::_mm256_shrdi_epi32 fn">_mm256_shrdi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并将低 32 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_shrdi_epi64.html" title="core::arch::x86::_mm256_shrdi_epi64 fn">_mm256_shrdi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并将低 64 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_shrdv_epi16.html" title="core::arch::x86::_mm256_shrdv_epi16 fn">_mm256_shrdv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的对应元素中指定的量，并将低 16 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_shrdv_epi32.html" title="core::arch::x86::_mm256_shrdv_epi32 fn">_mm256_shrdv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的对应元素中指定的量，并将低 32 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_shrdv_epi64.html" title="core::arch::x86::_mm256_shrdv_epi64 fn">_mm256_shrdv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的对应元素中指定的量，并将低 64 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_shuffle_f32x4.html" title="core::arch::x86::_mm256_shuffle_f32x4 fn">_mm256_shuffle_f32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>imm8 从 a 和 b 中随机选择 128 位 (由 4 个单精度 (32-bit) 浮点元素组成)，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_shuffle_f64x2.html" title="core::arch::x86::_mm256_shuffle_f64x2 fn">_mm256_shuffle_f64x2</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>随机排列 imm8 从 a 和 b 中选择的 128 位 (由 2 个双精度 (64-bit) 浮点元素组成)，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_shuffle_i32x4.html" title="core::arch::x86::_mm256_shuffle_i32x4 fn">_mm256_shuffle_i32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>随机排列 imm8 从 a 和 b 中选择的 128 位 (由 4 个 32 位整数组成)，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_shuffle_i64x2.html" title="core::arch::x86::_mm256_shuffle_i64x2 fn">_mm256_shuffle_i64x2</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>随机排列 imm8 从 a 和 b 中选择的 128 位 (由 2 个 64 位整数组成)，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_sllv_epi16.html" title="core::arch::x86::_mm256_sllv_epi16 fn">_mm256_sllv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数按 count 中相应元素指定的数量向左移位，同时将零移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_sra_epi64.html" title="core::arch::x86::_mm256_sra_epi64 fn">_mm256_sra_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在移动符号位的同时按计数右移包装的 64 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_srai_epi64.html" title="core::arch::x86::_mm256_srai_epi64 fn">_mm256_srai_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 64 位整数右移 imm8，同时将符号位移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_srav_epi16.html" title="core::arch::x86::_mm256_srav_epi16 fn">_mm256_srav_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数右移 count 中相应元素指定的数量，同时移入符号位，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_srav_epi64.html" title="core::arch::x86::_mm256_srav_epi64 fn">_mm256_srav_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将移位的 64 位整数向右移动计数中相应元素指定的数量，同时移入符号位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_srlv_epi16.html" title="core::arch::x86::_mm256_srlv_epi16 fn">_mm256_srlv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_store_epi32.html" title="core::arch::x86::_mm256_store_epi32 fn">_mm256_store_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的 256 位 (由 8 个包装的 32 位整数组成) 存储到内存中。mem_addr 必须在 32 字节边界上对齐，否则可能会生成一般保护异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_store_epi64.html" title="core::arch::x86::_mm256_store_epi64 fn">_mm256_store_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的 256 位 (由 4 个包装的 64 位整数组成) 存储到内存中。mem_addr 必须在 32 字节边界上对齐，否则可能会生成一般保护异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_storeu_epi8.html" title="core::arch::x86::_mm256_storeu_epi8 fn">_mm256_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的 256 位 (由 32 个包装的 8 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_storeu_epi16.html" title="core::arch::x86::_mm256_storeu_epi16 fn">_mm256_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的 256 位 (由 16 个包装的 16 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_storeu_epi32.html" title="core::arch::x86::_mm256_storeu_epi32 fn">_mm256_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的 256 位 (由 8 个包装的 32 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_storeu_epi64.html" title="core::arch::x86::_mm256_storeu_epi64 fn">_mm256_storeu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的 256 位 (由 4 个包装的 64 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_ternarylogic_epi32.html" title="core::arch::x86::_mm256_ternarylogic_epi32 fn">_mm256_ternarylogic_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个包装的 32 位整数中的每个位，来自 a，b 和 c 的相应位用于形成到 imm8 的 3 位索引，并且将 imm8 中该位的值写入 dst 中的相应位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_ternarylogic_epi64.html" title="core::arch::x86::_mm256_ternarylogic_epi64 fn">_mm256_ternarylogic_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 64 位整数中的每一位，a、b 和 c 中的相应位用于形成 imm8 中的 3 位索引，并将 imm8 中该位的值写入 dst 中的相应位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_test_epi8_mask.html" title="core::arch::x86::_mm256_test_epi8_mask fn">_mm256_test_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 和 b 中包装的 8 位整数的按位与，生成中间 8 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_test_epi16_mask.html" title="core::arch::x86::_mm256_test_epi16_mask fn">_mm256_test_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 和 b 中包装的 16 位整数的按位与，生成中间的 16 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_test_epi32_mask.html" title="core::arch::x86::_mm256_test_epi32_mask fn">_mm256_test_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 32 位整数的按位与，生成中间的 32 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_test_epi64_mask.html" title="core::arch::x86::_mm256_test_epi64_mask fn">_mm256_test_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 64 位整数的按位与，生成中间 64 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_testn_epi8_mask.html" title="core::arch::x86::_mm256_testn_epi8_mask fn">_mm256_testn_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 和 b 中包装的 8 位整数的按位 NAND，生成中间的 8 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_testn_epi16_mask.html" title="core::arch::x86::_mm256_testn_epi16_mask fn">_mm256_testn_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 和 b 中包装的 16 位整数的按位 NAND，生成中间的 16 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_testn_epi32_mask.html" title="core::arch::x86::_mm256_testn_epi32_mask fn">_mm256_testn_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 32 位整数的按位 NAND，生成中间的 32 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_testn_epi64_mask.html" title="core::arch::x86::_mm256_testn_epi64_mask fn">_mm256_testn_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 64 位整数的按位 NAND，生成中间的 64 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_xor_epi32.html" title="core::arch::x86::_mm256_xor_epi32 fn">_mm256_xor_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 32 位整数的按位 XOR，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm256_xor_epi64.html" title="core::arch::x86::_mm256_xor_epi64 fn">_mm256_xor_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 64 位整数的按位 XOR，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_abs_epi8.html" title="core::arch::x86::_mm512_abs_epi8 fn">_mm512_abs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 a 中包装的带符号的 8 位整数的绝对值，并将无符号的结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_abs_epi16.html" title="core::arch::x86::_mm512_abs_epi16 fn">_mm512_abs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 a 中包装的带符号的 16 位整数的绝对值，并将无符号的结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_abs_epi32.html" title="core::arch::x86::_mm512_abs_epi32 fn">_mm512_abs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 <code>a</code> 中包装的 32 位整数的绝对值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_abs_epi64.html" title="core::arch::x86::_mm512_abs_epi64 fn">_mm512_abs_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的带符号的 64 位整数的绝对值，并将无符号的结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_abs_pd.html" title="core::arch::x86::_mm512_abs_pd fn">_mm512_abs_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>查找 v2 中每个包装的双精度 (64-bit) 浮点元素的绝对值，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_abs_ps.html" title="core::arch::x86::_mm512_abs_ps fn">_mm512_abs_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>查找 v2 中每个包装的单精度 (32-bit) 浮点元素的绝对值，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_add_epi8.html" title="core::arch::x86::_mm512_add_epi8 fn">_mm512_add_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 8 位整数添加到 a 和 b 中，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_add_epi16.html" title="core::arch::x86::_mm512_add_epi16 fn">_mm512_add_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数添加到 a 和 b 中，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_add_epi32.html" title="core::arch::x86::_mm512_add_epi32 fn">_mm512_add_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加包装的 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_add_epi64.html" title="core::arch::x86::_mm512_add_epi64 fn">_mm512_add_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加包装的 64 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_add_pd.html" title="core::arch::x86::_mm512_add_pd fn">_mm512_add_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_add_ps.html" title="core::arch::x86::_mm512_add_ps fn">_mm512_add_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_add_round_pd.html" title="core::arch::x86::_mm512_add_round_pd fn">_mm512_add_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_add_round_ps.html" title="core::arch::x86::_mm512_add_round_ps fn">_mm512_add_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_adds_epi8.html" title="core::arch::x86::_mm512_adds_epi8 fn">_mm512_adds_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用饱和度在 a 和 b 中添加包装的带符号的 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_adds_epi16.html" title="core::arch::x86::_mm512_adds_epi16 fn">_mm512_adds_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用饱和度在 a 和 b 中添加包装的带符号的 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_adds_epu8.html" title="core::arch::x86::_mm512_adds_epu8 fn">_mm512_adds_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用饱和度在 a 和 b 中添加包装的无符号 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_adds_epu16.html" title="core::arch::x86::_mm512_adds_epu16 fn">_mm512_adds_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用饱和度在 a 和 b 中添加包装的无符号 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_aesdec_epi128.html" title="core::arch::x86::_mm512_aesdec_epi128 fn">_mm512_aesdec_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vaes,avx512f` only"><code>avx512vaes,avx512f</code></span><p>使用 <code>round_key</code> 中的相应 128 位字 (key) 对 <code>a</code> 中的每个 128 位字 (state) 执行一轮 AES 解密流程。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_aesdeclast_epi128.html" title="core::arch::x86::_mm512_aesdeclast_epi128 fn">_mm512_aesdeclast_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vaes,avx512f` only"><code>avx512vaes,avx512f</code></span><p>使用 <code>round_key</code> 中的相应 128 位字 (key) 对 <code>a</code> 中的每个 128 位字 (state) 执行最后一轮 AES 解密流程。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_aesenc_epi128.html" title="core::arch::x86::_mm512_aesenc_epi128 fn">_mm512_aesenc_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vaes,avx512f` only"><code>avx512vaes,avx512f</code></span><p>使用 <code>round_key</code> 中的相应 128 位字 (key) 对 <code>a</code> 中的每个 128 位字 (state) 执行一轮 AES 加密流程。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_aesenclast_epi128.html" title="core::arch::x86::_mm512_aesenclast_epi128 fn">_mm512_aesenclast_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vaes,avx512f` only"><code>avx512vaes,avx512f</code></span><p>使用 <code>round_key</code> 中的相应 128 位字 (key) 对 <code>a</code> 中的每个 128 位字 (state) 执行最后一轮 AES 加密流程。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_alignr_epi8.html" title="core::arch::x86::_mm512_alignr_epi8 fn">_mm512_alignr_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 和 b 中的 16 字节块对连接成 32 字节的临时结果，将结果右移 imm8 字节，并将低 16 字节存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_alignr_epi32.html" title="core::arch::x86::_mm512_alignr_epi32 fn">_mm512_alignr_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 连接成一个 128 字节的立即结果，将结果右移 imm8 32 位元素，并将低 64 字节 (16 个元素) 存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_alignr_epi64.html" title="core::arch::x86::_mm512_alignr_epi64 fn">_mm512_alignr_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 连接成一个 128 字节的立即结果，将结果右移 imm8 64 位元素，并将低 64 字节 (8 个元素) 存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_and_epi32.html" title="core::arch::x86::_mm512_and_epi32 fn">_mm512_and_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中包装的 32 位整数的按位与，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_and_epi64.html" title="core::arch::x86::_mm512_and_epi64 fn">_mm512_and_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中 512 位 (由包装的 64 位整数组成) 的按位与，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_and_si512.html" title="core::arch::x86::_mm512_and_si512 fn">_mm512_and_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中 512 位 (代表整数数据) 的按位与，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_andnot_epi32.html" title="core::arch::x86::_mm512_andnot_epi32 fn">_mm512_andnot_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的 32 位整数的按位 NOT，然后与 b 计算 AND，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_andnot_epi64.html" title="core::arch::x86::_mm512_andnot_epi64 fn">_mm512_andnot_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中的 512 位 (由包装的 64 位整数组成) 的按位非，然后与 b 计算 AND，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_andnot_si512.html" title="core::arch::x86::_mm512_andnot_si512 fn">_mm512_andnot_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中的 512 位 (代表整数数据) 的按位非，然后与 b 计算 AND，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_avg_epu8.html" title="core::arch::x86::_mm512_avg_epu8 fn">_mm512_avg_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 和 b 中包装的无符号 8 位整数平均，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_avg_epu16.html" title="core::arch::x86::_mm512_avg_epu16 fn">_mm512_avg_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 和 b 中的包装无符号 16 位整数进行平均，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_bitshuffle_epi64_mask.html" title="core::arch::x86::_mm512_bitshuffle_epi64_mask fn">_mm512_bitshuffle_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg` only"><code>avx512bitalg</code></span><p>将输入 <code>b</code> 视为包装的 64 位整数，并将 <code>c</code> 视为包装的 8 位整数。
然后将来自 <code>c</code> 的 8 个 8 位值作为索引分组到相应的 64 位整数的位中。
然后，选择这些位并将其包装到输出中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_broadcast_f32x4.html" title="core::arch::x86::_mm512_broadcast_f32x4 fn">_mm512_broadcast_f32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 广播 4 个包装的单精度 (32-bit) 浮点元素到 dst 的所有元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_broadcast_f64x4.html" title="core::arch::x86::_mm512_broadcast_f64x4 fn">_mm512_broadcast_f64x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 广播 4 个包装的双精度 (64-bit) 浮点元素到 dst 的所有元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_broadcast_i32x4.html" title="core::arch::x86::_mm512_broadcast_i32x4 fn">_mm512_broadcast_i32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 4 个包装的 32 位整数从 a 广播到 dst 的所有元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_broadcast_i64x4.html" title="core::arch::x86::_mm512_broadcast_i64x4 fn">_mm512_broadcast_i64x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 4 个包装的 64 位整数从 a 广播到 dst 的所有元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_broadcastb_epi8.html" title="core::arch::x86::_mm512_broadcastb_epi8 fn">_mm512_broadcastb_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将低包装的 8 位整数从 a 广播到 dst 的所有元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_broadcastd_epi32.html" title="core::arch::x86::_mm512_broadcastd_epi32 fn">_mm512_broadcastd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将低包装的 32 位整数从 a 广播到 dst 的所有元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_broadcastmb_epi64.html" title="core::arch::x86::_mm512_broadcastmb_epi64 fn">_mm512_broadcastmb_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span><p>将输入掩码 k 的低 8 位广播到 dst 的所有 64 位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_broadcastmw_epi32.html" title="core::arch::x86::_mm512_broadcastmw_epi32 fn">_mm512_broadcastmw_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span><p>将输入掩码 k 的低 16 位广播到 dst 的所有 32 位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_broadcastq_epi64.html" title="core::arch::x86::_mm512_broadcastq_epi64 fn">_mm512_broadcastq_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将低包装的 64 位整数从 a 广播到 dst 的所有元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_broadcastsd_pd.html" title="core::arch::x86::_mm512_broadcastsd_pd fn">_mm512_broadcastsd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 广播低双精度 (64-bit) 浮点元素到 dst 的所有元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_broadcastss_ps.html" title="core::arch::x86::_mm512_broadcastss_ps fn">_mm512_broadcastss_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将低单精度 (32-bit) 浮点元素从 A 广播到 dst 的所有元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_broadcastw_epi16.html" title="core::arch::x86::_mm512_broadcastw_epi16 fn">_mm512_broadcastw_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将低包装的 16 位整数从 a 广播到 dst 的所有元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_bslli_epi128.html" title="core::arch::x86::_mm512_bslli_epi128 fn">_mm512_bslli_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>向左移动 128 位通道 imm8 字节，同时向零移动，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_bsrli_epi128.html" title="core::arch::x86::_mm512_bsrli_epi128 fn">_mm512_bsrli_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>向右移动 128 位通道 imm8 字节，同时向零移动，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_castpd128_pd512.html" title="core::arch::x86::_mm512_castpd128_pd512 fn">_mm512_castpd128_pd512</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将类型 __m128d 的 vector 强制转换为 __m512d 类型; 结果的高 384 位未定义。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_castpd256_pd512.html" title="core::arch::x86::_mm512_castpd256_pd512 fn">_mm512_castpd256_pd512</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将类型 __m256d 的 vector 强制转换为 __m512d 类型; 结果的高 256 位未定义。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_castpd512_pd128.html" title="core::arch::x86::_mm512_castpd512_pd128 fn">_mm512_castpd512_pd128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将类型为 __m512d 的 vector 强制转换为类型为 __m128d 的 vector。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_castpd512_pd256.html" title="core::arch::x86::_mm512_castpd512_pd256 fn">_mm512_castpd512_pd256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将类型为 __m512d 的 vector 强制转换为类型为 __m256d 的 vector。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_castpd_ps.html" title="core::arch::x86::_mm512_castpd_ps fn">_mm512_castpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将类型为 __m512d 的 vector 强制转换为类型 __m512。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_castpd_si512.html" title="core::arch::x86::_mm512_castpd_si512 fn">_mm512_castpd_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将类型为 __m512d 的 vector 强制转换为类型为 __m512i 的 vector。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_castps128_ps512.html" title="core::arch::x86::_mm512_castps128_ps512 fn">_mm512_castps128_ps512</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将类型 __m128 的 vector 转换为 __m512 类型; 结果的高 384 位未定义。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_castps256_ps512.html" title="core::arch::x86::_mm512_castps256_ps512 fn">_mm512_castps256_ps512</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将类型为 __m256 的 vector 强制转换为类型 __m512; 结果的高 256 位未定义。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_castps512_ps128.html" title="core::arch::x86::_mm512_castps512_ps128 fn">_mm512_castps512_ps128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将类型为 __m512 的 vector 强制转换为类型为 __m128 的 vector。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_castps512_ps256.html" title="core::arch::x86::_mm512_castps512_ps256 fn">_mm512_castps512_ps256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将类型为 __m512 的 vector 强制转换为类型 __m256。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_castps_pd.html" title="core::arch::x86::_mm512_castps_pd fn">_mm512_castps_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将类型为 __m512 的 vector 强制转换为类型为 __m512d 的 vector。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_castps_si512.html" title="core::arch::x86::_mm512_castps_si512 fn">_mm512_castps_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将类型为 __m512 的 vector 强制转换为类型 __m512i。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_castsi128_si512.html" title="core::arch::x86::_mm512_castsi128_si512 fn">_mm512_castsi128_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将类型为 __m128i 的 vector 强制转换为类型 __m512i; 结果的高 384 位未定义。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_castsi256_si512.html" title="core::arch::x86::_mm512_castsi256_si512 fn">_mm512_castsi256_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将类型为 __m256i 的 vector 强制转换为类型 __m512i; 结果的高 256 位未定义。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_castsi512_pd.html" title="core::arch::x86::_mm512_castsi512_pd fn">_mm512_castsi512_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将类型为 __m512i 的 vector 强制转换为类型为 __m512d 的 vector。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_castsi512_ps.html" title="core::arch::x86::_mm512_castsi512_ps fn">_mm512_castsi512_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将类型为 __m512i 的 vector 强制转换为类型 __m512。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_castsi512_si128.html" title="core::arch::x86::_mm512_castsi512_si128 fn">_mm512_castsi512_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将类型为 __m512i 的 vector 强制转换为类型为 __m128i 的 vector。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_castsi512_si256.html" title="core::arch::x86::_mm512_castsi512_si256 fn">_mm512_castsi512_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将类型为 __m512i 的 vector 强制转换为类型为 __m256i 的 vector。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_clmulepi64_epi128.html" title="core::arch::x86::_mm512_clmulepi64_epi128 fn">_mm512_clmulepi64_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpclmulqdq,avx512f` only"><code>avx512vpclmulqdq,avx512f</code></span><p>在 4 个 128 位通道中的每一个中，在有限域 GF(2^k) 上执行两个 64 位多项式的无进位乘法。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmp_epi8_mask.html" title="core::arch::x86::_mm512_cmp_epi8_mask fn">_mm512_cmp_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装带符号 8 位整数，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmp_epi16_mask.html" title="core::arch::x86::_mm512_cmp_epi16_mask fn">_mm512_cmp_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号 16 位整数，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmp_epi32_mask.html" title="core::arch::x86::_mm512_cmp_epi32_mask fn">_mm512_cmp_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装有符号 32 位整数，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmp_epi64_mask.html" title="core::arch::x86::_mm512_cmp_epi64_mask fn">_mm512_cmp_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 64 位整数，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmp_epu8_mask.html" title="core::arch::x86::_mm512_cmp_epu8_mask fn">_mm512_cmp_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 8 位整数，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmp_epu16_mask.html" title="core::arch::x86::_mm512_cmp_epu16_mask fn">_mm512_cmp_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>根据 <code>IMM8</code> 指定的比较操作数比较 a 和 b 中包装的无符号 16 位整数，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmp_epu32_mask.html" title="core::arch::x86::_mm512_cmp_epu32_mask fn">_mm512_cmp_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 32 位整数，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmp_epu64_mask.html" title="core::arch::x86::_mm512_cmp_epu64_mask fn">_mm512_cmp_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 64 位整数，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmp_pd_mask.html" title="core::arch::x86::_mm512_cmp_pd_mask fn">_mm512_cmp_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmp_ps_mask.html" title="core::arch::x86::_mm512_cmp_ps_mask fn">_mm512_cmp_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmp_round_pd_mask.html" title="core::arch::x86::_mm512_cmp_round_pd_mask fn">_mm512_cmp_round_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在掩码 vector k 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmp_round_ps_mask.html" title="core::arch::x86::_mm512_cmp_round_ps_mask fn">_mm512_cmp_round_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并将结果存储在掩码 vector k 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpeq_epi8_mask.html" title="core::arch::x86::_mm512_cmpeq_epi8_mask fn">_mm512_cmpeq_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpeq_epi16_mask.html" title="core::arch::x86::_mm512_cmpeq_epi16_mask fn">_mm512_cmpeq_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpeq_epi32_mask.html" title="core::arch::x86::_mm512_cmpeq_epi32_mask fn">_mm512_cmpeq_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的 32 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpeq_epi64_mask.html" title="core::arch::x86::_mm512_cmpeq_epi64_mask fn">_mm512_cmpeq_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的 64 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpeq_epu8_mask.html" title="core::arch::x86::_mm512_cmpeq_epu8_mask fn">_mm512_cmpeq_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpeq_epu16_mask.html" title="core::arch::x86::_mm512_cmpeq_epu16_mask fn">_mm512_cmpeq_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpeq_epu32_mask.html" title="core::arch::x86::_mm512_cmpeq_epu32_mask fn">_mm512_cmpeq_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpeq_epu64_mask.html" title="core::arch::x86::_mm512_cmpeq_epu64_mask fn">_mm512_cmpeq_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpeq_pd_mask.html" title="core::arch::x86::_mm512_cmpeq_pd_mask fn">_mm512_cmpeq_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpeq_ps_mask.html" title="core::arch::x86::_mm512_cmpeq_ps_mask fn">_mm512_cmpeq_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpge_epi8_mask.html" title="core::arch::x86::_mm512_cmpge_epi8_mask fn">_mm512_cmpge_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否大于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpge_epi16_mask.html" title="core::arch::x86::_mm512_cmpge_epi16_mask fn">_mm512_cmpge_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号 16 位整数是否大于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpge_epi32_mask.html" title="core::arch::x86::_mm512_cmpge_epi32_mask fn">_mm512_cmpge_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号 32 位整数是否大于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpge_epi64_mask.html" title="core::arch::x86::_mm512_cmpge_epi64_mask fn">_mm512_cmpge_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数是否大于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpge_epu8_mask.html" title="core::arch::x86::_mm512_cmpge_epu8_mask fn">_mm512_cmpge_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否大于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpge_epu16_mask.html" title="core::arch::x86::_mm512_cmpge_epu16_mask fn">_mm512_cmpge_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否大于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpge_epu32_mask.html" title="core::arch::x86::_mm512_cmpge_epu32_mask fn">_mm512_cmpge_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否大于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpge_epu64_mask.html" title="core::arch::x86::_mm512_cmpge_epu64_mask fn">_mm512_cmpge_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否大于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpgt_epi8_mask.html" title="core::arch::x86::_mm512_cmpgt_epi8_mask fn">_mm512_cmpgt_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否大于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpgt_epi16_mask.html" title="core::arch::x86::_mm512_cmpgt_epi16_mask fn">_mm512_cmpgt_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号 16 位整数是否大于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpgt_epi32_mask.html" title="core::arch::x86::_mm512_cmpgt_epi32_mask fn">_mm512_cmpgt_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数是否大于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpgt_epi64_mask.html" title="core::arch::x86::_mm512_cmpgt_epi64_mask fn">_mm512_cmpgt_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数是否大于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpgt_epu8_mask.html" title="core::arch::x86::_mm512_cmpgt_epu8_mask fn">_mm512_cmpgt_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否大于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpgt_epu16_mask.html" title="core::arch::x86::_mm512_cmpgt_epu16_mask fn">_mm512_cmpgt_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否大于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpgt_epu32_mask.html" title="core::arch::x86::_mm512_cmpgt_epu32_mask fn">_mm512_cmpgt_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否大于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpgt_epu64_mask.html" title="core::arch::x86::_mm512_cmpgt_epu64_mask fn">_mm512_cmpgt_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否大于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmple_epi8_mask.html" title="core::arch::x86::_mm512_cmple_epi8_mask fn">_mm512_cmple_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数 (小于等于)，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmple_epi16_mask.html" title="core::arch::x86::_mm512_cmple_epi16_mask fn">_mm512_cmple_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数 (小于等于)，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmple_epi32_mask.html" title="core::arch::x86::_mm512_cmple_epi32_mask fn">_mm512_cmple_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数 (小于等于)，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmple_epi64_mask.html" title="core::arch::x86::_mm512_cmple_epi64_mask fn">_mm512_cmple_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数 (小于等于)，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmple_epu8_mask.html" title="core::arch::x86::_mm512_cmple_epu8_mask fn">_mm512_cmple_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 8 位整数以得出小于或等于的结果，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmple_epu16_mask.html" title="core::arch::x86::_mm512_cmple_epu16_mask fn">_mm512_cmple_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否小于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmple_epu32_mask.html" title="core::arch::x86::_mm512_cmple_epu32_mask fn">_mm512_cmple_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否小于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmple_epu64_mask.html" title="core::arch::x86::_mm512_cmple_epu64_mask fn">_mm512_cmple_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否小于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmple_pd_mask.html" title="core::arch::x86::_mm512_cmple_pd_mask fn">_mm512_cmple_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否小于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmple_ps_mask.html" title="core::arch::x86::_mm512_cmple_ps_mask fn">_mm512_cmple_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否小于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmplt_epi8_mask.html" title="core::arch::x86::_mm512_cmplt_epi8_mask fn">_mm512_cmplt_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数小于零，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmplt_epi16_mask.html" title="core::arch::x86::_mm512_cmplt_epi16_mask fn">_mm512_cmplt_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数 (小于)，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmplt_epi32_mask.html" title="core::arch::x86::_mm512_cmplt_epi32_mask fn">_mm512_cmplt_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数 (小于)，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmplt_epi64_mask.html" title="core::arch::x86::_mm512_cmplt_epi64_mask fn">_mm512_cmplt_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数小于零，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmplt_epu8_mask.html" title="core::arch::x86::_mm512_cmplt_epu8_mask fn">_mm512_cmplt_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 8 位整数以得到小于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmplt_epu16_mask.html" title="core::arch::x86::_mm512_cmplt_epu16_mask fn">_mm512_cmplt_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装后的无符号 16 位整数 (小于)，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmplt_epu32_mask.html" title="core::arch::x86::_mm512_cmplt_epu32_mask fn">_mm512_cmplt_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否小于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmplt_epu64_mask.html" title="core::arch::x86::_mm512_cmplt_epu64_mask fn">_mm512_cmplt_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否小于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmplt_pd_mask.html" title="core::arch::x86::_mm512_cmplt_pd_mask fn">_mm512_cmplt_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装后的双精度 (64-bit) 浮点元素的小于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmplt_ps_mask.html" title="core::arch::x86::_mm512_cmplt_ps_mask fn">_mm512_cmplt_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素的小于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpneq_epi8_mask.html" title="core::arch::x86::_mm512_cmpneq_epi8_mask fn">_mm512_cmpneq_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否不相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpneq_epi16_mask.html" title="core::arch::x86::_mm512_cmpneq_epi16_mask fn">_mm512_cmpneq_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号 16 位整数是否不相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpneq_epi32_mask.html" title="core::arch::x86::_mm512_cmpneq_epi32_mask fn">_mm512_cmpneq_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的 32 位整数是否不相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpneq_epi64_mask.html" title="core::arch::x86::_mm512_cmpneq_epi64_mask fn">_mm512_cmpneq_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数是否不相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpneq_epu8_mask.html" title="core::arch::x86::_mm512_cmpneq_epu8_mask fn">_mm512_cmpneq_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpneq_epu16_mask.html" title="core::arch::x86::_mm512_cmpneq_epu16_mask fn">_mm512_cmpneq_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否不相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpneq_epu32_mask.html" title="core::arch::x86::_mm512_cmpneq_epu32_mask fn">_mm512_cmpneq_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否不相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpneq_epu64_mask.html" title="core::arch::x86::_mm512_cmpneq_epu64_mask fn">_mm512_cmpneq_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否不相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpneq_pd_mask.html" title="core::arch::x86::_mm512_cmpneq_pd_mask fn">_mm512_cmpneq_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpneq_ps_mask.html" title="core::arch::x86::_mm512_cmpneq_ps_mask fn">_mm512_cmpneq_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否不相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpnle_pd_mask.html" title="core::arch::x86::_mm512_cmpnle_pd_mask fn">_mm512_cmpnle_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否等于或小于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpnle_ps_mask.html" title="core::arch::x86::_mm512_cmpnle_ps_mask fn">_mm512_cmpnle_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否等于或小于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpnlt_pd_mask.html" title="core::arch::x86::_mm512_cmpnlt_pd_mask fn">_mm512_cmpnlt_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的双精度 (64-bit) 浮点元素不小于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpnlt_ps_mask.html" title="core::arch::x86::_mm512_cmpnlt_ps_mask fn">_mm512_cmpnlt_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素不小于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpord_pd_mask.html" title="core::arch::x86::_mm512_cmpord_pd_mask fn">_mm512_cmpord_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，看是否都不是 NaN，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpord_ps_mask.html" title="core::arch::x86::_mm512_cmpord_ps_mask fn">_mm512_cmpord_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，看是否都不是 NaN，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpunord_pd_mask.html" title="core::arch::x86::_mm512_cmpunord_pd_mask fn">_mm512_cmpunord_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，以查看其中一个是否为 NaN，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cmpunord_ps_mask.html" title="core::arch::x86::_mm512_cmpunord_ps_mask fn">_mm512_cmpunord_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，以查看是否为 NaN，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_conflict_epi32.html" title="core::arch::x86::_mm512_conflict_epi32 fn">_mm512_conflict_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span><p>测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_conflict_epi64.html" title="core::arch::x86::_mm512_conflict_epi64 fn">_mm512_conflict_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span><p>测试 a 的每个 64 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvt_roundepi32_ps.html" title="core::arch::x86::_mm512_cvt_roundepi32_ps fn">_mm512_cvt_roundepi32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装后的带符号的 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvt_roundepu32_ps.html" title="core::arch::x86::_mm512_cvt_roundepu32_ps fn">_mm512_cvt_roundepu32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvt_roundpd_epi32.html" title="core::arch::x86::_mm512_cvt_roundpd_epi32 fn">_mm512_cvt_roundpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvt_roundpd_epu32.html" title="core::arch::x86::_mm512_cvt_roundpd_epu32 fn">_mm512_cvt_roundpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvt_roundpd_ps.html" title="core::arch::x86::_mm512_cvt_roundpd_ps fn">_mm512_cvt_roundpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvt_roundph_ps.html" title="core::arch::x86::_mm512_cvt_roundph_ps fn">_mm512_cvt_roundph_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的半精度 (16-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvt_roundps_epi32.html" title="core::arch::x86::_mm512_cvt_roundps_epi32 fn">_mm512_cvt_roundps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvt_roundps_epu32.html" title="core::arch::x86::_mm512_cvt_roundps_epu32 fn">_mm512_cvt_roundps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvt_roundps_pd.html" title="core::arch::x86::_mm512_cvt_roundps_pd fn">_mm512_cvt_roundps_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvt_roundps_ph.html" title="core::arch::x86::_mm512_cvt_roundps_ph fn">_mm512_cvt_roundps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtepi8_epi16.html" title="core::arch::x86::_mm512_cvtepi8_epi16 fn">_mm512_cvtepi8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用符号将包装的 8 位整数从 a 扩展到包装的 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtepi8_epi32.html" title="core::arch::x86::_mm512_cvtepi8_epi32 fn">_mm512_cvtepi8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用符号将包装的 8 位整数从 a 扩展到包装的 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtepi8_epi64.html" title="core::arch::x86::_mm512_cvtepi8_epi64 fn">_mm512_cvtepi8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>符号将 a 的低 8 个字节中的包装 8 位整数扩展为包装 64 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtepi16_epi8.html" title="core::arch::x86::_mm512_cvtepi16_epi8 fn">_mm512_cvtepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 中的包装的 16 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtepi16_epi32.html" title="core::arch::x86::_mm512_cvtepi16_epi32 fn">_mm512_cvtepi16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>符号将包装的 16 位整数从 a 扩展为包装的 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtepi16_epi64.html" title="core::arch::x86::_mm512_cvtepi16_epi64 fn">_mm512_cvtepi16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用符号将包装的 16 位整数从 a 扩展到包装的 64 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtepi32_epi8.html" title="core::arch::x86::_mm512_cvtepi32_epi8 fn">_mm512_cvtepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将带有 a 的包装的 32 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtepi32_epi16.html" title="core::arch::x86::_mm512_cvtepi32_epi16 fn">_mm512_cvtepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtepi32_epi64.html" title="core::arch::x86::_mm512_cvtepi32_epi64 fn">_mm512_cvtepi32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用符号将包装的 32 位整数从 a 扩展到包装的 64 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtepi32_pd.html" title="core::arch::x86::_mm512_cvtepi32_pd fn">_mm512_cvtepi32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装后的带符号的 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtepi32_ps.html" title="core::arch::x86::_mm512_cvtepi32_ps fn">_mm512_cvtepi32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装后的带符号的 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtepi32lo_pd.html" title="core::arch::x86::_mm512_cvtepi32lo_pd fn">_mm512_cvtepi32lo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 v2 中包装的 32 位整数整数元素的下半部分转换为包装的双精度 (64-bit) 浮点元素，将元素进行逐元素转换，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtepi64_epi8.html" title="core::arch::x86::_mm512_cvtepi64_epi8 fn">_mm512_cvtepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将带有 a 的包装的 64 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtepi64_epi16.html" title="core::arch::x86::_mm512_cvtepi64_epi16 fn">_mm512_cvtepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将带有 a 的包装的 64 位整数转换为带有截断的包装的 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtepi64_epi32.html" title="core::arch::x86::_mm512_cvtepi64_epi32 fn">_mm512_cvtepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将带有 a 的包装的 64 位整数转换为带有截断的包装的 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtepu8_epi16.html" title="core::arch::x86::_mm512_cvtepu8_epi16 fn">_mm512_cvtepu8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 中的包装无符号 8 位整数零扩展为包装 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtepu8_epi32.html" title="core::arch::x86::_mm512_cvtepu8_epi32 fn">_mm512_cvtepu8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 8 位整数零扩展为包装 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtepu8_epi64.html" title="core::arch::x86::_mm512_cvtepu8_epi64 fn">_mm512_cvtepu8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将低 8 字节 sof 中的包装无符号 8 位整数零扩展到包装 64 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtepu16_epi32.html" title="core::arch::x86::_mm512_cvtepu16_epi32 fn">_mm512_cvtepu16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 16 位整数零扩展为包装 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtepu16_epi64.html" title="core::arch::x86::_mm512_cvtepu16_epi64 fn">_mm512_cvtepu16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 16 位整数零扩展为包装 64 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtepu32_epi64.html" title="core::arch::x86::_mm512_cvtepu32_epi64 fn">_mm512_cvtepu32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 32 位整数零扩展为包装 64 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtepu32_pd.html" title="core::arch::x86::_mm512_cvtepu32_pd fn">_mm512_cvtepu32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 A 中的包装的无符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtepu32_ps.html" title="core::arch::x86::_mm512_cvtepu32_ps fn">_mm512_cvtepu32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtepu32lo_pd.html" title="core::arch::x86::_mm512_cvtepu32lo_pd fn">_mm512_cvtepu32lo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 v2 中包装的 32 位无符号整数整数元素的下半部分转换为包装的双精度 (64-bit) 浮点元素，将每个元素进行逐元素转换，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtne2ps_pbh.html" title="core::arch::x86::_mm512_cvtne2ps_pbh fn">_mm512_cvtne2ps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512f` only"><code>avx512bf16,avx512f</code></span><p>将两个 512 位 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并将结果存入 a</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtneps_pbh.html" title="core::arch::x86::_mm512_cvtneps_pbh fn">_mm512_cvtneps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512f` only"><code>avx512bf16,avx512f</code></span><p>将包装在 a 中的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并将结果存储在 dst 中。
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#expand=1769,1651,1654,1657,1660&amp;avx512techs=AVX512_BF16&amp;text=_mm512_cvtneps_pbh">Intel’s documentation</a></p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtpd_epi32.html" title="core::arch::x86::_mm512_cvtpd_epi32 fn">_mm512_cvtpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtpd_epu32.html" title="core::arch::x86::_mm512_cvtpd_epu32 fn">_mm512_cvtpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtpd_ps.html" title="core::arch::x86::_mm512_cvtpd_ps fn">_mm512_cvtpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtpd_pslo.html" title="core::arch::x86::_mm512_cvtpd_pslo fn">_mm512_cvtpd_pslo</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 v2 中的包装的双精度 (64-bit) 浮点元素执行逐元素转换为单精度 (32-bit) 浮点元素并将其存储在 dst 中。元素存储在结果 vector 的下半部分中，而其余的上半部分位置设置为 0。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtph_ps.html" title="core::arch::x86::_mm512_cvtph_ps fn">_mm512_cvtph_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的半精度 (16-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtps_epi32.html" title="core::arch::x86::_mm512_cvtps_epi32 fn">_mm512_cvtps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtps_epu32.html" title="core::arch::x86::_mm512_cvtps_epu32 fn">_mm512_cvtps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtps_pd.html" title="core::arch::x86::_mm512_cvtps_pd fn">_mm512_cvtps_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtps_ph.html" title="core::arch::x86::_mm512_cvtps_ph fn">_mm512_cvtps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtpslo_pd.html" title="core::arch::x86::_mm512_cvtpslo_pd fn">_mm512_cvtpslo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>对 v2 中包装的单精度 (32-bit) 浮点元素的下半部分到包装的双精度 (64-bit) 浮点元素的下半部分进行逐元素转换，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtsepi16_epi8.html" title="core::arch::x86::_mm512_cvtsepi16_epi8 fn">_mm512_cvtsepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 A 中的包装有符号 16 位整数转换为带符号饱和的包装 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtsepi32_epi8.html" title="core::arch::x86::_mm512_cvtsepi32_epi8 fn">_mm512_cvtsepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtsepi32_epi16.html" title="core::arch::x86::_mm512_cvtsepi32_epi16 fn">_mm512_cvtsepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtsepi64_epi8.html" title="core::arch::x86::_mm512_cvtsepi64_epi8 fn">_mm512_cvtsepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的带符号的 64 位整数转换为带符号饱和的包装的 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtsepi64_epi16.html" title="core::arch::x86::_mm512_cvtsepi64_epi16 fn">_mm512_cvtsepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的带符号的 64 位整数转换为带符号饱和的包装的 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtsepi64_epi32.html" title="core::arch::x86::_mm512_cvtsepi64_epi32 fn">_mm512_cvtsepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtsi512_si32.html" title="core::arch::x86::_mm512_cvtsi512_si32 fn">_mm512_cvtsi512_si32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的低 32 位整数复制到 dst。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtt_roundpd_epi32.html" title="core::arch::x86::_mm512_cvtt_roundpd_epi32 fn">_mm512_cvtt_roundpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtt_roundpd_epu32.html" title="core::arch::x86::_mm512_cvtt_roundpd_epu32 fn">_mm512_cvtt_roundpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtt_roundps_epi32.html" title="core::arch::x86::_mm512_cvtt_roundps_epi32 fn">_mm512_cvtt_roundps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtt_roundps_epu32.html" title="core::arch::x86::_mm512_cvtt_roundps_epu32 fn">_mm512_cvtt_roundps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvttpd_epi32.html" title="core::arch::x86::_mm512_cvttpd_epi32 fn">_mm512_cvttpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvttpd_epu32.html" title="core::arch::x86::_mm512_cvttpd_epu32 fn">_mm512_cvttpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvttps_epi32.html" title="core::arch::x86::_mm512_cvttps_epi32 fn">_mm512_cvttps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvttps_epu32.html" title="core::arch::x86::_mm512_cvttps_epu32 fn">_mm512_cvttps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtusepi16_epi8.html" title="core::arch::x86::_mm512_cvtusepi16_epi8 fn">_mm512_cvtusepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtusepi32_epi8.html" title="core::arch::x86::_mm512_cvtusepi32_epi8 fn">_mm512_cvtusepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtusepi32_epi16.html" title="core::arch::x86::_mm512_cvtusepi32_epi16 fn">_mm512_cvtusepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 A 中的包装无符号 32 位整数转换为具有无符号饱和度的包装无符号 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtusepi64_epi8.html" title="core::arch::x86::_mm512_cvtusepi64_epi8 fn">_mm512_cvtusepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtusepi64_epi16.html" title="core::arch::x86::_mm512_cvtusepi64_epi16 fn">_mm512_cvtusepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_cvtusepi64_epi32.html" title="core::arch::x86::_mm512_cvtusepi64_epi32 fn">_mm512_cvtusepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 A 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_dbsad_epu8.html" title="core::arch::x86::_mm512_dbsad_epu8 fn">_mm512_dbsad_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 a 中与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs)，并将 16 位结果存储在 dst 中。对于每个 64 位通道，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中通道的低 8 位四元组，而后两个 SAD 使用 a 中通道的较高 8 位四元组。根据 imm8 中的控件，从 128 位通道中选择 b 中的四元组，并且每个 64 位通道中的每个 SAD 使用 8 位偏移量的选定四元组。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_div_pd.html" title="core::arch::x86::_mm512_div_pd fn">_mm512_div_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_div_ps.html" title="core::arch::x86::_mm512_div_ps fn">_mm512_div_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的包装的单精度 (32-bit) 浮点元素除以 b 中的包装的元素，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_div_round_pd.html" title="core::arch::x86::_mm512_div_round_pd fn">_mm512_div_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_div_round_ps.html" title="core::arch::x86::_mm512_div_round_ps fn">_mm512_div_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的包装的单精度 (32-bit) 浮点元素除以 b 中的包装的元素，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_dpbf16_ps.html" title="core::arch::x86::_mm512_dpbf16_ps fn">_mm512_dpbf16_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512f` only"><code>avx512bf16,avx512f</code></span><p>计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间单精度 (32-bit) 浮点元素与 src 中的元素累加，结果存储在 BF16 (16-bit) 浮点对的 dst.Compute 点积中 b、将中间的单精度 (32-bit) 浮点元素与 src 中的元素进行累加，并将结果存入 dst。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_dpbusd_epi32.html" title="core::arch::x86::_mm512_dpbusd_epi32 fn">_mm512_dpbusd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni` only"><code>avx512vnni</code></span><p>将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果存入 dst。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_dpbusds_epi32.html" title="core::arch::x86::_mm512_dpbusds_epi32 fn">_mm512_dpbusds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni` only"><code>avx512vnni</code></span><p>将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。使用有符号饱和将这 4 个结果与 src 中相应的 32 位整数相加，并将包装的 32 位结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_dpwssd_epi32.html" title="core::arch::x86::_mm512_dpwssd_epi32 fn">_mm512_dpwssd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni` only"><code>avx512vnni</code></span><p>将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果存入 dst。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_dpwssds_epi32.html" title="core::arch::x86::_mm512_dpwssds_epi32 fn">_mm512_dpwssds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni` only"><code>avx512vnni</code></span><p>将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并将包装的 32 位结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_extractf32x4_ps.html" title="core::arch::x86::_mm512_extractf32x4_ps fn">_mm512_extractf32x4_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 提取 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并用 imm8 进行选择，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_extractf64x4_pd.html" title="core::arch::x86::_mm512_extractf64x4_pd fn">_mm512_extractf64x4_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 提取 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成)，并用 imm8 进行选择，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_extracti32x4_epi32.html" title="core::arch::x86::_mm512_extracti32x4_epi32 fn">_mm512_extracti32x4_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中提取 128 位 (由 4 个包装的 32 位整数组成)，用 IMM2 选中，结果存入 dst。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_extracti64x4_epi64.html" title="core::arch::x86::_mm512_extracti64x4_epi64 fn">_mm512_extracti64x4_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中提取 256 位 (由 4 个包装的 64 位整数组成)，用 IMM1 选择，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fixupimm_pd.html" title="core::arch::x86::_mm512_fixupimm_pd fn">_mm512_fixupimm_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 c 中的包装的 64 位整数修复 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fixupimm_ps.html" title="core::arch::x86::_mm512_fixupimm_ps fn">_mm512_fixupimm_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 c 中的包装 32 位整数修复 a 和 b 中包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fixupimm_round_pd.html" title="core::arch::x86::_mm512_fixupimm_round_pd fn">_mm512_fixupimm_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 c 中的包装的 64 位整数修复 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fixupimm_round_ps.html" title="core::arch::x86::_mm512_fixupimm_round_ps fn">_mm512_fixupimm_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 c 中的包装 32 位整数修复 a 和 b 中包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fmadd_pd.html" title="core::arch::x86::_mm512_fmadd_pd fn">_mm512_fmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fmadd_ps.html" title="core::arch::x86::_mm512_fmadd_ps fn">_mm512_fmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fmadd_round_pd.html" title="core::arch::x86::_mm512_fmadd_round_pd fn">_mm512_fmadd_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fmadd_round_ps.html" title="core::arch::x86::_mm512_fmadd_round_ps fn">_mm512_fmadd_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fmaddsub_pd.html" title="core::arch::x86::_mm512_fmaddsub_pd fn">_mm512_fmaddsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中乘以包装的双精度 (64-bit) 浮点元素，或者在中间结果中乘以 c to/from 的包装的元素，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fmaddsub_ps.html" title="core::arch::x86::_mm512_fmaddsub_ps fn">_mm512_fmaddsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，或者将 c to/from 中的包装的元素相加或相减，得到中间结果，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fmaddsub_round_pd.html" title="core::arch::x86::_mm512_fmaddsub_round_pd fn">_mm512_fmaddsub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中乘以包装的双精度 (64-bit) 浮点元素，或者在中间结果中乘以 c to/from 的包装的元素，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fmaddsub_round_ps.html" title="core::arch::x86::_mm512_fmaddsub_round_ps fn">_mm512_fmaddsub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，或者将 c to/from 中的包装的元素相加或相减，得到中间结果，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fmsub_pd.html" title="core::arch::x86::_mm512_fmsub_pd fn">_mm512_fmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fmsub_ps.html" title="core::arch::x86::_mm512_fmsub_ps fn">_mm512_fmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fmsub_round_pd.html" title="core::arch::x86::_mm512_fmsub_round_pd fn">_mm512_fmsub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fmsub_round_ps.html" title="core::arch::x86::_mm512_fmsub_round_ps fn">_mm512_fmsub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fmsubadd_pd.html" title="core::arch::x86::_mm512_fmsubadd_pd fn">_mm512_fmsubadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 c from/to 中的包装后的元素相减并相加，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fmsubadd_ps.html" title="core::arch::x86::_mm512_fmsubadd_ps fn">_mm512_fmsubadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，或者将 c from/to 中的包装的元素相减并相加，得到中间结果，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fmsubadd_round_pd.html" title="core::arch::x86::_mm512_fmsubadd_round_pd fn">_mm512_fmsubadd_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 c from/to 中的包装后的元素相减并相加，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fmsubadd_round_ps.html" title="core::arch::x86::_mm512_fmsubadd_round_ps fn">_mm512_fmsubadd_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，或者将 c from/to 中的包装的元素相减并相加，得到中间结果，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fnmadd_pd.html" title="core::arch::x86::_mm512_fnmadd_pd fn">_mm512_fnmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fnmadd_ps.html" title="core::arch::x86::_mm512_fnmadd_ps fn">_mm512_fnmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fnmadd_round_pd.html" title="core::arch::x86::_mm512_fnmadd_round_pd fn">_mm512_fnmadd_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fnmadd_round_ps.html" title="core::arch::x86::_mm512_fnmadd_round_ps fn">_mm512_fnmadd_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fnmsub_pd.html" title="core::arch::x86::_mm512_fnmsub_pd fn">_mm512_fnmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装的元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fnmsub_ps.html" title="core::arch::x86::_mm512_fnmsub_ps fn">_mm512_fnmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fnmsub_round_pd.html" title="core::arch::x86::_mm512_fnmsub_round_pd fn">_mm512_fnmsub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装的元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_fnmsub_round_ps.html" title="core::arch::x86::_mm512_fnmsub_round_ps fn">_mm512_fnmsub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_getexp_pd.html" title="core::arch::x86::_mm512_getexp_pd fn">_mm512_getexp_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并将结果存储在 dst 中。本质上，此内联函数为每个元素计算 floor(log2(x))。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_getexp_ps.html" title="core::arch::x86::_mm512_getexp_ps fn">_mm512_getexp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，并将结果存储在 dst 中。本质上，此内联函数为每个元素计算 floor(log2(x))。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_getexp_round_pd.html" title="core::arch::x86::_mm512_getexp_round_pd fn">_mm512_getexp_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并将结果存储在 dst 中。本质上，此内联函数为每个元素计算 floor(log2(x))。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_getexp_round_ps.html" title="core::arch::x86::_mm512_getexp_round_ps fn">_mm512_getexp_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，并将结果存储在 dst 中。本质上，此内联函数为每个元素计算 floor(log2(x))。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_getmant_pd.html" title="core::arch::x86::_mm512_getmant_pd fn">_mm512_getmant_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素的尾数规格化，并将结果存储在 dst 中。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_getmant_ps.html" title="core::arch::x86::_mm512_getmant_ps fn">_mm512_getmant_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素的尾数标准化，并将结果存储在 dst 中。
此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:
_MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) The sign is determined by sc which can take the following values:</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_getmant_round_pd.html" title="core::arch::x86::_mm512_getmant_round_pd fn">_mm512_getmant_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素的尾数规格化，并将结果存储在 dst 中。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_getmant_round_ps.html" title="core::arch::x86::_mm512_getmant_round_ps fn">_mm512_getmant_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素的尾数标准化，并将结果存储在 dst 中。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_gf2p8affine_epi64_epi8.html" title="core::arch::x86::_mm512_gf2p8affine_epi64_epi8 fn">_mm512_gf2p8affine_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512f` only"><code>avx512gfni,avx512bw,avx512f</code></span><p>对 x 中的包装字节执行仿射变换。
也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_gf2p8affineinv_epi64_epi8.html" title="core::arch::x86::_mm512_gf2p8affineinv_epi64_epi8 fn">_mm512_gf2p8affineinv_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512f` only"><code>avx512gfni,avx512bw,avx512f</code></span><p>对 x 中的反向包装的字节执行仿射变换。
也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_gf2p8mul_epi8.html" title="core::arch::x86::_mm512_gf2p8mul_epi8 fn">_mm512_gf2p8mul_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512f` only"><code>avx512gfni,avx512bw,avx512f</code></span><p>在包装的字节上执行 GF(2^8) 乘法。
该字段以多项式表示，具有约数多项式 x^8 + x^4 + x^3 + x + 1。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_i32gather_epi32.html" title="core::arch::x86::_mm512_i32gather_epi32 fn">_mm512_i32gather_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 32 位索引从内存中收集 32 位整数。从 base_addr 开始的地址加载 32 位元素，并由 vindex 中的每个 32 位元素偏移 (每个索引均按比例因子进行缩放)。收集的元素将合并到 dst 中。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_i32gather_epi64.html" title="core::arch::x86::_mm512_i32gather_epi64 fn">_mm512_i32gather_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 32 位索引从内存中收集 64 位整数。从 base_addr 开始的地址加载 64 位元素，并由 vindex 中的每个 32 位元素偏移 (每个索引均按比例因子进行缩放)。收集的元素将合并到 dst 中。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_i32gather_pd.html" title="core::arch::x86::_mm512_i32gather_pd fn">_mm512_i32gather_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 32 位索引从内存中收集双精度 (64-bit) 浮点元素。从 base_addr 开始的地址加载 64 位元素，并由 vindex 中的每个 32 位元素偏移 (每个索引均按比例因子进行缩放)。收集的元素将合并到 dst 中。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_i32gather_ps.html" title="core::arch::x86::_mm512_i32gather_ps fn">_mm512_i32gather_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 32 位索引从内存中收集单精度 (32-bit) 浮点元素。从 base_addr 开始的地址加载 32 位元素，并由 vindex 中的每个 32 位元素偏移 (每个索引均按比例因子进行缩放)。收集的元素将合并到 dst 中。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_i32scatter_epi32.html" title="core::arch::x86::_mm512_i32scatter_epi32 fn">_mm512_i32scatter_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 32 位索引将 32 位整数从 a 分散到内存中。32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 32 位元素偏移 (每个索引都按比例因子进行缩放)。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_i32scatter_epi64.html" title="core::arch::x86::_mm512_i32scatter_epi64 fn">_mm512_i32scatter_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 32 位索引将 64 位整数从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 32 位元素偏移 (每个索引都按比例因子进行缩放)。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_i32scatter_pd.html" title="core::arch::x86::_mm512_i32scatter_pd fn">_mm512_i32scatter_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 32 位索引将双精度 (64-bit) 浮点元素从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 32 位元素偏移 (每个索引都按比例因子进行缩放)。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_i32scatter_ps.html" title="core::arch::x86::_mm512_i32scatter_ps fn">_mm512_i32scatter_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 32 位索引将单精度 (32-bit) 浮点元素从 a 分散到内存中。32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 32 位元素偏移 (每个索引都按比例因子进行缩放)。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_i64gather_epi32.html" title="core::arch::x86::_mm512_i64gather_epi32 fn">_mm512_i64gather_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 64 位索引从内存中收集 32 位整数。从 base_addr 开始的地址加载 32 位元素，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)。收集的元素将合并到 dst 中。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_i64gather_epi64.html" title="core::arch::x86::_mm512_i64gather_epi64 fn">_mm512_i64gather_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 64 位索引从内存中收集 64 位整数。从 base_addr 开始的地址加载 64 位元素，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)。收集的元素将合并到 dst 中。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_i64gather_pd.html" title="core::arch::x86::_mm512_i64gather_pd fn">_mm512_i64gather_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 64 位索引从内存中收集双精度 (64-bit) 浮点元素。从 base_addr 开始的地址加载 64 位元素，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)。收集的元素将合并到 dst 中。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_i64gather_ps.html" title="core::arch::x86::_mm512_i64gather_ps fn">_mm512_i64gather_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 64 位索引从内存中收集单精度 (32-bit) 浮点元素。从 base_addr 开始的地址加载 32 位元素，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)。收集的元素将合并到 dst 中。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_i64scatter_epi32.html" title="core::arch::x86::_mm512_i64scatter_epi32 fn">_mm512_i64scatter_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 64 位索引将 32 位整数从 a 分散到内存中。32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_i64scatter_epi64.html" title="core::arch::x86::_mm512_i64scatter_epi64 fn">_mm512_i64scatter_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 64 位索引将 64 位整数从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_i64scatter_pd.html" title="core::arch::x86::_mm512_i64scatter_pd fn">_mm512_i64scatter_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 64 位索引将双精度 (64-bit) 浮点元素从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_i64scatter_ps.html" title="core::arch::x86::_mm512_i64scatter_ps fn">_mm512_i64scatter_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 64 位索引将单精度 (32-bit) 浮点元素从 a 分散到内存中。32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)，且受掩码 k 限制 (未设置相应的掩码位时不存储元素)。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_insertf32x4.html" title="core::arch::x86::_mm512_insertf32x4 fn">_mm512_insertf32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 复制到 dst，然后在 x00X 指定的位置将 d 的 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成) 插入 dst。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_insertf64x4.html" title="core::arch::x86::_mm512_insertf64x4 fn">_mm512_insertf64x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 复制到 dst，然后在 x00X 指定的位置将 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成) 插入 dst。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_inserti32x4.html" title="core::arch::x86::_mm512_inserti32x4 fn">_mm512_inserti32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 复制到 dst，然后在 x00X 指定的位置将 d 的 128 位 (由 4 个包装的 32 位整数组成) 插入 dst。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_inserti64x4.html" title="core::arch::x86::_mm512_inserti64x4 fn">_mm512_inserti64x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 复制到 dst，然后在 imm8 指定的位置将 256 位 (由 4 个包装的 64 位整数组成) 插入 dst。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_int2mask.html" title="core::arch::x86::_mm512_int2mask fn">_mm512_int2mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将整数掩码转换为位掩码，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_kand.html" title="core::arch::x86::_mm512_kand fn">_mm512_kand</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 16 位掩码 a 和 b 的按位与，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_kandn.html" title="core::arch::x86::_mm512_kandn fn">_mm512_kandn</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 16 位掩码 a 的按位非，然后与 b 计算 AND，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_kmov.html" title="core::arch::x86::_mm512_kmov fn">_mm512_kmov</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 16 位掩码 a 复制到 k。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_knot.html" title="core::arch::x86::_mm512_knot fn">_mm512_knot</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 16 位掩码 a 的按位非，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_kor.html" title="core::arch::x86::_mm512_kor fn">_mm512_kor</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 16 位掩码 a 和 b 的按位或，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_kortestc.html" title="core::arch::x86::_mm512_kortestc fn">_mm512_kortestc</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 k1 和 k2 之间执行按位或运算，将结果存储在 dst 中。如果 dst 全为 1，则设置 CF 标志。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_kunpackb.html" title="core::arch::x86::_mm512_kunpackb fn">_mm512_kunpackb</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从掩码 a 和 b 解包并交织 8 位，并将 16 位结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_kxnor.html" title="core::arch::x86::_mm512_kxnor fn">_mm512_kxnor</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 16 位掩码 a 和 b 的按位 XNOR，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_kxor.html" title="core::arch::x86::_mm512_kxor fn">_mm512_kxor</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 16 位掩码 a 和 b 的按位 XOR，并将结果存储在 k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_load_epi32.html" title="core::arch::x86::_mm512_load_epi32 fn">_mm512_load_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 512 位 (由 16 个包装的 32 位整数组成) 从 dst 加载。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_load_epi64.html" title="core::arch::x86::_mm512_load_epi64 fn">_mm512_load_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 512 位 (由 8 个包装的 64 位整数组成) 从 dst 加载。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_load_pd.html" title="core::arch::x86::_mm512_load_pd fn">_mm512_load_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 512 位 (由 8 个包装的双精度 (64-bit) 浮点元素组成) 从 dst 加载。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_load_ps.html" title="core::arch::x86::_mm512_load_ps fn">_mm512_load_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 512 位 (由 16 个包装的单精度 (32-bit) 浮点元素组成) 从 dst 加载。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_load_si512.html" title="core::arch::x86::_mm512_load_si512 fn">_mm512_load_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 512 位整数数据从内存加载到 dst 中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_loadu_epi8.html" title="core::arch::x86::_mm512_loadu_epi8 fn">_mm512_loadu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 512 位 (由 64 个包装的 8 位整数组成) 从 dst 加载。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_loadu_epi16.html" title="core::arch::x86::_mm512_loadu_epi16 fn">_mm512_loadu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 512 位 (由 32 个包装的 16 位整数组成) 从 dst 加载。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_loadu_epi32.html" title="core::arch::x86::_mm512_loadu_epi32 fn">_mm512_loadu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 512 位 (由 16 个包装的 32 位整数组成) 从 dst 加载。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_loadu_epi64.html" title="core::arch::x86::_mm512_loadu_epi64 fn">_mm512_loadu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 512 位 (由 8 个包装的 64 位整数组成) 从 dst 加载。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_loadu_pd.html" title="core::arch::x86::_mm512_loadu_pd fn">_mm512_loadu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从内存中加载 512 位 (由 8 个包装的双精度 (64-bit) 浮点元素组成) 到结果中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_loadu_ps.html" title="core::arch::x86::_mm512_loadu_ps fn">_mm512_loadu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从内存中将 512 位 (由 16 个包装的单精度 (32-bit) 浮点元素组成) 加载到结果中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_loadu_si512.html" title="core::arch::x86::_mm512_loadu_si512 fn">_mm512_loadu_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 512 位整数数据从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_lzcnt_epi32.html" title="core::arch::x86::_mm512_lzcnt_epi32 fn">_mm512_lzcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span><p>计算 a 中每个包装的 32 位整数中前导零位的数目，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_lzcnt_epi64.html" title="core::arch::x86::_mm512_lzcnt_epi64 fn">_mm512_lzcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span><p>计算 a 中每个包装的 64 位整数中前导零位的数目，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_madd52hi_epu64.html" title="core::arch::x86::_mm512_madd52hi_epu64 fn">_mm512_madd52hi_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512ifma` only"><code>avx512ifma</code></span><p>将 <code>b</code> 和 <code>c</code> 的每个 64 位元素中的包装无符号 52 位整数相乘以形成 104 位中间结果。
将中间结果的高 52 位无符号整数与 <code>a</code> 中的相应无符号 64 位整数相加，并将结果存储在 <code>dst</code> 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_madd52lo_epu64.html" title="core::arch::x86::_mm512_madd52lo_epu64 fn">_mm512_madd52lo_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512ifma` only"><code>avx512ifma</code></span><p>将 <code>b</code> 和 <code>c</code> 的每个 64 位元素中的包装无符号 52 位整数相乘以形成 104 位中间结果。
将中间结果的低 52 位无符号整数与 <code>a</code> 中的相应无符号 64 位整数相加，并将结果存储在 <code>dst</code> 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_madd_epi16.html" title="core::arch::x86::_mm512_madd_epi16 fn">_mm512_madd_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。将相邻的 32 位中间整数对水平相加，并将结果打包到 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maddubs_epi16.html" title="core::arch::x86::_mm512_maddubs_epi16 fn">_mm512_maddubs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 中的每个无符号 8 位整数与 b 中对应的有符号 8 位整数垂直相乘，生成中间有符号的 16 位整数。水平相加相邻的中间带符号的 16 位整数对，并将饱和结果包装到 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask2_permutex2var_epi8.html" title="core::arch::x86::_mm512_mask2_permutex2var_epi8 fn">_mm512_mask2_permutex2var_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi` only"><code>avx512vbmi</code></span><p>使用相应的选择器和 idx 中的索引将 a 和 b 中的 8 位整数跨通道打乱，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask2_permutex2var_epi16.html" title="core::arch::x86::_mm512_mask2_permutex2var_epi16 fn">_mm512_mask2_permutex2var_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用相应的选择器和 idx 中的索引在通道中的 a 和 b 中对 16 位整数进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 idx 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask2_permutex2var_epi32.html" title="core::arch::x86::_mm512_mask2_permutex2var_epi32 fn">_mm512_mask2_permutex2var_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用相应的选择器和 idx 中的索引在通道中的 a 和 b 中对 32 位整数进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 idx 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask2_permutex2var_epi64.html" title="core::arch::x86::_mm512_mask2_permutex2var_epi64 fn">_mm512_mask2_permutex2var_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中随机排列 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 idx 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask2_permutex2var_pd.html" title="core::arch::x86::_mm512_mask2_permutex2var_pd fn">_mm512_mask2_permutex2var_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 idx 复制元素)</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask2_permutex2var_ps.html" title="core::arch::x86::_mm512_mask2_permutex2var_ps fn">_mm512_mask2_permutex2var_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 idx 中的对应选择器和索引在 a 和 b 中的通道中对 a 和 b 中的单精度 (32-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 idx 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask2int.html" title="core::arch::x86::_mm512_mask2int fn">_mm512_mask2int</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将位掩码 k1 转换为整数值，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask3_fmadd_pd.html" title="core::arch::x86::_mm512_mask3_fmadd_pd fn">_mm512_mask3_fmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask3_fmadd_ps.html" title="core::arch::x86::_mm512_mask3_fmadd_ps fn">_mm512_mask3_fmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask3_fmadd_round_pd.html" title="core::arch::x86::_mm512_mask3_fmadd_round_pd fn">_mm512_mask3_fmadd_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask3_fmadd_round_ps.html" title="core::arch::x86::_mm512_mask3_fmadd_round_ps fn">_mm512_mask3_fmadd_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask3_fmaddsub_pd.html" title="core::arch::x86::_mm512_mask3_fmaddsub_pd fn">_mm512_mask3_fmaddsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中分别乘以包装的单精度 (32-bit) 浮点元素，或者在 to/from 中将中间结果乘以包装的元素加减乘以 x，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 c 复制元素) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask3_fmaddsub_ps.html" title="core::arch::x86::_mm512_mask3_fmaddsub_ps fn">_mm512_mask3_fmaddsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中分别乘以包装的单精度 (32-bit) 浮点元素，或者在 to/from 中将中间结果乘以包装的元素加减乘以 x，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 c 复制元素) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask3_fmaddsub_round_pd.html" title="core::arch::x86::_mm512_mask3_fmaddsub_round_pd fn">_mm512_mask3_fmaddsub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中分别乘以包装的单精度 (32-bit) 浮点元素，或者在 to/from 中将中间结果乘以包装的元素加减乘以 x，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 c 复制元素) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask3_fmaddsub_round_ps.html" title="core::arch::x86::_mm512_mask3_fmaddsub_round_ps fn">_mm512_mask3_fmaddsub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中分别乘以包装的单精度 (32-bit) 浮点元素，或者在 to/from 中将中间结果乘以包装的元素加减乘以 x，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 c 复制元素) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask3_fmsub_pd.html" title="core::arch::x86::_mm512_mask3_fmsub_pd fn">_mm512_mask3_fmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask3_fmsub_ps.html" title="core::arch::x86::_mm512_mask3_fmsub_ps fn">_mm512_mask3_fmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask3_fmsub_round_pd.html" title="core::arch::x86::_mm512_mask3_fmsub_round_pd fn">_mm512_mask3_fmsub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask3_fmsub_round_ps.html" title="core::arch::x86::_mm512_mask3_fmsub_round_ps fn">_mm512_mask3_fmsub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask3_fmsubadd_pd.html" title="core::arch::x86::_mm512_mask3_fmsubadd_pd fn">_mm512_mask3_fmsubadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，并使用 writemask k 将结果存储在 dst 中 (当未使用相应的 mask 位时从 c 复制元素) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask3_fmsubadd_ps.html" title="core::arch::x86::_mm512_mask3_fmsubadd_ps fn">_mm512_mask3_fmsubadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中乘以包装的单精度 (32-bit) 浮点元素，或者在中间结果中减去并在 c from/to 中包装的元素相乘，然后使用 writemask k 将结果存储在 dst 中 (当未使用相应的 mask 位时从 c 复制元素) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask3_fmsubadd_round_pd.html" title="core::arch::x86::_mm512_mask3_fmsubadd_round_pd fn">_mm512_mask3_fmsubadd_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，并使用 writemask k 将结果存储在 dst 中 (当未使用相应的 mask 位时从 c 复制元素) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask3_fmsubadd_round_ps.html" title="core::arch::x86::_mm512_mask3_fmsubadd_round_ps fn">_mm512_mask3_fmsubadd_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中乘以包装的单精度 (32-bit) 浮点元素，或者在中间结果中减去并在 c from/to 中包装的元素相乘，然后使用 writemask k 将结果存储在 dst 中 (当未使用相应的 mask 位时从 c 复制元素) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask3_fnmadd_pd.html" title="core::arch::x86::_mm512_mask3_fnmadd_pd fn">_mm512_mask3_fnmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask3_fnmadd_ps.html" title="core::arch::x86::_mm512_mask3_fnmadd_ps fn">_mm512_mask3_fnmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 c 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask3_fnmadd_round_pd.html" title="core::arch::x86::_mm512_mask3_fnmadd_round_pd fn">_mm512_mask3_fnmadd_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask3_fnmadd_round_ps.html" title="core::arch::x86::_mm512_mask3_fnmadd_round_ps fn">_mm512_mask3_fnmadd_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 c 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask3_fnmsub_pd.html" title="core::arch::x86::_mm512_mask3_fnmsub_pd fn">_mm512_mask3_fnmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask3_fnmsub_ps.html" title="core::arch::x86::_mm512_mask3_fnmsub_ps fn">_mm512_mask3_fnmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask3_fnmsub_round_pd.html" title="core::arch::x86::_mm512_mask3_fnmsub_round_pd fn">_mm512_mask3_fnmsub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask3_fnmsub_round_ps.html" title="core::arch::x86::_mm512_mask3_fnmsub_round_ps fn">_mm512_mask3_fnmsub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_abs_epi8.html" title="core::arch::x86::_mm512_mask_abs_epi8 fn">_mm512_mask_abs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 a 中包装的带符号的 8 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_abs_epi16.html" title="core::arch::x86::_mm512_mask_abs_epi16 fn">_mm512_mask_abs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 a 中包装的带符号的 16 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_abs_epi32.html" title="core::arch::x86::_mm512_mask_abs_epi32 fn">_mm512_mask_abs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 <code>a</code> 中包装的 32 位整数的绝对值，并使用写掩码 <code>k</code> 将无符号结果存储在 <code>dst</code> 中 (如果未设置相应的掩码位，则从 <code>src</code> 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_abs_epi64.html" title="core::arch::x86::_mm512_mask_abs_epi64 fn">_mm512_mask_abs_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的带符号的 64 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_abs_pd.html" title="core::arch::x86::_mm512_mask_abs_pd fn">_mm512_mask_abs_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>查找 v2 中每个包装的双精度 (64-bit) 浮点元素的绝对值，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_abs_ps.html" title="core::arch::x86::_mm512_mask_abs_ps fn">_mm512_mask_abs_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>查找 v2 中每个包装的单精度 (32-bit) 浮点元素的绝对值，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_add_epi8.html" title="core::arch::x86::_mm512_mask_add_epi8 fn">_mm512_mask_add_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>在 a 和 b 中添加包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_add_epi16.html" title="core::arch::x86::_mm512_mask_add_epi16 fn">_mm512_mask_add_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>在 a 和 b 中添加包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_add_epi32.html" title="core::arch::x86::_mm512_mask_add_epi32 fn">_mm512_mask_add_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_add_epi64.html" title="core::arch::x86::_mm512_mask_add_epi64 fn">_mm512_mask_add_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_add_pd.html" title="core::arch::x86::_mm512_mask_add_pd fn">_mm512_mask_add_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_add_ps.html" title="core::arch::x86::_mm512_mask_add_ps fn">_mm512_mask_add_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_add_round_pd.html" title="core::arch::x86::_mm512_mask_add_round_pd fn">_mm512_mask_add_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_add_round_ps.html" title="core::arch::x86::_mm512_mask_add_round_ps fn">_mm512_mask_add_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_adds_epi8.html" title="core::arch::x86::_mm512_mask_adds_epi8 fn">_mm512_mask_adds_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用饱和度在 a 和 b 中添加包装的带符号的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_adds_epi16.html" title="core::arch::x86::_mm512_mask_adds_epi16 fn">_mm512_mask_adds_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用饱和度在 a 和 b 中添加包装的带符号的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_adds_epu8.html" title="core::arch::x86::_mm512_mask_adds_epu8 fn">_mm512_mask_adds_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用饱和度在 a 和 b 中添加包装的无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_adds_epu16.html" title="core::arch::x86::_mm512_mask_adds_epu16 fn">_mm512_mask_adds_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用饱和度在 a 和 b 中添加包装的无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_alignr_epi8.html" title="core::arch::x86::_mm512_mask_alignr_epi8 fn">_mm512_mask_alignr_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 和 b 中的 16 字节块对连接成 32 字节的临时结果，将结果右移 imm8 字节，并使用写掩码 k 将低 16 个字节存储在 dst 中 (当相应的掩码位为 1 时，元素从 src 复制没有设置)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_alignr_epi32.html" title="core::arch::x86::_mm512_mask_alignr_epi32 fn">_mm512_mask_alignr_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 连接成一个 128 字节的立即结果，将结果右移 imm8 32 位元素，并使用写掩码 k 将低 64 字节 (16 个元素) 存储在 dst 中 (当相应的掩码位为 1 时，元素从 src 复制) 没有设置)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_alignr_epi64.html" title="core::arch::x86::_mm512_mask_alignr_epi64 fn">_mm512_mask_alignr_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 连接成一个 128 字节的立即结果，将结果右移 imm8 64 位元素，并使用写掩码 k 将低 64 字节 (8 个元素) 存储在 dst 中 (当相应的掩码位为 1 时，元素从 src 复制) 没有设置)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_and_epi32.html" title="core::arch::x86::_mm512_mask_and_epi32 fn">_mm512_mask_and_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在包装的 a 和 b 的 32 位整数元素之间执行逐个元素的按位 AND，使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_and_epi64.html" title="core::arch::x86::_mm512_mask_and_epi64 fn">_mm512_mask_and_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中包装的 64 位整数的按位与，并使用写掩码 k 将结果存储在 dst 中 (如果未设置相应的掩码位，则从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_andnot_epi32.html" title="core::arch::x86::_mm512_mask_andnot_epi32 fn">_mm512_mask_andnot_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的 32 位整数的按位 NOT，然后与 b 计算 AND，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_andnot_epi64.html" title="core::arch::x86::_mm512_mask_andnot_epi64 fn">_mm512_mask_andnot_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的 64 位整数的按位 NOT，然后与 b 计算 AND，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_avg_epu8.html" title="core::arch::x86::_mm512_mask_avg_epu8 fn">_mm512_mask_avg_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 和 b 中包装的无符号 8 位整数平均，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_avg_epu16.html" title="core::arch::x86::_mm512_mask_avg_epu16 fn">_mm512_mask_avg_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 和 b 中包装的无符号 16 位整数进行平均，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_bitshuffle_epi64_mask.html" title="core::arch::x86::_mm512_mask_bitshuffle_epi64_mask fn">_mm512_mask_bitshuffle_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg` only"><code>avx512bitalg</code></span><p>将输入 <code>b</code> 视为包装的 64 位整数，并将 <code>c</code> 视为包装的 8 位整数。
然后将来自 <code>c</code> 的 8 个 8 位值作为索引分组到相应的 64 位整数的位中。
然后，选择这些位并将其包装到输出中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_blend_epi8.html" title="core::arch::x86::_mm512_mask_blend_epi8 fn">_mm512_mask_blend_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用控制掩码 k 混合 a 和 b 中的包装 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_blend_epi16.html" title="core::arch::x86::_mm512_mask_blend_epi16 fn">_mm512_mask_blend_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用控制掩码 k 混合来自 a 和 b 的包装的 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_blend_epi32.html" title="core::arch::x86::_mm512_mask_blend_epi32 fn">_mm512_mask_blend_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用控制掩码 k 混合 a 和 b 中的包装 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_blend_epi64.html" title="core::arch::x86::_mm512_mask_blend_epi64 fn">_mm512_mask_blend_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用控制掩码 k 混合 a 和 b 中的包装 64 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_blend_pd.html" title="core::arch::x86::_mm512_mask_blend_pd fn">_mm512_mask_blend_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用控制掩码 k 混合来自 a 和 b 的包装后的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_blend_ps.html" title="core::arch::x86::_mm512_mask_blend_ps fn">_mm512_mask_blend_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用控制掩码 k 混合来自 a 和 b 的包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_broadcast_f32x4.html" title="core::arch::x86::_mm512_mask_broadcast_f32x4 fn">_mm512_mask_broadcast_f32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用写掩码 k 将 4 个包装的单精度 (32-bit) 浮点元素从 a 广播到 dst 的所有元素 (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_broadcast_f64x4.html" title="core::arch::x86::_mm512_mask_broadcast_f64x4 fn">_mm512_mask_broadcast_f64x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用写掩码 k 将 4 个包装的双精度 (64-bit) 浮点元素从 a 广播到 dst 的所有元素 (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_broadcast_i32x4.html" title="core::arch::x86::_mm512_mask_broadcast_i32x4 fn">_mm512_mask_broadcast_i32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用写掩码 k 将 a 的 4 个包装的 32 位整数广播到 dst 的所有元素 (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_broadcast_i64x4.html" title="core::arch::x86::_mm512_mask_broadcast_i64x4 fn">_mm512_mask_broadcast_i64x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用写掩码 k 将 a 的 4 个包装的 64 位整数广播到 dst 的所有元素 (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_broadcastb_epi8.html" title="core::arch::x86::_mm512_mask_broadcastb_epi8 fn">_mm512_mask_broadcastb_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用写掩码 k 将 d 的低包装的 8 位整数广播到 dst 的所有元素 (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_broadcastd_epi32.html" title="core::arch::x86::_mm512_mask_broadcastd_epi32 fn">_mm512_mask_broadcastd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用写掩码 k 将低包装的 32 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_broadcastq_epi64.html" title="core::arch::x86::_mm512_mask_broadcastq_epi64 fn">_mm512_mask_broadcastq_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用写掩码 k 将低包装的 64 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_broadcastsd_pd.html" title="core::arch::x86::_mm512_mask_broadcastsd_pd fn">_mm512_mask_broadcastsd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用写掩码 k 将低双精度 (64-bit) 浮点型元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_broadcastss_ps.html" title="core::arch::x86::_mm512_mask_broadcastss_ps fn">_mm512_mask_broadcastss_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用写掩码 k 将低单精度 (32-bit) 浮点型元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将元素从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_broadcastw_epi16.html" title="core::arch::x86::_mm512_mask_broadcastw_epi16 fn">_mm512_mask_broadcastw_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用写掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmp_epi8_mask.html" title="core::arch::x86::_mm512_mask_cmp_epi8_mask fn">_mm512_mask_cmp_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmp_epi16_mask.html" title="core::arch::x86::_mm512_mask_cmp_epi16_mask fn">_mm512_mask_cmp_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmp_epi32_mask.html" title="core::arch::x86::_mm512_mask_cmp_epi32_mask fn">_mm512_mask_cmp_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 32 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmp_epi64_mask.html" title="core::arch::x86::_mm512_mask_cmp_epi64_mask fn">_mm512_mask_cmp_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmp_epu8_mask.html" title="core::arch::x86::_mm512_mask_cmp_epu8_mask fn">_mm512_mask_cmp_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 8 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmp_epu16_mask.html" title="core::arch::x86::_mm512_mask_cmp_epu16_mask fn">_mm512_mask_cmp_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmp_epu32_mask.html" title="core::arch::x86::_mm512_mask_cmp_epu32_mask fn">_mm512_mask_cmp_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 32 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmp_epu64_mask.html" title="core::arch::x86::_mm512_mask_cmp_epu64_mask fn">_mm512_mask_cmp_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmp_pd_mask.html" title="core::arch::x86::_mm512_mask_cmp_pd_mask fn">_mm512_mask_cmp_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmp_ps_mask.html" title="core::arch::x86::_mm512_mask_cmp_ps_mask fn">_mm512_mask_cmp_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmp_round_pd_mask.html" title="core::arch::x86::_mm512_mask_cmp_round_pd_mask fn">_mm512_mask_cmp_round_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmp_round_ps_mask.html" title="core::arch::x86::_mm512_mask_cmp_round_ps_mask fn">_mm512_mask_cmp_round_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpeq_epi8_mask.html" title="core::arch::x86::_mm512_mask_cmpeq_epi8_mask fn">_mm512_mask_cmpeq_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpeq_epi16_mask.html" title="core::arch::x86::_mm512_mask_cmpeq_epi16_mask fn">_mm512_mask_cmpeq_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数是否相等，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpeq_epi32_mask.html" title="core::arch::x86::_mm512_mask_cmpeq_epi32_mask fn">_mm512_mask_cmpeq_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的 32 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpeq_epi64_mask.html" title="core::arch::x86::_mm512_mask_cmpeq_epi64_mask fn">_mm512_mask_cmpeq_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的 64 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpeq_epu8_mask.html" title="core::arch::x86::_mm512_mask_cmpeq_epu8_mask fn">_mm512_mask_cmpeq_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpeq_epu16_mask.html" title="core::arch::x86::_mm512_mask_cmpeq_epu16_mask fn">_mm512_mask_cmpeq_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpeq_epu32_mask.html" title="core::arch::x86::_mm512_mask_cmpeq_epu32_mask fn">_mm512_mask_cmpeq_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpeq_epu64_mask.html" title="core::arch::x86::_mm512_mask_cmpeq_epu64_mask fn">_mm512_mask_cmpeq_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpeq_pd_mask.html" title="core::arch::x86::_mm512_mask_cmpeq_pd_mask fn">_mm512_mask_cmpeq_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpeq_ps_mask.html" title="core::arch::x86::_mm512_mask_cmpeq_ps_mask fn">_mm512_mask_cmpeq_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpge_epi8_mask.html" title="core::arch::x86::_mm512_mask_cmpge_epi8_mask fn">_mm512_mask_cmpge_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpge_epi16_mask.html" title="core::arch::x86::_mm512_mask_cmpge_epi16_mask fn">_mm512_mask_cmpge_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpge_epi32_mask.html" title="core::arch::x86::_mm512_mask_cmpge_epi32_mask fn">_mm512_mask_cmpge_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数是否等于或大于等于，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpge_epi64_mask.html" title="core::arch::x86::_mm512_mask_cmpge_epi64_mask fn">_mm512_mask_cmpge_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpge_epu8_mask.html" title="core::arch::x86::_mm512_mask_cmpge_epu8_mask fn">_mm512_mask_cmpge_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpge_epu16_mask.html" title="core::arch::x86::_mm512_mask_cmpge_epu16_mask fn">_mm512_mask_cmpge_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否大于等于，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpge_epu32_mask.html" title="core::arch::x86::_mm512_mask_cmpge_epu32_mask fn">_mm512_mask_cmpge_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpge_epu64_mask.html" title="core::arch::x86::_mm512_mask_cmpge_epu64_mask fn">_mm512_mask_cmpge_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpgt_epi8_mask.html" title="core::arch::x86::_mm512_mask_cmpgt_epi8_mask fn">_mm512_mask_cmpgt_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpgt_epi16_mask.html" title="core::arch::x86::_mm512_mask_cmpgt_epi16_mask fn">_mm512_mask_cmpgt_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpgt_epi32_mask.html" title="core::arch::x86::_mm512_mask_cmpgt_epi32_mask fn">_mm512_mask_cmpgt_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数是否大于，并将结果使用零掩码 k1 存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpgt_epi64_mask.html" title="core::arch::x86::_mm512_mask_cmpgt_epi64_mask fn">_mm512_mask_cmpgt_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpgt_epu8_mask.html" title="core::arch::x86::_mm512_mask_cmpgt_epu8_mask fn">_mm512_mask_cmpgt_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpgt_epu16_mask.html" title="core::arch::x86::_mm512_mask_cmpgt_epu16_mask fn">_mm512_mask_cmpgt_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpgt_epu32_mask.html" title="core::arch::x86::_mm512_mask_cmpgt_epu32_mask fn">_mm512_mask_cmpgt_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpgt_epu64_mask.html" title="core::arch::x86::_mm512_mask_cmpgt_epu64_mask fn">_mm512_mask_cmpgt_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmple_epi8_mask.html" title="core::arch::x86::_mm512_mask_cmple_epi8_mask fn">_mm512_mask_cmple_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmple_epi16_mask.html" title="core::arch::x86::_mm512_mask_cmple_epi16_mask fn">_mm512_mask_cmple_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数 (小于或等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmple_epi32_mask.html" title="core::arch::x86::_mm512_mask_cmple_epi32_mask fn">_mm512_mask_cmple_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmple_epi64_mask.html" title="core::arch::x86::_mm512_mask_cmple_epi64_mask fn">_mm512_mask_cmple_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数 (小于等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmple_epu8_mask.html" title="core::arch::x86::_mm512_mask_cmple_epu8_mask fn">_mm512_mask_cmple_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmple_epu16_mask.html" title="core::arch::x86::_mm512_mask_cmple_epu16_mask fn">_mm512_mask_cmple_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmple_epu32_mask.html" title="core::arch::x86::_mm512_mask_cmple_epu32_mask fn">_mm512_mask_cmple_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmple_epu64_mask.html" title="core::arch::x86::_mm512_mask_cmple_epu64_mask fn">_mm512_mask_cmple_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmple_pd_mask.html" title="core::arch::x86::_mm512_mask_cmple_pd_mask fn">_mm512_mask_cmple_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmple_ps_mask.html" title="core::arch::x86::_mm512_mask_cmple_ps_mask fn">_mm512_mask_cmple_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmplt_epi8_mask.html" title="core::arch::x86::_mm512_mask_cmplt_epi8_mask fn">_mm512_mask_cmplt_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmplt_epi16_mask.html" title="core::arch::x86::_mm512_mask_cmplt_epi16_mask fn">_mm512_mask_cmplt_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmplt_epi32_mask.html" title="core::arch::x86::_mm512_mask_cmplt_epi32_mask fn">_mm512_mask_cmplt_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数 (小于或等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmplt_epi64_mask.html" title="core::arch::x86::_mm512_mask_cmplt_epi64_mask fn">_mm512_mask_cmplt_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmplt_epu8_mask.html" title="core::arch::x86::_mm512_mask_cmplt_epu8_mask fn">_mm512_mask_cmplt_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmplt_epu16_mask.html" title="core::arch::x86::_mm512_mask_cmplt_epu16_mask fn">_mm512_mask_cmplt_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 16 位整数以得到小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmplt_epu32_mask.html" title="core::arch::x86::_mm512_mask_cmplt_epu32_mask fn">_mm512_mask_cmplt_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmplt_epu64_mask.html" title="core::arch::x86::_mm512_mask_cmplt_epu64_mask fn">_mm512_mask_cmplt_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmplt_pd_mask.html" title="core::arch::x86::_mm512_mask_cmplt_pd_mask fn">_mm512_mask_cmplt_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的双精度 (64-bit) 浮点元素的小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmplt_ps_mask.html" title="core::arch::x86::_mm512_mask_cmplt_ps_mask fn">_mm512_mask_cmplt_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpneq_epi8_mask.html" title="core::arch::x86::_mm512_mask_cmpneq_epi8_mask fn">_mm512_mask_cmpneq_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpneq_epi16_mask.html" title="core::arch::x86::_mm512_mask_cmpneq_epi16_mask fn">_mm512_mask_cmpneq_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpneq_epi32_mask.html" title="core::arch::x86::_mm512_mask_cmpneq_epi32_mask fn">_mm512_mask_cmpneq_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的 32 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpneq_epi64_mask.html" title="core::arch::x86::_mm512_mask_cmpneq_epi64_mask fn">_mm512_mask_cmpneq_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpneq_epu8_mask.html" title="core::arch::x86::_mm512_mask_cmpneq_epu8_mask fn">_mm512_mask_cmpneq_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpneq_epu16_mask.html" title="core::arch::x86::_mm512_mask_cmpneq_epu16_mask fn">_mm512_mask_cmpneq_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpneq_epu32_mask.html" title="core::arch::x86::_mm512_mask_cmpneq_epu32_mask fn">_mm512_mask_cmpneq_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpneq_epu64_mask.html" title="core::arch::x86::_mm512_mask_cmpneq_epu64_mask fn">_mm512_mask_cmpneq_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpneq_pd_mask.html" title="core::arch::x86::_mm512_mask_cmpneq_pd_mask fn">_mm512_mask_cmpneq_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpneq_ps_mask.html" title="core::arch::x86::_mm512_mask_cmpneq_ps_mask fn">_mm512_mask_cmpneq_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否相等，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpnle_pd_mask.html" title="core::arch::x86::_mm512_mask_cmpnle_pd_mask fn">_mm512_mask_cmpnle_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否等于或小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpnle_ps_mask.html" title="core::arch::x86::_mm512_mask_cmpnle_ps_mask fn">_mm512_mask_cmpnle_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否等于或小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpnlt_pd_mask.html" title="core::arch::x86::_mm512_mask_cmpnlt_pd_mask fn">_mm512_mask_cmpnlt_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpnlt_ps_mask.html" title="core::arch::x86::_mm512_mask_cmpnlt_ps_mask fn">_mm512_mask_cmpnlt_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpord_pd_mask.html" title="core::arch::x86::_mm512_mask_cmpord_pd_mask fn">_mm512_mask_cmpord_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，看是否都不是 NaN，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpord_ps_mask.html" title="core::arch::x86::_mm512_mask_cmpord_ps_mask fn">_mm512_mask_cmpord_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，看是否都不是 NaN，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpunord_pd_mask.html" title="core::arch::x86::_mm512_mask_cmpunord_pd_mask fn">_mm512_mask_cmpunord_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的双精度 (64-bit) 浮点元素以查看是否为 NaN，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cmpunord_ps_mask.html" title="core::arch::x86::_mm512_mask_cmpunord_ps_mask fn">_mm512_mask_cmpunord_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，看是否为 NaN，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_compress_epi8.html" title="core::arch::x86::_mm512_mask_compress_epi8 fn">_mm512_mask_compress_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>将 a 中的活动 8 位整数 (它们各自的位设置在写掩码 k 中) 连续存储到 dst，并通过 src 中的其余元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_compress_epi16.html" title="core::arch::x86::_mm512_mask_compress_epi16 fn">_mm512_mask_compress_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>将 a 中的活动 16 位整数 (它们各自的位设置在写掩码 k 中) 连续存储到 dst，并通过 src 中的其余元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_compress_epi32.html" title="core::arch::x86::_mm512_mask_compress_epi32 fn">_mm512_mask_compress_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将活动的 32 位整数连续存储在 dst 中 (它们各自的位在写掩码 k 中设置的整数) 到 dst，并通过 src 中的其余元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_compress_epi64.html" title="core::arch::x86::_mm512_mask_compress_epi64 fn">_mm512_mask_compress_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将活动的 64 位整数连续存储在 dst 中 (它们各自的位在写掩码 k 中设置的整数) 到 dst，并通过 src 中的其余元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_compress_pd.html" title="core::arch::x86::_mm512_mask_compress_pd fn">_mm512_mask_compress_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将活动的双精度 (64-bit) 浮点元素连续存储在 dst 中 (它们各自的位在写掩码 k 中设置) 到 dst，并通过 src 中的其余元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_compress_ps.html" title="core::arch::x86::_mm512_mask_compress_ps fn">_mm512_mask_compress_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将活动的单精度 (32-bit) 浮点元素连续存储在 dst 中 (将其各自的位设置在写掩码 k 中的那些元素中) 存储到 dst，并通过 src 中的其余元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_conflict_epi32.html" title="core::arch::x86::_mm512_mask_conflict_epi32 fn">_mm512_mask_conflict_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span><p>使用写掩码 k (在未设置相应的掩码位时从 src 复制元素)，测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_conflict_epi64.html" title="core::arch::x86::_mm512_mask_conflict_epi64 fn">_mm512_mask_conflict_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span><p>使用写掩码 k 测试 a 的每个 64 位元素是否与所有其他元素相等 (更接近最低有效位) (当未设置相应的掩码位时，从 src 复制元素)。每个元素的比较在 dst 中形成零扩展位 vector。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvt_roundepi32_ps.html" title="core::arch::x86::_mm512_mask_cvt_roundepi32_ps fn">_mm512_mask_cvt_roundepi32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装有符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvt_roundepu32_ps.html" title="core::arch::x86::_mm512_mask_cvt_roundepu32_ps fn">_mm512_mask_cvt_roundepu32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvt_roundpd_epi32.html" title="core::arch::x86::_mm512_mask_cvt_roundpd_epi32 fn">_mm512_mask_cvt_roundpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvt_roundpd_epu32.html" title="core::arch::x86::_mm512_mask_cvt_roundpd_epu32 fn">_mm512_mask_cvt_roundpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvt_roundpd_ps.html" title="core::arch::x86::_mm512_mask_cvt_roundpd_ps fn">_mm512_mask_cvt_roundpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvt_roundph_ps.html" title="core::arch::x86::_mm512_mask_cvt_roundph_ps fn">_mm512_mask_cvt_roundph_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装后的半精度 (16-bit) 浮点元素转换为包装后的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvt_roundps_epi32.html" title="core::arch::x86::_mm512_mask_cvt_roundps_epi32 fn">_mm512_mask_cvt_roundps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvt_roundps_epu32.html" title="core::arch::x86::_mm512_mask_cvt_roundps_epu32 fn">_mm512_mask_cvt_roundps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvt_roundps_pd.html" title="core::arch::x86::_mm512_mask_cvt_roundps_pd fn">_mm512_mask_cvt_roundps_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvt_roundps_ph.html" title="core::arch::x86::_mm512_mask_cvt_roundps_ph fn">_mm512_mask_cvt_roundps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepi8_epi16.html" title="core::arch::x86::_mm512_mask_cvtepi8_epi16 fn">_mm512_mask_cvtepi8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用符号将包装的 8 位整数从 a 扩展为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepi8_epi32.html" title="core::arch::x86::_mm512_mask_cvtepi8_epi32 fn">_mm512_mask_cvtepi8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>符号将包装的 8 位整数从 a 扩展为包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepi8_epi64.html" title="core::arch::x86::_mm512_mask_cvtepi8_epi64 fn">_mm512_mask_cvtepi8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>符号将 a 的低 8 个字节中的包装 8 位整数扩展为包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepi16_epi8.html" title="core::arch::x86::_mm512_mask_cvtepi16_epi8 fn">_mm512_mask_cvtepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将带有 a 的包装的 16 位整数转换为带截断的 8 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepi16_epi32.html" title="core::arch::x86::_mm512_mask_cvtepi16_epi32 fn">_mm512_mask_cvtepi16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>符号将包装后的 16 位整数从 a 扩展为包装后的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepi16_epi64.html" title="core::arch::x86::_mm512_mask_cvtepi16_epi64 fn">_mm512_mask_cvtepi16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用符号将包装的 16 位整数从 a 扩展为包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepi16_storeu_epi8.html" title="core::arch::x86::_mm512_mask_cvtepi16_storeu_epi8 fn">_mm512_mask_cvtepi16_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 中的包装的 16 位整数转换为带有截断的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepi32_epi8.html" title="core::arch::x86::_mm512_mask_cvtepi32_epi8 fn">_mm512_mask_cvtepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将带有 a 的包装的 32 位整数转换为带截断的包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepi32_epi16.html" title="core::arch::x86::_mm512_mask_cvtepi32_epi16 fn">_mm512_mask_cvtepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepi32_epi64.html" title="core::arch::x86::_mm512_mask_cvtepi32_epi64 fn">_mm512_mask_cvtepi32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用符号将包装的 32 位整数从 a 扩展为包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepi32_pd.html" title="core::arch::x86::_mm512_mask_cvtepi32_pd fn">_mm512_mask_cvtepi32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装有符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepi32_ps.html" title="core::arch::x86::_mm512_mask_cvtepi32_ps fn">_mm512_mask_cvtepi32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装有符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepi32_storeu_epi8.html" title="core::arch::x86::_mm512_mask_cvtepi32_storeu_epi8 fn">_mm512_mask_cvtepi32_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 32 位整数在 a 中转换为带有截断的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepi32_storeu_epi16.html" title="core::arch::x86::_mm512_mask_cvtepi32_storeu_epi16 fn">_mm512_mask_cvtepi32_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的 32 位整数转换为带截断的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepi32lo_pd.html" title="core::arch::x86::_mm512_mask_cvtepi32lo_pd fn">_mm512_mask_cvtepi32lo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 v2 中包装的 32 位整数整数元素的下半部分转换为包装的双精度 (64-bit) 浮点元素，进行逐元素转换，并使用 writemask k 将结果存储在 dst 中 (当相应的 mask 位为 src 时，会复制这些元素未设置)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepi64_epi8.html" title="core::arch::x86::_mm512_mask_cvtepi64_epi8 fn">_mm512_mask_cvtepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的 64 位整数转换为带有截断的包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepi64_epi16.html" title="core::arch::x86::_mm512_mask_cvtepi64_epi16 fn">_mm512_mask_cvtepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的 64 位整数转换为带截断的 16 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepi64_epi32.html" title="core::arch::x86::_mm512_mask_cvtepi64_epi32 fn">_mm512_mask_cvtepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的 64 位整数转换为带截断的 32 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepi64_storeu_epi8.html" title="core::arch::x86::_mm512_mask_cvtepi64_storeu_epi8 fn">_mm512_mask_cvtepi64_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中包装的 64 位整数转换为包装的 8 位整数并截断，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepi64_storeu_epi16.html" title="core::arch::x86::_mm512_mask_cvtepi64_storeu_epi16 fn">_mm512_mask_cvtepi64_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的 64 位整数转换为带截断的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepi64_storeu_epi32.html" title="core::arch::x86::_mm512_mask_cvtepi64_storeu_epi32 fn">_mm512_mask_cvtepi64_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的 64 位整数转换为带截断的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepu8_epi16.html" title="core::arch::x86::_mm512_mask_cvtepu8_epi16 fn">_mm512_mask_cvtepu8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 中的包装无符号 8 位整数零扩展为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepu8_epi32.html" title="core::arch::x86::_mm512_mask_cvtepu8_epi32 fn">_mm512_mask_cvtepu8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 8 位整数零扩展为包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepu8_epi64.html" title="core::arch::x86::_mm512_mask_cvtepu8_epi64 fn">_mm512_mask_cvtepu8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 的低 8 个字节中的包装无符号 8 位整数零扩展为包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepu16_epi32.html" title="core::arch::x86::_mm512_mask_cvtepu16_epi32 fn">_mm512_mask_cvtepu16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 16 位整数零扩展为包装 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepu16_epi64.html" title="core::arch::x86::_mm512_mask_cvtepu16_epi64 fn">_mm512_mask_cvtepu16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 16 位整数零扩展为包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepu32_epi64.html" title="core::arch::x86::_mm512_mask_cvtepu32_epi64 fn">_mm512_mask_cvtepu32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 32 位整数零扩展为包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepu32_pd.html" title="core::arch::x86::_mm512_mask_cvtepu32_pd fn">_mm512_mask_cvtepu32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 32 位整数转换为包装双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepu32_ps.html" title="core::arch::x86::_mm512_mask_cvtepu32_ps fn">_mm512_mask_cvtepu32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtepu32lo_pd.html" title="core::arch::x86::_mm512_mask_cvtepu32lo_pd fn">_mm512_mask_cvtepu32lo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 v2 中 32 位无符号整数元素的下半部分转换为包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中，使用 writemask k (当相应的 mask 位为 src 时，复制这些元素) 未设置)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtne2ps_pbh.html" title="core::arch::x86::_mm512_mask_cvtne2ps_pbh fn">_mm512_mask_cvtne2ps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512f` only"><code>avx512bf16,avx512f</code></span><p>将两个 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 writemask k 将结果存储在单个 vector dst 中 (当对应的掩码位为没有设置)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtneps_pbh.html" title="core::arch::x86::_mm512_mask_cvtneps_pbh fn">_mm512_mask_cvtneps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512f` only"><code>avx512bf16,avx512f</code></span><p>将包装在 a 中的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtpd_epi32.html" title="core::arch::x86::_mm512_mask_cvtpd_epi32 fn">_mm512_mask_cvtpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtpd_epu32.html" title="core::arch::x86::_mm512_mask_cvtpd_epu32 fn">_mm512_mask_cvtpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtpd_ps.html" title="core::arch::x86::_mm512_mask_cvtpd_ps fn">_mm512_mask_cvtpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtpd_pslo.html" title="core::arch::x86::_mm512_mask_cvtpd_pslo fn">_mm512_mask_cvtpd_pslo</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 v2 中的包装的双精度 (64-bit) 浮点元素转换为单精度 (32-bit) 浮点元素，将其逐个元素转换，并使用 writemask k 将它们存储在 dst 中 (如果没有相应的 mask 位，则从 src 复制元素放)。元素存储在结果 vector 的下半部分中，而其余的上半部分位置设置为 0。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtph_ps.html" title="core::arch::x86::_mm512_mask_cvtph_ps fn">_mm512_mask_cvtph_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装后的半精度 (16-bit) 浮点元素转换为包装后的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtps_epi32.html" title="core::arch::x86::_mm512_mask_cvtps_epi32 fn">_mm512_mask_cvtps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtps_epu32.html" title="core::arch::x86::_mm512_mask_cvtps_epu32 fn">_mm512_mask_cvtps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtps_pd.html" title="core::arch::x86::_mm512_mask_cvtps_pd fn">_mm512_mask_cvtps_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtps_ph.html" title="core::arch::x86::_mm512_mask_cvtps_ph fn">_mm512_mask_cvtps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtpslo_pd.html" title="core::arch::x86::_mm512_mask_cvtpslo_pd fn">_mm512_mask_cvtpslo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 v2 中包装的单精度 (32-bit) 浮点元素的下半部分转换为包装的双精度 (64-bit) 浮点元素的下半部分进行逐元素转换，并使用写掩码 k 将结果存储在 dst 中 (当相应的屏蔽位未设置)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtsepi16_epi8.html" title="core::arch::x86::_mm512_mask_cvtsepi16_epi8 fn">_mm512_mask_cvtsepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 中的包装带符号的 16 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtsepi16_storeu_epi8.html" title="core::arch::x86::_mm512_mask_cvtsepi16_storeu_epi8 fn">_mm512_mask_cvtsepi16_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装在 a 中的有符号 16 位整数转换为有符号饱和的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtsepi32_epi8.html" title="core::arch::x86::_mm512_mask_cvtsepi32_epi8 fn">_mm512_mask_cvtsepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtsepi32_epi16.html" title="core::arch::x86::_mm512_mask_cvtsepi32_epi16 fn">_mm512_mask_cvtsepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtsepi32_storeu_epi8.html" title="core::arch::x86::_mm512_mask_cvtsepi32_storeu_epi8 fn">_mm512_mask_cvtsepi32_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装在 a 中的有符号 32 位整数转换为具有符号饱和的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtsepi32_storeu_epi16.html" title="core::arch::x86::_mm512_mask_cvtsepi32_storeu_epi16 fn">_mm512_mask_cvtsepi32_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装在 a 中的有符号 32 位整数转换为具有符号饱和的包装的 16 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtsepi64_epi8.html" title="core::arch::x86::_mm512_mask_cvtsepi64_epi8 fn">_mm512_mask_cvtsepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtsepi64_epi16.html" title="core::arch::x86::_mm512_mask_cvtsepi64_epi16 fn">_mm512_mask_cvtsepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtsepi64_epi32.html" title="core::arch::x86::_mm512_mask_cvtsepi64_epi32 fn">_mm512_mask_cvtsepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtsepi64_storeu_epi8.html" title="core::arch::x86::_mm512_mask_cvtsepi64_storeu_epi8 fn">_mm512_mask_cvtsepi64_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtsepi64_storeu_epi16.html" title="core::arch::x86::_mm512_mask_cvtsepi64_storeu_epi16 fn">_mm512_mask_cvtsepi64_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtsepi64_storeu_epi32.html" title="core::arch::x86::_mm512_mask_cvtsepi64_storeu_epi32 fn">_mm512_mask_cvtsepi64_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtt_roundpd_epi32.html" title="core::arch::x86::_mm512_mask_cvtt_roundpd_epi32 fn">_mm512_mask_cvtt_roundpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtt_roundpd_epu32.html" title="core::arch::x86::_mm512_mask_cvtt_roundpd_epu32 fn">_mm512_mask_cvtt_roundpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtt_roundps_epi32.html" title="core::arch::x86::_mm512_mask_cvtt_roundps_epi32 fn">_mm512_mask_cvtt_roundps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtt_roundps_epu32.html" title="core::arch::x86::_mm512_mask_cvtt_roundps_epu32 fn">_mm512_mask_cvtt_roundps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvttpd_epi32.html" title="core::arch::x86::_mm512_mask_cvttpd_epi32 fn">_mm512_mask_cvttpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvttpd_epu32.html" title="core::arch::x86::_mm512_mask_cvttpd_epu32 fn">_mm512_mask_cvttpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvttps_epi32.html" title="core::arch::x86::_mm512_mask_cvttps_epi32 fn">_mm512_mask_cvttps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvttps_epu32.html" title="core::arch::x86::_mm512_mask_cvttps_epu32 fn">_mm512_mask_cvttps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtusepi16_epi8.html" title="core::arch::x86::_mm512_mask_cvtusepi16_epi8 fn">_mm512_mask_cvtusepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtusepi16_storeu_epi8.html" title="core::arch::x86::_mm512_mask_cvtusepi16_storeu_epi8 fn">_mm512_mask_cvtusepi16_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装在 a 中的无符号 16 位整数转换为具有无符号饱和的包装的无符号 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtusepi32_epi8.html" title="core::arch::x86::_mm512_mask_cvtusepi32_epi8 fn">_mm512_mask_cvtusepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtusepi32_epi16.html" title="core::arch::x86::_mm512_mask_cvtusepi32_epi16 fn">_mm512_mask_cvtusepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtusepi32_storeu_epi8.html" title="core::arch::x86::_mm512_mask_cvtusepi32_storeu_epi8 fn">_mm512_mask_cvtusepi32_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装在 a 中的无符号 32 位整数转换为具有无符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtusepi32_storeu_epi16.html" title="core::arch::x86::_mm512_mask_cvtusepi32_storeu_epi16 fn">_mm512_mask_cvtusepi32_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装在 a 中的无符号 32 位整数转换为具有无符号饱和的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtusepi64_epi8.html" title="core::arch::x86::_mm512_mask_cvtusepi64_epi8 fn">_mm512_mask_cvtusepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtusepi64_epi16.html" title="core::arch::x86::_mm512_mask_cvtusepi64_epi16 fn">_mm512_mask_cvtusepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtusepi64_epi32.html" title="core::arch::x86::_mm512_mask_cvtusepi64_epi32 fn">_mm512_mask_cvtusepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtusepi64_storeu_epi8.html" title="core::arch::x86::_mm512_mask_cvtusepi64_storeu_epi8 fn">_mm512_mask_cvtusepi64_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的无符号 64 位整数在 a 中转换为具有无符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtusepi64_storeu_epi16.html" title="core::arch::x86::_mm512_mask_cvtusepi64_storeu_epi16 fn">_mm512_mask_cvtusepi64_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装在 a 中的无符号 64 位整数转换为具有无符号饱和的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_cvtusepi64_storeu_epi32.html" title="core::arch::x86::_mm512_mask_cvtusepi64_storeu_epi32 fn">_mm512_mask_cvtusepi64_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的无符号 64 位整数在 a 中转换为具有无符号饱和的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_dbsad_epu8.html" title="core::arch::x86::_mm512_mask_dbsad_epu8 fn">_mm512_mask_dbsad_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 a 中的无符号 8 位整数与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs)，并使用写掩码 k 将 16 位结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。对于每个 64 位通道，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中通道的低 8 位四元组，而后两个 SAD 使用 a 中通道的较高 8 位四元组。根据 imm8 中的控件，从 128 位通道中选择 b 中的四元组，并且每个 64 位通道中的每个 SAD 使用 8 位偏移量的选定四元组。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_div_pd.html" title="core::arch::x86::_mm512_mask_div_pd fn">_mm512_mask_div_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_div_ps.html" title="core::arch::x86::_mm512_mask_div_ps fn">_mm512_mask_div_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素除以 b 中的包装的元素，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_div_round_pd.html" title="core::arch::x86::_mm512_mask_div_round_pd fn">_mm512_mask_div_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_div_round_ps.html" title="core::arch::x86::_mm512_mask_div_round_ps fn">_mm512_mask_div_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素除以 b 中的包装的元素，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_dpbf16_ps.html" title="core::arch::x86::_mm512_mask_dpbf16_ps fn">_mm512_mask_dpbf16_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512f` only"><code>avx512bf16,avx512f</code></span><p>计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间的单精度 (32-bit) 浮点元素与 src 中的元素相加，并使用 writemask k 将结果存储在 dst 中 (当对应的元素从 src 复制时掩码位未设置)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_dpbusd_epi32.html" title="core::arch::x86::_mm512_mask_dpbusd_epi32 fn">_mm512_mask_dpbusd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni` only"><code>avx512vnni</code></span><p>将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (未设置相应掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_dpbusds_epi32.html" title="core::arch::x86::_mm512_mask_dpbusds_epi32 fn">_mm512_mask_dpbusds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni` only"><code>avx512vnni</code></span><p>将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。使用符号饱和将这 4 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_dpwssd_epi32.html" title="core::arch::x86::_mm512_mask_dpwssd_epi32 fn">_mm512_mask_dpwssd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni` only"><code>avx512vnni</code></span><p>将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_dpwssds_epi32.html" title="core::arch::x86::_mm512_mask_dpwssds_epi32 fn">_mm512_mask_dpwssds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni` only"><code>avx512vnni</code></span><p>将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_expand_epi8.html" title="core::arch::x86::_mm512_mask_expand_epi8 fn">_mm512_mask_expand_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>从 a 加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_expand_epi16.html" title="core::arch::x86::_mm512_mask_expand_epi16 fn">_mm512_mask_expand_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>从 a 加载连续的活动 16 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_expand_epi32.html" title="core::arch::x86::_mm512_mask_expand_epi32 fn">_mm512_mask_expand_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 加载连续的有效 32 位整数 (它们各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_expand_epi64.html" title="core::arch::x86::_mm512_mask_expand_epi64 fn">_mm512_mask_expand_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 加载连续的有效 64 位整数 (它们各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_expand_pd.html" title="core::arch::x86::_mm512_mask_expand_pd fn">_mm512_mask_expand_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 加载连续的活动双精度 (64-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_expand_ps.html" title="core::arch::x86::_mm512_mask_expand_ps fn">_mm512_mask_expand_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中加载连续的活动单精度 (32-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_extractf32x4_ps.html" title="core::arch::x86::_mm512_mask_extractf32x4_ps fn">_mm512_mask_extractf32x4_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 提取 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并用 imm8 进行选择，并使用写掩码 k 将结果存储在 dst 中 (如果未设置相应的掩码位，则从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_extractf64x4_pd.html" title="core::arch::x86::_mm512_mask_extractf64x4_pd fn">_mm512_mask_extractf64x4_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 提取 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成)，并用 imm8 进行选择，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_extracti32x4_epi32.html" title="core::arch::x86::_mm512_mask_extracti32x4_epi32 fn">_mm512_mask_extracti32x4_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中提取 128 位 (由 4 个包装的 32 位整数组成)，用 IMM2 选中，用 writemask k 将结果存入 dst 中 (未设置相应掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_extracti64x4_epi64.html" title="core::arch::x86::_mm512_mask_extracti64x4_epi64 fn">_mm512_mask_extracti64x4_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中提取 256 位 (由 4 个包装的 64 位整数组成)，用 IMM1 选中，用 writemask k 将结果存入 dst (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fixupimm_pd.html" title="core::arch::x86::_mm512_mask_fixupimm_pd fn">_mm512_mask_fixupimm_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 c 中的包装 64 位整数修复 a 和 b 中的包装双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 a 复制元素)。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fixupimm_ps.html" title="core::arch::x86::_mm512_mask_fixupimm_ps fn">_mm512_mask_fixupimm_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 c 中的包装 32 位整数修复 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 a 复制元素)。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fixupimm_round_pd.html" title="core::arch::x86::_mm512_mask_fixupimm_round_pd fn">_mm512_mask_fixupimm_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 c 中的包装 64 位整数修复 a 和 b 中的包装双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 a 复制元素)。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fixupimm_round_ps.html" title="core::arch::x86::_mm512_mask_fixupimm_round_ps fn">_mm512_mask_fixupimm_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 c 中的包装 32 位整数修复 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 a 复制元素)。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fmadd_pd.html" title="core::arch::x86::_mm512_mask_fmadd_pd fn">_mm512_mask_fmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fmadd_ps.html" title="core::arch::x86::_mm512_mask_fmadd_ps fn">_mm512_mask_fmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fmadd_round_pd.html" title="core::arch::x86::_mm512_mask_fmadd_round_pd fn">_mm512_mask_fmadd_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fmadd_round_ps.html" title="core::arch::x86::_mm512_mask_fmadd_round_ps fn">_mm512_mask_fmadd_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fmaddsub_pd.html" title="core::arch::x86::_mm512_mask_fmaddsub_pd fn">_mm512_mask_fmaddsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 a 中复制元素放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fmaddsub_ps.html" title="core::arch::x86::_mm512_mask_fmaddsub_ps fn">_mm512_mask_fmaddsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位则从 a 复制元素放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fmaddsub_round_pd.html" title="core::arch::x86::_mm512_mask_fmaddsub_round_pd fn">_mm512_mask_fmaddsub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 a 中复制元素放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fmaddsub_round_ps.html" title="core::arch::x86::_mm512_mask_fmaddsub_round_ps fn">_mm512_mask_fmaddsub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位则从 a 复制元素放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fmsub_pd.html" title="core::arch::x86::_mm512_mask_fmsub_pd fn">_mm512_mask_fmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (如果未设置相应的掩码位，则从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fmsub_ps.html" title="core::arch::x86::_mm512_mask_fmsub_ps fn">_mm512_mask_fmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fmsub_round_pd.html" title="core::arch::x86::_mm512_mask_fmsub_round_pd fn">_mm512_mask_fmsub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (如果未设置相应的掩码位，则从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fmsub_round_ps.html" title="core::arch::x86::_mm512_mask_fmsub_round_ps fn">_mm512_mask_fmsub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fmsubadd_pd.html" title="core::arch::x86::_mm512_mask_fmsubadd_pd fn">_mm512_mask_fmsubadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，并使用 writemask k 将结果存储在 dst 中 (当未使用相应的掩码位时，元素将从 a 复制放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fmsubadd_ps.html" title="core::arch::x86::_mm512_mask_fmsubadd_ps fn">_mm512_mask_fmsubadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 a 复制元素放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fmsubadd_round_pd.html" title="core::arch::x86::_mm512_mask_fmsubadd_round_pd fn">_mm512_mask_fmsubadd_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，并使用 writemask k 将结果存储在 dst 中 (当未使用相应的掩码位时，元素将从 a 复制放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fmsubadd_round_ps.html" title="core::arch::x86::_mm512_mask_fmsubadd_round_ps fn">_mm512_mask_fmsubadd_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 a 复制元素放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fnmadd_pd.html" title="core::arch::x86::_mm512_mask_fnmadd_pd fn">_mm512_mask_fnmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fnmadd_ps.html" title="core::arch::x86::_mm512_mask_fnmadd_ps fn">_mm512_mask_fnmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fnmadd_round_pd.html" title="core::arch::x86::_mm512_mask_fnmadd_round_pd fn">_mm512_mask_fnmadd_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fnmadd_round_ps.html" title="core::arch::x86::_mm512_mask_fnmadd_round_ps fn">_mm512_mask_fnmadd_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fnmsub_pd.html" title="core::arch::x86::_mm512_mask_fnmsub_pd fn">_mm512_mask_fnmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fnmsub_ps.html" title="core::arch::x86::_mm512_mask_fnmsub_ps fn">_mm512_mask_fnmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fnmsub_round_pd.html" title="core::arch::x86::_mm512_mask_fnmsub_round_pd fn">_mm512_mask_fnmsub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_fnmsub_round_ps.html" title="core::arch::x86::_mm512_mask_fnmsub_round_ps fn">_mm512_mask_fnmsub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_getexp_pd.html" title="core::arch::x86::_mm512_mask_getexp_pd fn">_mm512_mask_getexp_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并使用 writemask k 将结果存储在 dst 中 (当相应的 mask 时，元素从 src 复制位未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_getexp_ps.html" title="core::arch::x86::_mm512_mask_getexp_ps fn">_mm512_mask_getexp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，并使用 writemask k 将结果存储在 dst 中 (当相应的 mask 时，元素从 src 复制位未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_getexp_round_pd.html" title="core::arch::x86::_mm512_mask_getexp_round_pd fn">_mm512_mask_getexp_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并使用 writemask k 将结果存储在 dst 中 (当相应的 mask 时，元素从 src 复制位未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_getexp_round_ps.html" title="core::arch::x86::_mm512_mask_getexp_round_ps fn">_mm512_mask_getexp_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，并使用 writemask k 将结果存储在 dst 中 (当相应的 mask 时，元素从 src 复制位未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_getmant_pd.html" title="core::arch::x86::_mm512_mask_getmant_pd fn">_mm512_mask_getmant_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素的尾数标准化，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_getmant_ps.html" title="core::arch::x86::_mm512_mask_getmant_ps fn">_mm512_mask_getmant_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>标准化 a 中包装的单精度 (32-bit) 浮点元素的尾数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_getmant_round_pd.html" title="core::arch::x86::_mm512_mask_getmant_round_pd fn">_mm512_mask_getmant_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素的尾数标准化，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_getmant_round_ps.html" title="core::arch::x86::_mm512_mask_getmant_round_ps fn">_mm512_mask_getmant_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>标准化 a 中包装的单精度 (32-bit) 浮点元素的尾数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_gf2p8affine_epi64_epi8.html" title="core::arch::x86::_mm512_mask_gf2p8affine_epi64_epi8 fn">_mm512_mask_gf2p8affine_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512f` only"><code>avx512gfni,avx512bw,avx512f</code></span><p>对 x 中的包装字节执行仿射变换。
也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_gf2p8affineinv_epi64_epi8.html" title="core::arch::x86::_mm512_mask_gf2p8affineinv_epi64_epi8 fn">_mm512_mask_gf2p8affineinv_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512f` only"><code>avx512gfni,avx512bw,avx512f</code></span><p>对 x 中的反向包装的字节执行仿射变换。
也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_gf2p8mul_epi8.html" title="core::arch::x86::_mm512_mask_gf2p8mul_epi8 fn">_mm512_mask_gf2p8mul_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512f` only"><code>avx512gfni,avx512bw,avx512f</code></span><p>在包装的字节上执行 GF(2^8) 乘法。
该字段以多项式表示，具有约数多项式 x^8 + x^4 + x^3 + x + 1。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_i32gather_epi32.html" title="core::arch::x86::_mm512_mask_i32gather_epi32 fn">_mm512_mask_i32gather_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 32 位索引从内存中收集 32 位整数。从 base_addr 开始的地址加载 32 位元素，并由 vindex 中的每个 32 位元素偏移 (每个索引均按比例因子进行缩放)。使用 writemask k 将收集到的元素合并到 dst (当相应的掩码位未设置时，从 src 复制元素)。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_i32gather_epi64.html" title="core::arch::x86::_mm512_mask_i32gather_epi64 fn">_mm512_mask_i32gather_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 32 位索引从内存中收集 64 位整数。从 base_addr 开始的地址加载 64 位元素，并由 vindex 中的每个 32 位元素偏移 (每个索引均按比例因子进行缩放)。使用 writemask k 将收集到的元素合并到 dst (当相应的掩码位未设置时，从 src 复制元素)。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_i32gather_pd.html" title="core::arch::x86::_mm512_mask_i32gather_pd fn">_mm512_mask_i32gather_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 32 位索引从内存中收集双精度 (64-bit) 浮点元素。从 base_addr 开始的地址加载 64 位元素，并由 vindex 中的每个 32 位元素偏移 (每个索引均按比例因子进行缩放)。使用 writemask k 将收集到的元素合并到 dst (当相应的掩码位未设置时，从 src 复制元素)。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_i32gather_ps.html" title="core::arch::x86::_mm512_mask_i32gather_ps fn">_mm512_mask_i32gather_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 32 位索引从内存中收集单精度 (32-bit) 浮点元素。从 base_addr 开始的地址加载 32 位元素，并由 vindex 中的每个 32 位元素偏移 (每个索引均按比例因子进行缩放)。使用 writemask k 将收集到的元素合并到 dst (当相应的掩码位未设置时，从 src 复制元素)。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_i32scatter_epi32.html" title="core::arch::x86::_mm512_mask_i32scatter_epi32 fn">_mm512_mask_i32scatter_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 32 位索引将 32 位整数从 a 分散到内存中。32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 32 位元素偏移 (每个索引按比例因子缩放) 受掩码 k (当相应掩码位未设置时不存储元素) . 小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_i32scatter_epi64.html" title="core::arch::x86::_mm512_mask_i32scatter_epi64 fn">_mm512_mask_i32scatter_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 32 位索引将 64 位整数从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址中，并由 vindex 中的每个 32 位元素偏移 (每个索引按比例因子缩放) 受掩码 k (未设置相应掩码位时不存储元素) . 小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_i32scatter_pd.html" title="core::arch::x86::_mm512_mask_i32scatter_pd fn">_mm512_mask_i32scatter_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 32 位索引将双精度 (64-bit) 浮点元素从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址中，并由 vindex 中的每个 32 位元素偏移 (每个索引按比例因子缩放) 受掩码 k (未设置相应掩码位时不存储元素) . 小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_i32scatter_ps.html" title="core::arch::x86::_mm512_mask_i32scatter_ps fn">_mm512_mask_i32scatter_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 32 位索引将单精度 (32-bit) 浮点元素从 a 分散到内存中。32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 32 位元素偏移 (每个索引按比例因子缩放) 受掩码 k (当相应掩码位未设置时不存储元素) . 小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_i64gather_epi32.html" title="core::arch::x86::_mm512_mask_i64gather_epi32 fn">_mm512_mask_i64gather_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 64 位索引从内存中收集 32 位整数。从 base_addr 开始的地址加载 32 位元素，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)。使用 writemask k 将收集到的元素合并到 dst (当相应的掩码位未设置时，从 src 复制元素)。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_i64gather_epi64.html" title="core::arch::x86::_mm512_mask_i64gather_epi64 fn">_mm512_mask_i64gather_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 64 位索引从内存中收集 64 位整数。从 base_addr 开始的地址加载 64 位元素，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)。使用 writemask k 将收集到的元素合并到 dst (当相应的掩码位未设置时，从 src 复制元素)。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_i64gather_pd.html" title="core::arch::x86::_mm512_mask_i64gather_pd fn">_mm512_mask_i64gather_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 64 位索引从内存中收集双精度 (64-bit) 浮点元素。从 base_addr 开始的地址加载 64 位元素，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)。使用 writemask k 将收集到的元素合并到 dst (当相应的掩码位未设置时，从 src 复制元素)。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_i64gather_ps.html" title="core::arch::x86::_mm512_mask_i64gather_ps fn">_mm512_mask_i64gather_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 64 位索引从内存中收集单精度 (32-bit) 浮点元素。从 base_addr 开始的地址加载 32 位元素，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)。使用 writemask k 将收集到的元素合并到 dst (当相应的掩码位未设置时，从 src 复制元素)。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_i64scatter_epi32.html" title="core::arch::x86::_mm512_mask_i64scatter_epi32 fn">_mm512_mask_i64scatter_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 64 位索引将 32 位整数从 a 分散到内存中。32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)，且受掩码 k 限制 (未设置相应的掩码位时不存储元素)。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_i64scatter_epi64.html" title="core::arch::x86::_mm512_mask_i64scatter_epi64 fn">_mm512_mask_i64scatter_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 64 位索引将 64 位整数从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 64 位元素偏移 (每个索引按比例因子缩放) 受掩码 k (当相应掩码位未设置时不存储元素) . 小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_i64scatter_pd.html" title="core::arch::x86::_mm512_mask_i64scatter_pd fn">_mm512_mask_i64scatter_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 64 位索引将双精度 (64-bit) 浮点元素从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 64 位元素偏移 (每个索引按比例因子缩放) 受掩码 k (当相应掩码位未设置时不存储元素) . 小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_i64scatter_ps.html" title="core::arch::x86::_mm512_mask_i64scatter_ps fn">_mm512_mask_i64scatter_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 64 位索引将单精度 (32-bit) 浮点元素从 a 分散到内存中。32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)，且受掩码 k 限制 (未设置相应的掩码位时不存储元素)。小数位数应为 1、2、4 或 8。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_insertf32x4.html" title="core::arch::x86::_mm512_mask_insertf32x4 fn">_mm512_mask_insertf32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 复制到 tmp，然后在 x00X 指定的位置将 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成) 插入 tmp。使用写掩码 k 将 tmp 存储到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_insertf64x4.html" title="core::arch::x86::_mm512_mask_insertf64x4 fn">_mm512_mask_insertf64x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 复制到 tmp，然后在 x00X 指定的位置将 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成) 插入 tmp。使用写掩码 k 将 tmp 存储到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_inserti32x4.html" title="core::arch::x86::_mm512_mask_inserti32x4 fn">_mm512_mask_inserti32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 复制到 tmp，然后在 imm8 指定的位置，将 b 中的 128 位 (由 4 个包装的 32 位整数组成) 插入 tmp。使用写掩码 k 将 tmp 存储到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_inserti64x4.html" title="core::arch::x86::_mm512_mask_inserti64x4 fn">_mm512_mask_inserti64x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 复制到 tmp，然后在 imm8 指定的位置将 b 的 256 位 (由 4 个包装的 64 位整数组成) 插入 tmp。使用写掩码 k 将 tmp 存储到 dst (当未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_lzcnt_epi32.html" title="core::arch::x86::_mm512_mask_lzcnt_epi32 fn">_mm512_mask_lzcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span><p>计算 a 中每个包装的 32 位整数中前导零位的数目，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_lzcnt_epi64.html" title="core::arch::x86::_mm512_mask_lzcnt_epi64 fn">_mm512_mask_lzcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span><p>计算 a 中每个包装的 64 位整数中前导零位的数目，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_madd_epi16.html" title="core::arch::x86::_mm512_mask_madd_epi16 fn">_mm512_mask_madd_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。水平添加相邻的中间 32 位整数对，并使用 writemask k 将结果打包到 dst (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_maddubs_epi16.html" title="core::arch::x86::_mm512_mask_maddubs_epi16 fn">_mm512_mask_maddubs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 中的包装无符号 8 位整数与 b 中的包装有符号 8 位整数相乘，生成中间有符号的 16 位整数。水平相加相邻的中间带符号的 16 位整数对，并使用写掩码 k 将饱和结果包装到 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_max_epi8.html" title="core::arch::x86::_mm512_mask_max_epi8 fn">_mm512_mask_max_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_max_epi16.html" title="core::arch::x86::_mm512_mask_max_epi16 fn">_mm512_mask_max_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_max_epi32.html" title="core::arch::x86::_mm512_mask_max_epi32 fn">_mm512_mask_max_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_max_epi64.html" title="core::arch::x86::_mm512_mask_max_epi64 fn">_mm512_mask_max_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_max_epu8.html" title="core::arch::x86::_mm512_mask_max_epu8 fn">_mm512_mask_max_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 8 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_max_epu16.html" title="core::arch::x86::_mm512_mask_max_epu16 fn">_mm512_mask_max_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 16 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_max_epu32.html" title="core::arch::x86::_mm512_mask_max_epu32 fn">_mm512_mask_max_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 32 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_max_epu64.html" title="core::arch::x86::_mm512_mask_max_epu64 fn">_mm512_mask_max_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 64 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_max_pd.html" title="core::arch::x86::_mm512_mask_max_pd fn">_mm512_mask_max_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_max_ps.html" title="core::arch::x86::_mm512_mask_max_ps fn">_mm512_mask_max_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_max_round_pd.html" title="core::arch::x86::_mm512_mask_max_round_pd fn">_mm512_mask_max_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_max_round_ps.html" title="core::arch::x86::_mm512_mask_max_round_ps fn">_mm512_mask_max_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_min_epi8.html" title="core::arch::x86::_mm512_mask_min_epi8 fn">_mm512_mask_min_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_min_epi16.html" title="core::arch::x86::_mm512_mask_min_epi16 fn">_mm512_mask_min_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号 16 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_min_epi32.html" title="core::arch::x86::_mm512_mask_min_epi32 fn">_mm512_mask_min_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_min_epi64.html" title="core::arch::x86::_mm512_mask_min_epi64 fn">_mm512_mask_min_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_min_epu8.html" title="core::arch::x86::_mm512_mask_min_epu8 fn">_mm512_mask_min_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 8 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_min_epu16.html" title="core::arch::x86::_mm512_mask_min_epu16 fn">_mm512_mask_min_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 16 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_min_epu32.html" title="core::arch::x86::_mm512_mask_min_epu32 fn">_mm512_mask_min_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 32 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_min_epu64.html" title="core::arch::x86::_mm512_mask_min_epu64 fn">_mm512_mask_min_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 64 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_min_pd.html" title="core::arch::x86::_mm512_mask_min_pd fn">_mm512_mask_min_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_min_ps.html" title="core::arch::x86::_mm512_mask_min_ps fn">_mm512_mask_min_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_min_round_pd.html" title="core::arch::x86::_mm512_mask_min_round_pd fn">_mm512_mask_min_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_min_round_ps.html" title="core::arch::x86::_mm512_mask_min_round_ps fn">_mm512_mask_min_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_mov_epi8.html" title="core::arch::x86::_mm512_mask_mov_epi8 fn">_mm512_mask_mov_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用写掩码 k 将包装的 8 位整数从 a 移到 dst (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_mov_epi16.html" title="core::arch::x86::_mm512_mask_mov_epi16 fn">_mm512_mask_mov_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用写掩码 k 将包装的 16 位整数从 a 移到 dst (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_mov_epi32.html" title="core::arch::x86::_mm512_mask_mov_epi32 fn">_mm512_mask_mov_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用写掩码 k 将包装的 32 位整数从 a 移动到 dst (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_mov_epi64.html" title="core::arch::x86::_mm512_mask_mov_epi64 fn">_mm512_mask_mov_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用写掩码 k 将包装的 64 位整数从 a 移动到 dst (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_mov_pd.html" title="core::arch::x86::_mm512_mask_mov_pd fn">_mm512_mask_mov_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用写掩码 k 将包装的双精度 (64-bit) 浮点元素从 a 移动到 dst (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_mov_ps.html" title="core::arch::x86::_mm512_mask_mov_ps fn">_mm512_mask_mov_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用写掩码 k 将包装的单精度 (32-bit) 浮点元素从 a 移动到 dst (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_movedup_pd.html" title="core::arch::x86::_mm512_mask_movedup_pd fn">_mm512_mask_movedup_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 复制偶数索引的双精度 (64-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_movehdup_ps.html" title="core::arch::x86::_mm512_mask_movehdup_ps fn">_mm512_mask_movehdup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 复制奇数索引的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_moveldup_ps.html" title="core::arch::x86::_mm512_mask_moveldup_ps fn">_mm512_mask_moveldup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 复制偶数索引的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_mul_epi32.html" title="core::arch::x86::_mm512_mask_mul_epi32 fn">_mm512_mask_mul_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中每个包装的 64 位元素的低符号 32 位整数相乘，并使用写掩码 k 将有符号的 64 位结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_mul_epu32.html" title="core::arch::x86::_mm512_mask_mul_epu32 fn">_mm512_mask_mul_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中每个包装的 64 位元素的低无符号 32 位整数相乘，并使用写掩码 k 将无符号 64 位结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_mul_pd.html" title="core::arch::x86::_mm512_mask_mul_pd fn">_mm512_mask_mul_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_mul_ps.html" title="core::arch::x86::_mm512_mask_mul_ps fn">_mm512_mask_mul_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_mul_round_pd.html" title="core::arch::x86::_mm512_mask_mul_round_pd fn">_mm512_mask_mul_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_mul_round_ps.html" title="core::arch::x86::_mm512_mask_mul_round_ps fn">_mm512_mask_mul_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_mulhi_epi16.html" title="core::arch::x86::_mm512_mask_mulhi_epi16 fn">_mm512_mask_mulhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 和 b 中包装的带符号的 16 位整数相乘，生成 32 位中间整数，并使用写掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_mulhi_epu16.html" title="core::arch::x86::_mm512_mask_mulhi_epu16 fn">_mm512_mask_mulhi_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 和 b 中包装的无符号 16 位整数相乘，生成 32 位中间整数，并使用写掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_mulhrs_epi16.html" title="core::arch::x86::_mm512_mask_mulhrs_epi16 fn">_mm512_mask_mulhrs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。将每个中间整数截断为 18 个最高有效位，通过加 1 舍入，并使用 writemask k 将位 [16:1] 存储到 dst (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_mullo_epi16.html" title="core::arch::x86::_mm512_mask_mullo_epi16 fn">_mm512_mask_mullo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 和 b 中的包装的 16 位整数相乘，生成中间的 32 位整数，并使用写掩码 k 将中间整数的低 16 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_mullo_epi32.html" title="core::arch::x86::_mm512_mask_mullo_epi32 fn">_mm512_mask_mullo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的 32 位整数相乘，生成中间 64 位整数，并使用写掩码 k 将中间整数的低 32 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_mullox_epi64.html" title="core::arch::x86::_mm512_mask_mullox_epi64 fn">_mm512_mask_mullox_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 64 位整数 vectors a 和 b 中的元素相乘，使用写掩码 k 将结果的低 64 位存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_multishift_epi64_epi8.html" title="core::arch::x86::_mm512_mask_multishift_epi64_epi8 fn">_mm512_mask_multishift_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi` only"><code>avx512vbmi</code></span><p>对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并使用 writemask k (元素当相应的屏蔽位未设置时，从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_or_epi32.html" title="core::arch::x86::_mm512_mask_or_epi32 fn">_mm512_mask_or_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中包装的 32 位整数的按位或，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_or_epi64.html" title="core::arch::x86::_mm512_mask_or_epi64 fn">_mm512_mask_or_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中包装的 64 位整数的按位或，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_packs_epi16.html" title="core::arch::x86::_mm512_mask_packs_epi16 fn">_mm512_mask_packs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用带符号的饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_packs_epi32.html" title="core::arch::x86::_mm512_mask_packs_epi32 fn">_mm512_mask_packs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用带符号的饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_packus_epi16.html" title="core::arch::x86::_mm512_mask_packus_epi16 fn">_mm512_mask_packus_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用无符号饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_packus_epi32.html" title="core::arch::x86::_mm512_mask_packus_epi32 fn">_mm512_mask_packus_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用无符号饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_permute_pd.html" title="core::arch::x86::_mm512_mask_permute_pd fn">_mm512_mask_permute_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 imm8 中的控件在 128 位通道内对双精度 (64-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_permute_ps.html" title="core::arch::x86::_mm512_mask_permute_ps fn">_mm512_mask_permute_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_permutevar_epi32.html" title="core::arch::x86::_mm512_mask_permutevar_epi32 fn">_mm512_mask_permutevar_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 idx 中的相应索引在跨通道中对 32 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。请注意，与使用 permutevar 名称的过去内联函数不同，该内联函数在 128 位通道上进行了重排。此内联函数与 _mm512_mask_permutexvar_epi32 相同，建议您使用该内联函数名称。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_permutevar_pd.html" title="core::arch::x86::_mm512_mask_permutevar_pd fn">_mm512_mask_permutevar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的控件在 128 位通道内将 a 的双精度 (64-bit) 浮点元素进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_permutevar_ps.html" title="core::arch::x86::_mm512_mask_permutevar_ps fn">_mm512_mask_permutevar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的控件在 128 位通道内将 a 的单精度 (32-bit) 浮点元素打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_permutex2var_epi8.html" title="core::arch::x86::_mm512_mask_permutex2var_epi8 fn">_mm512_mask_permutex2var_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi` only"><code>avx512vbmi</code></span><p>使用相应的选择器和 idx 中的索引将 a 和 b 中的 8 位整数跨通道打乱，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_permutex2var_epi16.html" title="core::arch::x86::_mm512_mask_permutex2var_epi16 fn">_mm512_mask_permutex2var_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用相应的选择器和 idx 中的索引在通道中的 a 和 b 中对 16 位整数进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_permutex2var_epi32.html" title="core::arch::x86::_mm512_mask_permutex2var_epi32 fn">_mm512_mask_permutex2var_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中对 32 位整数进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_permutex2var_epi64.html" title="core::arch::x86::_mm512_mask_permutex2var_epi64 fn">_mm512_mask_permutex2var_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中随机排列 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_permutex2var_pd.html" title="core::arch::x86::_mm512_mask_permutex2var_pd fn">_mm512_mask_permutex2var_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_permutex2var_ps.html" title="core::arch::x86::_mm512_mask_permutex2var_ps fn">_mm512_mask_permutex2var_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用对应的选择器和 idx 中的索引在 a 和 b 中的通道上对 a 和 b 中的单精度 (32-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_permutex_epi64.html" title="core::arch::x86::_mm512_mask_permutex_epi64 fn">_mm512_mask_permutex_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 imm8 中的控件在 256 位通道内将 64 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_permutex_pd.html" title="core::arch::x86::_mm512_mask_permutex_pd fn">_mm512_mask_permutex_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 imm8 中的控件在 256 位通道内对双精度 (64-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_permutexvar_epi8.html" title="core::arch::x86::_mm512_mask_permutexvar_epi8 fn">_mm512_mask_permutexvar_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi` only"><code>avx512vbmi</code></span><p>使用 idx 中的相应索引在跨通道的 a 中打乱 8 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_permutexvar_epi16.html" title="core::arch::x86::_mm512_mask_permutexvar_epi16 fn">_mm512_mask_permutexvar_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用 idx 中的相应索引在跨通道中对 16 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_permutexvar_epi32.html" title="core::arch::x86::_mm512_mask_permutexvar_epi32 fn">_mm512_mask_permutexvar_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 idx 中的相应索引在跨通道中对 32 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_permutexvar_epi64.html" title="core::arch::x86::_mm512_mask_permutexvar_epi64 fn">_mm512_mask_permutexvar_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 idx 中的相应索引在跨通道中随机排列 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_permutexvar_pd.html" title="core::arch::x86::_mm512_mask_permutexvar_pd fn">_mm512_mask_permutexvar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 idx 中的相应索引对跨通道中的双精度 (64-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_permutexvar_ps.html" title="core::arch::x86::_mm512_mask_permutexvar_ps fn">_mm512_mask_permutexvar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 idx 中的相应索引对跨通道中的单精度 (32-bit) 浮点元素进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_popcnt_epi8.html" title="core::arch::x86::_mm512_mask_popcnt_epi8 fn">_mm512_mask_popcnt_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg` only"><code>avx512bitalg</code></span><p>对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_popcnt_epi16.html" title="core::arch::x86::_mm512_mask_popcnt_epi16 fn">_mm512_mask_popcnt_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg` only"><code>avx512bitalg</code></span><p>对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_popcnt_epi32.html" title="core::arch::x86::_mm512_mask_popcnt_epi32 fn">_mm512_mask_popcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq` only"><code>avx512vpopcntdq</code></span><p>对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_popcnt_epi64.html" title="core::arch::x86::_mm512_mask_popcnt_epi64 fn">_mm512_mask_popcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq` only"><code>avx512vpopcntdq</code></span><p>对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_rcp14_pd.html" title="core::arch::x86::_mm512_mask_rcp14_pd fn">_mm512_mask_rcp14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_rcp14_ps.html" title="core::arch::x86::_mm512_mask_rcp14_ps fn">_mm512_mask_rcp14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_reduce_add_epi32.html" title="core::arch::x86::_mm512_mask_reduce_add_epi32 fn">_mm512_mask_reduce_add_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用掩码 k 通过加法来减少 a 中包装的 32 位整数。返回 a 中所有活动元素的总和。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_reduce_add_epi64.html" title="core::arch::x86::_mm512_mask_reduce_add_epi64 fn">_mm512_mask_reduce_add_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用掩码 k 通过加法来减少 a 中包装的 64 位整数。返回 a 中所有活动元素的总和。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_reduce_add_pd.html" title="core::arch::x86::_mm512_mask_reduce_add_pd fn">_mm512_mask_reduce_add_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>通过使用掩膜 k 加法来减少包装的双精度 (64-bit) 浮点元素。返回 a 中所有活动元素的总和。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_reduce_add_ps.html" title="core::arch::x86::_mm512_mask_reduce_add_ps fn">_mm512_mask_reduce_add_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>通过使用掩码 k 加法来减少包装的单精度 (32-bit) 浮点元素。返回 a 中所有活动元素的总和。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_reduce_and_epi32.html" title="core::arch::x86::_mm512_mask_reduce_and_epi32 fn">_mm512_mask_reduce_and_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用掩码 k 按位与减少包装的 32 位整数。返回 a 中所有活动元素的按位与。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_reduce_and_epi64.html" title="core::arch::x86::_mm512_mask_reduce_and_epi64 fn">_mm512_mask_reduce_and_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用掩码 k 通过加法来减少 a 中包装的 64 位整数。返回 a 中所有活动元素的总和。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_reduce_max_epi32.html" title="core::arch::x86::_mm512_mask_reduce_max_epi32 fn">_mm512_mask_reduce_max_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用掩码 k 最多减少 a 中的包装有符号 32 位整数。返回 a 中所有活动元素的最大值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_reduce_max_epi64.html" title="core::arch::x86::_mm512_mask_reduce_max_epi64 fn">_mm512_mask_reduce_max_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用掩码 k 最大减少包装的带符号的 64 位整数。返回 a 中所有活动元素的最大值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_reduce_max_epu32.html" title="core::arch::x86::_mm512_mask_reduce_max_epu32 fn">_mm512_mask_reduce_max_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用掩码 k 最大减少包装的无符号 32 位整数。返回 a 中所有活动元素的最大值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_reduce_max_epu64.html" title="core::arch::x86::_mm512_mask_reduce_max_epu64 fn">_mm512_mask_reduce_max_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用掩码 k 最大减少包装的无符号 64 位整数。返回 a 中所有活动元素的最大值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_reduce_max_pd.html" title="core::arch::x86::_mm512_mask_reduce_max_pd fn">_mm512_mask_reduce_max_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用掩码 k 最多减少 a 中包装的双精度 (64-bit) 浮点元素。返回 a 中所有活动元素的最大值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_reduce_max_ps.html" title="core::arch::x86::_mm512_mask_reduce_max_ps fn">_mm512_mask_reduce_max_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>最多使用掩码 k 减少包装后的单精度 (32-bit) 浮点元素。返回 a 中所有活动元素的最大值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_reduce_min_epi32.html" title="core::arch::x86::_mm512_mask_reduce_min_epi32 fn">_mm512_mask_reduce_min_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用掩码 k 最多减少 a 中的包装有符号 32 位整数。返回 a 中所有活动元素的最小值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_reduce_min_epi64.html" title="core::arch::x86::_mm512_mask_reduce_min_epi64 fn">_mm512_mask_reduce_min_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用掩码 k 最大减少包装的带符号的 64 位整数。返回 a 中所有活动元素的最小值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_reduce_min_epu32.html" title="core::arch::x86::_mm512_mask_reduce_min_epu32 fn">_mm512_mask_reduce_min_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用掩码 k 最大减少包装的无符号 32 位整数。返回 a 中所有活动元素的最小值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_reduce_min_epu64.html" title="core::arch::x86::_mm512_mask_reduce_min_epu64 fn">_mm512_mask_reduce_min_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用掩码 k 最大减少包装的带符号的 64 位整数。返回 a 中所有活动元素的最小值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_reduce_min_pd.html" title="core::arch::x86::_mm512_mask_reduce_min_pd fn">_mm512_mask_reduce_min_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用掩码 k 最多减少 a 中包装的双精度 (64-bit) 浮点元素。返回 a 中所有活动元素的最小值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_reduce_min_ps.html" title="core::arch::x86::_mm512_mask_reduce_min_ps fn">_mm512_mask_reduce_min_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>最多使用掩码 k 减少包装后的单精度 (32-bit) 浮点元素。返回 a 中所有活动元素的最小值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_reduce_mul_epi32.html" title="core::arch::x86::_mm512_mask_reduce_mul_epi32 fn">_mm512_mask_reduce_mul_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用掩码 k 通过乘以减少 a 中包装的 32 位整数。返回 a 中所有活动元素的乘积。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_reduce_mul_epi64.html" title="core::arch::x86::_mm512_mask_reduce_mul_epi64 fn">_mm512_mask_reduce_mul_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用掩码 k 通过乘以减少 a 中包装的 64 位整数。返回 a 中所有活动元素的乘积。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_reduce_mul_pd.html" title="core::arch::x86::_mm512_mask_reduce_mul_pd fn">_mm512_mask_reduce_mul_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用掩码 k 通过乘以减少 a 中包装的双精度 (64-bit) 浮点元素。返回 a 中所有活动元素的乘积。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_reduce_mul_ps.html" title="core::arch::x86::_mm512_mask_reduce_mul_ps fn">_mm512_mask_reduce_mul_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用掩码 k 通过乘以减少 a 中包装的单精度 (32-bit) 浮点元素。返回 a 中所有活动元素的乘积。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_reduce_or_epi32.html" title="core::arch::x86::_mm512_mask_reduce_or_epi32 fn">_mm512_mask_reduce_or_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用掩码 k 按位或减少包装的 32 位整数。返回 a 中所有活动元素的按位或。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_reduce_or_epi64.html" title="core::arch::x86::_mm512_mask_reduce_or_epi64 fn">_mm512_mask_reduce_or_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用掩码 k 按位或减少包装的 64 位整数。返回 a 中所有活动元素的按位或。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_rol_epi32.html" title="core::arch::x86::_mm512_mask_rol_epi32 fn">_mm512_mask_rol_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_rol_epi64.html" title="core::arch::x86::_mm512_mask_rol_epi64 fn">_mm512_mask_rol_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_rolv_epi32.html" title="core::arch::x86::_mm512_mask_rolv_epi32 fn">_mm512_mask_rolv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中每个包装的 32 位整数中的位向左旋转 b 对应元素 b 中指定的位数，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 src 复制元素放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_rolv_epi64.html" title="core::arch::x86::_mm512_mask_rolv_epi64 fn">_mm512_mask_rolv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中每个包装的 64 位整数中的位向左旋转 b 的对应元素中指定的位数，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 src 复制元素放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_ror_epi32.html" title="core::arch::x86::_mm512_mask_ror_epi32 fn">_mm512_mask_ror_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 X 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_ror_epi64.html" title="core::arch::x86::_mm512_mask_ror_epi64 fn">_mm512_mask_ror_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 X 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_rorv_epi32.html" title="core::arch::x86::_mm512_mask_rorv_epi32 fn">_mm512_mask_rorv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中每个包装的 32 位整数中的位向右旋转 b 的对应元素中指定的位数，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 src 复制元素放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_rorv_epi64.html" title="core::arch::x86::_mm512_mask_rorv_epi64 fn">_mm512_mask_rorv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 src 复制元素放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_roundscale_pd.html" title="core::arch::x86::_mm512_mask_roundscale_pd fn">_mm512_mask_roundscale_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_roundscale_ps.html" title="core::arch::x86::_mm512_mask_roundscale_ps fn">_mm512_mask_roundscale_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的小数位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_roundscale_round_pd.html" title="core::arch::x86::_mm512_mask_roundscale_round_pd fn">_mm512_mask_roundscale_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_roundscale_round_ps.html" title="core::arch::x86::_mm512_mask_roundscale_round_ps fn">_mm512_mask_roundscale_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的小数位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_rsqrt14_pd.html" title="core::arch::x86::_mm512_mask_rsqrt14_pd fn">_mm512_mask_rsqrt14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_rsqrt14_ps.html" title="core::arch::x86::_mm512_mask_rsqrt14_ps fn">_mm512_mask_rsqrt14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_scalef_pd.html" title="core::arch::x86::_mm512_mask_scalef_pd fn">_mm512_mask_scalef_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_scalef_ps.html" title="core::arch::x86::_mm512_mask_scalef_ps fn">_mm512_mask_scalef_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_scalef_round_pd.html" title="core::arch::x86::_mm512_mask_scalef_round_pd fn">_mm512_mask_scalef_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_scalef_round_ps.html" title="core::arch::x86::_mm512_mask_scalef_round_ps fn">_mm512_mask_scalef_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_set1_epi8.html" title="core::arch::x86::_mm512_mask_set1_epi8 fn">_mm512_mask_set1_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用写掩码 k 将 8 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_set1_epi16.html" title="core::arch::x86::_mm512_mask_set1_epi16 fn">_mm512_mask_set1_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用写掩码 k 向 dst 的所有元素广播 16 位整数 a (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_set1_epi32.html" title="core::arch::x86::_mm512_mask_set1_epi32 fn">_mm512_mask_set1_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用写掩码 k 将 32 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_set1_epi64.html" title="core::arch::x86::_mm512_mask_set1_epi64 fn">_mm512_mask_set1_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用写掩码 k 将 64 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_shldi_epi16.html" title="core::arch::x86::_mm512_mask_shldi_epi16 fn">_mm512_mask_shldi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并使用 writemask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_shldi_epi32.html" title="core::arch::x86::_mm512_mask_shldi_epi32 fn">_mm512_mask_shldi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并使用 writemask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_shldi_epi64.html" title="core::arch::x86::_mm512_mask_shldi_epi64 fn">_mm512_mask_shldi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并使用 writemask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_shldv_epi16.html" title="core::arch::x86::_mm512_mask_shldv_epi16 fn">_mm512_mask_shldv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_shldv_epi32.html" title="core::arch::x86::_mm512_mask_shldv_epi32 fn">_mm512_mask_shldv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_shldv_epi64.html" title="core::arch::x86::_mm512_mask_shldv_epi64 fn">_mm512_mask_shldv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_shrdi_epi16.html" title="core::arch::x86::_mm512_mask_shrdi_epi16 fn">_mm512_mask_shrdi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并使用 writemask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_shrdi_epi32.html" title="core::arch::x86::_mm512_mask_shrdi_epi32 fn">_mm512_mask_shrdi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并使用 writemask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_shrdi_epi64.html" title="core::arch::x86::_mm512_mask_shrdi_epi64 fn">_mm512_mask_shrdi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并使用 writemask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，元素从 src` 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_shrdv_epi16.html" title="core::arch::x86::_mm512_mask_shrdv_epi16 fn">_mm512_mask_shrdv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_shrdv_epi32.html" title="core::arch::x86::_mm512_mask_shrdv_epi32 fn">_mm512_mask_shrdv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_shrdv_epi64.html" title="core::arch::x86::_mm512_mask_shrdv_epi64 fn">_mm512_mask_shrdv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_shuffle_epi8.html" title="core::arch::x86::_mm512_mask_shuffle_epi8 fn">_mm512_mask_shuffle_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用 b 中相应的 8 位元素中的控件在 128 位通道内对 a 中的 8 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_shuffle_epi32.html" title="core::arch::x86::_mm512_mask_shuffle_epi32 fn">_mm512_mask_shuffle_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 imm8 中的控件将 128 位通道中的 32 位整数随机排列，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_shuffle_f32x4.html" title="core::arch::x86::_mm512_mask_shuffle_f32x4 fn">_mm512_mask_shuffle_f32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 imm8 从 a 和 b 中选择的 128 位 (由 4 个单精度 (32-bit) 浮点元素组成) 混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_shuffle_f64x2.html" title="core::arch::x86::_mm512_mask_shuffle_f64x2 fn">_mm512_mask_shuffle_f64x2</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 imm8 从 a 和 b 中选择的 128 位 (由 2 个双精度 (64-bit) 浮点元素组成) 混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_shuffle_i32x4.html" title="core::arch::x86::_mm512_mask_shuffle_i32x4 fn">_mm512_mask_shuffle_i32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 imm8 从 a 和 b 中选择的 128 位 (由 4 个 32 位整数组成) 重排，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_shuffle_i64x2.html" title="core::arch::x86::_mm512_mask_shuffle_i64x2 fn">_mm512_mask_shuffle_i64x2</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 imm8 从 a 和 b 中选择的 128 位 (由 2 个 64 位整数组成) 进行混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_shuffle_pd.html" title="core::arch::x86::_mm512_mask_shuffle_pd fn">_mm512_mask_shuffle_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 imm8 中的控件对 128 位通道中的双精度 (64-bit) 浮点元素进行混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_shuffle_ps.html" title="core::arch::x86::_mm512_mask_shuffle_ps fn">_mm512_mask_shuffle_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_shufflehi_epi16.html" title="core::arch::x86::_mm512_mask_shufflehi_epi16 fn">_mm512_mask_shufflehi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用 imm8 中的控件在 a 的 128 位通道的高 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的高 64 位中，将 128 位通道的低 64 位从 a 复制到 dst，使用写掩码 k (当相应的掩码位不存在时，元素从 src 复制放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_shufflelo_epi16.html" title="core::arch::x86::_mm512_mask_shufflelo_epi16 fn">_mm512_mask_shufflelo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用 imm8 中的控件在 a 的 128 位通道的低 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的低 64 位中，并使用写掩码 k 将 128 位通道的高 64 位从 a 复制到 dst (当未使用相应的掩码位时，元素从 src 复制) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_sll_epi16.html" title="core::arch::x86::_mm512_mask_sll_epi16 fn">_mm512_mask_sll_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数按计数左移，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_sll_epi32.html" title="core::arch::x86::_mm512_mask_sll_epi32 fn">_mm512_mask_sll_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 32 位整数左移计数，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_sll_epi64.html" title="core::arch::x86::_mm512_mask_sll_epi64 fn">_mm512_mask_sll_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 64 位整数左移计数，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_slli_epi16.html" title="core::arch::x86::_mm512_mask_slli_epi16 fn">_mm512_mask_slli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数左移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_slli_epi32.html" title="core::arch::x86::_mm512_mask_slli_epi32 fn">_mm512_mask_slli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 32 位整数左移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_slli_epi64.html" title="core::arch::x86::_mm512_mask_slli_epi64 fn">_mm512_mask_slli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 64 位整数向左移动 imm8，同时向零移动，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_sllv_epi16.html" title="core::arch::x86::_mm512_mask_sllv_epi16 fn">_mm512_mask_sllv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数按 count 中相应元素指定的数量向左移位，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_sllv_epi32.html" title="core::arch::x86::_mm512_mask_sllv_epi32 fn">_mm512_mask_sllv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将填充的 32 位整数向左移动计数中相应元素指定的数量，同时将其移位为零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_sllv_epi64.html" title="core::arch::x86::_mm512_mask_sllv_epi64 fn">_mm512_mask_sllv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将填充的 64 位整数向左移动 count 中相应元素指定的数量，同时将其移位为零，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_sqrt_pd.html" title="core::arch::x86::_mm512_mask_sqrt_pd fn">_mm512_mask_sqrt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_sqrt_ps.html" title="core::arch::x86::_mm512_mask_sqrt_ps fn">_mm512_mask_sqrt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_sqrt_round_pd.html" title="core::arch::x86::_mm512_mask_sqrt_round_pd fn">_mm512_mask_sqrt_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_sqrt_round_ps.html" title="core::arch::x86::_mm512_mask_sqrt_round_ps fn">_mm512_mask_sqrt_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_sra_epi16.html" title="core::arch::x86::_mm512_mask_sra_epi16 fn">_mm512_mask_sra_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数按计数右移，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_sra_epi32.html" title="core::arch::x86::_mm512_mask_sra_epi32 fn">_mm512_mask_sra_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在移动符号位的同时右移计数包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_sra_epi64.html" title="core::arch::x86::_mm512_mask_sra_epi64 fn">_mm512_mask_sra_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在移动符号位的同时右移计数包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_srai_epi16.html" title="core::arch::x86::_mm512_mask_srai_epi16 fn">_mm512_mask_srai_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_srai_epi32.html" title="core::arch::x86::_mm512_mask_srai_epi32 fn">_mm512_mask_srai_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 32 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_srai_epi64.html" title="core::arch::x86::_mm512_mask_srai_epi64 fn">_mm512_mask_srai_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 64 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_srav_epi16.html" title="core::arch::x86::_mm512_mask_srav_epi16 fn">_mm512_mask_srav_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数右移 count 中相应元素指定的数量，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_srav_epi32.html" title="core::arch::x86::_mm512_mask_srav_epi32 fn">_mm512_mask_srav_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在将符号位移位的同时，将已包装的 32 位整数向右移动计数中相应元素指定的数量，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_srav_epi64.html" title="core::arch::x86::_mm512_mask_srav_epi64 fn">_mm512_mask_srav_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在移入符号位的同时，将包装的 64 位整数向右移动计数中相应元素指定的数量，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_srl_epi16.html" title="core::arch::x86::_mm512_mask_srl_epi16 fn">_mm512_mask_srl_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数右移，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_srl_epi32.html" title="core::arch::x86::_mm512_mask_srl_epi32 fn">_mm512_mask_srl_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 32 位整数右移，同时移零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_srl_epi64.html" title="core::arch::x86::_mm512_mask_srl_epi64 fn">_mm512_mask_srl_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 64 位整数右移，同时移零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_srli_epi16.html" title="core::arch::x86::_mm512_mask_srli_epi16 fn">_mm512_mask_srli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_srli_epi32.html" title="core::arch::x86::_mm512_mask_srli_epi32 fn">_mm512_mask_srli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 32 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_srli_epi64.html" title="core::arch::x86::_mm512_mask_srli_epi64 fn">_mm512_mask_srli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 64 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_srlv_epi16.html" title="core::arch::x86::_mm512_mask_srlv_epi16 fn">_mm512_mask_srlv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_srlv_epi32.html" title="core::arch::x86::_mm512_mask_srlv_epi32 fn">_mm512_mask_srlv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>向右移动包装的 32 位整数整数 (由 count 中相应元素指定的数量)，同时向零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_srlv_epi64.html" title="core::arch::x86::_mm512_mask_srlv_epi64 fn">_mm512_mask_srlv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>向右移位包装的 64 位整数，其数量为计数中相应元素指定的数量，同时向零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_sub_epi8.html" title="core::arch::x86::_mm512_mask_sub_epi8 fn">_mm512_mask_sub_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>从 a 中的包装 8 位整数中减去 b 中的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_sub_epi16.html" title="core::arch::x86::_mm512_mask_sub_epi16 fn">_mm512_mask_sub_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>从 a 中的包装的 16 位整数中减去 b 中的包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_sub_epi32.html" title="core::arch::x86::_mm512_mask_sub_epi32 fn">_mm512_mask_sub_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中的包装 32 位整数中减去 b 中的包装 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_sub_epi64.html" title="core::arch::x86::_mm512_mask_sub_epi64 fn">_mm512_mask_sub_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中的包装 64 位整数中减去 b 中的包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_sub_pd.html" title="core::arch::x86::_mm512_mask_sub_pd fn">_mm512_mask_sub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_sub_ps.html" title="core::arch::x86::_mm512_mask_sub_ps fn">_mm512_mask_sub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的包装后的单精度 (32-bit) 浮点元素减去 a 中的包装后的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_sub_round_pd.html" title="core::arch::x86::_mm512_mask_sub_round_pd fn">_mm512_mask_sub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_sub_round_ps.html" title="core::arch::x86::_mm512_mask_sub_round_ps fn">_mm512_mask_sub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的包装后的单精度 (32-bit) 浮点元素减去 a 中的包装后的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_subs_epi8.html" title="core::arch::x86::_mm512_mask_subs_epi8 fn">_mm512_mask_subs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用饱和度将 b 中的包装 8 位整数减去 b 中的包装 8 位有符号整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_subs_epi16.html" title="core::arch::x86::_mm512_mask_subs_epi16 fn">_mm512_mask_subs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用饱和度将 b 中的包装 16 位整数减去 b 中的包装有符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_subs_epu8.html" title="core::arch::x86::_mm512_mask_subs_epu8 fn">_mm512_mask_subs_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用 a 饱和度将 b 中的包装无符号 8 位整数减去 b 中的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_subs_epu16.html" title="core::arch::x86::_mm512_mask_subs_epu16 fn">_mm512_mask_subs_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用 a 饱和度从 b 中的包装无符号 16 位整数减去 b 中的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_ternarylogic_epi32.html" title="core::arch::x86::_mm512_mask_ternarylogic_epi32 fn">_mm512_mask_ternarylogic_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 32 位整数中的每一位，使用 src、a 和 b 中的相应位形成 imm8 的 3 位索引，并使用 writemask 将 imm8 中该位的值写入 dst 中的相应位 k 在 32 位粒度 (当相应的掩码位未设置时，从 src 复制 32 位元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_ternarylogic_epi64.html" title="core::arch::x86::_mm512_mask_ternarylogic_epi64 fn">_mm512_mask_ternarylogic_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 64 位整数中的每一位，src、a 和 b 中的相应位用于形成 imm8 的 3 位索引，并使用 writemask 将 imm8 中该位的值写入 dst 中的相应位 k 在 64 位粒度 (当相应的掩码位未设置时，从 src 复制 64 位元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_test_epi8_mask.html" title="core::arch::x86::_mm512_mask_test_epi8_mask fn">_mm512_mask_test_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 a 和 b 中包装的 8 位整数的按位与，生成中间 8 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_test_epi16_mask.html" title="core::arch::x86::_mm512_mask_test_epi16_mask fn">_mm512_mask_test_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 a 和 b 中包装的 16 位整数的按位与，生成中间的 16 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_test_epi32_mask.html" title="core::arch::x86::_mm512_mask_test_epi32_mask fn">_mm512_mask_test_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中包装的 32 位整数的按位与，生成中间的 32 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_test_epi64_mask.html" title="core::arch::x86::_mm512_mask_test_epi64_mask fn">_mm512_mask_test_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中包装的 64 位整数的按位与，生成中间 64 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_testn_epi8_mask.html" title="core::arch::x86::_mm512_mask_testn_epi8_mask fn">_mm512_mask_testn_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 a 和 b 中包装的 8 位整数的按位 NAND，生成中间的 8 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_testn_epi16_mask.html" title="core::arch::x86::_mm512_mask_testn_epi16_mask fn">_mm512_mask_testn_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 a 和 b 中包装的 16 位整数的按位 NAND，生成中间的 16 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_testn_epi32_mask.html" title="core::arch::x86::_mm512_mask_testn_epi32_mask fn">_mm512_mask_testn_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中包装的 32 位整数的按位 NAND，生成中间的 32 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_testn_epi64_mask.html" title="core::arch::x86::_mm512_mask_testn_epi64_mask fn">_mm512_mask_testn_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中包装的 64 位整数的按位 NAND，生成中间 64 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_unpackhi_epi8.html" title="core::arch::x86::_mm512_mask_unpackhi_epi8 fn">_mm512_mask_unpackhi_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>从 a 和 b 中每个 128 位通道的高半部分拆包和交织 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_unpackhi_epi16.html" title="core::arch::x86::_mm512_mask_unpackhi_epi16 fn">_mm512_mask_unpackhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>从 a 和 b 中每个 128 位通道的高半部分拆包和交织 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_unpackhi_epi32.html" title="core::arch::x86::_mm512_mask_unpackhi_epi32 fn">_mm512_mask_unpackhi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_unpackhi_epi64.html" title="core::arch::x86::_mm512_mask_unpackhi_epi64 fn">_mm512_mask_unpackhi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_unpackhi_pd.html" title="core::arch::x86::_mm512_mask_unpackhi_pd fn">_mm512_mask_unpackhi_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_unpackhi_ps.html" title="core::arch::x86::_mm512_mask_unpackhi_ps fn">_mm512_mask_unpackhi_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_unpacklo_epi8.html" title="core::arch::x86::_mm512_mask_unpacklo_epi8 fn">_mm512_mask_unpacklo_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>从 a 和 b 中每个 128 位通道的下半部分拆包和交织 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_unpacklo_epi16.html" title="core::arch::x86::_mm512_mask_unpacklo_epi16 fn">_mm512_mask_unpacklo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>从 a 和 b 中每个 128 位通道的下半部分拆包和交织 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_unpacklo_epi32.html" title="core::arch::x86::_mm512_mask_unpacklo_epi32 fn">_mm512_mask_unpacklo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包和交织 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_unpacklo_epi64.html" title="core::arch::x86::_mm512_mask_unpacklo_epi64 fn">_mm512_mask_unpacklo_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包和交织 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_unpacklo_pd.html" title="core::arch::x86::_mm512_mask_unpacklo_pd fn">_mm512_mask_unpacklo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包并交织双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_unpacklo_ps.html" title="core::arch::x86::_mm512_mask_unpacklo_ps fn">_mm512_mask_unpacklo_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包并交织单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_xor_epi32.html" title="core::arch::x86::_mm512_mask_xor_epi32 fn">_mm512_mask_xor_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中包装的 32 位整数的按位 XOR，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mask_xor_epi64.html" title="core::arch::x86::_mm512_mask_xor_epi64 fn">_mm512_mask_xor_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中包装的 64 位整数的按位 XOR，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_abs_epi8.html" title="core::arch::x86::_mm512_maskz_abs_epi8 fn">_mm512_maskz_abs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 a 中包装的带符号的 8 位整数的绝对值，并使用零掩码 k 将无符号结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_abs_epi16.html" title="core::arch::x86::_mm512_maskz_abs_epi16 fn">_mm512_maskz_abs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 a 中包装的带符号的 16 位整数的绝对值，并使用零掩码 k (将未设置相应掩码位的元素清零) 将无符号结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_abs_epi32.html" title="core::arch::x86::_mm512_maskz_abs_epi32 fn">_mm512_maskz_abs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 <code>a</code> 中包装的 32 位整数的绝对值，并使用零掩码 <code>k</code> 将无符号结果存储在 <code>dst</code> 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_abs_epi64.html" title="core::arch::x86::_mm512_maskz_abs_epi64 fn">_mm512_maskz_abs_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的带符号的 64 位整数的绝对值，并使用零掩码 k (将未设置相应掩码位的元素清零) 将无符号结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_add_epi8.html" title="core::arch::x86::_mm512_maskz_add_epi8 fn">_mm512_maskz_add_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>在 a 和 b 中添加包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_add_epi16.html" title="core::arch::x86::_mm512_maskz_add_epi16 fn">_mm512_maskz_add_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数添加到 a 和 b 中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_add_epi32.html" title="core::arch::x86::_mm512_maskz_add_epi32 fn">_mm512_maskz_add_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 32 位整数添加到 a 和 b 中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_add_epi64.html" title="core::arch::x86::_mm512_maskz_add_epi64 fn">_mm512_maskz_add_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_add_pd.html" title="core::arch::x86::_mm512_maskz_add_pd fn">_mm512_maskz_add_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_add_ps.html" title="core::arch::x86::_mm512_maskz_add_ps fn">_mm512_maskz_add_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_add_round_pd.html" title="core::arch::x86::_mm512_maskz_add_round_pd fn">_mm512_maskz_add_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_add_round_ps.html" title="core::arch::x86::_mm512_maskz_add_round_ps fn">_mm512_maskz_add_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_adds_epi8.html" title="core::arch::x86::_mm512_maskz_adds_epi8 fn">_mm512_maskz_adds_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用饱和度在 a 和 b 中添加包装的带符号的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_adds_epi16.html" title="core::arch::x86::_mm512_maskz_adds_epi16 fn">_mm512_maskz_adds_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用饱和度在 a 和 b 中添加包装的带符号的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_adds_epu8.html" title="core::arch::x86::_mm512_maskz_adds_epu8 fn">_mm512_maskz_adds_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用饱和度在 a 和 b 中添加包装的无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_adds_epu16.html" title="core::arch::x86::_mm512_maskz_adds_epu16 fn">_mm512_maskz_adds_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用饱和度在 a 和 b 中添加包装的无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_alignr_epi8.html" title="core::arch::x86::_mm512_maskz_alignr_epi8 fn">_mm512_maskz_alignr_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 和 b 中的 16 字节块对连接成一个 32 字节的临时结果，将结果右移 imm8 字节，并使用零掩码 k 将低 16 字节存储在 dst 中 (当未使用相应的掩码位时元素清零) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_alignr_epi32.html" title="core::arch::x86::_mm512_maskz_alignr_epi32 fn">_mm512_maskz_alignr_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 连接成一个 128 字节的立即结果，将结果右移 imm8 32 位元素，并使用零掩码 k 将低 64 字节 (16 个元素) 存储在 dst 中 (当未使用相应的掩码位时元素清零) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_alignr_epi64.html" title="core::arch::x86::_mm512_maskz_alignr_epi64 fn">_mm512_maskz_alignr_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 连接成一个 128 字节的立即结果，将结果右移 imm8 64 位元素，并使用零掩码 k 将低 64 字节 (8 个元素) 存储在 dst 中 (当未使用相应的掩码位时元素清零) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_and_epi32.html" title="core::arch::x86::_mm512_maskz_and_epi32 fn">_mm512_maskz_and_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中包装的 32 位整数的按位与，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_and_epi64.html" title="core::arch::x86::_mm512_maskz_and_epi64 fn">_mm512_maskz_and_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中包装的 64 位整数的按位与，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_andnot_epi32.html" title="core::arch::x86::_mm512_maskz_andnot_epi32 fn">_mm512_maskz_andnot_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的 32 位整数的按位 NOT，然后计算 b 中的 AND，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_andnot_epi64.html" title="core::arch::x86::_mm512_maskz_andnot_epi64 fn">_mm512_maskz_andnot_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的 64 位整数的按位 NOT，然后与 b 计算 AND，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_avg_epu8.html" title="core::arch::x86::_mm512_maskz_avg_epu8 fn">_mm512_maskz_avg_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 和 b 中包装的无符号 8 位整数进行平均，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_avg_epu16.html" title="core::arch::x86::_mm512_maskz_avg_epu16 fn">_mm512_maskz_avg_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 和 b 中包装的无符号 16 位整数进行平均，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_broadcast_f32x4.html" title="core::arch::x86::_mm512_maskz_broadcast_f32x4 fn">_mm512_maskz_broadcast_f32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用零掩码 k 将 4 个包装的单精度 (32-bit) 浮点元素从 a 广播到 dst 的所有元素 (未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_broadcast_f64x4.html" title="core::arch::x86::_mm512_maskz_broadcast_f64x4 fn">_mm512_maskz_broadcast_f64x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用零掩码 k 将 4 个包装的双精度 (64-bit) 浮点元素从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_broadcast_i32x4.html" title="core::arch::x86::_mm512_maskz_broadcast_i32x4 fn">_mm512_maskz_broadcast_i32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用零掩码 k 将 4 的包装的 32 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_broadcast_i64x4.html" title="core::arch::x86::_mm512_maskz_broadcast_i64x4 fn">_mm512_maskz_broadcast_i64x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用零掩码 k 将 4 个包装的 64 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_broadcastb_epi8.html" title="core::arch::x86::_mm512_maskz_broadcastb_epi8 fn">_mm512_maskz_broadcastb_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用零掩码 k 将低包装的 8 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_broadcastd_epi32.html" title="core::arch::x86::_mm512_maskz_broadcastd_epi32 fn">_mm512_maskz_broadcastd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用零掩码 k 将低包装的 32 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_broadcastq_epi64.html" title="core::arch::x86::_mm512_maskz_broadcastq_epi64 fn">_mm512_maskz_broadcastq_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用零掩码 k 将低包装的 64 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_broadcastsd_pd.html" title="core::arch::x86::_mm512_maskz_broadcastsd_pd fn">_mm512_maskz_broadcastsd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用零掩码 k 将低双精度 (64-bit) 浮点元素从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_broadcastss_ps.html" title="core::arch::x86::_mm512_maskz_broadcastss_ps fn">_mm512_maskz_broadcastss_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用零掩码 k 将低单精度 (32-bit) 浮点元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_broadcastw_epi16.html" title="core::arch::x86::_mm512_maskz_broadcastw_epi16 fn">_mm512_maskz_broadcastw_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用零掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_compress_epi8.html" title="core::arch::x86::_mm512_maskz_compress_epi8 fn">_mm512_maskz_compress_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>将 a 中的活动 8 位整数 (它们各自的位设置在 zeromask k 中) 连续存储到 dst，并将其余元素设置为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_compress_epi16.html" title="core::arch::x86::_mm512_maskz_compress_epi16 fn">_mm512_maskz_compress_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>将 a 中的活动 16 位整数 (它们各自的位设置在 zeromask k 中) 连续存储到 dst，并将其余元素设置为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_compress_epi32.html" title="core::arch::x86::_mm512_maskz_compress_epi32 fn">_mm512_maskz_compress_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将活动的 32 位整数连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的整数) 为 dst，并将其余元素设置为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_compress_epi64.html" title="core::arch::x86::_mm512_maskz_compress_epi64 fn">_mm512_maskz_compress_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将活动的 64 位整数连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的整数) 为 dst，并将其余元素设置为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_compress_pd.html" title="core::arch::x86::_mm512_maskz_compress_pd fn">_mm512_maskz_compress_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将活动的双精度 (64-bit) 浮点元素连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的那些元素) 为 dst，并将其余元素设置为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_compress_ps.html" title="core::arch::x86::_mm512_maskz_compress_ps fn">_mm512_maskz_compress_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将活动的单精度 (32-bit) 浮点元素连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的那些元素) 为 dst，并将其余元素设置为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_conflict_epi32.html" title="core::arch::x86::_mm512_maskz_conflict_epi32 fn">_mm512_maskz_conflict_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span><p>使用零掩码 k (在未设置相应的掩码位时将元素清零)，测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_conflict_epi64.html" title="core::arch::x86::_mm512_maskz_conflict_epi64 fn">_mm512_maskz_conflict_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span><p>使用零掩码 k (在未设置相应的掩码位时将元素清零)，测试 a 的每个 64 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvt_roundepi32_ps.html" title="core::arch::x86::_mm512_maskz_cvt_roundepi32_ps fn">_mm512_maskz_cvt_roundepi32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装有符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用零掩码 k (未设置相应的掩码位时将元素清零) 将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvt_roundepu32_ps.html" title="core::arch::x86::_mm512_maskz_cvt_roundepu32_ps fn">_mm512_maskz_cvt_roundepu32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvt_roundpd_epi32.html" title="core::arch::x86::_mm512_maskz_cvt_roundpd_epi32 fn">_mm512_maskz_cvt_roundpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvt_roundpd_epu32.html" title="core::arch::x86::_mm512_maskz_cvt_roundpd_epu32 fn">_mm512_maskz_cvt_roundpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvt_roundpd_ps.html" title="core::arch::x86::_mm512_maskz_cvt_roundpd_ps fn">_mm512_maskz_cvt_roundpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvt_roundph_ps.html" title="core::arch::x86::_mm512_maskz_cvt_roundph_ps fn">_mm512_maskz_cvt_roundph_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装后的半精度 (16-bit) 浮点元素转换为包装后的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvt_roundps_epi32.html" title="core::arch::x86::_mm512_maskz_cvt_roundps_epi32 fn">_mm512_maskz_cvt_roundps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvt_roundps_epu32.html" title="core::arch::x86::_mm512_maskz_cvt_roundps_epu32 fn">_mm512_maskz_cvt_roundps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvt_roundps_pd.html" title="core::arch::x86::_mm512_maskz_cvt_roundps_pd fn">_mm512_maskz_cvt_roundps_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvt_roundps_ph.html" title="core::arch::x86::_mm512_maskz_cvt_roundps_ph fn">_mm512_maskz_cvt_roundps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtepi8_epi16.html" title="core::arch::x86::_mm512_maskz_cvtepi8_epi16 fn">_mm512_maskz_cvtepi8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用符号将包装的 8 位整数从 a 扩展为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtepi8_epi32.html" title="core::arch::x86::_mm512_maskz_cvtepi8_epi32 fn">_mm512_maskz_cvtepi8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用符号将包装的 8 位整数从 a 扩展为包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtepi8_epi64.html" title="core::arch::x86::_mm512_maskz_cvtepi8_epi64 fn">_mm512_maskz_cvtepi8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>符号将 a 的低 8 个字节中的包装 8 位整数扩展为包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtepi16_epi8.html" title="core::arch::x86::_mm512_maskz_cvtepi16_epi8 fn">_mm512_maskz_cvtepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将带有 a 的包装的 16 位整数转换为带截断的 8 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtepi16_epi32.html" title="core::arch::x86::_mm512_maskz_cvtepi16_epi32 fn">_mm512_maskz_cvtepi16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>符号将包装的 16 位整数从 a 扩展为包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtepi16_epi64.html" title="core::arch::x86::_mm512_maskz_cvtepi16_epi64 fn">_mm512_maskz_cvtepi16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用符号将包装的 16 位整数从 a 扩展为包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtepi32_epi8.html" title="core::arch::x86::_mm512_maskz_cvtepi32_epi8 fn">_mm512_maskz_cvtepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将带有 a 的包装的 32 位整数转换为带有截断的包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtepi32_epi16.html" title="core::arch::x86::_mm512_maskz_cvtepi32_epi16 fn">_mm512_maskz_cvtepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtepi32_epi64.html" title="core::arch::x86::_mm512_maskz_cvtepi32_epi64 fn">_mm512_maskz_cvtepi32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用符号将包装的 32 位整数从 a 扩展为包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtepi32_pd.html" title="core::arch::x86::_mm512_maskz_cvtepi32_pd fn">_mm512_maskz_cvtepi32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装有符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtepi32_ps.html" title="core::arch::x86::_mm512_maskz_cvtepi32_ps fn">_mm512_maskz_cvtepi32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装有符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用零掩码 k (未设置相应的掩码位时将元素清零) 将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtepi64_epi8.html" title="core::arch::x86::_mm512_maskz_cvtepi64_epi8 fn">_mm512_maskz_cvtepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将带有 a 的包装的 64 位整数转换为带截断的 8 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtepi64_epi16.html" title="core::arch::x86::_mm512_maskz_cvtepi64_epi16 fn">_mm512_maskz_cvtepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将带有 a 的包装的 64 位整数转换为带截断的 16 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtepi64_epi32.html" title="core::arch::x86::_mm512_maskz_cvtepi64_epi32 fn">_mm512_maskz_cvtepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的 64 位整数转换为带截断的 32 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtepu8_epi16.html" title="core::arch::x86::_mm512_maskz_cvtepu8_epi16 fn">_mm512_maskz_cvtepu8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 中的包装无符号 8 位整数零扩展为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtepu8_epi32.html" title="core::arch::x86::_mm512_maskz_cvtepu8_epi32 fn">_mm512_maskz_cvtepu8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 8 位整数零扩展为包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtepu8_epi64.html" title="core::arch::x86::_mm512_maskz_cvtepu8_epi64 fn">_mm512_maskz_cvtepu8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 的低 8 个字节中的包装无符号 8 位整数零扩展为包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtepu16_epi32.html" title="core::arch::x86::_mm512_maskz_cvtepu16_epi32 fn">_mm512_maskz_cvtepu16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 16 位整数零扩展为包装 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtepu16_epi64.html" title="core::arch::x86::_mm512_maskz_cvtepu16_epi64 fn">_mm512_maskz_cvtepu16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 16 位整数零扩展为包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtepu32_epi64.html" title="core::arch::x86::_mm512_maskz_cvtepu32_epi64 fn">_mm512_maskz_cvtepu32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 32 位整数零扩展为包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtepu32_pd.html" title="core::arch::x86::_mm512_maskz_cvtepu32_pd fn">_mm512_maskz_cvtepu32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtepu32_ps.html" title="core::arch::x86::_mm512_maskz_cvtepu32_ps fn">_mm512_maskz_cvtepu32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtne2ps_pbh.html" title="core::arch::x86::_mm512_maskz_cvtne2ps_pbh fn">_mm512_maskz_cvtne2ps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512f` only"><code>avx512bf16,avx512f</code></span><p>将两个 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在单个 vector dst 中 (当对应的掩码位不存在时，元素归零放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtneps_pbh.html" title="core::arch::x86::_mm512_maskz_cvtneps_pbh fn">_mm512_maskz_cvtneps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512f` only"><code>avx512bf16,avx512f</code></span><p>将包装的单精度 (32-bit) 浮点元素在 a 中转换为包装的 BF16 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtpd_epi32.html" title="core::arch::x86::_mm512_maskz_cvtpd_epi32 fn">_mm512_maskz_cvtpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtpd_epu32.html" title="core::arch::x86::_mm512_maskz_cvtpd_epu32 fn">_mm512_maskz_cvtpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtpd_ps.html" title="core::arch::x86::_mm512_maskz_cvtpd_ps fn">_mm512_maskz_cvtpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtph_ps.html" title="core::arch::x86::_mm512_maskz_cvtph_ps fn">_mm512_maskz_cvtph_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装后的半精度 (16-bit) 浮点元素转换为包装后的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtps_epi32.html" title="core::arch::x86::_mm512_maskz_cvtps_epi32 fn">_mm512_maskz_cvtps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtps_epu32.html" title="core::arch::x86::_mm512_maskz_cvtps_epu32 fn">_mm512_maskz_cvtps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtps_pd.html" title="core::arch::x86::_mm512_maskz_cvtps_pd fn">_mm512_maskz_cvtps_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtps_ph.html" title="core::arch::x86::_mm512_maskz_cvtps_ph fn">_mm512_maskz_cvtps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtsepi16_epi8.html" title="core::arch::x86::_mm512_maskz_cvtsepi16_epi8 fn">_mm512_maskz_cvtsepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 中的包装有符号 16 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtsepi32_epi8.html" title="core::arch::x86::_mm512_maskz_cvtsepi32_epi8 fn">_mm512_maskz_cvtsepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtsepi32_epi16.html" title="core::arch::x86::_mm512_maskz_cvtsepi32_epi16 fn">_mm512_maskz_cvtsepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtsepi64_epi8.html" title="core::arch::x86::_mm512_maskz_cvtsepi64_epi8 fn">_mm512_maskz_cvtsepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装有符号 64 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtsepi64_epi16.html" title="core::arch::x86::_mm512_maskz_cvtsepi64_epi16 fn">_mm512_maskz_cvtsepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtsepi64_epi32.html" title="core::arch::x86::_mm512_maskz_cvtsepi64_epi32 fn">_mm512_maskz_cvtsepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtt_roundpd_epi32.html" title="core::arch::x86::_mm512_maskz_cvtt_roundpd_epi32 fn">_mm512_maskz_cvtt_roundpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将带有 a 的包装的单精度 (32-bit) 浮点元素转换为带有截断的包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtt_roundpd_epu32.html" title="core::arch::x86::_mm512_maskz_cvtt_roundpd_epu32 fn">_mm512_maskz_cvtt_roundpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtt_roundps_epi32.html" title="core::arch::x86::_mm512_maskz_cvtt_roundps_epi32 fn">_mm512_maskz_cvtt_roundps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将带有 a 的包装的单精度 (32-bit) 浮点元素转换为带有截断的包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtt_roundps_epu32.html" title="core::arch::x86::_mm512_maskz_cvtt_roundps_epu32 fn">_mm512_maskz_cvtt_roundps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素转换为带有截断的包装无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvttpd_epi32.html" title="core::arch::x86::_mm512_maskz_cvttpd_epi32 fn">_mm512_maskz_cvttpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvttpd_epu32.html" title="core::arch::x86::_mm512_maskz_cvttpd_epu32 fn">_mm512_maskz_cvttpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvttps_epi32.html" title="core::arch::x86::_mm512_maskz_cvttps_epi32 fn">_mm512_maskz_cvttps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将带有 a 的包装的单精度 (32-bit) 浮点元素转换为带有截断的包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvttps_epu32.html" title="core::arch::x86::_mm512_maskz_cvttps_epu32 fn">_mm512_maskz_cvttps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtusepi16_epi8.html" title="core::arch::x86::_mm512_maskz_cvtusepi16_epi8 fn">_mm512_maskz_cvtusepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtusepi32_epi8.html" title="core::arch::x86::_mm512_maskz_cvtusepi32_epi8 fn">_mm512_maskz_cvtusepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtusepi32_epi16.html" title="core::arch::x86::_mm512_maskz_cvtusepi32_epi16 fn">_mm512_maskz_cvtusepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtusepi64_epi8.html" title="core::arch::x86::_mm512_maskz_cvtusepi64_epi8 fn">_mm512_maskz_cvtusepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtusepi64_epi16.html" title="core::arch::x86::_mm512_maskz_cvtusepi64_epi16 fn">_mm512_maskz_cvtusepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_cvtusepi64_epi32.html" title="core::arch::x86::_mm512_maskz_cvtusepi64_epi32 fn">_mm512_maskz_cvtusepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_dbsad_epu8.html" title="core::arch::x86::_mm512_maskz_dbsad_epu8 fn">_mm512_maskz_dbsad_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 a 中与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs) 的总和，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将 16 位结果存储在 dst 中。对于每个 64 位通道，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中通道的低 8 位四元组，而后两个 SAD 使用 a 中通道的较高 8 位四元组。根据 imm8 中的控件，从 128 位通道中选择 b 中的四元组，并且每个 64 位通道中的每个 SAD 使用 8 位偏移量的选定四元组。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_div_pd.html" title="core::arch::x86::_mm512_maskz_div_pd fn">_mm512_maskz_div_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_div_ps.html" title="core::arch::x86::_mm512_maskz_div_ps fn">_mm512_maskz_div_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素除以 b 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_div_round_pd.html" title="core::arch::x86::_mm512_maskz_div_round_pd fn">_mm512_maskz_div_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_div_round_ps.html" title="core::arch::x86::_mm512_maskz_div_round_ps fn">_mm512_maskz_div_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素除以 b 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_dpbf16_ps.html" title="core::arch::x86::_mm512_maskz_dpbf16_ps fn">_mm512_maskz_dpbf16_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512f` only"><code>avx512bf16,avx512f</code></span><p>计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间单精度 (32-bit) 浮点元素与 src 中的元素进行累加，并将结果存储在 dst 中使用 zeromask k (当对应的掩码为位未设置)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_dpbusd_epi32.html" title="core::arch::x86::_mm512_maskz_dpbusd_epi32 fn">_mm512_maskz_dpbusd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni` only"><code>avx512vnni</code></span><p>将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果使用 zeromask k 存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_dpbusds_epi32.html" title="core::arch::x86::_mm512_maskz_dpbusds_epi32 fn">_mm512_maskz_dpbusds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni` only"><code>avx512vnni</code></span><p>将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数用带符号饱和求和，并将包装的 32 位结果用 zeromask k 存储在 dst 中 (当对应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_dpwssd_epi32.html" title="core::arch::x86::_mm512_maskz_dpwssd_epi32 fn">_mm512_maskz_dpwssd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni` only"><code>avx512vnni</code></span><p>将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中对应的 32 位整数相加，并使用 zeromask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_dpwssds_epi32.html" title="core::arch::x86::_mm512_maskz_dpwssds_epi32 fn">_mm512_maskz_dpwssds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni` only"><code>avx512vnni</code></span><p>将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并使用 zeromask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_expand_epi8.html" title="core::arch::x86::_mm512_maskz_expand_epi8 fn">_mm512_maskz_expand_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>从 a 加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_expand_epi16.html" title="core::arch::x86::_mm512_maskz_expand_epi16 fn">_mm512_maskz_expand_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>从 a 加载连续的活动 16 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_expand_epi32.html" title="core::arch::x86::_mm512_maskz_expand_epi32 fn">_mm512_maskz_expand_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中加载连续的有效 32 位整数 (它们各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_expand_epi64.html" title="core::arch::x86::_mm512_maskz_expand_epi64 fn">_mm512_maskz_expand_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中加载连续的有效 64 位整数 (它们各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_expand_pd.html" title="core::arch::x86::_mm512_maskz_expand_pd fn">_mm512_maskz_expand_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中加载连续的活动双精度 (64-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_expand_ps.html" title="core::arch::x86::_mm512_maskz_expand_ps fn">_mm512_maskz_expand_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中加载连续的活动单精度 (32-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_extractf32x4_ps.html" title="core::arch::x86::_mm512_maskz_extractf32x4_ps fn">_mm512_maskz_extractf32x4_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 提取 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并用 imm8 进行选择，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_extractf64x4_pd.html" title="core::arch::x86::_mm512_maskz_extractf64x4_pd fn">_mm512_maskz_extractf64x4_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 提取 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成)，并用 imm8 进行选择，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_extracti32x4_epi32.html" title="core::arch::x86::_mm512_maskz_extracti32x4_epi32 fn">_mm512_maskz_extracti32x4_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中提取 128 位 (由 4 个包装的 32 位整数组成)，用 IMM2 选择，结果用 zeromask k 存储在 dst 中 (当相应的掩码位未设置时，元素归零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_extracti64x4_epi64.html" title="core::arch::x86::_mm512_maskz_extracti64x4_epi64 fn">_mm512_maskz_extracti64x4_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中提取 256 位 (由 4 个包装的 64 位整数组成)，用 IMM1 选择，结果用 zeromask k 存储在 dst 中 (当相应的掩码位未设置时，元素归零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fixupimm_pd.html" title="core::arch::x86::_mm512_maskz_fixupimm_pd fn">_mm512_maskz_fixupimm_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 c 中的包装 64 位整数修复 a 和 b 中的包装双精度 (64-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fixupimm_ps.html" title="core::arch::x86::_mm512_maskz_fixupimm_ps fn">_mm512_maskz_fixupimm_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 c 中的包装 32 位整数修复 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fixupimm_round_pd.html" title="core::arch::x86::_mm512_maskz_fixupimm_round_pd fn">_mm512_maskz_fixupimm_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 c 中的包装 64 位整数修复 a 和 b 中的包装双精度 (64-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fixupimm_round_ps.html" title="core::arch::x86::_mm512_maskz_fixupimm_round_ps fn">_mm512_maskz_fixupimm_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 c 中的包装 32 位整数修复 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fmadd_pd.html" title="core::arch::x86::_mm512_maskz_fmadd_pd fn">_mm512_maskz_fmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fmadd_ps.html" title="core::arch::x86::_mm512_maskz_fmadd_ps fn">_mm512_maskz_fmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fmadd_round_pd.html" title="core::arch::x86::_mm512_maskz_fmadd_round_pd fn">_mm512_maskz_fmadd_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fmadd_round_ps.html" title="core::arch::x86::_mm512_maskz_fmadd_round_ps fn">_mm512_maskz_fmadd_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并将结果存储在使用零掩码 k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fmaddsub_pd.html" title="core::arch::x86::_mm512_maskz_fmaddsub_pd fn">_mm512_maskz_fmaddsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或减去，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fmaddsub_ps.html" title="core::arch::x86::_mm512_maskz_fmaddsub_ps fn">_mm512_maskz_fmaddsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fmaddsub_round_pd.html" title="core::arch::x86::_mm512_maskz_fmaddsub_round_pd fn">_mm512_maskz_fmaddsub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或减去，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fmaddsub_round_ps.html" title="core::arch::x86::_mm512_maskz_fmaddsub_round_ps fn">_mm512_maskz_fmaddsub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fmsub_pd.html" title="core::arch::x86::_mm512_maskz_fmsub_pd fn">_mm512_maskz_fmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fmsub_ps.html" title="core::arch::x86::_mm512_maskz_fmsub_ps fn">_mm512_maskz_fmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fmsub_round_pd.html" title="core::arch::x86::_mm512_maskz_fmsub_round_pd fn">_mm512_maskz_fmsub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fmsub_round_ps.html" title="core::arch::x86::_mm512_maskz_fmsub_round_ps fn">_mm512_maskz_fmsub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fmsubadd_pd.html" title="core::arch::x86::_mm512_maskz_fmsubadd_pd fn">_mm512_maskz_fmsubadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或减去，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fmsubadd_ps.html" title="core::arch::x86::_mm512_maskz_fmsubadd_ps fn">_mm512_maskz_fmsubadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，或者将 C from/to 中的包装元素相减并相加，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fmsubadd_round_pd.html" title="core::arch::x86::_mm512_maskz_fmsubadd_round_pd fn">_mm512_maskz_fmsubadd_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或减去，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fmsubadd_round_ps.html" title="core::arch::x86::_mm512_maskz_fmsubadd_round_ps fn">_mm512_maskz_fmsubadd_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，或者将 C from/to 中的包装元素相减并相加，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fnmadd_pd.html" title="core::arch::x86::_mm512_maskz_fnmadd_pd fn">_mm512_maskz_fnmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fnmadd_ps.html" title="core::arch::x86::_mm512_maskz_fnmadd_ps fn">_mm512_maskz_fnmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fnmadd_round_pd.html" title="core::arch::x86::_mm512_maskz_fnmadd_round_pd fn">_mm512_maskz_fnmadd_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fnmadd_round_ps.html" title="core::arch::x86::_mm512_maskz_fnmadd_round_ps fn">_mm512_maskz_fnmadd_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fnmsub_pd.html" title="core::arch::x86::_mm512_maskz_fnmsub_pd fn">_mm512_maskz_fnmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fnmsub_ps.html" title="core::arch::x86::_mm512_maskz_fnmsub_ps fn">_mm512_maskz_fnmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fnmsub_round_pd.html" title="core::arch::x86::_mm512_maskz_fnmsub_round_pd fn">_mm512_maskz_fnmsub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_fnmsub_round_ps.html" title="core::arch::x86::_mm512_maskz_fnmsub_round_ps fn">_mm512_maskz_fnmsub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_getexp_pd.html" title="core::arch::x86::_mm512_maskz_getexp_pd fn">_mm512_maskz_getexp_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并使用 zeromask k 将结果存储在 dst 中 (当相应的 mask 位为零时，元素被清零未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_getexp_ps.html" title="core::arch::x86::_mm512_maskz_getexp_ps fn">_mm512_maskz_getexp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为代表整数指数的单精度 (32-bit) 浮点数，并使用 zeromask k 将结果存储在 dst 中 (当相应的 mask 位为零时，元素被清零未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_getexp_round_pd.html" title="core::arch::x86::_mm512_maskz_getexp_round_pd fn">_mm512_maskz_getexp_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并使用 zeromask k 将结果存储在 dst 中 (当相应的 mask 位为零时，元素被清零未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_getexp_round_ps.html" title="core::arch::x86::_mm512_maskz_getexp_round_ps fn">_mm512_maskz_getexp_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为代表整数指数的单精度 (32-bit) 浮点数，并使用 zeromask k 将结果存储在 dst 中 (当相应的 mask 位为零时，元素被清零未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_getmant_pd.html" title="core::arch::x86::_mm512_maskz_getmant_pd fn">_mm512_maskz_getmant_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素的尾数标准化，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_getmant_ps.html" title="core::arch::x86::_mm512_maskz_getmant_ps fn">_mm512_maskz_getmant_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素的尾数规格化，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_getmant_round_pd.html" title="core::arch::x86::_mm512_maskz_getmant_round_pd fn">_mm512_maskz_getmant_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素的尾数标准化，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_getmant_round_ps.html" title="core::arch::x86::_mm512_maskz_getmant_round_ps fn">_mm512_maskz_getmant_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素的尾数规格化，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_gf2p8affine_epi64_epi8.html" title="core::arch::x86::_mm512_maskz_gf2p8affine_epi64_epi8 fn">_mm512_maskz_gf2p8affine_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512f` only"><code>avx512gfni,avx512bw,avx512f</code></span><p>对 x 中的包装字节执行仿射变换。
也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_gf2p8affineinv_epi64_epi8.html" title="core::arch::x86::_mm512_maskz_gf2p8affineinv_epi64_epi8 fn">_mm512_maskz_gf2p8affineinv_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512f` only"><code>avx512gfni,avx512bw,avx512f</code></span><p>对 x 中的反向包装的字节执行仿射变换。
也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_gf2p8mul_epi8.html" title="core::arch::x86::_mm512_maskz_gf2p8mul_epi8 fn">_mm512_maskz_gf2p8mul_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512f` only"><code>avx512gfni,avx512bw,avx512f</code></span><p>在包装的字节上执行 GF(2^8) 乘法。
该字段以多项式表示，具有约数多项式 x^8 + x^4 + x^3 + x + 1。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_insertf32x4.html" title="core::arch::x86::_mm512_maskz_insertf32x4 fn">_mm512_maskz_insertf32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 复制到 tmp，然后在 x00X 指定的位置将 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成) 插入 tmp。使用 zeromask k 将 tmp 存储到 dst (当未设置相应的掩码位时，元素会被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_insertf64x4.html" title="core::arch::x86::_mm512_maskz_insertf64x4 fn">_mm512_maskz_insertf64x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 复制到 tmp，然后在 x00X 指定的位置将 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成) 插入 tmp。使用 zeromask k 将 tmp 存储到 dst (当未设置相应的掩码位时，元素会被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_inserti32x4.html" title="core::arch::x86::_mm512_maskz_inserti32x4 fn">_mm512_maskz_inserti32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 复制到 tmp，然后在 imm8 指定的位置，将 b 中的 128 位 (由 4 个包装的 32 位整数组成) 插入 tmp。使用 zeromask k 将 tmp 存储到 dst (当未设置相应的掩码位时，元素会被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_inserti64x4.html" title="core::arch::x86::_mm512_maskz_inserti64x4 fn">_mm512_maskz_inserti64x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 复制到 tmp，然后在 imm8 指定的位置将 b 的 256 位 (由 4 个包装的 64 位整数组成) 插入 tmp。使用 zeromask k 将 tmp 存储到 dst (当未设置相应的掩码位时，元素会被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_lzcnt_epi32.html" title="core::arch::x86::_mm512_maskz_lzcnt_epi32 fn">_mm512_maskz_lzcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span><p>计算 a 中每个包装的 32 位整数中前导零位的数目，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_lzcnt_epi64.html" title="core::arch::x86::_mm512_maskz_lzcnt_epi64 fn">_mm512_maskz_lzcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd` only"><code>avx512cd</code></span><p>计算 a 中每个包装的 64 位整数中前导零位的数目，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_madd_epi16.html" title="core::arch::x86::_mm512_maskz_madd_epi16 fn">_mm512_maskz_madd_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。水平添加相邻的中间 32 位整数对，并使用 zeromask k 将结果打包到 dst (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_maddubs_epi16.html" title="core::arch::x86::_mm512_maskz_maddubs_epi16 fn">_mm512_maskz_maddubs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 中的包装无符号 8 位整数与 b 中的包装有符号 8 位整数相乘，生成中间有符号的 16 位整数。水平添加相邻的中间有符号 16 位整数对，并使用 zeromask k 将饱和结果打包到 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_max_epi8.html" title="core::arch::x86::_mm512_maskz_max_epi8 fn">_mm512_maskz_max_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_max_epi16.html" title="core::arch::x86::_mm512_maskz_max_epi16 fn">_mm512_maskz_max_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_max_epi32.html" title="core::arch::x86::_mm512_maskz_max_epi32 fn">_mm512_maskz_max_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_max_epi64.html" title="core::arch::x86::_mm512_maskz_max_epi64 fn">_mm512_maskz_max_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_max_epu8.html" title="core::arch::x86::_mm512_maskz_max_epu8 fn">_mm512_maskz_max_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 8 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_max_epu16.html" title="core::arch::x86::_mm512_maskz_max_epu16 fn">_mm512_maskz_max_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_max_epu32.html" title="core::arch::x86::_mm512_maskz_max_epu32 fn">_mm512_maskz_max_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 32 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_max_epu64.html" title="core::arch::x86::_mm512_maskz_max_epu64 fn">_mm512_maskz_max_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_max_pd.html" title="core::arch::x86::_mm512_maskz_max_pd fn">_mm512_maskz_max_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_max_ps.html" title="core::arch::x86::_mm512_maskz_max_ps fn">_mm512_maskz_max_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_max_round_pd.html" title="core::arch::x86::_mm512_maskz_max_round_pd fn">_mm512_maskz_max_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_max_round_ps.html" title="core::arch::x86::_mm512_maskz_max_round_ps fn">_mm512_maskz_max_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_min_epi8.html" title="core::arch::x86::_mm512_maskz_min_epi8 fn">_mm512_maskz_min_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_min_epi16.html" title="core::arch::x86::_mm512_maskz_min_epi16 fn">_mm512_maskz_min_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_min_epi32.html" title="core::arch::x86::_mm512_maskz_min_epi32 fn">_mm512_maskz_min_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号 32 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_min_epi64.html" title="core::arch::x86::_mm512_maskz_min_epi64 fn">_mm512_maskz_min_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_min_epu8.html" title="core::arch::x86::_mm512_maskz_min_epu8 fn">_mm512_maskz_min_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 8 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_min_epu16.html" title="core::arch::x86::_mm512_maskz_min_epu16 fn">_mm512_maskz_min_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_min_epu32.html" title="core::arch::x86::_mm512_maskz_min_epu32 fn">_mm512_maskz_min_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 32 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_min_epu64.html" title="core::arch::x86::_mm512_maskz_min_epu64 fn">_mm512_maskz_min_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_min_pd.html" title="core::arch::x86::_mm512_maskz_min_pd fn">_mm512_maskz_min_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_min_ps.html" title="core::arch::x86::_mm512_maskz_min_ps fn">_mm512_maskz_min_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_min_round_pd.html" title="core::arch::x86::_mm512_maskz_min_round_pd fn">_mm512_maskz_min_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_min_round_ps.html" title="core::arch::x86::_mm512_maskz_min_round_ps fn">_mm512_maskz_min_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_mov_epi8.html" title="core::arch::x86::_mm512_maskz_mov_epi8 fn">_mm512_maskz_mov_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用零掩码 k 将包装的 8 位整数从 a 移到 dst (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_mov_epi16.html" title="core::arch::x86::_mm512_maskz_mov_epi16 fn">_mm512_maskz_mov_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用零掩码 k 将包装的 16 位整数从 a 移到 dst (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_mov_epi32.html" title="core::arch::x86::_mm512_maskz_mov_epi32 fn">_mm512_maskz_mov_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用零掩码 k 将包装的 32 位整数从 a 移至 dst (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_mov_epi64.html" title="core::arch::x86::_mm512_maskz_mov_epi64 fn">_mm512_maskz_mov_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用零掩码 k 将包装的 64 位整数从 a 移到 dst (未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_mov_pd.html" title="core::arch::x86::_mm512_maskz_mov_pd fn">_mm512_maskz_mov_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用零掩码 k 将包装的双精度 (64-bit) 浮点元素从 a 移到 dst (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_mov_ps.html" title="core::arch::x86::_mm512_maskz_mov_ps fn">_mm512_maskz_mov_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用零掩码 k 将包装的单精度 (32-bit) 浮点元素从 a 移到 dst (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_movedup_pd.html" title="core::arch::x86::_mm512_maskz_movedup_pd fn">_mm512_maskz_movedup_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 复制偶数索引的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_movehdup_ps.html" title="core::arch::x86::_mm512_maskz_movehdup_ps fn">_mm512_maskz_movehdup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 复制奇数索引的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_moveldup_ps.html" title="core::arch::x86::_mm512_maskz_moveldup_ps fn">_mm512_maskz_moveldup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 复制偶数索引的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_mul_epi32.html" title="core::arch::x86::_mm512_maskz_mul_epi32 fn">_mm512_maskz_mul_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中每个包装的 64 位元素的低位有符号 32 位整数相乘，并使用零掩码 k 将有符号的 64 位结果存储在 dst 中 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_mul_epu32.html" title="core::arch::x86::_mm512_maskz_mul_epu32 fn">_mm512_maskz_mul_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中每个包装的 64 位元素的低无符号 32 位整数相乘，并使用零掩码 k 将无符号 64 位结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_mul_pd.html" title="core::arch::x86::_mm512_maskz_mul_pd fn">_mm512_maskz_mul_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_mul_ps.html" title="core::arch::x86::_mm512_maskz_mul_ps fn">_mm512_maskz_mul_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_mul_round_pd.html" title="core::arch::x86::_mm512_maskz_mul_round_pd fn">_mm512_maskz_mul_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_mul_round_ps.html" title="core::arch::x86::_mm512_maskz_mul_round_ps fn">_mm512_maskz_mul_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_mulhi_epi16.html" title="core::arch::x86::_mm512_maskz_mulhi_epi16 fn">_mm512_maskz_mulhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 和 b 中包装的带符号的 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_mulhi_epu16.html" title="core::arch::x86::_mm512_maskz_mulhi_epu16 fn">_mm512_maskz_mulhi_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 和 b 中包装的无符号 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_mulhrs_epi16.html" title="core::arch::x86::_mm512_maskz_mulhrs_epi16 fn">_mm512_maskz_mulhrs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。将每个中间整数截断为 18 个最高有效位，通过加 1 舍入，并使用 zeromask k 将位 [16:1] 存储到 dst (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_mullo_epi16.html" title="core::arch::x86::_mm512_maskz_mullo_epi16 fn">_mm512_maskz_mullo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 和 b 中的包装的 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的低 16 位存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_mullo_epi32.html" title="core::arch::x86::_mm512_maskz_mullo_epi32 fn">_mm512_maskz_mullo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的 32 位整数相乘，生成中间 64 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将中间整数的低 32 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_multishift_epi64_epi8.html" title="core::arch::x86::_mm512_maskz_multishift_epi64_epi8 fn">_mm512_maskz_multishift_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi` only"><code>avx512vbmi</code></span><p>对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并使用 zeromask k (元素当相应的屏蔽位未设置时被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_or_epi32.html" title="core::arch::x86::_mm512_maskz_or_epi32 fn">_mm512_maskz_or_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中包装的 32 位整数的按位或，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_or_epi64.html" title="core::arch::x86::_mm512_maskz_or_epi64 fn">_mm512_maskz_or_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中包装的 64 位整数的按位或，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_packs_epi16.html" title="core::arch::x86::_mm512_maskz_packs_epi16 fn">_mm512_maskz_packs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用带符号的饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_packs_epi32.html" title="core::arch::x86::_mm512_maskz_packs_epi32 fn">_mm512_maskz_packs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用带符号的饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_packus_epi16.html" title="core::arch::x86::_mm512_maskz_packus_epi16 fn">_mm512_maskz_packus_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用无符号饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_packus_epi32.html" title="core::arch::x86::_mm512_maskz_packus_epi32 fn">_mm512_maskz_packus_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用无符号饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_permute_pd.html" title="core::arch::x86::_mm512_maskz_permute_pd fn">_mm512_maskz_permute_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 imm8 中的控件在 128 位通道内对双精度 (64-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_permute_ps.html" title="core::arch::x86::_mm512_maskz_permute_ps fn">_mm512_maskz_permute_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_permutevar_pd.html" title="core::arch::x86::_mm512_maskz_permutevar_pd fn">_mm512_maskz_permutevar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的控件在 128 位通道内将 a 中的双精度 (64-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_permutevar_ps.html" title="core::arch::x86::_mm512_maskz_permutevar_ps fn">_mm512_maskz_permutevar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的控件在 128 位通道内将 a 的单精度 (32-bit) 浮点元素打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_permutex2var_epi8.html" title="core::arch::x86::_mm512_maskz_permutex2var_epi8 fn">_mm512_maskz_permutex2var_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi` only"><code>avx512vbmi</code></span><p>使用 idx 中的相应选择器和索引将 a 和 b 中的 8 位整数跨通道打乱，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_permutex2var_epi16.html" title="core::arch::x86::_mm512_maskz_permutex2var_epi16 fn">_mm512_maskz_permutex2var_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用相应的选择器和 idx 中的索引在通道中的 a 和 b 中对 16 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_permutex2var_epi32.html" title="core::arch::x86::_mm512_maskz_permutex2var_epi32 fn">_mm512_maskz_permutex2var_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中对 32 位整数进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_permutex2var_epi64.html" title="core::arch::x86::_mm512_maskz_permutex2var_epi64 fn">_mm512_maskz_permutex2var_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中对 64 位整数进行混洗，并使用 zeromask k (未设置相应的 mask 位时将元素清零) 将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_permutex2var_pd.html" title="core::arch::x86::_mm512_maskz_permutex2var_pd fn">_mm512_maskz_permutex2var_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用对应的选择器和 idx 中的索引在通道中的通道 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_permutex2var_ps.html" title="core::arch::x86::_mm512_maskz_permutex2var_ps fn">_mm512_maskz_permutex2var_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对单精度 (32-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_permutex_epi64.html" title="core::arch::x86::_mm512_maskz_permutex_epi64 fn">_mm512_maskz_permutex_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 imm8 中的控件在 256 位通道内将 64 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_permutex_pd.html" title="core::arch::x86::_mm512_maskz_permutex_pd fn">_mm512_maskz_permutex_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 imm8 中的控件在 256 位通道内将双精度 (64-bit) 浮点元素打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_permutexvar_epi8.html" title="core::arch::x86::_mm512_maskz_permutexvar_epi8 fn">_mm512_maskz_permutexvar_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi` only"><code>avx512vbmi</code></span><p>使用 idx 中的相应索引在跨通道的 a 中打乱 8 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_permutexvar_epi16.html" title="core::arch::x86::_mm512_maskz_permutexvar_epi16 fn">_mm512_maskz_permutexvar_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用 idx 中的相应索引在跨通道中对 16 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_permutexvar_epi32.html" title="core::arch::x86::_mm512_maskz_permutexvar_epi32 fn">_mm512_maskz_permutexvar_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 idx 中的相应索引在跨通道中对 32 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_permutexvar_epi64.html" title="core::arch::x86::_mm512_maskz_permutexvar_epi64 fn">_mm512_maskz_permutexvar_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 idx 中的相应索引在跨通道中对 64 位整数进行打乱，并使用零掩码 k (未设置相应的掩码位时将元素清零) 将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_permutexvar_pd.html" title="core::arch::x86::_mm512_maskz_permutexvar_pd fn">_mm512_maskz_permutexvar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 idx 中的相应索引在跨通道中对双精度 (64-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_permutexvar_ps.html" title="core::arch::x86::_mm512_maskz_permutexvar_ps fn">_mm512_maskz_permutexvar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 idx 中的相应索引在跨通道中对单精度 (32-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_popcnt_epi8.html" title="core::arch::x86::_mm512_maskz_popcnt_epi8 fn">_mm512_maskz_popcnt_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg` only"><code>avx512bitalg</code></span><p>对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_popcnt_epi16.html" title="core::arch::x86::_mm512_maskz_popcnt_epi16 fn">_mm512_maskz_popcnt_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg` only"><code>avx512bitalg</code></span><p>对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_popcnt_epi32.html" title="core::arch::x86::_mm512_maskz_popcnt_epi32 fn">_mm512_maskz_popcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq` only"><code>avx512vpopcntdq</code></span><p>对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_popcnt_epi64.html" title="core::arch::x86::_mm512_maskz_popcnt_epi64 fn">_mm512_maskz_popcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq` only"><code>avx512vpopcntdq</code></span><p>对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_rcp14_pd.html" title="core::arch::x86::_mm512_maskz_rcp14_pd fn">_mm512_maskz_rcp14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_rcp14_ps.html" title="core::arch::x86::_mm512_maskz_rcp14_ps fn">_mm512_maskz_rcp14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_rol_epi32.html" title="core::arch::x86::_mm512_maskz_rol_epi32 fn">_mm512_maskz_rol_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_rol_epi64.html" title="core::arch::x86::_mm512_maskz_rol_epi64 fn">_mm512_maskz_rol_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_rolv_epi32.html" title="core::arch::x86::_mm512_maskz_rolv_epi32 fn">_mm512_maskz_rolv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中每个包装的 32 位整数中的位向左旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_rolv_epi64.html" title="core::arch::x86::_mm512_maskz_rolv_epi64 fn">_mm512_maskz_rolv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中每个包装的 64 位整数中的位向左旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_ror_epi32.html" title="core::arch::x86::_mm512_maskz_ror_epi32 fn">_mm512_maskz_ror_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 X 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_ror_epi64.html" title="core::arch::x86::_mm512_maskz_ror_epi64 fn">_mm512_maskz_ror_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 X 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_rorv_epi32.html" title="core::arch::x86::_mm512_maskz_rorv_epi32 fn">_mm512_maskz_rorv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中每个包装的 32 位整数中的位向右旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_rorv_epi64.html" title="core::arch::x86::_mm512_maskz_rorv_epi64 fn">_mm512_maskz_rorv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_roundscale_pd.html" title="core::arch::x86::_mm512_maskz_roundscale_pd fn">_mm512_maskz_roundscale_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 x 中的包装双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_roundscale_ps.html" title="core::arch::x86::_mm512_maskz_roundscale_ps fn">_mm512_maskz_roundscale_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_roundscale_round_pd.html" title="core::arch::x86::_mm512_maskz_roundscale_round_pd fn">_mm512_maskz_roundscale_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 x 中的包装双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_roundscale_round_ps.html" title="core::arch::x86::_mm512_maskz_roundscale_round_ps fn">_mm512_maskz_roundscale_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_rsqrt14_pd.html" title="core::arch::x86::_mm512_maskz_rsqrt14_pd fn">_mm512_maskz_rsqrt14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中的包装的双精度 (64-bit) 浮点元素的近似倒数平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_rsqrt14_ps.html" title="core::arch::x86::_mm512_maskz_rsqrt14_ps fn">_mm512_maskz_rsqrt14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_scalef_pd.html" title="core::arch::x86::_mm512_maskz_scalef_pd fn">_mm512_maskz_scalef_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_scalef_ps.html" title="core::arch::x86::_mm512_maskz_scalef_ps fn">_mm512_maskz_scalef_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_scalef_round_pd.html" title="core::arch::x86::_mm512_maskz_scalef_round_pd fn">_mm512_maskz_scalef_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_scalef_round_ps.html" title="core::arch::x86::_mm512_maskz_scalef_round_ps fn">_mm512_maskz_scalef_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_set1_epi8.html" title="core::arch::x86::_mm512_maskz_set1_epi8 fn">_mm512_maskz_set1_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用零掩码 k 将 8 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_set1_epi16.html" title="core::arch::x86::_mm512_maskz_set1_epi16 fn">_mm512_maskz_set1_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用零掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_set1_epi32.html" title="core::arch::x86::_mm512_maskz_set1_epi32 fn">_mm512_maskz_set1_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用零掩码 k 将 32 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_set1_epi64.html" title="core::arch::x86::_mm512_maskz_set1_epi64 fn">_mm512_maskz_set1_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用零掩码 k 将 64 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_shldi_epi16.html" title="core::arch::x86::_mm512_maskz_shldi_epi16 fn">_mm512_maskz_shldi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_shldi_epi32.html" title="core::arch::x86::_mm512_maskz_shldi_epi32 fn">_mm512_maskz_shldi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_shldi_epi64.html" title="core::arch::x86::_mm512_maskz_shldi_epi64 fn">_mm512_maskz_shldi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_shldv_epi16.html" title="core::arch::x86::_mm512_maskz_shldv_epi16 fn">_mm512_maskz_shldv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_shldv_epi32.html" title="core::arch::x86::_mm512_maskz_shldv_epi32 fn">_mm512_maskz_shldv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_shldv_epi64.html" title="core::arch::x86::_mm512_maskz_shldv_epi64 fn">_mm512_maskz_shldv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_shrdi_epi16.html" title="core::arch::x86::_mm512_maskz_shrdi_epi16 fn">_mm512_maskz_shrdi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_shrdi_epi32.html" title="core::arch::x86::_mm512_maskz_shrdi_epi32 fn">_mm512_maskz_shrdi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_shrdi_epi64.html" title="core::arch::x86::_mm512_maskz_shrdi_epi64 fn">_mm512_maskz_shrdi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_shrdv_epi16.html" title="core::arch::x86::_mm512_maskz_shrdv_epi16 fn">_mm512_maskz_shrdv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_shrdv_epi32.html" title="core::arch::x86::_mm512_maskz_shrdv_epi32 fn">_mm512_maskz_shrdv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_shrdv_epi64.html" title="core::arch::x86::_mm512_maskz_shrdv_epi64 fn">_mm512_maskz_shrdv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_shuffle_epi8.html" title="core::arch::x86::_mm512_maskz_shuffle_epi8 fn">_mm512_maskz_shuffle_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>根据 b 的相应 8 位元素中的打乱控制掩码对 a 中的包装 8 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_shuffle_epi32.html" title="core::arch::x86::_mm512_maskz_shuffle_epi32 fn">_mm512_maskz_shuffle_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 imm8 中的控件在 128 位通道中的 32 位整数中混洗 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_shuffle_f32x4.html" title="core::arch::x86::_mm512_maskz_shuffle_f32x4 fn">_mm512_maskz_shuffle_f32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 imm8 从 a 和 b 中选择的 128 位 (由 4 个单精度 (32-bit) 浮点元素组成) 混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_shuffle_f64x2.html" title="core::arch::x86::_mm512_maskz_shuffle_f64x2 fn">_mm512_maskz_shuffle_f64x2</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 imm8 从 a 和 b 中选择的 128 位 (由 2 个双精度 (64-bit) 浮点元素组成) 混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_shuffle_i32x4.html" title="core::arch::x86::_mm512_maskz_shuffle_i32x4 fn">_mm512_maskz_shuffle_i32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 imm8 从 a 和 b 中选择的 128 位 (由 4 个 32 位整数组成) 混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_shuffle_i64x2.html" title="core::arch::x86::_mm512_maskz_shuffle_i64x2 fn">_mm512_maskz_shuffle_i64x2</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 imm8 从 a 和 b 中选择的 128 位 (由 2 个 64 位整数组成) 混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_shuffle_pd.html" title="core::arch::x86::_mm512_maskz_shuffle_pd fn">_mm512_maskz_shuffle_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 imm8 中的控件对 128 位通道内的双精度 (64-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_shuffle_ps.html" title="core::arch::x86::_mm512_maskz_shuffle_ps fn">_mm512_maskz_shuffle_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_shufflehi_epi16.html" title="core::arch::x86::_mm512_maskz_shufflehi_epi16 fn">_mm512_maskz_shufflehi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用 imm8 中的控件在 a 的 128 位通道的高 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的高 64 位中，将 128 位通道的低 64 位从 a 复制到 dst，使用 zeromask k (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_shufflelo_epi16.html" title="core::arch::x86::_mm512_maskz_shufflelo_epi16 fn">_mm512_maskz_shufflelo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用 imm8 中的控件在 a 的 128 位通道的低 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的低 64 位中，128 位通道的高 64 位从 a 复制到 dst，使用 zeromask k (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_sll_epi16.html" title="core::arch::x86::_mm512_maskz_sll_epi16 fn">_mm512_maskz_sll_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数按计数左移，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_sll_epi32.html" title="core::arch::x86::_mm512_maskz_sll_epi32 fn">_mm512_maskz_sll_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 32 位整数左移计数，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_sll_epi64.html" title="core::arch::x86::_mm512_maskz_sll_epi64 fn">_mm512_maskz_sll_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将填充的 64 位整数左移计数，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_slli_epi16.html" title="core::arch::x86::_mm512_maskz_slli_epi16 fn">_mm512_maskz_slli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_slli_epi32.html" title="core::arch::x86::_mm512_maskz_slli_epi32 fn">_mm512_maskz_slli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 32 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_slli_epi64.html" title="core::arch::x86::_mm512_maskz_slli_epi64 fn">_mm512_maskz_slli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 64 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_sllv_epi16.html" title="core::arch::x86::_mm512_maskz_sllv_epi16 fn">_mm512_maskz_sllv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数左移由 count 中的相应元素指定的数量，同时移入零，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_sllv_epi32.html" title="core::arch::x86::_mm512_maskz_sllv_epi32 fn">_mm512_maskz_sllv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在将移位的 32 位整数左移零时，将其对应计数指定的数量左移，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_sllv_epi64.html" title="core::arch::x86::_mm512_maskz_sllv_epi64 fn">_mm512_maskz_sllv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在将移位的 64 位整数左移零时，将其对应计数指定的数量左移，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_sqrt_pd.html" title="core::arch::x86::_mm512_maskz_sqrt_pd fn">_mm512_maskz_sqrt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并使用零掩码 k (将结果置零，当未设置相应的掩码位时将元素清零) 将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_sqrt_ps.html" title="core::arch::x86::_mm512_maskz_sqrt_ps fn">_mm512_maskz_sqrt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_sqrt_round_pd.html" title="core::arch::x86::_mm512_maskz_sqrt_round_pd fn">_mm512_maskz_sqrt_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并使用零掩码 k (将结果置零，当未设置相应的掩码位时将元素清零) 将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_sqrt_round_ps.html" title="core::arch::x86::_mm512_maskz_sqrt_round_ps fn">_mm512_maskz_sqrt_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_sra_epi16.html" title="core::arch::x86::_mm512_maskz_sra_epi16 fn">_mm512_maskz_sra_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数按计数右移，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_sra_epi32.html" title="core::arch::x86::_mm512_maskz_sra_epi32 fn">_mm512_maskz_sra_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在移动符号位的同时右移计数包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_sra_epi64.html" title="core::arch::x86::_mm512_maskz_sra_epi64 fn">_mm512_maskz_sra_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在移动符号位的同时右移计数包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_srai_epi16.html" title="core::arch::x86::_mm512_maskz_srai_epi16 fn">_mm512_maskz_srai_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_srai_epi32.html" title="core::arch::x86::_mm512_maskz_srai_epi32 fn">_mm512_maskz_srai_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 32 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_srai_epi64.html" title="core::arch::x86::_mm512_maskz_srai_epi64 fn">_mm512_maskz_srai_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 64 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_srav_epi16.html" title="core::arch::x86::_mm512_maskz_srav_epi16 fn">_mm512_maskz_srav_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数右移由 count 中的相应元素指定的数量，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_srav_epi32.html" title="core::arch::x86::_mm512_maskz_srav_epi32 fn">_mm512_maskz_srav_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在将符号位移位的同时，将已包装的 32 位整数向右移动计数中相应元素指定的数量，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_srav_epi64.html" title="core::arch::x86::_mm512_maskz_srav_epi64 fn">_mm512_maskz_srav_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在移入符号位的同时，将包装的 64 位整数右移由 count 中相应元素指定的数量，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_srl_epi16.html" title="core::arch::x86::_mm512_maskz_srl_epi16 fn">_mm512_maskz_srl_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数右移，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_srl_epi32.html" title="core::arch::x86::_mm512_maskz_srl_epi32 fn">_mm512_maskz_srl_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将移位的 32 位整数右移，同时移零，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_srl_epi64.html" title="core::arch::x86::_mm512_maskz_srl_epi64 fn">_mm512_maskz_srl_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 64 位整数右移计数，同时移入零，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_srli_epi16.html" title="core::arch::x86::_mm512_maskz_srli_epi16 fn">_mm512_maskz_srli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_srli_epi32.html" title="core::arch::x86::_mm512_maskz_srli_epi32 fn">_mm512_maskz_srli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 32 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_srli_epi64.html" title="core::arch::x86::_mm512_maskz_srli_epi64 fn">_mm512_maskz_srli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 64 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_srlv_epi16.html" title="core::arch::x86::_mm512_maskz_srlv_epi16 fn">_mm512_maskz_srlv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_srlv_epi32.html" title="core::arch::x86::_mm512_maskz_srlv_epi32 fn">_mm512_maskz_srlv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>向右移动已包装的 32 位整数，偏移量为相应元素在计数中指定的数量，同时向零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_srlv_epi64.html" title="core::arch::x86::_mm512_maskz_srlv_epi64 fn">_mm512_maskz_srlv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>向右移位包装的 64 位整数，其数量为计数中相应元素指定的数量，同时移位为零，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_sub_epi8.html" title="core::arch::x86::_mm512_maskz_sub_epi8 fn">_mm512_maskz_sub_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>从 a 中的包装 8 位整数中减去 b 中的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_sub_epi16.html" title="core::arch::x86::_mm512_maskz_sub_epi16 fn">_mm512_maskz_sub_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>从 a 中的包装的 16 位整数中减去 b 中的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_sub_epi32.html" title="core::arch::x86::_mm512_maskz_sub_epi32 fn">_mm512_maskz_sub_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中的包装 32 位整数中减去 b 中的包装 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_sub_epi64.html" title="core::arch::x86::_mm512_maskz_sub_epi64 fn">_mm512_maskz_sub_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中的包装 64 位整数中减去 b 中的包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_sub_pd.html" title="core::arch::x86::_mm512_maskz_sub_pd fn">_mm512_maskz_sub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_sub_ps.html" title="core::arch::x86::_mm512_maskz_sub_ps fn">_mm512_maskz_sub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的包装后的单精度 (32-bit) 浮点元素减去 a 中的包装后的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_sub_round_pd.html" title="core::arch::x86::_mm512_maskz_sub_round_pd fn">_mm512_maskz_sub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_sub_round_ps.html" title="core::arch::x86::_mm512_maskz_sub_round_ps fn">_mm512_maskz_sub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的包装后的单精度 (32-bit) 浮点元素减去 a 中的包装后的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_subs_epi8.html" title="core::arch::x86::_mm512_maskz_subs_epi8 fn">_mm512_maskz_subs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用饱和度从包装的 8 位整数中减去 b 中的包装有符号的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_subs_epi16.html" title="core::arch::x86::_mm512_maskz_subs_epi16 fn">_mm512_maskz_subs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用饱和度将 b 中的包装 16 位整数减去 b 中的包装有符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_subs_epu8.html" title="core::arch::x86::_mm512_maskz_subs_epu8 fn">_mm512_maskz_subs_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用 a 饱和度从 b 中的包装无符号 8 位整数减去 b 中的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_subs_epu16.html" title="core::arch::x86::_mm512_maskz_subs_epu16 fn">_mm512_maskz_subs_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用 a 饱和度将 b 中的包装无符号 16 位整数减去 b 中的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_ternarylogic_epi32.html" title="core::arch::x86::_mm512_maskz_ternarylogic_epi32 fn">_mm512_maskz_ternarylogic_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 32 位整数中的每一位，来自 a、b 和 c 的相应位用于形成 imm8 的 3 位索引，并使用零掩码将 imm8 中该位的值写入 dst 中的相应位 k 在 32 位粒度 (当未设置相应的掩码位时，32 位元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_ternarylogic_epi64.html" title="core::arch::x86::_mm512_maskz_ternarylogic_epi64 fn">_mm512_maskz_ternarylogic_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 64 位整数中的每一位，来自 a、b 和 c 的相应位用于在 imm8 中形成 3 位索引，并使用零掩码将 imm8 中该位的值写入 dst 中的相应位 k 在 64 位粒度 (当未设置相应的掩码位时，64 位元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_unpackhi_epi8.html" title="core::arch::x86::_mm512_maskz_unpackhi_epi8 fn">_mm512_maskz_unpackhi_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>从 a 和 b 中每个 128 位通道的高半部分拆包和交织 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_unpackhi_epi16.html" title="core::arch::x86::_mm512_maskz_unpackhi_epi16 fn">_mm512_maskz_unpackhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>从 a 和 b 中每个 128 位通道的高半部分拆包和交织 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_unpackhi_epi32.html" title="core::arch::x86::_mm512_maskz_unpackhi_epi32 fn">_mm512_maskz_unpackhi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_unpackhi_epi64.html" title="core::arch::x86::_mm512_maskz_unpackhi_epi64 fn">_mm512_maskz_unpackhi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_unpackhi_pd.html" title="core::arch::x86::_mm512_maskz_unpackhi_pd fn">_mm512_maskz_unpackhi_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_unpackhi_ps.html" title="core::arch::x86::_mm512_maskz_unpackhi_ps fn">_mm512_maskz_unpackhi_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_unpacklo_epi8.html" title="core::arch::x86::_mm512_maskz_unpacklo_epi8 fn">_mm512_maskz_unpacklo_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>从 a 和 b 中每个 128 位通道的下半部分拆包和交织 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_unpacklo_epi16.html" title="core::arch::x86::_mm512_maskz_unpacklo_epi16 fn">_mm512_maskz_unpacklo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>从 a 和 b 中每个 128 位通道的下半部分拆包和交织 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_unpacklo_epi32.html" title="core::arch::x86::_mm512_maskz_unpacklo_epi32 fn">_mm512_maskz_unpacklo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包和交织 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_unpacklo_epi64.html" title="core::arch::x86::_mm512_maskz_unpacklo_epi64 fn">_mm512_maskz_unpacklo_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包和交织 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_unpacklo_pd.html" title="core::arch::x86::_mm512_maskz_unpacklo_pd fn">_mm512_maskz_unpacklo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包和交织双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_unpacklo_ps.html" title="core::arch::x86::_mm512_maskz_unpacklo_ps fn">_mm512_maskz_unpacklo_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包和交织单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_xor_epi32.html" title="core::arch::x86::_mm512_maskz_xor_epi32 fn">_mm512_maskz_xor_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中包装的 32 位整数的按位 XOR，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_maskz_xor_epi64.html" title="core::arch::x86::_mm512_maskz_xor_epi64 fn">_mm512_maskz_xor_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中包装的 64 位整数的按位 XOR，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_max_epi8.html" title="core::arch::x86::_mm512_max_epi8 fn">_mm512_max_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数，并将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_max_epi16.html" title="core::arch::x86::_mm512_max_epi16 fn">_mm512_max_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数，并将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_max_epi32.html" title="core::arch::x86::_mm512_max_epi32 fn">_mm512_max_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号 32 位整数，并将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_max_epi64.html" title="core::arch::x86::_mm512_max_epi64 fn">_mm512_max_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数，并将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_max_epu8.html" title="core::arch::x86::_mm512_max_epu8 fn">_mm512_max_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 8 位整数，并将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_max_epu16.html" title="core::arch::x86::_mm512_max_epu16 fn">_mm512_max_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 16 位整数，并将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_max_epu32.html" title="core::arch::x86::_mm512_max_epu32 fn">_mm512_max_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 32 位整数，并将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_max_epu64.html" title="core::arch::x86::_mm512_max_epu64 fn">_mm512_max_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 64 位整数，并将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_max_pd.html" title="core::arch::x86::_mm512_max_pd fn">_mm512_max_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，并将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_max_ps.html" title="core::arch::x86::_mm512_max_ps fn">_mm512_max_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_max_round_pd.html" title="core::arch::x86::_mm512_max_round_pd fn">_mm512_max_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，并将包装的最大值存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_max_round_ps.html" title="core::arch::x86::_mm512_max_round_ps fn">_mm512_max_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并将包装的最大值存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_min_epi8.html" title="core::arch::x86::_mm512_min_epi8 fn">_mm512_min_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数，并将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_min_epi16.html" title="core::arch::x86::_mm512_min_epi16 fn">_mm512_min_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数，并将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_min_epi32.html" title="core::arch::x86::_mm512_min_epi32 fn">_mm512_min_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号 32 位整数，并将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_min_epi64.html" title="core::arch::x86::_mm512_min_epi64 fn">_mm512_min_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数，并将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_min_epu8.html" title="core::arch::x86::_mm512_min_epu8 fn">_mm512_min_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 8 位整数，并将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_min_epu16.html" title="core::arch::x86::_mm512_min_epu16 fn">_mm512_min_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>比较 a 和 b 中包装的无符号 16 位整数，并将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_min_epu32.html" title="core::arch::x86::_mm512_min_epu32 fn">_mm512_min_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 32 位整数，并将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_min_epu64.html" title="core::arch::x86::_mm512_min_epu64 fn">_mm512_min_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的无符号 64 位整数，并将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_min_pd.html" title="core::arch::x86::_mm512_min_pd fn">_mm512_min_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，并将包装的最小值存储在 dst 中。
比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，并将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_min_ps.html" title="core::arch::x86::_mm512_min_ps fn">_mm512_min_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_min_round_pd.html" title="core::arch::x86::_mm512_min_round_pd fn">_mm512_min_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，并将包装的最小值存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_min_round_ps.html" title="core::arch::x86::_mm512_min_round_ps fn">_mm512_min_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并将包装的最小值存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_movedup_pd.html" title="core::arch::x86::_mm512_movedup_pd fn">_mm512_movedup_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 复制偶数索引的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_movehdup_ps.html" title="core::arch::x86::_mm512_movehdup_ps fn">_mm512_movehdup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 复制奇数索引的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_moveldup_ps.html" title="core::arch::x86::_mm512_moveldup_ps fn">_mm512_moveldup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 复制偶数索引的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_movepi8_mask.html" title="core::arch::x86::_mm512_movepi8_mask fn">_mm512_movepi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>根据 a 中相应包装的 8 位整数的最高有效位设置掩码寄存器 k 的每个位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_movepi16_mask.html" title="core::arch::x86::_mm512_movepi16_mask fn">_mm512_movepi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>根据 a 中相应的包装的 16 位整数的最高有效位设置掩码寄存器 k 的每一位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_movm_epi8.html" title="core::arch::x86::_mm512_movm_epi8 fn">_mm512_movm_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>根据 k 中相应位的值，将 dst 中每个包装的 8 位整数设置为全 1 或全 0。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_movm_epi16.html" title="core::arch::x86::_mm512_movm_epi16 fn">_mm512_movm_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>根据 k 中相应位的值，将 dst 中每个包装的 16 位整数设置为全 1 或全 0。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mul_epi32.html" title="core::arch::x86::_mm512_mul_epi32 fn">_mm512_mul_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中每个包装的 64 位元素的低符号 32 位整数相乘，并将带符号的 64 位结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mul_epu32.html" title="core::arch::x86::_mm512_mul_epu32 fn">_mm512_mul_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中每个包装的 64 位元素的低无符号 32 位整数相乘，并将无符号 64 位结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mul_pd.html" title="core::arch::x86::_mm512_mul_pd fn">_mm512_mul_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mul_ps.html" title="core::arch::x86::_mm512_mul_ps fn">_mm512_mul_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mul_round_pd.html" title="core::arch::x86::_mm512_mul_round_pd fn">_mm512_mul_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mul_round_ps.html" title="core::arch::x86::_mm512_mul_round_ps fn">_mm512_mul_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mulhi_epi16.html" title="core::arch::x86::_mm512_mulhi_epi16 fn">_mm512_mulhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的带符号的 16 位整数与 a 和 b 相乘，生成中间的 32 位整数，并将中间整数的高 16 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mulhi_epu16.html" title="core::arch::x86::_mm512_mulhi_epu16 fn">_mm512_mulhi_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的无符号 16 位整数与 a 和 b 相乘，生成中间的 32 位整数，并将中间整数的高 16 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mulhrs_epi16.html" title="core::arch::x86::_mm512_mulhrs_epi16 fn">_mm512_mulhrs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。将每个中间整数截断为 18 个最高有效位，加 1 舍入，然后将 [16: 1] 位存储到 dst。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mullo_epi16.html" title="core::arch::x86::_mm512_mullo_epi16 fn">_mm512_mullo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 和 b 中的包装的 16 位整数相乘，生成中间的 32 位整数，并将中间整数的低 16 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mullo_epi32.html" title="core::arch::x86::_mm512_mullo_epi32 fn">_mm512_mullo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的包装的 32 位整数相乘，生成中间 64 位整数，并将中间整数的低 32 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_mullox_epi64.html" title="core::arch::x86::_mm512_mullox_epi64 fn">_mm512_mullox_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 64 位整数 vectors a 和 b 中的元素相乘，将结果的低 64 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_multishift_epi64_epi8.html" title="core::arch::x86::_mm512_multishift_epi64_epi8 fn">_mm512_multishift_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi` only"><code>avx512vbmi</code></span><p>对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并将 8 个组装字节存储到 dst 的相应 64 位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_or_epi32.html" title="core::arch::x86::_mm512_or_epi32 fn">_mm512_or_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中包装的 32 位整数的按位或，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_or_epi64.html" title="core::arch::x86::_mm512_or_epi64 fn">_mm512_or_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中包装的 64 位整数的按位或，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_or_si512.html" title="core::arch::x86::_mm512_or_si512 fn">_mm512_or_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中 512 位 (代表整数数据) 的按位或，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_packs_epi16.html" title="core::arch::x86::_mm512_packs_epi16 fn">_mm512_packs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用带符号的饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_packs_epi32.html" title="core::arch::x86::_mm512_packs_epi32 fn">_mm512_packs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用带符号的饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_packus_epi16.html" title="core::arch::x86::_mm512_packus_epi16 fn">_mm512_packus_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用无符号饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_packus_epi32.html" title="core::arch::x86::_mm512_packus_epi32 fn">_mm512_packus_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用无符号饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_permute_pd.html" title="core::arch::x86::_mm512_permute_pd fn">_mm512_permute_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 imm8 中的控件在 128 位通道内对双精度 (64-bit) 浮点元素进行打乱，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_permute_ps.html" title="core::arch::x86::_mm512_permute_ps fn">_mm512_permute_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_permutevar_epi32.html" title="core::arch::x86::_mm512_permutevar_epi32 fn">_mm512_permutevar_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 idx 中的相应索引在跨通道中随机排列 32 位整数，并将结果存储在 dst 中。请注意，与使用 permutevar 名称的过去内联函数不同，该内联函数在 128 位通道上进行了重排。此内部函数与 _mm512_permutexvar_epi32 相同，建议您使用该内部函数名称。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_permutevar_pd.html" title="core::arch::x86::_mm512_permutevar_pd fn">_mm512_permutevar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的控件在 128 位通道内将 a 双精度 (64-bit) 浮点元素进行打乱，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_permutevar_ps.html" title="core::arch::x86::_mm512_permutevar_ps fn">_mm512_permutevar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的控件在 128 位通道内将 a 单精度 (32-bit) 浮点元素进行打乱，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_permutex2var_epi8.html" title="core::arch::x86::_mm512_permutex2var_epi8 fn">_mm512_permutex2var_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi` only"><code>avx512vbmi</code></span><p>使用 idx 中的相应选择器和索引将 a 和 b 中的 8 位整数跨通道打乱，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_permutex2var_epi16.html" title="core::arch::x86::_mm512_permutex2var_epi16 fn">_mm512_permutex2var_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中对 16 位整数进行打乱，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_permutex2var_epi32.html" title="core::arch::x86::_mm512_permutex2var_epi32 fn">_mm512_permutex2var_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中随机排列 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_permutex2var_epi64.html" title="core::arch::x86::_mm512_permutex2var_epi64 fn">_mm512_permutex2var_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 idx 中的相应选择器和索引在通道中的 a 和 b 中随机排列 64 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_permutex2var_pd.html" title="core::arch::x86::_mm512_permutex2var_pd fn">_mm512_permutex2var_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_permutex2var_ps.html" title="core::arch::x86::_mm512_permutex2var_ps fn">_mm512_permutex2var_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对单精度 (32-bit) 浮点元素进行混洗，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_permutex_epi64.html" title="core::arch::x86::_mm512_permutex_epi64 fn">_mm512_permutex_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 imm8 中的控件在 256 位通道中的 a 内随机排列 64 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_permutex_pd.html" title="core::arch::x86::_mm512_permutex_pd fn">_mm512_permutex_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 imm8 中的控件在 256 位通道内对双精度 (64-bit) 浮点元素进行打乱，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_permutexvar_epi8.html" title="core::arch::x86::_mm512_permutexvar_epi8 fn">_mm512_permutexvar_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi` only"><code>avx512vbmi</code></span><p>使用 idx 中的相应索引将 a 中的 8 位整数打乱到通道中，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_permutexvar_epi16.html" title="core::arch::x86::_mm512_permutexvar_epi16 fn">_mm512_permutexvar_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用 idx 中的相应索引在跨通道中对 16 位整数进行打乱，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_permutexvar_epi32.html" title="core::arch::x86::_mm512_permutexvar_epi32 fn">_mm512_permutexvar_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 idx 中的相应索引在跨通道中随机排列 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_permutexvar_epi64.html" title="core::arch::x86::_mm512_permutexvar_epi64 fn">_mm512_permutexvar_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 idx 中的相应索引在跨通道中随机排列 64 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_permutexvar_pd.html" title="core::arch::x86::_mm512_permutexvar_pd fn">_mm512_permutexvar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 idx 中的相应索引在跨通道中对双精度 (64-bit) 浮点元素进行混洗，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_permutexvar_ps.html" title="core::arch::x86::_mm512_permutexvar_ps fn">_mm512_permutexvar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 idx 中的相应索引对跨通道中的单精度 (32-bit) 浮点元素进行打乱。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_popcnt_epi8.html" title="core::arch::x86::_mm512_popcnt_epi8 fn">_mm512_popcnt_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg` only"><code>avx512bitalg</code></span><p>对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_popcnt_epi16.html" title="core::arch::x86::_mm512_popcnt_epi16 fn">_mm512_popcnt_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg` only"><code>avx512bitalg</code></span><p>对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_popcnt_epi32.html" title="core::arch::x86::_mm512_popcnt_epi32 fn">_mm512_popcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq` only"><code>avx512vpopcntdq</code></span><p>对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_popcnt_epi64.html" title="core::arch::x86::_mm512_popcnt_epi64 fn">_mm512_popcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq` only"><code>avx512vpopcntdq</code></span><p>对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_rcp14_pd.html" title="core::arch::x86::_mm512_rcp14_pd fn">_mm512_rcp14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并将结果存储在 dst 中。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_rcp14_ps.html" title="core::arch::x86::_mm512_rcp14_ps fn">_mm512_rcp14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并将结果存储在 dst 中。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_reduce_add_epi32.html" title="core::arch::x86::_mm512_reduce_add_epi32 fn">_mm512_reduce_add_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>通过加法减少包装的 32 位整数。返回 a 中所有元素的总和。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_reduce_add_epi64.html" title="core::arch::x86::_mm512_reduce_add_epi64 fn">_mm512_reduce_add_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>通过加法减少包装的 64 位整数。返回 a 中所有元素的总和。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_reduce_add_pd.html" title="core::arch::x86::_mm512_reduce_add_pd fn">_mm512_reduce_add_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>另外，还减少了包装的双精度 (64-bit) 浮点元素。返回 a 中所有元素的总和。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_reduce_add_ps.html" title="core::arch::x86::_mm512_reduce_add_ps fn">_mm512_reduce_add_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>此外，还减少了包装的单精度 (32-bit) 浮点元素。返回 a 中所有元素的总和。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_reduce_and_epi32.html" title="core::arch::x86::_mm512_reduce_and_epi32 fn">_mm512_reduce_and_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>通过按位 AND 减少包装的 32 位整数。返回 a 中所有元素的按位与。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_reduce_and_epi64.html" title="core::arch::x86::_mm512_reduce_and_epi64 fn">_mm512_reduce_and_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>通过按位 AND 减少包装的 64 位整数。返回 a 中所有元素的按位与。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_reduce_max_epi32.html" title="core::arch::x86::_mm512_reduce_max_epi32 fn">_mm512_reduce_max_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>最多减少包装的带符号 32 位整数。返回 a 中所有元素的最大值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_reduce_max_epi64.html" title="core::arch::x86::_mm512_reduce_max_epi64 fn">_mm512_reduce_max_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>最大减少包装的带符号的 64 位整数。返回 a 中所有元素的最大值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_reduce_max_epu32.html" title="core::arch::x86::_mm512_reduce_max_epu32 fn">_mm512_reduce_max_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>最多减少包装的无符号 32 位整数。返回 a 中所有元素的最大值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_reduce_max_epu64.html" title="core::arch::x86::_mm512_reduce_max_epu64 fn">_mm512_reduce_max_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>最多减少包装的无符号 64 位整数。返回 a 中所有元素的最大值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_reduce_max_pd.html" title="core::arch::x86::_mm512_reduce_max_pd fn">_mm512_reduce_max_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>最大减少包装的双精度 (64-bit) 浮点元素。返回 a 中所有元素的最大值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_reduce_max_ps.html" title="core::arch::x86::_mm512_reduce_max_ps fn">_mm512_reduce_max_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>最大减少包装的单精度 (32-bit) 浮点元素。返回 a 中所有元素的最大值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_reduce_min_epi32.html" title="core::arch::x86::_mm512_reduce_min_epi32 fn">_mm512_reduce_min_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的有符号的 32 位整数减少到最小值。返回 a 中所有元素的最小值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_reduce_min_epi64.html" title="core::arch::x86::_mm512_reduce_min_epi64 fn">_mm512_reduce_min_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将一个包装的有符号 64 位整数减少到最小值。返回 a 中所有元素的最小值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_reduce_min_epu32.html" title="core::arch::x86::_mm512_reduce_min_epu32 fn">_mm512_reduce_min_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将一个包装的无符号 32 位整数减少到最小值。返回 a 中所有元素的最小值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_reduce_min_epu64.html" title="core::arch::x86::_mm512_reduce_min_epu64 fn">_mm512_reduce_min_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将一个包装的无符号 64 位整数减少到最小。返回 a 中所有元素的最小值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_reduce_min_pd.html" title="core::arch::x86::_mm512_reduce_min_pd fn">_mm512_reduce_min_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将一个包装的双精度（64位）浮点元素减少到最小。返回 a 中所有元素的最小值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_reduce_min_ps.html" title="core::arch::x86::_mm512_reduce_min_ps fn">_mm512_reduce_min_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将一个包装的单精度（32位）浮点元素减少到最小。返回 a 中所有元素的最小值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_reduce_mul_epi32.html" title="core::arch::x86::_mm512_reduce_mul_epi32 fn">_mm512_reduce_mul_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>通过乘法减少包装的 32 位整数。返回 a 中所有元素的乘积。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_reduce_mul_epi64.html" title="core::arch::x86::_mm512_reduce_mul_epi64 fn">_mm512_reduce_mul_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>通过乘法减少包装的 64 位整数。返回 a 中所有元素的乘积。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_reduce_mul_pd.html" title="core::arch::x86::_mm512_reduce_mul_pd fn">_mm512_reduce_mul_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>通过乘法减少包装的双精度 (64-bit) 浮点元素。返回 a 中所有元素的乘积。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_reduce_mul_ps.html" title="core::arch::x86::_mm512_reduce_mul_ps fn">_mm512_reduce_mul_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>通过乘法减少包装的单精度 (32-bit) 浮点元素。返回 a 中所有元素的乘积。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_reduce_or_epi32.html" title="core::arch::x86::_mm512_reduce_or_epi32 fn">_mm512_reduce_or_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>通过按位 OR 减少包装的 32 位整数。返回 a 中所有元素的按位或。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_reduce_or_epi64.html" title="core::arch::x86::_mm512_reduce_or_epi64 fn">_mm512_reduce_or_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>通过按位 OR 减少包装的 64 位整数。返回 a 中所有元素的按位或。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_rol_epi32.html" title="core::arch::x86::_mm512_rol_epi32 fn">_mm512_rol_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 X 中每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_rol_epi64.html" title="core::arch::x86::_mm512_rol_epi64 fn">_mm512_rol_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 X 中每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_rolv_epi32.html" title="core::arch::x86::_mm512_rolv_epi32 fn">_mm512_rolv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中每个包装的 32 位整数中的位向左旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_rolv_epi64.html" title="core::arch::x86::_mm512_rolv_epi64 fn">_mm512_rolv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中每个包装的 64 位整数中的位向左旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_ror_epi32.html" title="core::arch::x86::_mm512_ror_epi32 fn">_mm512_ror_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 X 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_ror_epi64.html" title="core::arch::x86::_mm512_ror_epi64 fn">_mm512_ror_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 X 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_rorv_epi32.html" title="core::arch::x86::_mm512_rorv_epi32 fn">_mm512_rorv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中每个包装的 32 位整数中的位向右旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_rorv_epi64.html" title="core::arch::x86::_mm512_rorv_epi64 fn">_mm512_rorv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_roundscale_pd.html" title="core::arch::x86::_mm512_roundscale_pd fn">_mm512_roundscale_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 x 中的包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并将结果存储在 dst 中。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_roundscale_ps.html" title="core::arch::x86::_mm512_roundscale_ps fn">_mm512_roundscale_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的小数位数，然后将结果存储在 dst 中。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_roundscale_round_pd.html" title="core::arch::x86::_mm512_roundscale_round_pd fn">_mm512_roundscale_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 x 中的包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并将结果存储在 dst 中。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_roundscale_round_ps.html" title="core::arch::x86::_mm512_roundscale_round_ps fn">_mm512_roundscale_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的小数位数，然后将结果存储在 dst 中。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_rsqrt14_pd.html" title="core::arch::x86::_mm512_rsqrt14_pd fn">_mm512_rsqrt14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数平方根，并将结果存储在 dst 中。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_rsqrt14_ps.html" title="core::arch::x86::_mm512_rsqrt14_ps fn">_mm512_rsqrt14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并将结果存储在 dst 中。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_sad_epu8.html" title="core::arch::x86::_mm512_sad_epu8 fn">_mm512_sad_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 a 和 b 中包装的无符号 8 位整数的绝对差，然后将每个连续的 8 个差水平地求和以生成八个无符号的 16 位整数，并将这些无符号的 16 位整数包装在 64 位元素的低 16 位中在 dst。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_scalef_pd.html" title="core::arch::x86::_mm512_scalef_pd fn">_mm512_scalef_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_scalef_ps.html" title="core::arch::x86::_mm512_scalef_ps fn">_mm512_scalef_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_scalef_round_pd.html" title="core::arch::x86::_mm512_scalef_round_pd fn">_mm512_scalef_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_scalef_round_ps.html" title="core::arch::x86::_mm512_scalef_round_ps fn">_mm512_scalef_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_set1_epi8.html" title="core::arch::x86::_mm512_set1_epi8 fn">_mm512_set1_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>向 dst 的所有元素广播 8 位整数 a。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_set1_epi16.html" title="core::arch::x86::_mm512_set1_epi16 fn">_mm512_set1_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将低包装的 16 位整数从 a 广播到 dst 的所有所有元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_set1_epi32.html" title="core::arch::x86::_mm512_set1_epi32 fn">_mm512_set1_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>向 <code>dst</code> 的所有元素广播 32 位整数 <code>a</code>。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_set1_epi64.html" title="core::arch::x86::_mm512_set1_epi64 fn">_mm512_set1_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>向 <code>dst</code> 的所有元素广播 64 位整数 <code>a</code>。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_set1_pd.html" title="core::arch::x86::_mm512_set1_pd fn">_mm512_set1_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>向 <code>dst</code> 的所有元素广播 64 位浮点数 <code>a</code>。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_set1_ps.html" title="core::arch::x86::_mm512_set1_ps fn">_mm512_set1_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>向 <code>dst</code> 的所有元素广播 32 位浮点数 <code>a</code>。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_set4_epi32.html" title="core::arch::x86::_mm512_set4_epi32 fn">_mm512_set4_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用重复的 4 个元素序列在 dst 中设置包装的 32 位整数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_set4_epi64.html" title="core::arch::x86::_mm512_set4_epi64 fn">_mm512_set4_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用重复的 4 个元素序列在 dst 中设置包装的 64 位整数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_set4_pd.html" title="core::arch::x86::_mm512_set4_pd fn">_mm512_set4_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用重复的 4 个元素序列在 dst 中设置包装的双精度 (64-bit) 浮点元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_set4_ps.html" title="core::arch::x86::_mm512_set4_ps fn">_mm512_set4_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用重复的 4 个元素序列在 dst 中设置包装的单精度 (32-bit) 浮点元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_set_epi8.html" title="core::arch::x86::_mm512_set_epi8 fn">_mm512_set_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用提供的值在 dst 中设置包装的 8 位整数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_set_epi16.html" title="core::arch::x86::_mm512_set_epi16 fn">_mm512_set_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用提供的值在 dst 中设置包装的 16 位整数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_set_epi32.html" title="core::arch::x86::_mm512_set_epi32 fn">_mm512_set_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用提供的值在 <code>dst</code> 中设置包装的 32 位整数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_set_epi64.html" title="core::arch::x86::_mm512_set_epi64 fn">_mm512_set_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用提供的值在 dst 中设置包装的 64 位整数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_set_pd.html" title="core::arch::x86::_mm512_set_pd fn">_mm512_set_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用提供的值在 dst 中设置包装的双精度 (64-bit) 浮点元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_set_ps.html" title="core::arch::x86::_mm512_set_ps fn">_mm512_set_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用提供的值在 <code>dst</code> 中设置包装的 32 位整数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_setr4_epi32.html" title="core::arch::x86::_mm512_setr4_epi32 fn">_mm512_setr4_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 dst 中设置包装的 32 位整数，并以相反的顺序重复 4 个元素序列。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_setr4_epi64.html" title="core::arch::x86::_mm512_setr4_epi64 fn">_mm512_setr4_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 dst 中设置包装的 64 位整数，并以相反的顺序重复 4 个元素序列。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_setr4_pd.html" title="core::arch::x86::_mm512_setr4_pd fn">_mm512_setr4_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 dst 中设置包装的双精度 (64-bit) 浮点元素，并以相反的顺序重复 4 个元素序列。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_setr4_ps.html" title="core::arch::x86::_mm512_setr4_ps fn">_mm512_setr4_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 dst 中设置包装的单精度 (32-bit) 浮点元素，并以相反的顺序重复 4 个元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_setr_epi32.html" title="core::arch::x86::_mm512_setr_epi32 fn">_mm512_setr_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 <code>dst</code> 中设置包装的 32 位整数，并以相反的顺序提供所提供的值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_setr_epi64.html" title="core::arch::x86::_mm512_setr_epi64 fn">_mm512_setr_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 dst 中设置包装的 64 位整数，并以相反的顺序提供所提供的值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_setr_pd.html" title="core::arch::x86::_mm512_setr_pd fn">_mm512_setr_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 dst 中设置包装的双精度 (64-bit) 浮点元素，并以相反的顺序提供所提供的值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_setr_ps.html" title="core::arch::x86::_mm512_setr_ps fn">_mm512_setr_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 <code>dst</code> 中设置包装的 32 位整数，并以相反的顺序提供所提供的值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_setzero.html" title="core::arch::x86::_mm512_setzero fn">_mm512_setzero</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>返回 __m512 类型的 vector，所有元素均设置为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_setzero_epi32.html" title="core::arch::x86::_mm512_setzero_epi32 fn">_mm512_setzero_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>返回类型为 __m512i 的 vector，所有元素均设置为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_setzero_pd.html" title="core::arch::x86::_mm512_setzero_pd fn">_mm512_setzero_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>返回 <code>__m512d</code> 类型的 vector，所有元素均设置为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_setzero_ps.html" title="core::arch::x86::_mm512_setzero_ps fn">_mm512_setzero_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>返回 <code>__m512d</code> 类型的 vector，所有元素均设置为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_setzero_si512.html" title="core::arch::x86::_mm512_setzero_si512 fn">_mm512_setzero_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>返回 <code>__m512i</code> 类型的 vector，所有元素均设置为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_shldi_epi16.html" title="core::arch::x86::_mm512_shldi_epi16 fn">_mm512_shldi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并将高 16 位存储在 dst 中)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_shldi_epi32.html" title="core::arch::x86::_mm512_shldi_epi32 fn">_mm512_shldi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并将高 32 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_shldi_epi64.html" title="core::arch::x86::_mm512_shldi_epi64 fn">_mm512_shldi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并将高 64 位存储在 dst 中)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_shldv_epi16.html" title="core::arch::x86::_mm512_shldv_epi16 fn">_mm512_shldv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的对应元素中指定的量，并将高 16 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_shldv_epi32.html" title="core::arch::x86::_mm512_shldv_epi32 fn">_mm512_shldv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的对应元素中指定的量，并将高 32 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_shldv_epi64.html" title="core::arch::x86::_mm512_shldv_epi64 fn">_mm512_shldv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的对应元素中指定的量，并将高 64 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_shrdi_epi16.html" title="core::arch::x86::_mm512_shrdi_epi16 fn">_mm512_shrdi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并将低 16 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_shrdi_epi32.html" title="core::arch::x86::_mm512_shrdi_epi32 fn">_mm512_shrdi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并将低 32 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_shrdi_epi64.html" title="core::arch::x86::_mm512_shrdi_epi64 fn">_mm512_shrdi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并将低 64 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_shrdv_epi16.html" title="core::arch::x86::_mm512_shrdv_epi16 fn">_mm512_shrdv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的对应元素中指定的量，并将低 16 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_shrdv_epi32.html" title="core::arch::x86::_mm512_shrdv_epi32 fn">_mm512_shrdv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的对应元素中指定的量，并将低 32 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_shrdv_epi64.html" title="core::arch::x86::_mm512_shrdv_epi64 fn">_mm512_shrdv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2` only"><code>avx512vbmi2</code></span><p>将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的对应元素中指定的量，并将低 64 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_shuffle_epi8.html" title="core::arch::x86::_mm512_shuffle_epi8 fn">_mm512_shuffle_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>根据 b 的对应 8 位元素中的打乱控制掩码，将 a 中的包装 8 位整数进行打乱，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_shuffle_epi32.html" title="core::arch::x86::_mm512_shuffle_epi32 fn">_mm512_shuffle_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_shuffle_f32x4.html" title="core::arch::x86::_mm512_shuffle_f32x4 fn">_mm512_shuffle_f32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>imm8 从 a 和 b 中随机选择 128 位 (由 4 个单精度 (32-bit) 浮点元素组成)，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_shuffle_f64x2.html" title="core::arch::x86::_mm512_shuffle_f64x2 fn">_mm512_shuffle_f64x2</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>随机排列 imm8 从 a 和 b 中选择的 128 位 (由 2 个双精度 (64-bit) 浮点元素组成)，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_shuffle_i32x4.html" title="core::arch::x86::_mm512_shuffle_i32x4 fn">_mm512_shuffle_i32x4</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>随机排列 imm8 从 a 和 b 中选择的 128 位 (由 4 个 32 位整数组成)，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_shuffle_i64x2.html" title="core::arch::x86::_mm512_shuffle_i64x2 fn">_mm512_shuffle_i64x2</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>随机排列 imm8 从 a 和 b 中选择的 128 位 (由 2 个 64 位整数组成)，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_shuffle_pd.html" title="core::arch::x86::_mm512_shuffle_pd fn">_mm512_shuffle_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 imm8 中的控件对 128 位通道中的双精度 (64-bit) 浮点元素进行混洗，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_shuffle_ps.html" title="core::arch::x86::_mm512_shuffle_ps fn">_mm512_shuffle_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_shufflehi_epi16.html" title="core::arch::x86::_mm512_shufflehi_epi16 fn">_mm512_shufflehi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用 imm8 中的控件在 a 的 128 位通道的高 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的高 64 位中，并从 a 到 dst 复制 128 位的通道的低 64 位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_shufflelo_epi16.html" title="core::arch::x86::_mm512_shufflelo_epi16 fn">_mm512_shufflelo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用 imm8 中的控件在 a 的 128 位通道的低 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的低 64 位中，并从 a 到 dst 复制 128 位的通道的高 64 位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_sll_epi16.html" title="core::arch::x86::_mm512_sll_epi16 fn">_mm512_sll_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数按计数左移，同时将零移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_sll_epi32.html" title="core::arch::x86::_mm512_sll_epi32 fn">_mm512_sll_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 32 位整数左移计数，同时将零移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_sll_epi64.html" title="core::arch::x86::_mm512_sll_epi64 fn">_mm512_sll_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将填充的 64 位整数左移计数，同时将零移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_slli_epi16.html" title="core::arch::x86::_mm512_slli_epi16 fn">_mm512_slli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数左移 imm8，同时将零移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_slli_epi32.html" title="core::arch::x86::_mm512_slli_epi32 fn">_mm512_slli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 32 位整数左移 imm8，同时将零移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_slli_epi64.html" title="core::arch::x86::_mm512_slli_epi64 fn">_mm512_slli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 64 位整数左移 imm8，同时将零移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_sllv_epi16.html" title="core::arch::x86::_mm512_sllv_epi16 fn">_mm512_sllv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数按 count 中相应元素指定的数量向左移位，同时将零移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_sllv_epi32.html" title="core::arch::x86::_mm512_sllv_epi32 fn">_mm512_sllv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将填充的 32 位整数向左移动 count 中相应元素指定的数量，同时向零移动，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_sllv_epi64.html" title="core::arch::x86::_mm512_sllv_epi64 fn">_mm512_sllv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将填充的 64 位整数向左移动由 count 中相应元素指定的数量，同时向零移动，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_sqrt_pd.html" title="core::arch::x86::_mm512_sqrt_pd fn">_mm512_sqrt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_sqrt_ps.html" title="core::arch::x86::_mm512_sqrt_ps fn">_mm512_sqrt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_sqrt_round_pd.html" title="core::arch::x86::_mm512_sqrt_round_pd fn">_mm512_sqrt_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_sqrt_round_ps.html" title="core::arch::x86::_mm512_sqrt_round_ps fn">_mm512_sqrt_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_sra_epi16.html" title="core::arch::x86::_mm512_sra_epi16 fn">_mm512_sra_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数按计数右移，同时将符号位移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_sra_epi32.html" title="core::arch::x86::_mm512_sra_epi32 fn">_mm512_sra_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在移入符号位的同时按计数右移包装的 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_sra_epi64.html" title="core::arch::x86::_mm512_sra_epi64 fn">_mm512_sra_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在移动符号位的同时按计数右移包装的 64 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_srai_epi16.html" title="core::arch::x86::_mm512_srai_epi16 fn">_mm512_srai_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数右移 imm8，同时将符号位移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_srai_epi32.html" title="core::arch::x86::_mm512_srai_epi32 fn">_mm512_srai_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 32 位整数右移 imm8，同时将符号位移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_srai_epi64.html" title="core::arch::x86::_mm512_srai_epi64 fn">_mm512_srai_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 64 位整数右移 imm8，同时将符号位移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_srav_epi16.html" title="core::arch::x86::_mm512_srav_epi16 fn">_mm512_srav_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数右移 count 中相应元素指定的数量，同时移入符号位，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_srav_epi32.html" title="core::arch::x86::_mm512_srav_epi32 fn">_mm512_srav_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在将符号位移位的同时，将已包装的 32 位整数右移由 count 中相应元素指定的数量，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_srav_epi64.html" title="core::arch::x86::_mm512_srav_epi64 fn">_mm512_srav_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将移位的 64 位整数向右移动计数中相应元素指定的数量，同时移入符号位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_srl_epi16.html" title="core::arch::x86::_mm512_srl_epi16 fn">_mm512_srl_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数按计数右移，同时将零移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_srl_epi32.html" title="core::arch::x86::_mm512_srl_epi32 fn">_mm512_srl_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将计数包装的 32 位整数右移，同时将零移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_srl_epi64.html" title="core::arch::x86::_mm512_srl_epi64 fn">_mm512_srl_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>按计数右移包装的 64 位整数，同时将零移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_srli_epi16.html" title="core::arch::x86::_mm512_srli_epi16 fn">_mm512_srli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数右移 imm8，同时将零移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_srli_epi32.html" title="core::arch::x86::_mm512_srli_epi32 fn">_mm512_srli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 32 位整数右移 imm8，同时将零移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_srli_epi64.html" title="core::arch::x86::_mm512_srli_epi64 fn">_mm512_srli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将包装的 64 位整数右移 imm8，同时将零移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_srlv_epi16.html" title="core::arch::x86::_mm512_srlv_epi16 fn">_mm512_srlv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_srlv_epi32.html" title="core::arch::x86::_mm512_srlv_epi32 fn">_mm512_srlv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>向右移动已包装的 32 位整数，偏移量为计数中相应元素指定的数量，同时向零移动，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_srlv_epi64.html" title="core::arch::x86::_mm512_srlv_epi64 fn">_mm512_srlv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>向右移位包装的 64 位整数 (由 count 中相应元素指定的数量)，同时向零移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_store_epi32.html" title="core::arch::x86::_mm512_store_epi32 fn">_mm512_store_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的 512 位 (由 16 个包装的 32 位整数组成) 存储到内存中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_store_epi64.html" title="core::arch::x86::_mm512_store_epi64 fn">_mm512_store_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的 512 位 (由 8 个包装的 64 位整数组成) 存储到内存中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_store_pd.html" title="core::arch::x86::_mm512_store_pd fn">_mm512_store_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的 512 位 (由 8 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_store_ps.html" title="core::arch::x86::_mm512_store_ps fn">_mm512_store_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的 512 位整数数据存储到内存中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_store_si512.html" title="core::arch::x86::_mm512_store_si512 fn">_mm512_store_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的 512 位整数数据存储到内存中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_storeu_epi8.html" title="core::arch::x86::_mm512_storeu_epi8 fn">_mm512_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 中的 512 位 (由 64 个包装的 8 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_storeu_epi16.html" title="core::arch::x86::_mm512_storeu_epi16 fn">_mm512_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 a 中的 512 位 (由 32 个包装的 16 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_storeu_epi32.html" title="core::arch::x86::_mm512_storeu_epi32 fn">_mm512_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的 512 位 (由 16 个包装的 32 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_storeu_epi64.html" title="core::arch::x86::_mm512_storeu_epi64 fn">_mm512_storeu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的 512 位 (由 8 个包装的 64 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_storeu_pd.html" title="core::arch::x86::_mm512_storeu_pd fn">_mm512_storeu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将来自 <code>a</code> 的 512 位 (由 8 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_storeu_si512.html" title="core::arch::x86::_mm512_storeu_si512 fn">_mm512_storeu_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的 512 位整数数据存储到内存中。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_stream_pd.html" title="core::arch::x86::_mm512_stream_pd fn">_mm512_stream_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用非临时内存提示将 512 位 (由 8 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_stream_ps.html" title="core::arch::x86::_mm512_stream_ps fn">_mm512_stream_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用非临时内存提示将 512 位 (由 16 个包装的单精度 (32-bit) 浮点元素组成) 存储到内存中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_stream_si512.html" title="core::arch::x86::_mm512_stream_si512 fn">_mm512_stream_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用非临时内存提示将 512 位整数数据从 a 存储到内存中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_sub_epi8.html" title="core::arch::x86::_mm512_sub_epi8 fn">_mm512_sub_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>从 a 中的包装 8 位整数中减去 b 中的包装 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_sub_epi16.html" title="core::arch::x86::_mm512_sub_epi16 fn">_mm512_sub_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>从 a 中的包装的 16 位整数中减去 b 中的包装的 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_sub_epi32.html" title="core::arch::x86::_mm512_sub_epi32 fn">_mm512_sub_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中的包装 32 位整数中减去 b 中的包装 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_sub_epi64.html" title="core::arch::x86::_mm512_sub_epi64 fn">_mm512_sub_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中的包装 64 位整数中减去 b 中的包装 64 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_sub_pd.html" title="core::arch::x86::_mm512_sub_pd fn">_mm512_sub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_sub_ps.html" title="core::arch::x86::_mm512_sub_ps fn">_mm512_sub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中的包装的单精度 (32-bit) 浮点元素中减去 b 中的包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_sub_round_pd.html" title="core::arch::x86::_mm512_sub_round_pd fn">_mm512_sub_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_sub_round_ps.html" title="core::arch::x86::_mm512_sub_round_ps fn">_mm512_sub_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中的包装的单精度 (32-bit) 浮点元素中减去 b 中的包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_subs_epi8.html" title="core::arch::x86::_mm512_subs_epi8 fn">_mm512_subs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用饱和度从包装的 8 位整数中减去 b 中的包装有符号 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_subs_epi16.html" title="core::arch::x86::_mm512_subs_epi16 fn">_mm512_subs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用饱和度从 a 中的包装的 16 位整数减去 b 中的包装的有符号 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_subs_epu8.html" title="core::arch::x86::_mm512_subs_epu8 fn">_mm512_subs_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用 a 饱和度将 b 中的包装无符号 8 位整数减去 b 中的包装无符号 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_subs_epu16.html" title="core::arch::x86::_mm512_subs_epu16 fn">_mm512_subs_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>使用饱和度将 b 中的包装无符号 16 位整数减去 b 中的包装无符号 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_ternarylogic_epi32.html" title="core::arch::x86::_mm512_ternarylogic_epi32 fn">_mm512_ternarylogic_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个包装的 32 位整数中的每个位，来自 a，b 和 c 的相应位用于形成到 imm8 的 3 位索引，并且将 imm8 中该位的值写入 dst 中的相应位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_ternarylogic_epi64.html" title="core::arch::x86::_mm512_ternarylogic_epi64 fn">_mm512_ternarylogic_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 64 位整数中的每一位，a、b 和 c 中的相应位用于形成 imm8 中的 3 位索引，并将 imm8 中该位的值写入 dst 中的相应位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_test_epi8_mask.html" title="core::arch::x86::_mm512_test_epi8_mask fn">_mm512_test_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 a 和 b 中包装的 8 位整数的按位与，生成中间 8 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_test_epi16_mask.html" title="core::arch::x86::_mm512_test_epi16_mask fn">_mm512_test_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 a 和 b 中包装的 16 位整数的按位与，生成中间的 16 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_test_epi32_mask.html" title="core::arch::x86::_mm512_test_epi32_mask fn">_mm512_test_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中包装的 32 位整数的按位与，生成中间的 32 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_test_epi64_mask.html" title="core::arch::x86::_mm512_test_epi64_mask fn">_mm512_test_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中包装的 64 位整数的按位与，生成中间 64 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_testn_epi8_mask.html" title="core::arch::x86::_mm512_testn_epi8_mask fn">_mm512_testn_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 a 和 b 中包装的 8 位整数的按位 NAND，生成中间的 8 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_testn_epi16_mask.html" title="core::arch::x86::_mm512_testn_epi16_mask fn">_mm512_testn_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>计算 a 和 b 中包装的 16 位整数的按位 NAND，生成中间的 16 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_testn_epi32_mask.html" title="core::arch::x86::_mm512_testn_epi32_mask fn">_mm512_testn_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中包装的 32 位整数的按位 NAND，生成中间的 32 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_testn_epi64_mask.html" title="core::arch::x86::_mm512_testn_epi64_mask fn">_mm512_testn_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中包装的 64 位整数的按位 NAND，生成中间的 64 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_undefined.html" title="core::arch::x86::_mm512_undefined fn">_mm512_undefined</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>返回类型为 __m512 的 vector，其中包含未定义的元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_undefined_epi32.html" title="core::arch::x86::_mm512_undefined_epi32 fn">_mm512_undefined_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>返回类型为 __m512i 的 vector，其中包含未定义的元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_undefined_pd.html" title="core::arch::x86::_mm512_undefined_pd fn">_mm512_undefined_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>返回带有未定义元素的 <code>__m512d</code> 类型的 vector。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_undefined_ps.html" title="core::arch::x86::_mm512_undefined_ps fn">_mm512_undefined_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>返回带有未定义元素的 <code>__m512</code> 类型的 vector。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_unpackhi_epi8.html" title="core::arch::x86::_mm512_unpackhi_epi8 fn">_mm512_unpackhi_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>从 a 和 b 中每个 128 位通道的高半部分拆包和交织 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_unpackhi_epi16.html" title="core::arch::x86::_mm512_unpackhi_epi16 fn">_mm512_unpackhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>从 a 和 b 中每个 128 位通道的高半部分拆包和交织 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_unpackhi_epi32.html" title="core::arch::x86::_mm512_unpackhi_epi32 fn">_mm512_unpackhi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_unpackhi_epi64.html" title="core::arch::x86::_mm512_unpackhi_epi64 fn">_mm512_unpackhi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织 64 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_unpackhi_pd.html" title="core::arch::x86::_mm512_unpackhi_pd fn">_mm512_unpackhi_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包并交织双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_unpackhi_ps.html" title="core::arch::x86::_mm512_unpackhi_ps fn">_mm512_unpackhi_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_unpacklo_epi8.html" title="core::arch::x86::_mm512_unpacklo_epi8 fn">_mm512_unpacklo_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>从 a 和 b 中每个 128 位通道的下半部分拆包并交织 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_unpacklo_epi16.html" title="core::arch::x86::_mm512_unpacklo_epi16 fn">_mm512_unpacklo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>从 a 和 b 中每个 128 位通道的下半部分拆包并交织 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_unpacklo_epi32.html" title="core::arch::x86::_mm512_unpacklo_epi32 fn">_mm512_unpacklo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包和交织 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_unpacklo_epi64.html" title="core::arch::x86::_mm512_unpacklo_epi64 fn">_mm512_unpacklo_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包并交织 64 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_unpacklo_pd.html" title="core::arch::x86::_mm512_unpacklo_pd fn">_mm512_unpacklo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解解包并交织双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_unpacklo_ps.html" title="core::arch::x86::_mm512_unpacklo_ps fn">_mm512_unpacklo_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解压包并交织单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_xor_epi32.html" title="core::arch::x86::_mm512_xor_epi32 fn">_mm512_xor_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中包装的 32 位整数的按位 XOR，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_xor_epi64.html" title="core::arch::x86::_mm512_xor_epi64 fn">_mm512_xor_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中包装的 64 位整数的按位 XOR，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_xor_si512.html" title="core::arch::x86::_mm512_xor_si512 fn">_mm512_xor_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 a 和 b 中 512 位 (代表整数数据) 的按位 XOR，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_zextpd128_pd512.html" title="core::arch::x86::_mm512_zextpd128_pd512 fn">_mm512_zextpd128_pd512</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将类型 __m128d 的 vector 强制转换为 __m512d 类型; 结果的高 384 位被清零。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_zextpd256_pd512.html" title="core::arch::x86::_mm512_zextpd256_pd512 fn">_mm512_zextpd256_pd512</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将类型 __m256d 的 vector 强制转换为 __m512d 类型; 结果的高 256 位被清零。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_zextps128_ps512.html" title="core::arch::x86::_mm512_zextps128_ps512 fn">_mm512_zextps128_ps512</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将类型 __m128 的 vector 转换为 __m512 类型; 结果的高 384 位被清零。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_zextps256_ps512.html" title="core::arch::x86::_mm512_zextps256_ps512 fn">_mm512_zextps256_ps512</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将类型为 __m256 的 vector 强制转换为类型 __m512; 结果的高 256 位被清零。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_zextsi128_si512.html" title="core::arch::x86::_mm512_zextsi128_si512 fn">_mm512_zextsi128_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将类型为 __m128i 的 vector 强制转换为类型 __m512i; 结果的高 384 位被清零。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm512_zextsi256_si512.html" title="core::arch::x86::_mm512_zextsi256_si512 fn">_mm512_zextsi256_si512</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将类型为 __m256i 的 vector 强制转换为类型 __m512i; 结果的高 256 位被清零。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_add_round_sd.html" title="core::arch::x86::_mm_add_round_sd fn">_mm_add_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加较低的双精度 (64-bit) 浮点元素，将结果存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_add_round_ss.html" title="core::arch::x86::_mm_add_round_ss fn">_mm_add_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加较低的单精度 (32-bit) 浮点元素，将结果存储在 dst 的较低元素中，并将较高的 3 个包装的元素从 a 复制到 dst 的较高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_alignr_epi32.html" title="core::arch::x86::_mm_alignr_epi32 fn">_mm_alignr_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 连接成一个 32 字节的 immediate 结果，将结果右移 imm8 个 32 位元素，并将低 16 字节 (4 个元素) 存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_alignr_epi64.html" title="core::arch::x86::_mm_alignr_epi64 fn">_mm_alignr_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 连接成一个 32 字节的 immediate 结果，将结果右移 imm8 个 64 位元素，并将低 16 字节 (2 个元素) 存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_bitshuffle_epi64_mask.html" title="core::arch::x86::_mm_bitshuffle_epi64_mask fn">_mm_bitshuffle_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span><p>将输入 <code>b</code> 视为包装的 64 位整数，并将 <code>c</code> 视为包装的 8 位整数。
然后将来自 <code>c</code> 的 8 个 8 位值作为索引分组到相应的 64 位整数的位中。
然后，选择这些位并将其包装到输出中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_broadcastmb_epi64.html" title="core::arch::x86::_mm_broadcastmb_epi64 fn">_mm_broadcastmb_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>将输入掩码 k 的低 8 位广播到 dst 的所有 64 位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_broadcastmw_epi32.html" title="core::arch::x86::_mm_broadcastmw_epi32 fn">_mm_broadcastmw_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>将输入掩码 k 的低 16 位广播到 dst 的所有 32 位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmp_epi8_mask.html" title="core::arch::x86::_mm_cmp_epi8_mask fn">_mm_cmp_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装带符号 8 位整数，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmp_epi16_mask.html" title="core::arch::x86::_mm_cmp_epi16_mask fn">_mm_cmp_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号 16 位整数，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmp_epi32_mask.html" title="core::arch::x86::_mm_cmp_epi32_mask fn">_mm_cmp_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装有符号 32 位整数，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmp_epi64_mask.html" title="core::arch::x86::_mm_cmp_epi64_mask fn">_mm_cmp_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 64 位整数，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmp_epu8_mask.html" title="core::arch::x86::_mm_cmp_epu8_mask fn">_mm_cmp_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 8 位整数，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmp_epu16_mask.html" title="core::arch::x86::_mm_cmp_epu16_mask fn">_mm_cmp_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 16 位整数，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmp_epu32_mask.html" title="core::arch::x86::_mm_cmp_epu32_mask fn">_mm_cmp_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 32 位整数，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmp_epu64_mask.html" title="core::arch::x86::_mm_cmp_epu64_mask fn">_mm_cmp_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 64 位整数，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmp_pd_mask.html" title="core::arch::x86::_mm_cmp_pd_mask fn">_mm_cmp_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmp_ps_mask.html" title="core::arch::x86::_mm_cmp_ps_mask fn">_mm_cmp_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmp_round_sd_mask.html" title="core::arch::x86::_mm_cmp_round_sd_mask fn">_mm_cmp_round_sd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，并将结果存储在掩码 vector k 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmp_round_ss_mask.html" title="core::arch::x86::_mm_cmp_round_ss_mask fn">_mm_cmp_round_ss_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，并将结果存储在掩码 vector k 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmp_sd_mask.html" title="core::arch::x86::_mm_cmp_sd_mask fn">_mm_cmp_sd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmp_ss_mask.html" title="core::arch::x86::_mm_cmp_ss_mask fn">_mm_cmp_ss_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpeq_epi8_mask.html" title="core::arch::x86::_mm_cmpeq_epi8_mask fn">_mm_cmpeq_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpeq_epi16_mask.html" title="core::arch::x86::_mm_cmpeq_epi16_mask fn">_mm_cmpeq_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpeq_epi32_mask.html" title="core::arch::x86::_mm_cmpeq_epi32_mask fn">_mm_cmpeq_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的 32 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpeq_epi64_mask.html" title="core::arch::x86::_mm_cmpeq_epi64_mask fn">_mm_cmpeq_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的 64 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpeq_epu8_mask.html" title="core::arch::x86::_mm_cmpeq_epu8_mask fn">_mm_cmpeq_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpeq_epu16_mask.html" title="core::arch::x86::_mm_cmpeq_epu16_mask fn">_mm_cmpeq_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpeq_epu32_mask.html" title="core::arch::x86::_mm_cmpeq_epu32_mask fn">_mm_cmpeq_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpeq_epu64_mask.html" title="core::arch::x86::_mm_cmpeq_epu64_mask fn">_mm_cmpeq_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpge_epi8_mask.html" title="core::arch::x86::_mm_cmpge_epi8_mask fn">_mm_cmpge_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否大于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpge_epi16_mask.html" title="core::arch::x86::_mm_cmpge_epi16_mask fn">_mm_cmpge_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号 16 位整数是否大于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpge_epi32_mask.html" title="core::arch::x86::_mm_cmpge_epi32_mask fn">_mm_cmpge_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号 32 位整数是否大于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpge_epi64_mask.html" title="core::arch::x86::_mm_cmpge_epi64_mask fn">_mm_cmpge_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数是否大于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpge_epu8_mask.html" title="core::arch::x86::_mm_cmpge_epu8_mask fn">_mm_cmpge_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否大于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpge_epu16_mask.html" title="core::arch::x86::_mm_cmpge_epu16_mask fn">_mm_cmpge_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否大于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpge_epu32_mask.html" title="core::arch::x86::_mm_cmpge_epu32_mask fn">_mm_cmpge_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否大于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpge_epu64_mask.html" title="core::arch::x86::_mm_cmpge_epu64_mask fn">_mm_cmpge_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否大于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpgt_epi8_mask.html" title="core::arch::x86::_mm_cmpgt_epi8_mask fn">_mm_cmpgt_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否大于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpgt_epi16_mask.html" title="core::arch::x86::_mm_cmpgt_epi16_mask fn">_mm_cmpgt_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号 16 位整数是否大于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpgt_epi32_mask.html" title="core::arch::x86::_mm_cmpgt_epi32_mask fn">_mm_cmpgt_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数是否大于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpgt_epi64_mask.html" title="core::arch::x86::_mm_cmpgt_epi64_mask fn">_mm_cmpgt_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数是否大于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpgt_epu8_mask.html" title="core::arch::x86::_mm_cmpgt_epu8_mask fn">_mm_cmpgt_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否大于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpgt_epu16_mask.html" title="core::arch::x86::_mm_cmpgt_epu16_mask fn">_mm_cmpgt_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否大于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpgt_epu32_mask.html" title="core::arch::x86::_mm_cmpgt_epu32_mask fn">_mm_cmpgt_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否大于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpgt_epu64_mask.html" title="core::arch::x86::_mm_cmpgt_epu64_mask fn">_mm_cmpgt_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否大于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmple_epi8_mask.html" title="core::arch::x86::_mm_cmple_epi8_mask fn">_mm_cmple_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数 (小于等于)，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmple_epi16_mask.html" title="core::arch::x86::_mm_cmple_epi16_mask fn">_mm_cmple_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数 (小于等于)，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmple_epi32_mask.html" title="core::arch::x86::_mm_cmple_epi32_mask fn">_mm_cmple_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数 (小于等于)，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmple_epi64_mask.html" title="core::arch::x86::_mm_cmple_epi64_mask fn">_mm_cmple_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数 (小于等于)，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmple_epu8_mask.html" title="core::arch::x86::_mm_cmple_epu8_mask fn">_mm_cmple_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数以得出小于或等于的结果，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmple_epu16_mask.html" title="core::arch::x86::_mm_cmple_epu16_mask fn">_mm_cmple_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否小于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmple_epu32_mask.html" title="core::arch::x86::_mm_cmple_epu32_mask fn">_mm_cmple_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否小于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmple_epu64_mask.html" title="core::arch::x86::_mm_cmple_epu64_mask fn">_mm_cmple_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否小于等于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmplt_epi8_mask.html" title="core::arch::x86::_mm_cmplt_epi8_mask fn">_mm_cmplt_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数小于零，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmplt_epi16_mask.html" title="core::arch::x86::_mm_cmplt_epi16_mask fn">_mm_cmplt_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数 (小于)，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmplt_epi32_mask.html" title="core::arch::x86::_mm_cmplt_epi32_mask fn">_mm_cmplt_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数 (小于)，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmplt_epi64_mask.html" title="core::arch::x86::_mm_cmplt_epi64_mask fn">_mm_cmplt_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数小于零，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmplt_epu8_mask.html" title="core::arch::x86::_mm_cmplt_epu8_mask fn">_mm_cmplt_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数以得到小于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmplt_epu16_mask.html" title="core::arch::x86::_mm_cmplt_epu16_mask fn">_mm_cmplt_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装后的无符号 16 位整数 (小于)，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmplt_epu32_mask.html" title="core::arch::x86::_mm_cmplt_epu32_mask fn">_mm_cmplt_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否小于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmplt_epu64_mask.html" title="core::arch::x86::_mm_cmplt_epu64_mask fn">_mm_cmplt_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否小于，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpneq_epi8_mask.html" title="core::arch::x86::_mm_cmpneq_epi8_mask fn">_mm_cmpneq_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否不相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpneq_epi16_mask.html" title="core::arch::x86::_mm_cmpneq_epi16_mask fn">_mm_cmpneq_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号 16 位整数是否不相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpneq_epi32_mask.html" title="core::arch::x86::_mm_cmpneq_epi32_mask fn">_mm_cmpneq_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的 32 位整数是否不相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpneq_epi64_mask.html" title="core::arch::x86::_mm_cmpneq_epi64_mask fn">_mm_cmpneq_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数是否不相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpneq_epu8_mask.html" title="core::arch::x86::_mm_cmpneq_epu8_mask fn">_mm_cmpneq_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpneq_epu16_mask.html" title="core::arch::x86::_mm_cmpneq_epu16_mask fn">_mm_cmpneq_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否不相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpneq_epu32_mask.html" title="core::arch::x86::_mm_cmpneq_epu32_mask fn">_mm_cmpneq_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否不相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cmpneq_epu64_mask.html" title="core::arch::x86::_mm_cmpneq_epu64_mask fn">_mm_cmpneq_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否不相等，并将结果存储在掩码 vector k 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_comi_round_sd.html" title="core::arch::x86::_mm_comi_round_sd fn">_mm_comi_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，并返回布尔结果 (0 或 1)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_comi_round_ss.html" title="core::arch::x86::_mm_comi_round_ss fn">_mm_comi_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，并返回布尔结果 (0 或 1)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_conflict_epi32.html" title="core::arch::x86::_mm_conflict_epi32 fn">_mm_conflict_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_conflict_epi64.html" title="core::arch::x86::_mm_conflict_epi64 fn">_mm_conflict_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>测试 a 的每个 64 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvt_roundi32_ss.html" title="core::arch::x86::_mm_cvt_roundi32_ss fn">_mm_cvt_roundi32_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将带符号的 32 位整数 b 转换为单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvt_roundsd_i32.html" title="core::arch::x86::_mm_cvt_roundsd_i32 fn">_mm_cvt_roundsd_i32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的较低单精度 (32-bit) 浮点元素转换为 32 位整数，并将结果存储在 dst 中。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一:<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvt_roundsd_si32.html" title="core::arch::x86::_mm_cvt_roundsd_si32 fn">_mm_cvt_roundsd_si32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的较低双精度 (64-bit) 浮点元素转换为 32 位整数，并将结果存储在 dst 中。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一:<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvt_roundsd_ss.html" title="core::arch::x86::_mm_cvt_roundsd_ss fn">_mm_cvt_roundsd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的下部双精度 (64-bit) 浮点元素转换为单精度 (32-bit) 浮点元素，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到 dst 的上部元素。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一:<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvt_roundsd_u32.html" title="core::arch::x86::_mm_cvt_roundsd_u32 fn">_mm_cvt_roundsd_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的较低双精度 (64-bit) 浮点元素转换为 32 位无符号整数，并将结果存储在 dst 中。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一:<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvt_roundsi32_ss.html" title="core::arch::x86::_mm_cvt_roundsi32_ss fn">_mm_cvt_roundsi32_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将带符号的 32 位整数 b 转换为单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvt_roundss_i32.html" title="core::arch::x86::_mm_cvt_roundss_i32 fn">_mm_cvt_roundss_i32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的较低单精度 (32-bit) 浮点元素转换为 32 位整数，并将结果存储在 dst 中。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一:<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvt_roundss_sd.html" title="core::arch::x86::_mm_cvt_roundss_sd fn">_mm_cvt_roundss_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的下部单精度 (32-bit) 浮点元素转换为双精度 (64-bit) 浮点元素，将结果存储在 dst 的下部元素中，然后将上部的元素从 a 复制到 dst 的上部元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvt_roundss_si32.html" title="core::arch::x86::_mm_cvt_roundss_si32 fn">_mm_cvt_roundss_si32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的较低单精度 (32-bit) 浮点元素转换为 32 位整数，并将结果存储在 dst 中。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一:<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvt_roundss_u32.html" title="core::arch::x86::_mm_cvt_roundss_u32 fn">_mm_cvt_roundss_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的较低单精度 (32-bit) 浮点元素转换为 32 位无符号整数，并将结果存储在 dst 中。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一:<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvt_roundu32_ss.html" title="core::arch::x86::_mm_cvt_roundu32_ss fn">_mm_cvt_roundu32_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将无符号的 32 位整数 b 转换为单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 dst 的高位元素。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一:<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtepi16_epi8.html" title="core::arch::x86::_mm_cvtepi16_epi8 fn">_mm_cvtepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的包装的 16 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtepi32_epi8.html" title="core::arch::x86::_mm_cvtepi32_epi8 fn">_mm_cvtepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将带有 a 的包装的 32 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtepi32_epi16.html" title="core::arch::x86::_mm_cvtepi32_epi16 fn">_mm_cvtepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtepi64_epi8.html" title="core::arch::x86::_mm_cvtepi64_epi8 fn">_mm_cvtepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将带有 a 的包装的 64 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtepi64_epi16.html" title="core::arch::x86::_mm_cvtepi64_epi16 fn">_mm_cvtepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将带有 a 的包装的 64 位整数转换为带有截断的包装的 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtepi64_epi32.html" title="core::arch::x86::_mm_cvtepi64_epi32 fn">_mm_cvtepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将带有 a 的包装的 64 位整数转换为带有截断的包装的 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtepu32_pd.html" title="core::arch::x86::_mm_cvtepu32_pd fn">_mm_cvtepu32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 A 中的包装的无符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvti32_sd.html" title="core::arch::x86::_mm_cvti32_sd fn">_mm_cvti32_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将带符号的 32 位整数 b 转换为双精度 (64-bit) 浮点元素，将结果存储在 dst 的下部元素中，然后将 a 的上部元素复制到 dst 的上部元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvti32_ss.html" title="core::arch::x86::_mm_cvti32_ss fn">_mm_cvti32_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将带符号的 32 位整数 b 转换为单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtne2ps_pbh.html" title="core::arch::x86::_mm_cvtne2ps_pbh fn">_mm_cvtne2ps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span><p>将两个 128 位 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并将结果存入 a</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtpd_epu32.html" title="core::arch::x86::_mm_cvtpd_epu32 fn">_mm_cvtpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtph_ps.html" title="core::arch::x86::_mm_cvtph_ps fn">_mm_cvtph_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `f16c` only"><code>f16c</code></span><p>将 128 位 vector <code>a</code> 的最低 64 位中的 4 x 16 位半精度浮点值转换为存储在 128 位宽的 vector 中的 4 x 32 位浮点值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtps_epu32.html" title="core::arch::x86::_mm_cvtps_epu32 fn">_mm_cvtps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtps_ph.html" title="core::arch::x86::_mm_cvtps_ph fn">_mm_cvtps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `f16c` only"><code>f16c</code></span><p>将 128 位 vector <code>a</code> 中的 4 x 32 位浮点值转换为 4 x
16 位半精度浮点值存储在 128 位 vector 的最低 64 位中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtsd_i32.html" title="core::arch::x86::_mm_cvtsd_i32 fn">_mm_cvtsd_i32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的较低双精度 (64-bit) 浮点元素转换为 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtsd_u32.html" title="core::arch::x86::_mm_cvtsd_u32 fn">_mm_cvtsd_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的较低双精度 (64-bit) 浮点元素转换为 32 位无符号整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtsepi16_epi8.html" title="core::arch::x86::_mm_cvtsepi16_epi8 fn">_mm_cvtsepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 A 中的包装有符号 16 位整数转换为带符号饱和的包装 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtsepi32_epi8.html" title="core::arch::x86::_mm_cvtsepi32_epi8 fn">_mm_cvtsepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtsepi32_epi16.html" title="core::arch::x86::_mm_cvtsepi32_epi16 fn">_mm_cvtsepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtsepi64_epi8.html" title="core::arch::x86::_mm_cvtsepi64_epi8 fn">_mm_cvtsepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的带符号的 64 位整数转换为带符号饱和的包装的 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtsepi64_epi16.html" title="core::arch::x86::_mm_cvtsepi64_epi16 fn">_mm_cvtsepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的带符号的 64 位整数转换为带符号饱和的包装的 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtsepi64_epi32.html" title="core::arch::x86::_mm_cvtsepi64_epi32 fn">_mm_cvtsepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtss_i32.html" title="core::arch::x86::_mm_cvtss_i32 fn">_mm_cvtss_i32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的较低单精度 (32-bit) 浮点元素转换为 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtss_u32.html" title="core::arch::x86::_mm_cvtss_u32 fn">_mm_cvtss_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的较低单精度 (32-bit) 浮点元素转换为 32 位无符号整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtt_roundsd_i32.html" title="core::arch::x86::_mm_cvtt_roundsd_i32 fn">_mm_cvtt_roundsd_i32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的较低双精度 (64-bit) 浮点元素转换为带截断的 32 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtt_roundsd_si32.html" title="core::arch::x86::_mm_cvtt_roundsd_si32 fn">_mm_cvtt_roundsd_si32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的较低双精度 (64-bit) 浮点元素转换为带截断的 32 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtt_roundsd_u32.html" title="core::arch::x86::_mm_cvtt_roundsd_u32 fn">_mm_cvtt_roundsd_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的较低双精度 (64-bit) 浮点元素转换为带截断的无符号 32 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtt_roundss_i32.html" title="core::arch::x86::_mm_cvtt_roundss_i32 fn">_mm_cvtt_roundss_i32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的较低单精度 (32-bit) 浮点元素转换为带截断的 32 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtt_roundss_si32.html" title="core::arch::x86::_mm_cvtt_roundss_si32 fn">_mm_cvtt_roundss_si32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的较低单精度 (32-bit) 浮点元素转换为带截断的 32 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtt_roundss_u32.html" title="core::arch::x86::_mm_cvtt_roundss_u32 fn">_mm_cvtt_roundss_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的较低单精度 (32-bit) 浮点元素转换为带截断的无符号 32 位整数，并将结果存储在 dst 中。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvttpd_epu32.html" title="core::arch::x86::_mm_cvttpd_epu32 fn">_mm_cvttpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvttps_epu32.html" title="core::arch::x86::_mm_cvttps_epu32 fn">_mm_cvttps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvttsd_i32.html" title="core::arch::x86::_mm_cvttsd_i32 fn">_mm_cvttsd_i32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的较低双精度 (64-bit) 浮点元素转换为带截断的 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvttsd_u32.html" title="core::arch::x86::_mm_cvttsd_u32 fn">_mm_cvttsd_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的较低双精度 (64-bit) 浮点元素转换为带截断的无符号 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvttss_i32.html" title="core::arch::x86::_mm_cvttss_i32 fn">_mm_cvttss_i32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的较低单精度 (32-bit) 浮点元素转换为带截断的 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvttss_u32.html" title="core::arch::x86::_mm_cvttss_u32 fn">_mm_cvttss_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的较低单精度 (32-bit) 浮点元素转换为带截断的无符号 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtu32_sd.html" title="core::arch::x86::_mm_cvtu32_sd fn">_mm_cvtu32_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将无符号的 32 位整数 b 转换为双精度 (64-bit) 浮点元素，将结果存储在 dst 的低位元素中，然后将 a 的高位元素复制到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtu32_ss.html" title="core::arch::x86::_mm_cvtu32_ss fn">_mm_cvtu32_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将无符号的 32 位整数 b 转换为单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtusepi16_epi8.html" title="core::arch::x86::_mm_cvtusepi16_epi8 fn">_mm_cvtusepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtusepi32_epi8.html" title="core::arch::x86::_mm_cvtusepi32_epi8 fn">_mm_cvtusepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtusepi32_epi16.html" title="core::arch::x86::_mm_cvtusepi32_epi16 fn">_mm_cvtusepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 A 中的包装无符号 32 位整数转换为具有无符号饱和度的包装无符号 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtusepi64_epi8.html" title="core::arch::x86::_mm_cvtusepi64_epi8 fn">_mm_cvtusepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtusepi64_epi16.html" title="core::arch::x86::_mm_cvtusepi64_epi16 fn">_mm_cvtusepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_cvtusepi64_epi32.html" title="core::arch::x86::_mm_cvtusepi64_epi32 fn">_mm_cvtusepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 A 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_dbsad_epu8.html" title="core::arch::x86::_mm_dbsad_epu8 fn">_mm_dbsad_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 中与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs)，并将 16 位结果存储在 dst 中。对于每个 64 位通道，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中通道的低 8 位四元组，而后两个 SAD 使用 a 中通道的较高 8 位四元组。根据 imm8 中的控件，从 128 位通道中选择 b 中的四元组，并且每个 64 位通道中的每个 SAD 使用 8 位偏移量的选定四元组。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_div_round_sd.html" title="core::arch::x86::_mm_div_round_sd fn">_mm_div_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的下部双精度 (64-bit) 浮点元素除以 b 中的下部双精度 (64-bit) 浮点元素，将结果存储在 dst 的下部元素中，并将上部的元素从 a 复制到 dst 的上部元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_div_round_ss.html" title="core::arch::x86::_mm_div_round_ss fn">_mm_div_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的下部单精度 (32-bit) 浮点元素除以 b 中的下部单精度 (32-bit) 浮点元素，将结果存储在 dst 的下部元素中，并将上部 3 个包装的元素从 a 复制到上部元素 dst。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_dpbf16_ps.html" title="core::arch::x86::_mm_dpbf16_ps fn">_mm_dpbf16_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span><p>计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间单精度 (32-bit) 浮点元素与 src 中的元素相加，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_dpbusd_epi32.html" title="core::arch::x86::_mm_dpbusd_epi32 fn">_mm_dpbusd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span><p>将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果存入 dst。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_dpbusds_epi32.html" title="core::arch::x86::_mm_dpbusds_epi32 fn">_mm_dpbusds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span><p>将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。使用有符号饱和将这 4 个结果与 src 中相应的 32 位整数相加，并将包装的 32 位结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_dpwssd_epi32.html" title="core::arch::x86::_mm_dpwssd_epi32 fn">_mm_dpwssd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span><p>将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果存入 dst。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_dpwssds_epi32.html" title="core::arch::x86::_mm_dpwssds_epi32 fn">_mm_dpwssds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span><p>将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并将包装的 32 位结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_fixupimm_pd.html" title="core::arch::x86::_mm_fixupimm_pd fn">_mm_fixupimm_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 c 中的包装的 64 位整数修复 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_fixupimm_ps.html" title="core::arch::x86::_mm_fixupimm_ps fn">_mm_fixupimm_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 c 中的包装 32 位整数修复 a 和 b 中包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_fixupimm_round_sd.html" title="core::arch::x86::_mm_fixupimm_round_sd fn">_mm_fixupimm_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 c 中的较低 64 位整数修复 a 和 b 中较低的双精度 (64-bit) 浮点元素，将结果存储在 dst 的较低元素中，并将较高的元素从 a 复制到 dst 的较高元素。imm8 用于设置所需的标志报告。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_fixupimm_round_ss.html" title="core::arch::x86::_mm_fixupimm_round_ss fn">_mm_fixupimm_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 c 中的低 32 位整数修复 a 和 b 中的低位单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 a 的高位元素 dst。imm8 用于设置所需的标志报告。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_fixupimm_sd.html" title="core::arch::x86::_mm_fixupimm_sd fn">_mm_fixupimm_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 c 中的较低 64 位整数修复 a 和 b 中较低的双精度 (64-bit) 浮点元素，将结果存储在 dst 的较低元素中，并将较高的元素从 a 复制到 dst 的较高元素。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_fixupimm_ss.html" title="core::arch::x86::_mm_fixupimm_ss fn">_mm_fixupimm_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 c 中的低 32 位整数修复 a 和 b 中的低位单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 a 的高位元素 dst。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_fmadd_round_sd.html" title="core::arch::x86::_mm_fmadd_round_sd fn">_mm_fmadd_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，并将中间结果与较低元素 in c. Store 的结果相加到 dst 的较低元素中，并将较高的元素从 a 复制到 dst 的较高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_fmadd_round_ss.html" title="core::arch::x86::_mm_fmadd_round_ss fn">_mm_fmadd_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，并将中间结果与较低元素 in c. Store 的结果相加到 dst 的较低元素中，然后将较高的 3 个包装的元素从 a 复制到 dst 的较高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_fmsub_round_sd.html" title="core::arch::x86::_mm_fmsub_round_sd fn">_mm_fmsub_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。将结果存储在 dst 的下部元素中，然后将 a 的上部元素复制到 dst 的上部元素中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_fmsub_round_ss.html" title="core::arch::x86::_mm_fmsub_round_ss fn">_mm_fmsub_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。将结果存储在 dst 的下部元素中，并将上部 3 个包装的元素从 a 复制到 dst 的上部元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_fnmadd_round_sd.html" title="core::arch::x86::_mm_fnmadd_round_sd fn">_mm_fnmadd_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后将求和的中间结果与较低元素 in c. Store 的结果相加到 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_fnmadd_round_ss.html" title="core::arch::x86::_mm_fnmadd_round_ss fn">_mm_fnmadd_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后将取反的中间结果与较低元素 in c. Store 相加，将结果与 dst 的较低元素相乘，然后将较高的 3 个包装的元素从 a 复制到 dst。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_fnmsub_round_sd.html" title="core::arch::x86::_mm_fnmsub_round_sd fn">_mm_fnmsub_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。将结果存储在 dst 的下部元素中，然后将 a 的上部元素复制到 dst 的上部元素中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_fnmsub_round_ss.html" title="core::arch::x86::_mm_fnmsub_round_ss fn">_mm_fnmsub_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的下部单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的下部元素，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到上部 dst 的元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_getexp_pd.html" title="core::arch::x86::_mm_getexp_pd fn">_mm_getexp_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并将结果存储在 dst 中。本质上，此内联函数为每个元素计算 floor(log2(x))。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_getexp_ps.html" title="core::arch::x86::_mm_getexp_ps fn">_mm_getexp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，并将结果存储在 dst 中。本质上，此内联函数为每个元素计算 floor(log2(x))。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_getexp_round_sd.html" title="core::arch::x86::_mm_getexp_round_sd fn">_mm_getexp_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中较低的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，将结果存储在 dst 的低位元素中，并将高位元素从 a 复制到 dst 的上层元素。本质上，此内联函数计算下部元素的 floor(log2(x))。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_getexp_round_ss.html" title="core::arch::x86::_mm_getexp_round_ss fn">_mm_getexp_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中较低的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，将结果存储在 dst 的较低元素中，并从 a 中复制较高的 3 个包装的元素到 dst 的上层元素。本质上，此内联函数计算下部元素的 floor(log2(x))。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_getexp_sd.html" title="core::arch::x86::_mm_getexp_sd fn">_mm_getexp_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中较低的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，将结果存储在 dst 的低位元素中，并将高位元素从 a 复制到 dst 的上层元素。本质上，此内联函数计算下部元素的 floor(log2(x))。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_getexp_ss.html" title="core::arch::x86::_mm_getexp_ss fn">_mm_getexp_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中较低的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，将结果存储在 dst 的较低元素中，并从 a 中复制较高的 3 个包装的元素到 dst 的上层元素。本质上，此内联函数计算下部元素的 floor(log2(x))。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_getmant_pd.html" title="core::arch::x86::_mm_getmant_pd fn">_mm_getmant_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素的尾数规格化，并将结果存储在 dst 中。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_getmant_ps.html" title="core::arch::x86::_mm_getmant_ps fn">_mm_getmant_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素的尾数标准化，并将结果存储在 dst 中。
此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:
_MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) The sign is determined by sc which can take the following values:</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_getmant_round_sd.html" title="core::arch::x86::_mm_getmant_round_sd fn">_mm_getmant_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>标准化 b 中较低的双精度 (64-bit) 浮点元素的尾数，将结果存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_getmant_round_ss.html" title="core::arch::x86::_mm_getmant_round_ss fn">_mm_getmant_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>标准化 b 中较低单精度 (32-bit) 浮点元素的尾数，将结果存储在 dst 的较低元素中，并将高 3 个包装的元素从 a 复制到 dst 的较高元素。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_getmant_sd.html" title="core::arch::x86::_mm_getmant_sd fn">_mm_getmant_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>标准化 b 中较低的双精度 (64-bit) 浮点元素的尾数，将结果存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_getmant_ss.html" title="core::arch::x86::_mm_getmant_ss fn">_mm_getmant_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>标准化 b 中较低单精度 (32-bit) 浮点元素的尾数，将结果存储在 dst 的较低元素中，并将高 3 个包装的元素从 a 复制到 dst 的较高元素。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_gf2p8affine_epi64_epi8.html" title="core::arch::x86::_mm_gf2p8affine_epi64_epi8 fn">_mm_gf2p8affine_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span><p>对 x 中的包装字节执行仿射变换。
也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_gf2p8affineinv_epi64_epi8.html" title="core::arch::x86::_mm_gf2p8affineinv_epi64_epi8 fn">_mm_gf2p8affineinv_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span><p>对 x 中的反向包装的字节执行仿射变换。
也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_gf2p8mul_epi8.html" title="core::arch::x86::_mm_gf2p8mul_epi8 fn">_mm_gf2p8mul_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span><p>在包装的字节上执行 GF(2^8) 乘法。
该字段以多项式表示，具有约数多项式 x^8 + x^4 + x^3 + x + 1。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_load_epi32.html" title="core::arch::x86::_mm_load_epi32 fn">_mm_load_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 128 位 (由 4 个包装的 32 位整数组成) 从内存加载到 dst 中。mem_addr 必须在 16 字节边界上对齐，否则可能会生成一般保护异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_load_epi64.html" title="core::arch::x86::_mm_load_epi64 fn">_mm_load_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 128 位 (由 2 个包装的 64 位整数组成) 从内存加载到 dst 中。mem_addr 必须在 16 字节边界上对齐，否则可能会生成一般保护异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_loadu_epi8.html" title="core::arch::x86::_mm_loadu_epi8 fn">_mm_loadu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 128 位 (由 16 个包装的 8 位整数组成) 从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_loadu_epi16.html" title="core::arch::x86::_mm_loadu_epi16 fn">_mm_loadu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 128 位 (由 8 个包装的 16 位整数组成) 从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_loadu_epi32.html" title="core::arch::x86::_mm_loadu_epi32 fn">_mm_loadu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 128 位 (由 4 个包装的 32 位整数组成) 从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_loadu_epi64.html" title="core::arch::x86::_mm_loadu_epi64 fn">_mm_loadu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 128 位 (由 2 个包装的 64 位整数组成) 从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_lzcnt_epi32.html" title="core::arch::x86::_mm_lzcnt_epi32 fn">_mm_lzcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>计算 a 中每个包装的 32 位整数中前导零位的数目，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_lzcnt_epi64.html" title="core::arch::x86::_mm_lzcnt_epi64 fn">_mm_lzcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>计算 a 中每个包装的 64 位整数中前导零位的数目，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_madd52hi_epu64.html" title="core::arch::x86::_mm_madd52hi_epu64 fn">_mm_madd52hi_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512ifma,avx512vl` only"><code>avx512ifma,avx512vl</code></span><p>将 <code>b</code> 和 <code>c</code> 的每个 64 位元素中的包装无符号 52 位整数相乘以形成 104 位中间结果。
将中间结果的高 52 位无符号整数与 <code>a</code> 中的相应无符号 64 位整数相加，并将结果存储在 <code>dst</code> 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_madd52lo_epu64.html" title="core::arch::x86::_mm_madd52lo_epu64 fn">_mm_madd52lo_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512ifma,avx512vl` only"><code>avx512ifma,avx512vl</code></span><p>将 <code>b</code> 和 <code>c</code> 的每个 64 位元素中的包装无符号 52 位整数相乘以形成 104 位中间结果。
将中间结果的低 52 位无符号整数与 <code>a</code> 中的相应无符号 64 位整数相加，并将结果存储在 <code>dst</code> 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask2_permutex2var_epi8.html" title="core::arch::x86::_mm_mask2_permutex2var_epi8 fn">_mm_mask2_permutex2var_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span><p>使用相应的选择器和 idx 中的索引将 a 和 b 中的 8 位整数跨通道打乱，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask2_permutex2var_epi16.html" title="core::arch::x86::_mm_mask2_permutex2var_epi16 fn">_mm_mask2_permutex2var_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用相应的选择器和 idx 中的索引在通道中的 a 和 b 中对 16 位整数进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 idx 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask2_permutex2var_epi32.html" title="core::arch::x86::_mm_mask2_permutex2var_epi32 fn">_mm_mask2_permutex2var_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用相应的选择器和 idx 中的索引在通道中的 a 和 b 中对 32 位整数进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 idx 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask2_permutex2var_epi64.html" title="core::arch::x86::_mm_mask2_permutex2var_epi64 fn">_mm_mask2_permutex2var_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中随机排列 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 idx 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask2_permutex2var_pd.html" title="core::arch::x86::_mm_mask2_permutex2var_pd fn">_mm_mask2_permutex2var_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 idx 复制元素)</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask2_permutex2var_ps.html" title="core::arch::x86::_mm_mask2_permutex2var_ps fn">_mm_mask2_permutex2var_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的对应选择器和索引在 a 和 b 中的通道中对 a 和 b 中的单精度 (32-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 idx 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fmadd_pd.html" title="core::arch::x86::_mm_mask3_fmadd_pd fn">_mm_mask3_fmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fmadd_ps.html" title="core::arch::x86::_mm_mask3_fmadd_ps fn">_mm_mask3_fmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fmadd_round_sd.html" title="core::arch::x86::_mm_mask3_fmadd_round_sd fn">_mm_mask3_fmadd_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，并将中间结果与较低的元素 in c. Store 的结果相加，使用 writemask k 在 dst 的较低元素中 (当未使用 mask bit 0 时从 c 复制该元素) 设置)，然后将 c 的上部元素复制到 dst 的上部元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fmadd_round_ss.html" title="core::arch::x86::_mm_mask3_fmadd_round_ss fn">_mm_mask3_fmadd_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，并将中间结果加到较低元素 in c. Store 中，并使用 writemask k 将结果存储到 dst 较低元素中 (当未使用 mask bit 0 时从 c 复制该元素) 设置)，然后将 c 的高 3 个包装的元素复制到 dst 的高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fmadd_sd.html" title="core::arch::x86::_mm_mask3_fmadd_sd fn">_mm_mask3_fmadd_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，并将中间结果与较低的元素 in c. Store 的结果相加，使用 writemask k 在 dst 的较低元素中 (当未使用 mask bit 0 时从 c 复制该元素) 设置)，然后将 c 的上部元素复制到 dst 的上部元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fmadd_ss.html" title="core::arch::x86::_mm_mask3_fmadd_ss fn">_mm_mask3_fmadd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，并将中间结果加到较低元素 in c. Store 中，并使用 writemask k 将结果存储到 dst 较低元素中 (当未使用 mask bit 0 时从 c 复制该元素) 设置)，然后将 c 的高 3 个包装的元素复制到 dst 的高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fmaddsub_pd.html" title="core::arch::x86::_mm_mask3_fmaddsub_pd fn">_mm_mask3_fmaddsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在 a 和 b 中分别乘以包装的单精度 (32-bit) 浮点元素，或者在 to/from 中将中间结果乘以包装的元素加减乘以 x，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 c 复制元素) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fmaddsub_ps.html" title="core::arch::x86::_mm_mask3_fmaddsub_ps fn">_mm_mask3_fmaddsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在 a 和 b 中分别乘以包装的单精度 (32-bit) 浮点元素，或者在 to/from 中将中间结果乘以包装的元素加减乘以 x，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 c 复制元素) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fmsub_pd.html" title="core::arch::x86::_mm_mask3_fmsub_pd fn">_mm_mask3_fmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fmsub_ps.html" title="core::arch::x86::_mm_mask3_fmsub_ps fn">_mm_mask3_fmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fmsub_round_sd.html" title="core::arch::x86::_mm_mask3_fmsub_round_sd fn">_mm_mask3_fmsub_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用 writemask k 将结果存储在 dst 的下层元素中 (当掩码位 0 未设置时，从 c 复制元素)，并将 c 上的上层元素复制到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fmsub_round_ss.html" title="core::arch::x86::_mm_mask3_fmsub_round_ss fn">_mm_mask3_fmsub_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高 3 个包装的元素从 c 复制到 dst 的上部元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fmsub_sd.html" title="core::arch::x86::_mm_mask3_fmsub_sd fn">_mm_mask3_fmsub_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用 writemask k 将结果存储在 dst 的下层元素中 (当掩码位 0 未设置时，从 c 复制元素)，并将 c 上的上层元素复制到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fmsub_ss.html" title="core::arch::x86::_mm_mask3_fmsub_ss fn">_mm_mask3_fmsub_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高 3 个包装的元素从 c 复制到 dst 的上部元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fmsubadd_pd.html" title="core::arch::x86::_mm_mask3_fmsubadd_pd fn">_mm_mask3_fmsubadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，并使用 writemask k 将结果存储在 dst 中 (当未使用相应的 mask 位时从 c 复制元素) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fmsubadd_ps.html" title="core::arch::x86::_mm_mask3_fmsubadd_ps fn">_mm_mask3_fmsubadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在 a 和 b 中乘以包装的单精度 (32-bit) 浮点元素，或者在中间结果中减去并在 c from/to 中包装的元素相乘，然后使用 writemask k 将结果存储在 dst 中 (当未使用相应的 mask 位时从 c 复制元素) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fnmadd_pd.html" title="core::arch::x86::_mm_mask3_fnmadd_pd fn">_mm_mask3_fnmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fnmadd_ps.html" title="core::arch::x86::_mm_mask3_fnmadd_ps fn">_mm_mask3_fnmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 c 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fnmadd_round_sd.html" title="core::arch::x86::_mm_mask3_fnmadd_round_sd fn">_mm_mask3_fnmadd_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，然后使用写掩码 k 将求反的中间结果与较低的元素 in c. Store 的结果相加到 dst 的较低元素中 (当掩码位 0 为 0 时从 c 复制该元素) (未设置)，然后将 c 的上部元素复制到 dst 的上部元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fnmadd_round_ss.html" title="core::arch::x86::_mm_mask3_fnmadd_round_ss fn">_mm_mask3_fnmadd_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用写掩码 k 将取反的中间结果与较低元素 in c. Store 的结果相加到 dst 较低元素中 (当掩码位 0 为 0 时从 c 复制该元素) (未设置)，然后将 c 的高 3 个包装的元素复制到 dst 的高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fnmadd_sd.html" title="core::arch::x86::_mm_mask3_fnmadd_sd fn">_mm_mask3_fnmadd_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，然后使用写掩码 k 将求反的中间结果与较低的元素 in c. Store 的结果相加到 dst 的较低元素中 (当掩码位 0 为 0 时从 c 复制该元素) (未设置)，然后将 c 的上部元素复制到 dst 的上部元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fnmadd_ss.html" title="core::arch::x86::_mm_mask3_fnmadd_ss fn">_mm_mask3_fnmadd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用写掩码 k 将取反的中间结果与较低元素 in c. Store 的结果相加到 dst 较低元素中 (当掩码位 0 为 0 时从 c 复制该元素) (未设置)，然后将 c 的高 3 个包装的元素复制到 dst 的高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fnmsub_pd.html" title="core::arch::x86::_mm_mask3_fnmsub_pd fn">_mm_mask3_fnmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fnmsub_ps.html" title="core::arch::x86::_mm_mask3_fnmsub_ps fn">_mm_mask3_fnmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 c 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fnmsub_round_sd.html" title="core::arch::x86::_mm_mask3_fnmsub_round_sd fn">_mm_mask3_fnmsub_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用 writemask k 将结果存储在 dst 的下层元素中 (当掩码位 0 未设置时，从 c 复制元素)，并将 c 上的上层元素复制到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fnmsub_round_ss.html" title="core::arch::x86::_mm_mask3_fnmsub_round_ss fn">_mm_mask3_fnmsub_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高 3 个包装的元素从 c 复制到 dst 的上部元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fnmsub_sd.html" title="core::arch::x86::_mm_mask3_fnmsub_sd fn">_mm_mask3_fnmsub_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用 writemask k 将结果存储在 dst 的下层元素中 (当掩码位 0 未设置时，从 c 复制元素)，并将 c 上的上层元素复制到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask3_fnmsub_ss.html" title="core::arch::x86::_mm_mask3_fnmsub_ss fn">_mm_mask3_fnmsub_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高 3 个包装的元素从 c 复制到 dst 的上部元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_abs_epi8.html" title="core::arch::x86::_mm_mask_abs_epi8 fn">_mm_mask_abs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 中包装的带符号的 8 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_abs_epi16.html" title="core::arch::x86::_mm_mask_abs_epi16 fn">_mm_mask_abs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 中包装的带符号的 16 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_abs_epi32.html" title="core::arch::x86::_mm_mask_abs_epi32 fn">_mm_mask_abs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的有符号 32 位整数的绝对值，并使用 writemask k 将无符号结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_add_epi8.html" title="core::arch::x86::_mm_mask_add_epi8 fn">_mm_mask_add_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>在 a 和 b 中添加包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_add_epi16.html" title="core::arch::x86::_mm_mask_add_epi16 fn">_mm_mask_add_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>在 a 和 b 中添加包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_add_epi32.html" title="core::arch::x86::_mm_mask_add_epi32 fn">_mm_mask_add_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在 a 和 b 中添加包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_add_epi64.html" title="core::arch::x86::_mm_mask_add_epi64 fn">_mm_mask_add_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在 a 和 b 中添加包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_add_pd.html" title="core::arch::x86::_mm_mask_add_pd fn">_mm_mask_add_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_add_ps.html" title="core::arch::x86::_mm_mask_add_ps fn">_mm_mask_add_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_add_round_sd.html" title="core::arch::x86::_mm_mask_add_round_sd fn">_mm_mask_add_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并从中复制较高的元素。a 到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_add_round_ss.html" title="core::arch::x86::_mm_mask_add_round_ss fn">_mm_mask_add_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加较低的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的较低元素中 (当未设置 mask bit 0 时，该元素是从 src 复制的)，并复制高位 3 从 a 到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_add_sd.html" title="core::arch::x86::_mm_mask_add_sd fn">_mm_mask_add_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并从中复制较高的元素。a 到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_add_ss.html" title="core::arch::x86::_mm_mask_add_ss fn">_mm_mask_add_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加较低的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的较低元素中 (当未设置 mask bit 0 时，该元素是从 src 复制的)，并复制高位 3 从 a 到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_adds_epi8.html" title="core::arch::x86::_mm_mask_adds_epi8 fn">_mm_mask_adds_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用饱和度在 a 和 b 中添加包装的带符号的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_adds_epi16.html" title="core::arch::x86::_mm_mask_adds_epi16 fn">_mm_mask_adds_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用饱和度在 a 和 b 中添加包装的带符号的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_adds_epu8.html" title="core::arch::x86::_mm_mask_adds_epu8 fn">_mm_mask_adds_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用饱和度在 a 和 b 中添加包装的无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_adds_epu16.html" title="core::arch::x86::_mm_mask_adds_epu16 fn">_mm_mask_adds_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用饱和度在 a 和 b 中添加包装的无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_alignr_epi8.html" title="core::arch::x86::_mm_mask_alignr_epi8 fn">_mm_mask_alignr_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 和 b 中的 16 字节块对连接成 32 字节的临时结果，将结果右移 imm8 字节，并使用写掩码 k 将低 16 个字节存储在 dst 中 (当相应的掩码位为 1 时，元素从 src 复制没有设置)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_alignr_epi32.html" title="core::arch::x86::_mm_mask_alignr_epi32 fn">_mm_mask_alignr_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 连接成一个 32 字节的 immediate 结果，将结果右移 imm8 个 32 位元素，并使用 writemask k 将低 16 字节 (4 个元素) 存储在 dst 中 (当对应的掩码位为没有设置)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_alignr_epi64.html" title="core::arch::x86::_mm_mask_alignr_epi64 fn">_mm_mask_alignr_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 连接成 32 字节的 immediate 结果，将结果右移 imm8 个 64 位元素，并使用 writemask k 将低 16 字节 (2 个元素) 存储在 dst 中 (当相应的掩码位为没有设置)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_and_epi32.html" title="core::arch::x86::_mm_mask_and_epi32 fn">_mm_mask_and_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在包装的 a 和 b 的 32 位整数元素之间执行逐个元素的按位 AND，使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_and_epi64.html" title="core::arch::x86::_mm_mask_and_epi64 fn">_mm_mask_and_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 64 位整数的按位与，并使用写掩码 k 将结果存储在 dst 中 (如果未设置相应的掩码位，则从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_andnot_epi32.html" title="core::arch::x86::_mm_mask_andnot_epi32 fn">_mm_mask_andnot_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的 32 位整数的按位 NOT，然后与 b 计算 AND，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_andnot_epi64.html" title="core::arch::x86::_mm_mask_andnot_epi64 fn">_mm_mask_andnot_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的 64 位整数的按位 NOT，然后与 b 计算 AND，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_avg_epu8.html" title="core::arch::x86::_mm_mask_avg_epu8 fn">_mm_mask_avg_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 和 b 中包装的无符号 8 位整数平均，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_avg_epu16.html" title="core::arch::x86::_mm_mask_avg_epu16 fn">_mm_mask_avg_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 和 b 中包装的无符号 16 位整数进行平均，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_bitshuffle_epi64_mask.html" title="core::arch::x86::_mm_mask_bitshuffle_epi64_mask fn">_mm_mask_bitshuffle_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span><p>将输入 <code>b</code> 视为包装的 64 位整数，并将 <code>c</code> 视为包装的 8 位整数。
然后将来自 <code>c</code> 的 8 个 8 位值作为索引分组到相应的 64 位整数的位中。
然后，选择这些位并将其包装到输出中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_blend_epi8.html" title="core::arch::x86::_mm_mask_blend_epi8 fn">_mm_mask_blend_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用控制掩码 k 混合 a 和 b 中的包装 8 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_blend_epi16.html" title="core::arch::x86::_mm_mask_blend_epi16 fn">_mm_mask_blend_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用控制掩码 k 混合来自 a 和 b 的包装的 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_blend_epi32.html" title="core::arch::x86::_mm_mask_blend_epi32 fn">_mm_mask_blend_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用控制掩码 k 混合 a 和 b 中的包装 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_blend_epi64.html" title="core::arch::x86::_mm_mask_blend_epi64 fn">_mm_mask_blend_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用控制掩码 k 混合 a 和 b 中的包装 64 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_blend_pd.html" title="core::arch::x86::_mm_mask_blend_pd fn">_mm_mask_blend_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用控制掩码 k 混合来自 a 和 b 的包装后的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_blend_ps.html" title="core::arch::x86::_mm_mask_blend_ps fn">_mm_mask_blend_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用控制掩码 k 混合来自 a 和 b 的包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_broadcastb_epi8.html" title="core::arch::x86::_mm_mask_broadcastb_epi8 fn">_mm_mask_broadcastb_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用写掩码 k 将 d 的低包装的 8 位整数广播到 dst 的所有元素 (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_broadcastd_epi32.html" title="core::arch::x86::_mm_mask_broadcastd_epi32 fn">_mm_mask_broadcastd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用写掩码 k 将低包装的 32 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_broadcastq_epi64.html" title="core::arch::x86::_mm_mask_broadcastq_epi64 fn">_mm_mask_broadcastq_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用写掩码 k 将低包装的 64 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_broadcastss_ps.html" title="core::arch::x86::_mm_mask_broadcastss_ps fn">_mm_mask_broadcastss_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用写掩码 k 将低单精度 (32-bit) 浮点型元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将元素从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_broadcastw_epi16.html" title="core::arch::x86::_mm_mask_broadcastw_epi16 fn">_mm_mask_broadcastw_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用写掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmp_epi8_mask.html" title="core::arch::x86::_mm_mask_cmp_epi8_mask fn">_mm_mask_cmp_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmp_epi16_mask.html" title="core::arch::x86::_mm_mask_cmp_epi16_mask fn">_mm_mask_cmp_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmp_epi32_mask.html" title="core::arch::x86::_mm_mask_cmp_epi32_mask fn">_mm_mask_cmp_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 32 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmp_epi64_mask.html" title="core::arch::x86::_mm_mask_cmp_epi64_mask fn">_mm_mask_cmp_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmp_epu8_mask.html" title="core::arch::x86::_mm_mask_cmp_epu8_mask fn">_mm_mask_cmp_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 8 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmp_epu16_mask.html" title="core::arch::x86::_mm_mask_cmp_epu16_mask fn">_mm_mask_cmp_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmp_epu32_mask.html" title="core::arch::x86::_mm_mask_cmp_epu32_mask fn">_mm_mask_cmp_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 32 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmp_epu64_mask.html" title="core::arch::x86::_mm_mask_cmp_epu64_mask fn">_mm_mask_cmp_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmp_pd_mask.html" title="core::arch::x86::_mm_mask_cmp_pd_mask fn">_mm_mask_cmp_pd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmp_ps_mask.html" title="core::arch::x86::_mm_mask_cmp_ps_mask fn">_mm_mask_cmp_ps_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmp_round_sd_mask.html" title="core::arch::x86::_mm_mask_cmp_round_sd_mask fn">_mm_mask_cmp_round_sd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置掩码位 0 时该元素清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmp_round_ss_mask.html" title="core::arch::x86::_mm_mask_cmp_round_ss_mask fn">_mm_mask_cmp_round_ss_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置掩码位 0 时该元素清零)。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmp_sd_mask.html" title="core::arch::x86::_mm_mask_cmp_sd_mask fn">_mm_mask_cmp_sd_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置掩码位 0 时该元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmp_ss_mask.html" title="core::arch::x86::_mm_mask_cmp_ss_mask fn">_mm_mask_cmp_ss_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>根据 imm8 指定的比较操作数比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置掩码位 0 时该元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpeq_epi8_mask.html" title="core::arch::x86::_mm_mask_cmpeq_epi8_mask fn">_mm_mask_cmpeq_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpeq_epi16_mask.html" title="core::arch::x86::_mm_mask_cmpeq_epi16_mask fn">_mm_mask_cmpeq_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数是否相等，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpeq_epi32_mask.html" title="core::arch::x86::_mm_mask_cmpeq_epi32_mask fn">_mm_mask_cmpeq_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的 32 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpeq_epi64_mask.html" title="core::arch::x86::_mm_mask_cmpeq_epi64_mask fn">_mm_mask_cmpeq_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的 64 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpeq_epu8_mask.html" title="core::arch::x86::_mm_mask_cmpeq_epu8_mask fn">_mm_mask_cmpeq_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpeq_epu16_mask.html" title="core::arch::x86::_mm_mask_cmpeq_epu16_mask fn">_mm_mask_cmpeq_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpeq_epu32_mask.html" title="core::arch::x86::_mm_mask_cmpeq_epu32_mask fn">_mm_mask_cmpeq_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpeq_epu64_mask.html" title="core::arch::x86::_mm_mask_cmpeq_epu64_mask fn">_mm_mask_cmpeq_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpge_epi8_mask.html" title="core::arch::x86::_mm_mask_cmpge_epi8_mask fn">_mm_mask_cmpge_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpge_epi16_mask.html" title="core::arch::x86::_mm_mask_cmpge_epi16_mask fn">_mm_mask_cmpge_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpge_epi32_mask.html" title="core::arch::x86::_mm_mask_cmpge_epi32_mask fn">_mm_mask_cmpge_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数是否等于或大于等于，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpge_epi64_mask.html" title="core::arch::x86::_mm_mask_cmpge_epi64_mask fn">_mm_mask_cmpge_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpge_epu8_mask.html" title="core::arch::x86::_mm_mask_cmpge_epu8_mask fn">_mm_mask_cmpge_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpge_epu16_mask.html" title="core::arch::x86::_mm_mask_cmpge_epu16_mask fn">_mm_mask_cmpge_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否大于等于，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpge_epu32_mask.html" title="core::arch::x86::_mm_mask_cmpge_epu32_mask fn">_mm_mask_cmpge_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpge_epu64_mask.html" title="core::arch::x86::_mm_mask_cmpge_epu64_mask fn">_mm_mask_cmpge_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpgt_epi8_mask.html" title="core::arch::x86::_mm_mask_cmpgt_epi8_mask fn">_mm_mask_cmpgt_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpgt_epi16_mask.html" title="core::arch::x86::_mm_mask_cmpgt_epi16_mask fn">_mm_mask_cmpgt_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpgt_epi32_mask.html" title="core::arch::x86::_mm_mask_cmpgt_epi32_mask fn">_mm_mask_cmpgt_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数是否大于，并将结果使用零掩码 k1 存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpgt_epi64_mask.html" title="core::arch::x86::_mm_mask_cmpgt_epi64_mask fn">_mm_mask_cmpgt_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpgt_epu8_mask.html" title="core::arch::x86::_mm_mask_cmpgt_epu8_mask fn">_mm_mask_cmpgt_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpgt_epu16_mask.html" title="core::arch::x86::_mm_mask_cmpgt_epu16_mask fn">_mm_mask_cmpgt_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpgt_epu32_mask.html" title="core::arch::x86::_mm_mask_cmpgt_epu32_mask fn">_mm_mask_cmpgt_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpgt_epu64_mask.html" title="core::arch::x86::_mm_mask_cmpgt_epu64_mask fn">_mm_mask_cmpgt_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmple_epi8_mask.html" title="core::arch::x86::_mm_mask_cmple_epi8_mask fn">_mm_mask_cmple_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmple_epi16_mask.html" title="core::arch::x86::_mm_mask_cmple_epi16_mask fn">_mm_mask_cmple_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数 (小于或等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmple_epi32_mask.html" title="core::arch::x86::_mm_mask_cmple_epi32_mask fn">_mm_mask_cmple_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmple_epi64_mask.html" title="core::arch::x86::_mm_mask_cmple_epi64_mask fn">_mm_mask_cmple_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数 (小于等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmple_epu8_mask.html" title="core::arch::x86::_mm_mask_cmple_epu8_mask fn">_mm_mask_cmple_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmple_epu16_mask.html" title="core::arch::x86::_mm_mask_cmple_epu16_mask fn">_mm_mask_cmple_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmple_epu32_mask.html" title="core::arch::x86::_mm_mask_cmple_epu32_mask fn">_mm_mask_cmple_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmple_epu64_mask.html" title="core::arch::x86::_mm_mask_cmple_epu64_mask fn">_mm_mask_cmple_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmplt_epi8_mask.html" title="core::arch::x86::_mm_mask_cmplt_epi8_mask fn">_mm_mask_cmplt_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmplt_epi16_mask.html" title="core::arch::x86::_mm_mask_cmplt_epi16_mask fn">_mm_mask_cmplt_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmplt_epi32_mask.html" title="core::arch::x86::_mm_mask_cmplt_epi32_mask fn">_mm_mask_cmplt_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数 (小于或等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmplt_epi64_mask.html" title="core::arch::x86::_mm_mask_cmplt_epi64_mask fn">_mm_mask_cmplt_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmplt_epu8_mask.html" title="core::arch::x86::_mm_mask_cmplt_epu8_mask fn">_mm_mask_cmplt_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmplt_epu16_mask.html" title="core::arch::x86::_mm_mask_cmplt_epu16_mask fn">_mm_mask_cmplt_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数以得到小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmplt_epu32_mask.html" title="core::arch::x86::_mm_mask_cmplt_epu32_mask fn">_mm_mask_cmplt_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmplt_epu64_mask.html" title="core::arch::x86::_mm_mask_cmplt_epu64_mask fn">_mm_mask_cmplt_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpneq_epi8_mask.html" title="core::arch::x86::_mm_mask_cmpneq_epi8_mask fn">_mm_mask_cmpneq_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpneq_epi16_mask.html" title="core::arch::x86::_mm_mask_cmpneq_epi16_mask fn">_mm_mask_cmpneq_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpneq_epi32_mask.html" title="core::arch::x86::_mm_mask_cmpneq_epi32_mask fn">_mm_mask_cmpneq_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的 32 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpneq_epi64_mask.html" title="core::arch::x86::_mm_mask_cmpneq_epi64_mask fn">_mm_mask_cmpneq_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpneq_epu8_mask.html" title="core::arch::x86::_mm_mask_cmpneq_epu8_mask fn">_mm_mask_cmpneq_epu8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpneq_epu16_mask.html" title="core::arch::x86::_mm_mask_cmpneq_epu16_mask fn">_mm_mask_cmpneq_epu16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpneq_epu32_mask.html" title="core::arch::x86::_mm_mask_cmpneq_epu32_mask fn">_mm_mask_cmpneq_epu32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cmpneq_epu64_mask.html" title="core::arch::x86::_mm_mask_cmpneq_epu64_mask fn">_mm_mask_cmpneq_epu64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_compress_epi8.html" title="core::arch::x86::_mm_mask_compress_epi8 fn">_mm_mask_compress_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 a 中的活动 8 位整数 (它们各自的位设置在写掩码 k 中) 连续存储到 dst，并通过 src 中的其余元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_compress_epi16.html" title="core::arch::x86::_mm_mask_compress_epi16 fn">_mm_mask_compress_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 a 中的活动 16 位整数 (它们各自的位设置在写掩码 k 中) 连续存储到 dst，并通过 src 中的其余元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_compress_epi32.html" title="core::arch::x86::_mm_mask_compress_epi32 fn">_mm_mask_compress_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将活动的 32 位整数连续存储在 dst 中 (它们各自的位在写掩码 k 中设置的整数) 到 dst，并通过 src 中的其余元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_compress_epi64.html" title="core::arch::x86::_mm_mask_compress_epi64 fn">_mm_mask_compress_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将活动的 64 位整数连续存储在 dst 中 (它们各自的位在写掩码 k 中设置的整数) 到 dst，并通过 src 中的其余元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_compress_pd.html" title="core::arch::x86::_mm_mask_compress_pd fn">_mm_mask_compress_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将活动的双精度 (64-bit) 浮点元素连续存储在 dst 中 (它们各自的位在写掩码 k 中设置) 到 dst，并通过 src 中的其余元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_compress_ps.html" title="core::arch::x86::_mm_mask_compress_ps fn">_mm_mask_compress_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将活动的单精度 (32-bit) 浮点元素连续存储在 dst 中 (将其各自的位设置在写掩码 k 中的那些元素中) 存储到 dst，并通过 src 中的其余元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_conflict_epi32.html" title="core::arch::x86::_mm_mask_conflict_epi32 fn">_mm_mask_conflict_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>使用写掩码 k (在未设置相应的掩码位时从 src 复制元素)，测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_conflict_epi64.html" title="core::arch::x86::_mm_mask_conflict_epi64 fn">_mm_mask_conflict_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>使用写掩码 k 测试 a 的每个 64 位元素是否与所有其他元素相等 (更接近最低有效位) (当未设置相应的掩码位时，从 src 复制元素)。每个元素的比较在 dst 中形成零扩展位 vector。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvt_roundps_ph.html" title="core::arch::x86::_mm_mask_cvt_roundps_ph fn">_mm_mask_cvt_roundps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvt_roundsd_ss.html" title="core::arch::x86::_mm_mask_cvt_roundsd_ss fn">_mm_mask_cvt_roundsd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的下部双精度 (64-bit) 浮点元素转换为单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一:<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvt_roundss_sd.html" title="core::arch::x86::_mm_mask_cvt_roundss_sd fn">_mm_mask_cvt_roundss_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的下部单精度 (32-bit) 浮点元素转换为双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，然后将上层元素从 a 复制到 dst 的上层元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepi8_epi16.html" title="core::arch::x86::_mm_mask_cvtepi8_epi16 fn">_mm_mask_cvtepi8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用符号将包装的 8 位整数从 a 扩展为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepi8_epi32.html" title="core::arch::x86::_mm_mask_cvtepi8_epi32 fn">_mm_mask_cvtepi8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>符号将包装的 8 位整数从 a 扩展为包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepi8_epi64.html" title="core::arch::x86::_mm_mask_cvtepi8_epi64 fn">_mm_mask_cvtepi8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 的低 2 字节中的 8 位整数符号扩展为包装的 64 位整数，并使用 writemask k 将结果存入 dst 中 (未设置相应掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepi16_epi8.html" title="core::arch::x86::_mm_mask_cvtepi16_epi8 fn">_mm_mask_cvtepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将带有 a 的包装的 16 位整数转换为带截断的 8 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepi16_epi32.html" title="core::arch::x86::_mm_mask_cvtepi16_epi32 fn">_mm_mask_cvtepi16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>符号将包装后的 16 位整数从 a 扩展为包装后的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepi16_epi64.html" title="core::arch::x86::_mm_mask_cvtepi16_epi64 fn">_mm_mask_cvtepi16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用符号将包装的 16 位整数从 a 扩展为包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepi16_storeu_epi8.html" title="core::arch::x86::_mm_mask_cvtepi16_storeu_epi8 fn">_mm_mask_cvtepi16_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的包装的 16 位整数转换为带有截断的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepi32_epi8.html" title="core::arch::x86::_mm_mask_cvtepi32_epi8 fn">_mm_mask_cvtepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将带有 a 的包装的 32 位整数转换为带截断的包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepi32_epi16.html" title="core::arch::x86::_mm_mask_cvtepi32_epi16 fn">_mm_mask_cvtepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepi32_epi64.html" title="core::arch::x86::_mm_mask_cvtepi32_epi64 fn">_mm_mask_cvtepi32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用符号将包装的 32 位整数从 a 扩展为包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepi32_pd.html" title="core::arch::x86::_mm_mask_cvtepi32_pd fn">_mm_mask_cvtepi32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装有符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepi32_ps.html" title="core::arch::x86::_mm_mask_cvtepi32_ps fn">_mm_mask_cvtepi32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装有符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepi32_storeu_epi8.html" title="core::arch::x86::_mm_mask_cvtepi32_storeu_epi8 fn">_mm_mask_cvtepi32_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 32 位整数在 a 中转换为带有截断的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepi32_storeu_epi16.html" title="core::arch::x86::_mm_mask_cvtepi32_storeu_epi16 fn">_mm_mask_cvtepi32_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的 32 位整数转换为带截断的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepi64_epi8.html" title="core::arch::x86::_mm_mask_cvtepi64_epi8 fn">_mm_mask_cvtepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的 64 位整数转换为带有截断的包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepi64_epi16.html" title="core::arch::x86::_mm_mask_cvtepi64_epi16 fn">_mm_mask_cvtepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的 64 位整数转换为带截断的 16 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepi64_epi32.html" title="core::arch::x86::_mm_mask_cvtepi64_epi32 fn">_mm_mask_cvtepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的 64 位整数转换为带截断的 32 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepi64_storeu_epi8.html" title="core::arch::x86::_mm_mask_cvtepi64_storeu_epi8 fn">_mm_mask_cvtepi64_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中包装的 64 位整数转换为包装的 8 位整数并截断，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepi64_storeu_epi16.html" title="core::arch::x86::_mm_mask_cvtepi64_storeu_epi16 fn">_mm_mask_cvtepi64_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的 64 位整数转换为带截断的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepi64_storeu_epi32.html" title="core::arch::x86::_mm_mask_cvtepi64_storeu_epi32 fn">_mm_mask_cvtepi64_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的 64 位整数转换为带截断的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepu8_epi16.html" title="core::arch::x86::_mm_mask_cvtepu8_epi16 fn">_mm_mask_cvtepu8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的包装无符号 8 位整数零扩展为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepu8_epi32.html" title="core::arch::x86::_mm_mask_cvtepu8_epi32 fn">_mm_mask_cvtepu8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>零扩展包装的无符号 8 位整数在 a 的低 4 字节到包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepu8_epi64.html" title="core::arch::x86::_mm_mask_cvtepu8_epi64 fn">_mm_mask_cvtepu8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>零扩展包装的无符号 8 位整数在 a 的低 2 字节到包装的 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepu16_epi32.html" title="core::arch::x86::_mm_mask_cvtepu16_epi32 fn">_mm_mask_cvtepu16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 16 位整数零扩展为包装 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepu16_epi64.html" title="core::arch::x86::_mm_mask_cvtepu16_epi64 fn">_mm_mask_cvtepu16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>零扩展包装的无符号 16 位整数 a 的低 4 字节到包装的 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepu32_epi64.html" title="core::arch::x86::_mm_mask_cvtepu32_epi64 fn">_mm_mask_cvtepu32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 32 位整数零扩展为包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtepu32_pd.html" title="core::arch::x86::_mm_mask_cvtepu32_pd fn">_mm_mask_cvtepu32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 32 位整数转换为包装双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtne2ps_pbh.html" title="core::arch::x86::_mm_mask_cvtne2ps_pbh fn">_mm_mask_cvtne2ps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span><p>将两个 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 writemask k 将结果存储在单个 vector dst 中 (当对应的掩码位为没有设置)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtpd_epi32.html" title="core::arch::x86::_mm_mask_cvtpd_epi32 fn">_mm_mask_cvtpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtpd_epu32.html" title="core::arch::x86::_mm_mask_cvtpd_epu32 fn">_mm_mask_cvtpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtpd_ps.html" title="core::arch::x86::_mm_mask_cvtpd_ps fn">_mm_mask_cvtpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtph_ps.html" title="core::arch::x86::_mm_mask_cvtph_ps fn">_mm_mask_cvtph_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装后的半精度 (16-bit) 浮点元素转换为包装后的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtps_epi32.html" title="core::arch::x86::_mm_mask_cvtps_epi32 fn">_mm_mask_cvtps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtps_epu32.html" title="core::arch::x86::_mm_mask_cvtps_epu32 fn">_mm_mask_cvtps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtps_ph.html" title="core::arch::x86::_mm_mask_cvtps_ph fn">_mm_mask_cvtps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtsd_ss.html" title="core::arch::x86::_mm_mask_cvtsd_ss fn">_mm_mask_cvtsd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的下部双精度 (64-bit) 浮点元素转换为单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtsepi16_epi8.html" title="core::arch::x86::_mm_mask_cvtsepi16_epi8 fn">_mm_mask_cvtsepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的包装带符号的 16 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtsepi16_storeu_epi8.html" title="core::arch::x86::_mm_mask_cvtsepi16_storeu_epi8 fn">_mm_mask_cvtsepi16_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装在 a 中的有符号 16 位整数转换为有符号饱和的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtsepi32_epi8.html" title="core::arch::x86::_mm_mask_cvtsepi32_epi8 fn">_mm_mask_cvtsepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtsepi32_epi16.html" title="core::arch::x86::_mm_mask_cvtsepi32_epi16 fn">_mm_mask_cvtsepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtsepi32_storeu_epi8.html" title="core::arch::x86::_mm_mask_cvtsepi32_storeu_epi8 fn">_mm_mask_cvtsepi32_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装在 a 中的有符号 32 位整数转换为具有符号饱和的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtsepi32_storeu_epi16.html" title="core::arch::x86::_mm_mask_cvtsepi32_storeu_epi16 fn">_mm_mask_cvtsepi32_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装在 a 中的有符号 32 位整数转换为具有符号饱和的包装的 16 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtsepi64_epi8.html" title="core::arch::x86::_mm_mask_cvtsepi64_epi8 fn">_mm_mask_cvtsepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtsepi64_epi16.html" title="core::arch::x86::_mm_mask_cvtsepi64_epi16 fn">_mm_mask_cvtsepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtsepi64_epi32.html" title="core::arch::x86::_mm_mask_cvtsepi64_epi32 fn">_mm_mask_cvtsepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtsepi64_storeu_epi8.html" title="core::arch::x86::_mm_mask_cvtsepi64_storeu_epi8 fn">_mm_mask_cvtsepi64_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtsepi64_storeu_epi16.html" title="core::arch::x86::_mm_mask_cvtsepi64_storeu_epi16 fn">_mm_mask_cvtsepi64_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtsepi64_storeu_epi32.html" title="core::arch::x86::_mm_mask_cvtsepi64_storeu_epi32 fn">_mm_mask_cvtsepi64_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtss_sd.html" title="core::arch::x86::_mm_mask_cvtss_sd fn">_mm_mask_cvtss_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的下部单精度 (32-bit) 浮点元素转换为双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，然后将上层元素从 a 复制到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvttpd_epi32.html" title="core::arch::x86::_mm_mask_cvttpd_epi32 fn">_mm_mask_cvttpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvttpd_epu32.html" title="core::arch::x86::_mm_mask_cvttpd_epu32 fn">_mm_mask_cvttpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvttps_epi32.html" title="core::arch::x86::_mm_mask_cvttps_epi32 fn">_mm_mask_cvttps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvttps_epu32.html" title="core::arch::x86::_mm_mask_cvttps_epu32 fn">_mm_mask_cvttps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtusepi16_epi8.html" title="core::arch::x86::_mm_mask_cvtusepi16_epi8 fn">_mm_mask_cvtusepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtusepi16_storeu_epi8.html" title="core::arch::x86::_mm_mask_cvtusepi16_storeu_epi8 fn">_mm_mask_cvtusepi16_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装在 a 中的无符号 16 位整数转换为具有无符号饱和的包装的无符号 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtusepi32_epi8.html" title="core::arch::x86::_mm_mask_cvtusepi32_epi8 fn">_mm_mask_cvtusepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtusepi32_epi16.html" title="core::arch::x86::_mm_mask_cvtusepi32_epi16 fn">_mm_mask_cvtusepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtusepi32_storeu_epi8.html" title="core::arch::x86::_mm_mask_cvtusepi32_storeu_epi8 fn">_mm_mask_cvtusepi32_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装在 a 中的无符号 32 位整数转换为具有无符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtusepi32_storeu_epi16.html" title="core::arch::x86::_mm_mask_cvtusepi32_storeu_epi16 fn">_mm_mask_cvtusepi32_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装在 a 中的无符号 32 位整数转换为具有无符号饱和的包装的无符号 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtusepi64_epi8.html" title="core::arch::x86::_mm_mask_cvtusepi64_epi8 fn">_mm_mask_cvtusepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtusepi64_epi16.html" title="core::arch::x86::_mm_mask_cvtusepi64_epi16 fn">_mm_mask_cvtusepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtusepi64_epi32.html" title="core::arch::x86::_mm_mask_cvtusepi64_epi32 fn">_mm_mask_cvtusepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtusepi64_storeu_epi8.html" title="core::arch::x86::_mm_mask_cvtusepi64_storeu_epi8 fn">_mm_mask_cvtusepi64_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的无符号 64 位整数在 a 中转换为具有无符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtusepi64_storeu_epi16.html" title="core::arch::x86::_mm_mask_cvtusepi64_storeu_epi16 fn">_mm_mask_cvtusepi64_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装在 a 中的无符号 64 位整数转换为具有无符号饱和的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_cvtusepi64_storeu_epi32.html" title="core::arch::x86::_mm_mask_cvtusepi64_storeu_epi32 fn">_mm_mask_cvtusepi64_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的无符号 64 位整数在 a 中转换为具有无符号饱和的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_dbsad_epu8.html" title="core::arch::x86::_mm_mask_dbsad_epu8 fn">_mm_mask_dbsad_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 中的无符号 8 位整数与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs)，并使用写掩码 k 将 16 位结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。对于每个 64 位通道，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中通道的低 8 位四元组，而后两个 SAD 使用 a 中通道的较高 8 位四元组。根据 imm8 中的控件，从 128 位通道中选择 b 中的四元组，并且每个 64 位通道中的每个 SAD 使用 8 位偏移量的选定四元组。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_div_pd.html" title="core::arch::x86::_mm_mask_div_pd fn">_mm_mask_div_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_div_ps.html" title="core::arch::x86::_mm_mask_div_ps fn">_mm_mask_div_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素除以 b 中的包装的元素，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_div_round_sd.html" title="core::arch::x86::_mm_mask_div_round_sd fn">_mm_mask_div_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的较低双精度 (64-bit) 浮点元素除以 b 中的较低双精度 (64-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 时从 src 复制该元素 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_div_round_ss.html" title="core::arch::x86::_mm_mask_div_round_ss fn">_mm_mask_div_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的下部单精度 (32-bit) 浮点元素除以 b 中的下部单精度 (32-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的下部元素中 (当掩码位 0 时，该元素从 src 复制 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_div_sd.html" title="core::arch::x86::_mm_mask_div_sd fn">_mm_mask_div_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的较低双精度 (64-bit) 浮点元素除以 b 中的较低双精度 (64-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 时从 src 复制该元素 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_div_ss.html" title="core::arch::x86::_mm_mask_div_ss fn">_mm_mask_div_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的下部单精度 (32-bit) 浮点元素除以 b 中的下部单精度 (32-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的下部元素中 (当掩码位 0 时，该元素从 src 复制 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_dpbf16_ps.html" title="core::arch::x86::_mm_mask_dpbf16_ps fn">_mm_mask_dpbf16_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span><p>计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间的单精度 (32-bit) 浮点元素与 src 中的元素相加，并使用 writemask k 将结果存储在 dst 中 (当对应的元素从 src 复制时掩码位未设置)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_dpbusd_epi32.html" title="core::arch::x86::_mm_mask_dpbusd_epi32 fn">_mm_mask_dpbusd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span><p>将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (未设置相应掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_dpbusds_epi32.html" title="core::arch::x86::_mm_mask_dpbusds_epi32 fn">_mm_mask_dpbusds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span><p>将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。使用符号饱和将这 4 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_dpwssd_epi32.html" title="core::arch::x86::_mm_mask_dpwssd_epi32 fn">_mm_mask_dpwssd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span><p>将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_dpwssds_epi32.html" title="core::arch::x86::_mm_mask_dpwssds_epi32 fn">_mm_mask_dpwssds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span><p>将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_expand_epi8.html" title="core::arch::x86::_mm_mask_expand_epi8 fn">_mm_mask_expand_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>从 a 加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_expand_epi16.html" title="core::arch::x86::_mm_mask_expand_epi16 fn">_mm_mask_expand_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>从 a 加载连续的活动 16 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_expand_epi32.html" title="core::arch::x86::_mm_mask_expand_epi32 fn">_mm_mask_expand_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 加载连续的有效 32 位整数 (它们各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_expand_epi64.html" title="core::arch::x86::_mm_mask_expand_epi64 fn">_mm_mask_expand_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 加载连续的有效 64 位整数 (它们各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_expand_pd.html" title="core::arch::x86::_mm_mask_expand_pd fn">_mm_mask_expand_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 加载连续的活动双精度 (64-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_expand_ps.html" title="core::arch::x86::_mm_mask_expand_ps fn">_mm_mask_expand_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中加载连续的活动单精度 (32-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fixupimm_pd.html" title="core::arch::x86::_mm_mask_fixupimm_pd fn">_mm_mask_fixupimm_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 c 中的包装 64 位整数修复 a 和 b 中的包装双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 a 复制元素)。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fixupimm_ps.html" title="core::arch::x86::_mm_mask_fixupimm_ps fn">_mm_mask_fixupimm_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 c 中的包装 32 位整数修复 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 a 复制元素)。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fixupimm_round_sd.html" title="core::arch::x86::_mm_mask_fixupimm_round_sd fn">_mm_mask_fixupimm_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 c 中的较低 64 位整数修复 a 和 b 中的较低双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的较低元素中 (当 mask bit 0 为 0 时从 a 复制该元素 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。imm8 用于设置所需的标志报告。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fixupimm_round_ss.html" title="core::arch::x86::_mm_mask_fixupimm_round_ss fn">_mm_mask_fixupimm_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 c 中的较低 32 位整数修复 a 和 b 中的较低单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的较低元素中 (当 mask bit 0 为 0 时从 a 复制该元素 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。imm8 用于设置所需的标志报告。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fixupimm_sd.html" title="core::arch::x86::_mm_mask_fixupimm_sd fn">_mm_mask_fixupimm_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 c 中的较低 64 位整数修复 a 和 b 中的较低双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的较低元素中 (当 mask bit 0 为 0 时从 a 复制该元素 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fixupimm_ss.html" title="core::arch::x86::_mm_mask_fixupimm_ss fn">_mm_mask_fixupimm_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 c 中的较低 32 位整数修复 a 和 b 中的较低单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的较低元素中 (当 mask bit 0 为 0 时从 a 复制该元素 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fmadd_pd.html" title="core::arch::x86::_mm_mask_fmadd_pd fn">_mm_mask_fmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fmadd_ps.html" title="core::arch::x86::_mm_mask_fmadd_ps fn">_mm_mask_fmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fmadd_round_sd.html" title="core::arch::x86::_mm_mask_fmadd_round_sd fn">_mm_mask_fmadd_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，并使用 writemask k 将中间结果添加到 dst 较低元素中的较低元素 in c. Store 的结果 (当未使用掩码位 0 时从 a 复制该元素) set)，然后将上层元素从 a 复制到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fmadd_round_ss.html" title="core::arch::x86::_mm_mask_fmadd_round_ss fn">_mm_mask_fmadd_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，并将中间结果加到较低元素 in c. Store 中，并使用 writemask k 将结果添加到 dst 较低元素中 (当未使用 mask bit 0 时从 a 复制该元素设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fmadd_sd.html" title="core::arch::x86::_mm_mask_fmadd_sd fn">_mm_mask_fmadd_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，并使用 writemask k 将中间结果添加到 dst 较低元素中的较低元素 in c. Store 的结果 (当未使用掩码位 0 时从 a 复制该元素) set)，然后将上层元素从 a 复制到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fmadd_ss.html" title="core::arch::x86::_mm_mask_fmadd_ss fn">_mm_mask_fmadd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，并将中间结果加到较低元素 in c. Store 中，并使用 writemask k 将结果添加到 dst 较低元素中 (当未使用 mask bit 0 时从 a 复制该元素设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fmaddsub_pd.html" title="core::arch::x86::_mm_mask_fmaddsub_pd fn">_mm_mask_fmaddsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 a 中复制元素放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fmaddsub_ps.html" title="core::arch::x86::_mm_mask_fmaddsub_ps fn">_mm_mask_fmaddsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位则从 a 复制元素放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fmsub_pd.html" title="core::arch::x86::_mm_mask_fmsub_pd fn">_mm_mask_fmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (如果未设置相应的掩码位，则从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fmsub_ps.html" title="core::arch::x86::_mm_mask_fmsub_ps fn">_mm_mask_fmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fmsub_round_sd.html" title="core::arch::x86::_mm_mask_fmsub_round_sd fn">_mm_mask_fmsub_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 a 复制该元素)，然后将 a 的上部元素复制到 dst 的上部元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fmsub_round_ss.html" title="core::arch::x86::_mm_mask_fmsub_round_ss fn">_mm_mask_fmsub_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的低位元素中 (当未设置掩码位 0 时从 a 复制该元素)，并将高 3 个压缩元素从 a 复制到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fmsub_sd.html" title="core::arch::x86::_mm_mask_fmsub_sd fn">_mm_mask_fmsub_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 a 复制该元素)，然后将 a 的上部元素复制到 dst 的上部元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fmsub_ss.html" title="core::arch::x86::_mm_mask_fmsub_ss fn">_mm_mask_fmsub_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。将结果存储在 dst 的下部元素中，并将上部 3 个包装的元素从 a 复制到 dst 的上部元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fmsubadd_pd.html" title="core::arch::x86::_mm_mask_fmsubadd_pd fn">_mm_mask_fmsubadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，并使用 writemask k 将结果存储在 dst 中 (当未使用相应的掩码位时，元素将从 a 复制放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fmsubadd_ps.html" title="core::arch::x86::_mm_mask_fmsubadd_ps fn">_mm_mask_fmsubadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 a 复制元素放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fnmadd_pd.html" title="core::arch::x86::_mm_mask_fnmadd_pd fn">_mm_mask_fnmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fnmadd_ps.html" title="core::arch::x86::_mm_mask_fnmadd_ps fn">_mm_mask_fnmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fnmadd_round_sd.html" title="core::arch::x86::_mm_mask_fnmadd_round_sd fn">_mm_mask_fnmadd_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，然后使用写掩码 k 将求反的中间结果与较低的元素 in c. Store 的结果相加到 dst 的较低元素中 (当掩码位 0 为 0 时从 a 复制 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fnmadd_round_ss.html" title="core::arch::x86::_mm_mask_fnmadd_round_ss fn">_mm_mask_fnmadd_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用写掩码 k 将求反的中间结果与较低元素 in c. Store 的结果相加到 dst 较低元素中 (当掩码位 0 为 0 时，该元素是从 a 复制的 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fnmadd_sd.html" title="core::arch::x86::_mm_mask_fnmadd_sd fn">_mm_mask_fnmadd_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，然后使用写掩码 k 将求反的中间结果与较低的元素 in c. Store 的结果相加到 dst 的较低元素中 (当掩码位 0 为 0 时从 a 复制 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fnmadd_ss.html" title="core::arch::x86::_mm_mask_fnmadd_ss fn">_mm_mask_fnmadd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用写掩码 k 将求反的中间结果与较低元素 in c. Store 的结果相加到 dst 较低元素中 (当掩码位 0 为 0 时，该元素是从 a 复制的 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fnmsub_pd.html" title="core::arch::x86::_mm_mask_fnmsub_pd fn">_mm_mask_fnmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fnmsub_ps.html" title="core::arch::x86::_mm_mask_fnmsub_ps fn">_mm_mask_fnmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fnmsub_round_sd.html" title="core::arch::x86::_mm_mask_fnmsub_round_sd fn">_mm_mask_fnmsub_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的低位元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高位元素从 a 复制到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fnmsub_round_ss.html" title="core::arch::x86::_mm_mask_fnmsub_round_ss fn">_mm_mask_fnmsub_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高 3 个包装的元素从 a 复制到 dst 的上部元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fnmsub_sd.html" title="core::arch::x86::_mm_mask_fnmsub_sd fn">_mm_mask_fnmsub_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的低位元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高位元素从 a 复制到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_fnmsub_ss.html" title="core::arch::x86::_mm_mask_fnmsub_ss fn">_mm_mask_fnmsub_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高 3 个包装的元素从 a 复制到 dst 的上部元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_getexp_pd.html" title="core::arch::x86::_mm_mask_getexp_pd fn">_mm_mask_getexp_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并使用 writemask k 将结果存储在 dst 中 (当相应的 mask 时，元素从 src 复制位未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_getexp_ps.html" title="core::arch::x86::_mm_mask_getexp_ps fn">_mm_mask_getexp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，并使用 writemask k 将结果存储在 dst 中 (当相应的 mask 时，元素从 src 复制位未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_getexp_round_sd.html" title="core::arch::x86::_mm_mask_getexp_round_sd fn">_mm_mask_getexp_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中较低的双精度 (64-bit) 浮点元素的指数转换为表示整数指数的双精度 (64-bit) 浮点数，使用写掩码 k 将结果存储在 dst 的较低元素中 (该元素从 src 复制 (当未设置屏蔽位 0 时)，然后将 a 的高位元素复制到 dst 的高位元素。本质上，此内联函数计算下部元素的 floor(log2(x))。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_getexp_round_ss.html" title="core::arch::x86::_mm_mask_getexp_round_ss fn">_mm_mask_getexp_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中较低的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，使用写掩码 k 将结果存储在 dst 的较低元素中 (该元素从 src 复制 (当未设置掩码位 0 时)，并将高 3 个包装的元素从 a 复制到 dst 的高元素。本质上，此内联函数计算下部元素的 floor(log2(x))。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_getexp_sd.html" title="core::arch::x86::_mm_mask_getexp_sd fn">_mm_mask_getexp_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中较低的双精度 (64-bit) 浮点元素的指数转换为表示整数指数的双精度 (64-bit) 浮点数，使用写掩码 k 将结果存储在 dst 的较低元素中 (该元素从 src 复制 (当未设置屏蔽位 0 时)，然后将 a 的高位元素复制到 dst 的高位元素。本质上，此内联函数计算下部元素的 floor(log2(x))。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_getexp_ss.html" title="core::arch::x86::_mm_mask_getexp_ss fn">_mm_mask_getexp_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中较低的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，使用写掩码 k 将结果存储在 dst 的较低元素中 (该元素从 src 复制 (当未设置掩码位 0 时)，并将高 3 个包装的元素从 a 复制到 dst 的高元素。本质上，此内联函数计算下部元素的 floor(log2(x))。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_getmant_pd.html" title="core::arch::x86::_mm_mask_getmant_pd fn">_mm_mask_getmant_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素的尾数标准化，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_getmant_ps.html" title="core::arch::x86::_mm_mask_getmant_ps fn">_mm_mask_getmant_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>标准化 a 中包装的单精度 (32-bit) 浮点元素的尾数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_getmant_round_sd.html" title="core::arch::x86::_mm_mask_getmant_round_sd fn">_mm_mask_getmant_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>标准化 b 中下部双精度 (64-bit) 浮点元素的尾数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部元素从 a 到 dst 的高位元素。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_getmant_round_ss.html" title="core::arch::x86::_mm_mask_getmant_round_ss fn">_mm_mask_getmant_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>标准化 b 中较低单精度 (32-bit) 浮点元素的尾数，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制高 3 从 a 到 dst 的上层元素的包装的元素。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_getmant_sd.html" title="core::arch::x86::_mm_mask_getmant_sd fn">_mm_mask_getmant_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>标准化 b 中下部双精度 (64-bit) 浮点元素的尾数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部元素从 a 到 dst 的高位元素。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_getmant_ss.html" title="core::arch::x86::_mm_mask_getmant_ss fn">_mm_mask_getmant_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>标准化 b 中较低单精度 (32-bit) 浮点元素的尾数，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制高 3 从 a 到 dst 的上层元素的包装的元素。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_gf2p8affine_epi64_epi8.html" title="core::arch::x86::_mm_mask_gf2p8affine_epi64_epi8 fn">_mm_mask_gf2p8affine_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span><p>对 x 中的包装字节执行仿射变换。
也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_gf2p8affineinv_epi64_epi8.html" title="core::arch::x86::_mm_mask_gf2p8affineinv_epi64_epi8 fn">_mm_mask_gf2p8affineinv_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span><p>对 x 中的反向包装的字节执行仿射变换。
也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_gf2p8mul_epi8.html" title="core::arch::x86::_mm_mask_gf2p8mul_epi8 fn">_mm_mask_gf2p8mul_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span><p>在包装的字节上执行 GF(2^8) 乘法。
该字段以多项式表示，具有约数多项式 x^8 + x^4 + x^3 + x + 1。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_lzcnt_epi32.html" title="core::arch::x86::_mm_mask_lzcnt_epi32 fn">_mm_mask_lzcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>计算 a 中每个包装的 32 位整数中前导零位的数目，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_lzcnt_epi64.html" title="core::arch::x86::_mm_mask_lzcnt_epi64 fn">_mm_mask_lzcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>计算 a 中每个包装的 64 位整数中前导零位的数目，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_madd_epi16.html" title="core::arch::x86::_mm_mask_madd_epi16 fn">_mm_mask_madd_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。水平添加相邻的中间 32 位整数对，并使用 writemask k 将结果打包到 dst (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_maddubs_epi16.html" title="core::arch::x86::_mm_mask_maddubs_epi16 fn">_mm_mask_maddubs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的包装无符号 8 位整数与 b 中的包装有符号 8 位整数相乘，生成中间有符号的 16 位整数。水平相加相邻的中间带符号的 16 位整数对，并使用写掩码 k 将饱和结果包装到 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_max_epi8.html" title="core::arch::x86::_mm_mask_max_epi8 fn">_mm_mask_max_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_max_epi16.html" title="core::arch::x86::_mm_mask_max_epi16 fn">_mm_mask_max_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 16 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_max_epi32.html" title="core::arch::x86::_mm_mask_max_epi32 fn">_mm_mask_max_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_max_epi64.html" title="core::arch::x86::_mm_mask_max_epi64 fn">_mm_mask_max_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_max_epu8.html" title="core::arch::x86::_mm_mask_max_epu8 fn">_mm_mask_max_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_max_epu16.html" title="core::arch::x86::_mm_mask_max_epu16 fn">_mm_mask_max_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_max_epu32.html" title="core::arch::x86::_mm_mask_max_epu32 fn">_mm_mask_max_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_max_epu64.html" title="core::arch::x86::_mm_mask_max_epu64 fn">_mm_mask_max_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_max_pd.html" title="core::arch::x86::_mm_mask_max_pd fn">_mm_mask_max_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_max_ps.html" title="core::arch::x86::_mm_mask_max_ps fn">_mm_mask_max_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_max_round_sd.html" title="core::arch::x86::_mm_mask_max_round_sd fn">_mm_mask_max_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将最大值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的元素从 a 到 dst 的高位元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_max_round_ss.html" title="core::arch::x86::_mm_mask_max_round_ss fn">_mm_mask_max_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用写掩码 k 将最大值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的 3 从 a 到 dst 的上层元素的包装的元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_max_sd.html" title="core::arch::x86::_mm_mask_max_sd fn">_mm_mask_max_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将最大值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的元素从 a 到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_max_ss.html" title="core::arch::x86::_mm_mask_max_ss fn">_mm_mask_max_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用写掩码 k 将最大值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的 3 从 a 到 dst 的上层元素的包装的元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_min_epi8.html" title="core::arch::x86::_mm_mask_min_epi8 fn">_mm_mask_min_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_min_epi16.html" title="core::arch::x86::_mm_mask_min_epi16 fn">_mm_mask_min_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号 16 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_min_epi32.html" title="core::arch::x86::_mm_mask_min_epi32 fn">_mm_mask_min_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_min_epu8.html" title="core::arch::x86::_mm_mask_min_epu8 fn">_mm_mask_min_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_min_epu16.html" title="core::arch::x86::_mm_mask_min_epu16 fn">_mm_mask_min_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_min_epu32.html" title="core::arch::x86::_mm_mask_min_epu32 fn">_mm_mask_min_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_min_epu64.html" title="core::arch::x86::_mm_mask_min_epu64 fn">_mm_mask_min_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_min_pd.html" title="core::arch::x86::_mm_mask_min_pd fn">_mm_mask_min_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_min_ps.html" title="core::arch::x86::_mm_mask_min_ps fn">_mm_mask_min_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_min_round_sd.html" title="core::arch::x86::_mm_mask_min_round_sd fn">_mm_mask_min_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将最小值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，然后复制较高的元素从 a 到 dst 的高位元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_min_round_ss.html" title="core::arch::x86::_mm_mask_min_round_ss fn">_mm_mask_min_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用写掩码 k 将最小值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的 3 从 a 到 dst 的上层元素的包装的元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_min_sd.html" title="core::arch::x86::_mm_mask_min_sd fn">_mm_mask_min_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将最小值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，然后复制较高的元素从 a 到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_min_ss.html" title="core::arch::x86::_mm_mask_min_ss fn">_mm_mask_min_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用写掩码 k 将最小值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的 3 从 a 到 dst 的上层元素的包装的元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_mov_epi8.html" title="core::arch::x86::_mm_mask_mov_epi8 fn">_mm_mask_mov_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用写掩码 k 将包装的 8 位整数从 a 移到 dst (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_mov_epi16.html" title="core::arch::x86::_mm_mask_mov_epi16 fn">_mm_mask_mov_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用写掩码 k 将包装的 16 位整数从 a 移到 dst (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_mov_epi32.html" title="core::arch::x86::_mm_mask_mov_epi32 fn">_mm_mask_mov_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用写掩码 k 将包装的 32 位整数从 a 移动到 dst (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_mov_epi64.html" title="core::arch::x86::_mm_mask_mov_epi64 fn">_mm_mask_mov_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用写掩码 k 将包装的 64 位整数从 a 移动到 dst (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_mov_pd.html" title="core::arch::x86::_mm_mask_mov_pd fn">_mm_mask_mov_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用写掩码 k 将包装的双精度 (64-bit) 浮点元素从 a 移动到 dst (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_mov_ps.html" title="core::arch::x86::_mm_mask_mov_ps fn">_mm_mask_mov_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用写掩码 k 将包装的单精度 (32-bit) 浮点元素从 a 移动到 dst (未设置相应的掩码位时，将从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_move_sd.html" title="core::arch::x86::_mm_mask_move_sd fn">_mm_mask_move_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用写掩码 k 将低位双精度 (64-bit) 浮点元素从 b 移到 dst 的低位元素 (当未设置掩码位 0 时从 src 复制该元素)，并将高位元素从 a 复制到 a 的高位元素 dst。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_move_ss.html" title="core::arch::x86::_mm_mask_move_ss fn">_mm_mask_move_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用写掩码 k 将低位单精度 (32-bit) 浮点元素从 b 移到 dst 的低位元素 (当未设置掩码位 0 时从 src 复制该元素)，并将高 3 个包装的元素从 a 复制到高位 dst 的元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_movedup_pd.html" title="core::arch::x86::_mm_mask_movedup_pd fn">_mm_mask_movedup_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 复制偶数索引的双精度 (64-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_movehdup_ps.html" title="core::arch::x86::_mm_mask_movehdup_ps fn">_mm_mask_movehdup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 复制奇数索引的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_moveldup_ps.html" title="core::arch::x86::_mm_mask_moveldup_ps fn">_mm_mask_moveldup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 复制偶数索引的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_mul_epi32.html" title="core::arch::x86::_mm_mask_mul_epi32 fn">_mm_mask_mul_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中每个包装的 64 位元素的低符号 32 位整数相乘，并使用写掩码 k 将有符号的 64 位结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_mul_epu32.html" title="core::arch::x86::_mm_mask_mul_epu32 fn">_mm_mask_mul_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中每个包装的 64 位元素的低无符号 32 位整数相乘，并使用写掩码 k 将无符号 64 位结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_mul_pd.html" title="core::arch::x86::_mm_mask_mul_pd fn">_mm_mask_mul_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_mul_ps.html" title="core::arch::x86::_mm_mask_mul_ps fn">_mm_mask_mul_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_mul_round_sd.html" title="core::arch::x86::_mm_mask_mul_round_sd fn">_mm_mask_mul_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的下部双精度 (64-bit) 浮点元素相乘，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并从中复制上部元素。a 到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_mul_round_ss.html" title="core::arch::x86::_mm_mask_mul_round_ss fn">_mm_mask_mul_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的下部单精度 (32-bit) 浮点元素相乘，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制包装后的高 3 位元素从 a 到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_mul_sd.html" title="core::arch::x86::_mm_mask_mul_sd fn">_mm_mask_mul_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的下部双精度 (64-bit) 浮点元素相乘，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并从中复制上部元素。a 到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_mul_ss.html" title="core::arch::x86::_mm_mask_mul_ss fn">_mm_mask_mul_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的下部单精度 (32-bit) 浮点元素相乘，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制包装后的高 3 位元素从 a 到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_mulhi_epi16.html" title="core::arch::x86::_mm_mask_mulhi_epi16 fn">_mm_mask_mulhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 和 b 中包装的带符号的 16 位整数相乘，生成 32 位中间整数，并使用写掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_mulhi_epu16.html" title="core::arch::x86::_mm_mask_mulhi_epu16 fn">_mm_mask_mulhi_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 和 b 中包装的无符号 16 位整数相乘，生成 32 位中间整数，并使用写掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_mulhrs_epi16.html" title="core::arch::x86::_mm_mask_mulhrs_epi16 fn">_mm_mask_mulhrs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。将每个中间整数截断为 18 个最高有效位，通过加 1 舍入，并使用 writemask k 将位 [16:1] 存储到 dst (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_mullo_epi16.html" title="core::arch::x86::_mm_mask_mullo_epi16 fn">_mm_mask_mullo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 和 b 中的包装的 16 位整数相乘，生成中间的 32 位整数，并使用写掩码 k 将中间整数的低 16 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_mullo_epi32.html" title="core::arch::x86::_mm_mask_mullo_epi32 fn">_mm_mask_mullo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装的 32 位整数相乘，生成中间 64 位整数，并使用写掩码 k 将中间整数的低 32 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_multishift_epi64_epi8.html" title="core::arch::x86::_mm_mask_multishift_epi64_epi8 fn">_mm_mask_multishift_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span><p>对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并使用 writemask k (元素当相应的屏蔽位未设置时，从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_or_epi32.html" title="core::arch::x86::_mm_mask_or_epi32 fn">_mm_mask_or_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 32 位整数的按位或，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_or_epi64.html" title="core::arch::x86::_mm_mask_or_epi64 fn">_mm_mask_or_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 64 位整数的按位或，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_packs_epi16.html" title="core::arch::x86::_mm_mask_packs_epi16 fn">_mm_mask_packs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用带符号的饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_packs_epi32.html" title="core::arch::x86::_mm_mask_packs_epi32 fn">_mm_mask_packs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用带符号的饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_packus_epi16.html" title="core::arch::x86::_mm_mask_packus_epi16 fn">_mm_mask_packus_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用无符号饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_packus_epi32.html" title="core::arch::x86::_mm_mask_packus_epi32 fn">_mm_mask_packus_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用无符号饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_permute_pd.html" title="core::arch::x86::_mm_mask_permute_pd fn">_mm_mask_permute_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件在 128 位通道内对双精度 (64-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_permute_ps.html" title="core::arch::x86::_mm_mask_permute_ps fn">_mm_mask_permute_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_permutevar_pd.html" title="core::arch::x86::_mm_mask_permutevar_pd fn">_mm_mask_permutevar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 b 中的控件在 128 位通道内将 a 的双精度 (64-bit) 浮点元素进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_permutevar_ps.html" title="core::arch::x86::_mm_mask_permutevar_ps fn">_mm_mask_permutevar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 b 中的控件在 128 位通道内将 a 的单精度 (32-bit) 浮点元素打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_permutex2var_epi8.html" title="core::arch::x86::_mm_mask_permutex2var_epi8 fn">_mm_mask_permutex2var_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span><p>使用相应的选择器和 idx 中的索引将 a 和 b 中的 8 位整数跨通道打乱，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_permutex2var_epi16.html" title="core::arch::x86::_mm_mask_permutex2var_epi16 fn">_mm_mask_permutex2var_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用相应的选择器和 idx 中的索引在通道中的 a 和 b 中对 16 位整数进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_permutex2var_epi32.html" title="core::arch::x86::_mm_mask_permutex2var_epi32 fn">_mm_mask_permutex2var_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中对 32 位整数进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_permutex2var_epi64.html" title="core::arch::x86::_mm_mask_permutex2var_epi64 fn">_mm_mask_permutex2var_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中随机排列 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_permutex2var_pd.html" title="core::arch::x86::_mm_mask_permutex2var_pd fn">_mm_mask_permutex2var_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_permutex2var_ps.html" title="core::arch::x86::_mm_mask_permutex2var_ps fn">_mm_mask_permutex2var_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用对应的选择器和 idx 中的索引在 a 和 b 中的通道上对 a 和 b 中的单精度 (32-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_permutexvar_epi8.html" title="core::arch::x86::_mm_mask_permutexvar_epi8 fn">_mm_mask_permutexvar_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span><p>使用 idx 中的相应索引在跨通道的 a 中打乱 8 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_permutexvar_epi16.html" title="core::arch::x86::_mm_mask_permutexvar_epi16 fn">_mm_mask_permutexvar_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用 idx 中的相应索引在跨通道中对 16 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_popcnt_epi8.html" title="core::arch::x86::_mm_mask_popcnt_epi8 fn">_mm_mask_popcnt_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span><p>对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_popcnt_epi16.html" title="core::arch::x86::_mm_mask_popcnt_epi16 fn">_mm_mask_popcnt_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span><p>对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_popcnt_epi32.html" title="core::arch::x86::_mm_mask_popcnt_epi32 fn">_mm_mask_popcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq,avx512vl` only"><code>avx512vpopcntdq,avx512vl</code></span><p>对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_popcnt_epi64.html" title="core::arch::x86::_mm_mask_popcnt_epi64 fn">_mm_mask_popcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq,avx512vl` only"><code>avx512vpopcntdq,avx512vl</code></span><p>对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_rcp14_pd.html" title="core::arch::x86::_mm_mask_rcp14_pd fn">_mm_mask_rcp14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_rcp14_ps.html" title="core::arch::x86::_mm_mask_rcp14_ps fn">_mm_mask_rcp14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_rcp14_sd.html" title="core::arch::x86::_mm_mask_rcp14_sd fn">_mm_mask_rcp14_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 b 中较低的双精度 (64-bit) 浮点元素的近似倒数，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的 x 元素从 a 到 dst 的高位元素。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_rcp14_ss.html" title="core::arch::x86::_mm_mask_rcp14_ss fn">_mm_mask_rcp14_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 b 中下部单精度 (32-bit) 浮点元素的近似倒数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部从 a 到 dst 的上层元素的 3 个包装的元素。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_rol_epi32.html" title="core::arch::x86::_mm_mask_rol_epi32 fn">_mm_mask_rol_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_rol_epi64.html" title="core::arch::x86::_mm_mask_rol_epi64 fn">_mm_mask_rol_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_rolv_epi32.html" title="core::arch::x86::_mm_mask_rolv_epi32 fn">_mm_mask_rolv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的 32 位整数中的位向左旋转 b 对应元素 b 中指定的位数，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 src 复制元素放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_rolv_epi64.html" title="core::arch::x86::_mm_mask_rolv_epi64 fn">_mm_mask_rolv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的 64 位整数中的位向左旋转 b 的对应元素中指定的位数，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 src 复制元素放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_ror_epi32.html" title="core::arch::x86::_mm_mask_ror_epi32 fn">_mm_mask_ror_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 X 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_ror_epi64.html" title="core::arch::x86::_mm_mask_ror_epi64 fn">_mm_mask_ror_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 X 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_rorv_epi32.html" title="core::arch::x86::_mm_mask_rorv_epi32 fn">_mm_mask_rorv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的 32 位整数中的位向右旋转 b 的对应元素中指定的位数，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 src 复制元素放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_rorv_epi64.html" title="core::arch::x86::_mm_mask_rorv_epi64 fn">_mm_mask_rorv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 src 复制元素放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_roundscale_pd.html" title="core::arch::x86::_mm_mask_roundscale_pd fn">_mm_mask_roundscale_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_roundscale_ps.html" title="core::arch::x86::_mm_mask_roundscale_ps fn">_mm_mask_roundscale_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的小数位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_roundscale_round_sd.html" title="core::arch::x86::_mm_mask_roundscale_round_sd fn">_mm_mask_roundscale_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的下部双精度 (64-bit) 浮点元素四舍五入为 imm8 指定的分数位数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时，该元素从 src 复制)，然后将上层元素从 a 复制到 dst 的上层元素。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_roundscale_round_ss.html" title="core::arch::x86::_mm_mask_roundscale_round_ss fn">_mm_mask_roundscale_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的下部单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时，该元素从 src 复制)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_roundscale_sd.html" title="core::arch::x86::_mm_mask_roundscale_sd fn">_mm_mask_roundscale_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的下部双精度 (64-bit) 浮点元素四舍五入为 imm8 指定的分数位数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时，该元素从 src 复制)，然后将上层元素从 a 复制到 dst 的上层元素。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_roundscale_ss.html" title="core::arch::x86::_mm_mask_roundscale_ss fn">_mm_mask_roundscale_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的下部单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时，该元素从 src 复制)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_rsqrt14_pd.html" title="core::arch::x86::_mm_mask_rsqrt14_pd fn">_mm_mask_rsqrt14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_rsqrt14_ps.html" title="core::arch::x86::_mm_mask_rsqrt14_ps fn">_mm_mask_rsqrt14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_rsqrt14_sd.html" title="core::arch::x86::_mm_mask_rsqrt14_sd fn">_mm_mask_rsqrt14_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 b 中较低的双精度 (64-bit) 浮点元素的近似平方根，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，然后复制从 a 到 dst 的上元素的上元素。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_rsqrt14_ss.html" title="core::arch::x86::_mm_mask_rsqrt14_ss fn">_mm_mask_rsqrt14_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 b 中较低单精度 (32-bit) 浮点元素的近似倒数平方根，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，然后复制从 a 到 dst 的高位元素的前 3 个包装的元素。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_scalef_pd.html" title="core::arch::x86::_mm_mask_scalef_pd fn">_mm_mask_scalef_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_scalef_ps.html" title="core::arch::x86::_mm_mask_scalef_ps fn">_mm_mask_scalef_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_scalef_round_sd.html" title="core::arch::x86::_mm_mask_scalef_round_sd fn">_mm_mask_scalef_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的值缩放 a 中的包装双精度 (64-bit) 浮点元素，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部元素从 a 到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_scalef_round_ss.html" title="core::arch::x86::_mm_mask_scalef_round_ss fn">_mm_mask_scalef_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的下部元素 (未设置 mask bit 0 时从 src 复制该元素)，并复制上部从 a 到 dst 的上层元素的 3 个包装的元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_scalef_sd.html" title="core::arch::x86::_mm_mask_scalef_sd fn">_mm_mask_scalef_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的值缩放 a 中的包装双精度 (64-bit) 浮点元素，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部元素从 a 到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_scalef_ss.html" title="core::arch::x86::_mm_mask_scalef_ss fn">_mm_mask_scalef_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的下部元素 (未设置 mask bit 0 时从 src 复制该元素)，并复制上部从 a 到 dst 的上层元素的 3 个包装的元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_set1_epi8.html" title="core::arch::x86::_mm_mask_set1_epi8 fn">_mm_mask_set1_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用写掩码 k 将 8 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_set1_epi16.html" title="core::arch::x86::_mm_mask_set1_epi16 fn">_mm_mask_set1_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用写掩码 k 向 dst 的所有元素广播 16 位整数 a (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_set1_epi32.html" title="core::arch::x86::_mm_mask_set1_epi32 fn">_mm_mask_set1_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用写掩码 k 将 32 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_set1_epi64.html" title="core::arch::x86::_mm_mask_set1_epi64 fn">_mm_mask_set1_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用写掩码 k 将 64 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_shldi_epi16.html" title="core::arch::x86::_mm_mask_shldi_epi16 fn">_mm_mask_shldi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并使用 writemask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_shldi_epi32.html" title="core::arch::x86::_mm_mask_shldi_epi32 fn">_mm_mask_shldi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并使用 writemask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_shldi_epi64.html" title="core::arch::x86::_mm_mask_shldi_epi64 fn">_mm_mask_shldi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并使用 writemask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_shldv_epi16.html" title="core::arch::x86::_mm_mask_shldv_epi16 fn">_mm_mask_shldv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_shldv_epi32.html" title="core::arch::x86::_mm_mask_shldv_epi32 fn">_mm_mask_shldv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_shldv_epi64.html" title="core::arch::x86::_mm_mask_shldv_epi64 fn">_mm_mask_shldv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_shrdi_epi16.html" title="core::arch::x86::_mm_mask_shrdi_epi16 fn">_mm_mask_shrdi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并使用 writemask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_shrdi_epi32.html" title="core::arch::x86::_mm_mask_shrdi_epi32 fn">_mm_mask_shrdi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并使用 writemask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_shrdi_epi64.html" title="core::arch::x86::_mm_mask_shrdi_epi64 fn">_mm_mask_shrdi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并使用 writemask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，元素从 src` 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_shrdv_epi16.html" title="core::arch::x86::_mm_mask_shrdv_epi16 fn">_mm_mask_shrdv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_shrdv_epi32.html" title="core::arch::x86::_mm_mask_shrdv_epi32 fn">_mm_mask_shrdv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_shrdv_epi64.html" title="core::arch::x86::_mm_mask_shrdv_epi64 fn">_mm_mask_shrdv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_shuffle_epi8.html" title="core::arch::x86::_mm_mask_shuffle_epi8 fn">_mm_mask_shuffle_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用 b 中相应的 8 位元素中的控件在 128 位通道内对 a 中的 8 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_shuffle_epi32.html" title="core::arch::x86::_mm_mask_shuffle_epi32 fn">_mm_mask_shuffle_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件将 128 位通道中的 32 位整数随机排列，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_shuffle_pd.html" title="core::arch::x86::_mm_mask_shuffle_pd fn">_mm_mask_shuffle_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件对 128 位通道中的双精度 (64-bit) 浮点元素进行混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_shuffle_ps.html" title="core::arch::x86::_mm_mask_shuffle_ps fn">_mm_mask_shuffle_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件 shuffle a 中的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_shufflehi_epi16.html" title="core::arch::x86::_mm_mask_shufflehi_epi16 fn">_mm_mask_shufflehi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用 imm8 中的控件在 a 的 128 位通道的高 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的高 64 位中，将 128 位通道的低 64 位从 a 复制到 dst，使用写掩码 k (当相应的掩码位不存在时，元素从 src 复制放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_shufflelo_epi16.html" title="core::arch::x86::_mm_mask_shufflelo_epi16 fn">_mm_mask_shufflelo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用 imm8 中的控件在 a 的 128 位通道的低 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的低 64 位中，并使用写掩码 k 将 128 位通道的高 64 位从 a 复制到 dst (当未使用相应的掩码位时，元素从 src 复制) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sll_epi16.html" title="core::arch::x86::_mm_mask_sll_epi16 fn">_mm_mask_sll_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数按计数左移，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sll_epi32.html" title="core::arch::x86::_mm_mask_sll_epi32 fn">_mm_mask_sll_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 32 位整数左移计数，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sll_epi64.html" title="core::arch::x86::_mm_mask_sll_epi64 fn">_mm_mask_sll_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 64 位整数左移计数，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_slli_epi16.html" title="core::arch::x86::_mm_mask_slli_epi16 fn">_mm_mask_slli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数左移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_slli_epi32.html" title="core::arch::x86::_mm_mask_slli_epi32 fn">_mm_mask_slli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 32 位整数左移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_slli_epi64.html" title="core::arch::x86::_mm_mask_slli_epi64 fn">_mm_mask_slli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 64 位整数向左移动 imm8，同时向零移动，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sllv_epi16.html" title="core::arch::x86::_mm_mask_sllv_epi16 fn">_mm_mask_sllv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数按 count 中相应元素指定的数量向左移位，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sllv_epi32.html" title="core::arch::x86::_mm_mask_sllv_epi32 fn">_mm_mask_sllv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将填充的 32 位整数向左移动计数中相应元素指定的数量，同时将其移位为零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sllv_epi64.html" title="core::arch::x86::_mm_mask_sllv_epi64 fn">_mm_mask_sllv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将填充的 64 位整数向左移动 count 中相应元素指定的数量，同时将其移位为零，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sqrt_pd.html" title="core::arch::x86::_mm_mask_sqrt_pd fn">_mm_mask_sqrt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sqrt_ps.html" title="core::arch::x86::_mm_mask_sqrt_ps fn">_mm_mask_sqrt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sqrt_round_sd.html" title="core::arch::x86::_mm_mask_sqrt_round_sd fn">_mm_mask_sqrt_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 b 中下部双精度 (64-bit) 浮点元素的平方根，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部元素从 a 到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sqrt_round_ss.html" title="core::arch::x86::_mm_mask_sqrt_round_ss fn">_mm_mask_sqrt_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 b 中下部单精度 (32-bit) 浮点元素的平方根，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部从 a 到 dst 的上层元素的 3 个包装的元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sqrt_sd.html" title="core::arch::x86::_mm_mask_sqrt_sd fn">_mm_mask_sqrt_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 b 中下部双精度 (64-bit) 浮点元素的平方根，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部元素从 a 到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sqrt_ss.html" title="core::arch::x86::_mm_mask_sqrt_ss fn">_mm_mask_sqrt_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 b 中下部单精度 (32-bit) 浮点元素的平方根，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部从 a 到 dst 的上层元素的 3 个包装的元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sra_epi16.html" title="core::arch::x86::_mm_mask_sra_epi16 fn">_mm_mask_sra_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数按计数右移，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sra_epi32.html" title="core::arch::x86::_mm_mask_sra_epi32 fn">_mm_mask_sra_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在移动符号位的同时右移计数包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sra_epi64.html" title="core::arch::x86::_mm_mask_sra_epi64 fn">_mm_mask_sra_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在移动符号位的同时右移计数包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_srai_epi16.html" title="core::arch::x86::_mm_mask_srai_epi16 fn">_mm_mask_srai_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_srai_epi32.html" title="core::arch::x86::_mm_mask_srai_epi32 fn">_mm_mask_srai_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 32 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_srai_epi64.html" title="core::arch::x86::_mm_mask_srai_epi64 fn">_mm_mask_srai_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 64 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_srav_epi16.html" title="core::arch::x86::_mm_mask_srav_epi16 fn">_mm_mask_srav_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数右移 count 中相应元素指定的数量，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_srav_epi32.html" title="core::arch::x86::_mm_mask_srav_epi32 fn">_mm_mask_srav_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在将符号位移位的同时，将已包装的 32 位整数向右移动计数中相应元素指定的数量，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_srav_epi64.html" title="core::arch::x86::_mm_mask_srav_epi64 fn">_mm_mask_srav_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在移入符号位的同时，将包装的 64 位整数向右移动计数中相应元素指定的数量，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_srl_epi16.html" title="core::arch::x86::_mm_mask_srl_epi16 fn">_mm_mask_srl_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数右移，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_srl_epi32.html" title="core::arch::x86::_mm_mask_srl_epi32 fn">_mm_mask_srl_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 32 位整数右移，同时移零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_srl_epi64.html" title="core::arch::x86::_mm_mask_srl_epi64 fn">_mm_mask_srl_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 64 位整数右移，同时移零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_srli_epi16.html" title="core::arch::x86::_mm_mask_srli_epi16 fn">_mm_mask_srli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_srli_epi32.html" title="core::arch::x86::_mm_mask_srli_epi32 fn">_mm_mask_srli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 32 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_srli_epi64.html" title="core::arch::x86::_mm_mask_srli_epi64 fn">_mm_mask_srli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 64 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_srlv_epi16.html" title="core::arch::x86::_mm_mask_srlv_epi16 fn">_mm_mask_srlv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_srlv_epi32.html" title="core::arch::x86::_mm_mask_srlv_epi32 fn">_mm_mask_srlv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>向右移动包装的 32 位整数整数 (由 count 中相应元素指定的数量)，同时向零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_srlv_epi64.html" title="core::arch::x86::_mm_mask_srlv_epi64 fn">_mm_mask_srlv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>向右移位包装的 64 位整数，其数量为计数中相应元素指定的数量，同时向零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sub_epi8.html" title="core::arch::x86::_mm_mask_sub_epi8 fn">_mm_mask_sub_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>从 a 中的包装 8 位整数中减去 b 中的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sub_epi16.html" title="core::arch::x86::_mm_mask_sub_epi16 fn">_mm_mask_sub_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>从 a 中的包装的 16 位整数中减去 b 中的包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sub_epi32.html" title="core::arch::x86::_mm_mask_sub_epi32 fn">_mm_mask_sub_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中的包装 32 位整数中减去 b 中的包装 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sub_epi64.html" title="core::arch::x86::_mm_mask_sub_epi64 fn">_mm_mask_sub_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中的包装 64 位整数中减去 b 中的包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sub_pd.html" title="core::arch::x86::_mm_mask_sub_pd fn">_mm_mask_sub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sub_ps.html" title="core::arch::x86::_mm_mask_sub_ps fn">_mm_mask_sub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 b 中的包装后的单精度 (32-bit) 浮点元素减去 a 中的包装后的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sub_round_sd.html" title="core::arch::x86::_mm_mask_sub_round_sd fn">_mm_mask_sub_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中的较低双精度 (64-bit) 浮点元素中减去 b 中较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 时，该元素是从 src 复制的 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sub_round_ss.html" title="core::arch::x86::_mm_mask_sub_round_ss fn">_mm_mask_sub_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中的较低单精度 (32-bit) 浮点元素减去 b 中的较低单精度 (32-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 时从 src 复制该元素 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sub_sd.html" title="core::arch::x86::_mm_mask_sub_sd fn">_mm_mask_sub_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中的较低双精度 (64-bit) 浮点元素中减去 b 中较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 时，该元素是从 src 复制的 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_sub_ss.html" title="core::arch::x86::_mm_mask_sub_ss fn">_mm_mask_sub_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中的较低单精度 (32-bit) 浮点元素减去 b 中的较低单精度 (32-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 时从 src 复制该元素 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_subs_epi8.html" title="core::arch::x86::_mm_mask_subs_epi8 fn">_mm_mask_subs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用饱和度将 b 中的包装 8 位整数减去 b 中的包装 8 位有符号整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_subs_epi16.html" title="core::arch::x86::_mm_mask_subs_epi16 fn">_mm_mask_subs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用饱和度将 b 中的包装 16 位整数减去 b 中的包装有符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_subs_epu8.html" title="core::arch::x86::_mm_mask_subs_epu8 fn">_mm_mask_subs_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用 a 饱和度将 b 中的包装无符号 8 位整数减去 b 中的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_subs_epu16.html" title="core::arch::x86::_mm_mask_subs_epu16 fn">_mm_mask_subs_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用 a 饱和度从 b 中的包装无符号 16 位整数减去 b 中的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_ternarylogic_epi32.html" title="core::arch::x86::_mm_mask_ternarylogic_epi32 fn">_mm_mask_ternarylogic_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 32 位整数中的每一位，使用 src、a 和 b 中的相应位形成 imm8 的 3 位索引，并使用 writemask 将 imm8 中该位的值写入 dst 中的相应位 k 在 32 位粒度 (当相应的掩码位未设置时，从 src 复制 32 位元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_ternarylogic_epi64.html" title="core::arch::x86::_mm_mask_ternarylogic_epi64 fn">_mm_mask_ternarylogic_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 64 位整数中的每一位，src、a 和 b 中的相应位用于形成 imm8 的 3 位索引，并使用 writemask 将 imm8 中该位的值写入 dst 中的相应位 k 在 64 位粒度 (当相应的掩码位未设置时，从 src 复制 64 位元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_test_epi8_mask.html" title="core::arch::x86::_mm_mask_test_epi8_mask fn">_mm_mask_test_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 和 b 中包装的 8 位整数的按位与，生成中间 8 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_test_epi16_mask.html" title="core::arch::x86::_mm_mask_test_epi16_mask fn">_mm_mask_test_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 和 b 中包装的 16 位整数的按位与，生成中间的 16 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_test_epi32_mask.html" title="core::arch::x86::_mm_mask_test_epi32_mask fn">_mm_mask_test_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 32 位整数的按位与，生成中间的 32 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_test_epi64_mask.html" title="core::arch::x86::_mm_mask_test_epi64_mask fn">_mm_mask_test_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 64 位整数的按位与，生成中间 64 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_testn_epi8_mask.html" title="core::arch::x86::_mm_mask_testn_epi8_mask fn">_mm_mask_testn_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 和 b 中包装的 8 位整数的按位 NAND，生成中间的 8 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_testn_epi16_mask.html" title="core::arch::x86::_mm_mask_testn_epi16_mask fn">_mm_mask_testn_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 和 b 中包装的 16 位整数的按位 NAND，生成中间的 16 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_testn_epi32_mask.html" title="core::arch::x86::_mm_mask_testn_epi32_mask fn">_mm_mask_testn_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 32 位整数的按位 NAND，生成中间的 32 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_testn_epi64_mask.html" title="core::arch::x86::_mm_mask_testn_epi64_mask fn">_mm_mask_testn_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 64 位整数的按位 NAND，生成中间 64 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_unpackhi_epi8.html" title="core::arch::x86::_mm_mask_unpackhi_epi8 fn">_mm_mask_unpackhi_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的高半部分拆包和交织 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_unpackhi_epi16.html" title="core::arch::x86::_mm_mask_unpackhi_epi16 fn">_mm_mask_unpackhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的高半部分拆包和交织 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_unpackhi_epi32.html" title="core::arch::x86::_mm_mask_unpackhi_epi32 fn">_mm_mask_unpackhi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_unpackhi_epi64.html" title="core::arch::x86::_mm_mask_unpackhi_epi64 fn">_mm_mask_unpackhi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_unpackhi_pd.html" title="core::arch::x86::_mm_mask_unpackhi_pd fn">_mm_mask_unpackhi_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_unpackhi_ps.html" title="core::arch::x86::_mm_mask_unpackhi_ps fn">_mm_mask_unpackhi_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_unpacklo_epi8.html" title="core::arch::x86::_mm_mask_unpacklo_epi8 fn">_mm_mask_unpacklo_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的下半部分拆包和交织 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_unpacklo_epi16.html" title="core::arch::x86::_mm_mask_unpacklo_epi16 fn">_mm_mask_unpacklo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的下半部分拆包和交织 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_unpacklo_epi32.html" title="core::arch::x86::_mm_mask_unpacklo_epi32 fn">_mm_mask_unpacklo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包和交织 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_unpacklo_epi64.html" title="core::arch::x86::_mm_mask_unpacklo_epi64 fn">_mm_mask_unpacklo_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包和交织 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_unpacklo_pd.html" title="core::arch::x86::_mm_mask_unpacklo_pd fn">_mm_mask_unpacklo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包并交织双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_unpacklo_ps.html" title="core::arch::x86::_mm_mask_unpacklo_ps fn">_mm_mask_unpacklo_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包并交织单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 src 复制元素)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_xor_epi32.html" title="core::arch::x86::_mm_mask_xor_epi32 fn">_mm_mask_xor_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 32 位整数的按位 XOR，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mask_xor_epi64.html" title="core::arch::x86::_mm_mask_xor_epi64 fn">_mm_mask_xor_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 64 位整数的按位 XOR，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_abs_epi8.html" title="core::arch::x86::_mm_maskz_abs_epi8 fn">_mm_maskz_abs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 中包装的带符号的 8 位整数的绝对值，并使用零掩码 k 将无符号结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_abs_epi16.html" title="core::arch::x86::_mm_maskz_abs_epi16 fn">_mm_maskz_abs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 中包装的带符号的 16 位整数的绝对值，并使用零掩码 k (将未设置相应掩码位的元素清零) 将无符号结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_abs_epi32.html" title="core::arch::x86::_mm_maskz_abs_epi32 fn">_mm_maskz_abs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的有符号 32 位整数的绝对值，并使用 zeromask k 将无符号结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_add_epi8.html" title="core::arch::x86::_mm_maskz_add_epi8 fn">_mm_maskz_add_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>在 a 和 b 中添加包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_add_epi16.html" title="core::arch::x86::_mm_maskz_add_epi16 fn">_mm_maskz_add_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数添加到 a 和 b 中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_add_epi32.html" title="core::arch::x86::_mm_maskz_add_epi32 fn">_mm_maskz_add_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 32 位整数添加到 a 和 b 中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_add_epi64.html" title="core::arch::x86::_mm_maskz_add_epi64 fn">_mm_maskz_add_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在 a 和 b 中添加包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_add_pd.html" title="core::arch::x86::_mm_maskz_add_pd fn">_mm_maskz_add_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_add_ps.html" title="core::arch::x86::_mm_maskz_add_ps fn">_mm_maskz_add_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_add_round_sd.html" title="core::arch::x86::_mm_maskz_add_round_sd fn">_mm_maskz_add_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加较低的双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素清零)，然后从 a 中复制较高的元素到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_add_round_ss.html" title="core::arch::x86::_mm_maskz_add_round_ss fn">_mm_maskz_add_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加较低的单精度 (32-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素归零)，并复制较高的 3 个包装的元素从 a 到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_add_sd.html" title="core::arch::x86::_mm_maskz_add_sd fn">_mm_maskz_add_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加较低的双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素清零)，然后从 a 中复制较高的元素到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_add_ss.html" title="core::arch::x86::_mm_maskz_add_ss fn">_mm_maskz_add_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>在 a 和 b 中添加较低的单精度 (32-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素归零)，并复制较高的 3 个包装的元素从 a 到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_adds_epi8.html" title="core::arch::x86::_mm_maskz_adds_epi8 fn">_mm_maskz_adds_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用饱和度在 a 和 b 中添加包装的带符号的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_adds_epi16.html" title="core::arch::x86::_mm_maskz_adds_epi16 fn">_mm_maskz_adds_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用饱和度在 a 和 b 中添加包装的带符号的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_adds_epu8.html" title="core::arch::x86::_mm_maskz_adds_epu8 fn">_mm_maskz_adds_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用饱和度在 a 和 b 中添加包装的无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_adds_epu16.html" title="core::arch::x86::_mm_maskz_adds_epu16 fn">_mm_maskz_adds_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用饱和度在 a 和 b 中添加包装的无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_alignr_epi8.html" title="core::arch::x86::_mm_maskz_alignr_epi8 fn">_mm_maskz_alignr_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 和 b 中的 16 字节块对连接成一个 32 字节的临时结果，将结果右移 imm8 字节，并使用零掩码 k 将低 16 字节存储在 dst 中 (当未使用相应的掩码位时元素清零) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_alignr_epi32.html" title="core::arch::x86::_mm_maskz_alignr_epi32 fn">_mm_maskz_alignr_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 连接成 32 字节的 immediate 结果，将结果右移 imm8 个 32 位元素，并使用 zeromask k 将低 16 字节 (4 个元素) 存储在 dst 中 (当相应的掩码位不存在时，元素被清零放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_alignr_epi64.html" title="core::arch::x86::_mm_maskz_alignr_epi64 fn">_mm_maskz_alignr_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 连接成 32 字节的 immediate 结果，将结果右移 imm8 个 64 位元素，并使用 zeromask k 将低 16 字节 (2 个元素) 存储在 dst 中 (当相应的掩码位不存在时，元素被清零放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_and_epi32.html" title="core::arch::x86::_mm_maskz_and_epi32 fn">_mm_maskz_and_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 32 位整数的按位与，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_and_epi64.html" title="core::arch::x86::_mm_maskz_and_epi64 fn">_mm_maskz_and_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 64 位整数的按位与，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_andnot_epi32.html" title="core::arch::x86::_mm_maskz_andnot_epi32 fn">_mm_maskz_andnot_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的 32 位整数的按位 NOT，然后计算 b 中的 AND，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_andnot_epi64.html" title="core::arch::x86::_mm_maskz_andnot_epi64 fn">_mm_maskz_andnot_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的 64 位整数的按位 NOT，然后与 b 计算 AND，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_avg_epu8.html" title="core::arch::x86::_mm_maskz_avg_epu8 fn">_mm_maskz_avg_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 和 b 中包装的无符号 8 位整数进行平均，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_avg_epu16.html" title="core::arch::x86::_mm_maskz_avg_epu16 fn">_mm_maskz_avg_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 和 b 中包装的无符号 16 位整数进行平均，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_broadcastb_epi8.html" title="core::arch::x86::_mm_maskz_broadcastb_epi8 fn">_mm_maskz_broadcastb_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用零掩码 k 将低包装的 8 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_broadcastd_epi32.html" title="core::arch::x86::_mm_maskz_broadcastd_epi32 fn">_mm_maskz_broadcastd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用零掩码 k 将低包装的 32 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_broadcastq_epi64.html" title="core::arch::x86::_mm_maskz_broadcastq_epi64 fn">_mm_maskz_broadcastq_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用零掩码 k 将低包装的 64 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_broadcastss_ps.html" title="core::arch::x86::_mm_maskz_broadcastss_ps fn">_mm_maskz_broadcastss_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用零掩码 k 将低单精度 (32-bit) 浮点元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_broadcastw_epi16.html" title="core::arch::x86::_mm_maskz_broadcastw_epi16 fn">_mm_maskz_broadcastw_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用零掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_compress_epi8.html" title="core::arch::x86::_mm_maskz_compress_epi8 fn">_mm_maskz_compress_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 a 中的活动 8 位整数 (它们各自的位设置在 zeromask k 中) 连续存储到 dst，并将其余元素设置为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_compress_epi16.html" title="core::arch::x86::_mm_maskz_compress_epi16 fn">_mm_maskz_compress_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 a 中的活动 16 位整数 (它们各自的位设置在 zeromask k 中) 连续存储到 dst，并将其余元素设置为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_compress_epi32.html" title="core::arch::x86::_mm_maskz_compress_epi32 fn">_mm_maskz_compress_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将活动的 32 位整数连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的整数) 为 dst，并将其余元素设置为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_compress_epi64.html" title="core::arch::x86::_mm_maskz_compress_epi64 fn">_mm_maskz_compress_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将活动的 64 位整数连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的整数) 为 dst，并将其余元素设置为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_compress_pd.html" title="core::arch::x86::_mm_maskz_compress_pd fn">_mm_maskz_compress_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将活动的双精度 (64-bit) 浮点元素连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的那些元素) 为 dst，并将其余元素设置为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_compress_ps.html" title="core::arch::x86::_mm_maskz_compress_ps fn">_mm_maskz_compress_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将活动的单精度 (32-bit) 浮点元素连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的那些元素) 为 dst，并将其余元素设置为零。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_conflict_epi32.html" title="core::arch::x86::_mm_maskz_conflict_epi32 fn">_mm_maskz_conflict_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>使用零掩码 k (在未设置相应的掩码位时将元素清零)，测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_conflict_epi64.html" title="core::arch::x86::_mm_maskz_conflict_epi64 fn">_mm_maskz_conflict_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>使用零掩码 k (在未设置相应的掩码位时将元素清零)，测试 a 的每个 64 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvt_roundps_ph.html" title="core::arch::x86::_mm_maskz_cvt_roundps_ph fn">_mm_maskz_cvt_roundps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvt_roundsd_ss.html" title="core::arch::x86::_mm_maskz_cvt_roundsd_ss fn">_mm_maskz_cvt_roundsd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的下部双精度 (64-bit) 浮点元素转换为单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。<br />
根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一:<br />
(_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常<br />
(_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常<br />
(_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常<br />
(_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常<br />
_MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvt_roundss_sd.html" title="core::arch::x86::_mm_maskz_cvt_roundss_sd fn">_mm_maskz_cvt_roundss_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的下部单精度 (32-bit) 浮点元素转换为双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后将上层元素从 a 复制到 dst 的上层元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtepi8_epi16.html" title="core::arch::x86::_mm_maskz_cvtepi8_epi16 fn">_mm_maskz_cvtepi8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用符号将包装的 8 位整数从 a 扩展为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtepi8_epi32.html" title="core::arch::x86::_mm_maskz_cvtepi8_epi32 fn">_mm_maskz_cvtepi8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用符号将包装的 8 位整数从 a 扩展为包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtepi8_epi64.html" title="core::arch::x86::_mm_maskz_cvtepi8_epi64 fn">_mm_maskz_cvtepi8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 的低 2 字节中的 8 位整数符号扩展为包装的 64 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtepi16_epi8.html" title="core::arch::x86::_mm_maskz_cvtepi16_epi8 fn">_mm_maskz_cvtepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将带有 a 的包装的 16 位整数转换为带截断的 8 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtepi16_epi32.html" title="core::arch::x86::_mm_maskz_cvtepi16_epi32 fn">_mm_maskz_cvtepi16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>符号将包装的 16 位整数从 a 扩展为包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtepi16_epi64.html" title="core::arch::x86::_mm_maskz_cvtepi16_epi64 fn">_mm_maskz_cvtepi16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用符号将包装的 16 位整数从 a 扩展为包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtepi32_epi8.html" title="core::arch::x86::_mm_maskz_cvtepi32_epi8 fn">_mm_maskz_cvtepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将带有 a 的包装的 32 位整数转换为带有截断的包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtepi32_epi16.html" title="core::arch::x86::_mm_maskz_cvtepi32_epi16 fn">_mm_maskz_cvtepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtepi32_epi64.html" title="core::arch::x86::_mm_maskz_cvtepi32_epi64 fn">_mm_maskz_cvtepi32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用符号将包装的 32 位整数从 a 扩展为包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtepi32_pd.html" title="core::arch::x86::_mm_maskz_cvtepi32_pd fn">_mm_maskz_cvtepi32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装有符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtepi32_ps.html" title="core::arch::x86::_mm_maskz_cvtepi32_ps fn">_mm_maskz_cvtepi32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装有符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用零掩码 k (未设置相应的掩码位时将元素清零) 将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtepi64_epi8.html" title="core::arch::x86::_mm_maskz_cvtepi64_epi8 fn">_mm_maskz_cvtepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将带有 a 的包装的 64 位整数转换为带截断的 8 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtepi64_epi16.html" title="core::arch::x86::_mm_maskz_cvtepi64_epi16 fn">_mm_maskz_cvtepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将带有 a 的包装的 64 位整数转换为带截断的 16 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtepi64_epi32.html" title="core::arch::x86::_mm_maskz_cvtepi64_epi32 fn">_mm_maskz_cvtepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的 64 位整数转换为带截断的 32 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtepu8_epi16.html" title="core::arch::x86::_mm_maskz_cvtepu8_epi16 fn">_mm_maskz_cvtepu8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的包装无符号 8 位整数零扩展为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtepu8_epi32.html" title="core::arch::x86::_mm_maskz_cvtepu8_epi32 fn">_mm_maskz_cvtepu8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>零扩展包装的无符号 8 位整数 a 的后 4 个字节到包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtepu8_epi64.html" title="core::arch::x86::_mm_maskz_cvtepu8_epi64 fn">_mm_maskz_cvtepu8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>零扩展包装的无符号 8 位整数在 a 的低 2 字节到包装的 64 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtepu16_epi32.html" title="core::arch::x86::_mm_maskz_cvtepu16_epi32 fn">_mm_maskz_cvtepu16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 16 位整数零扩展为包装 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtepu16_epi64.html" title="core::arch::x86::_mm_maskz_cvtepu16_epi64 fn">_mm_maskz_cvtepu16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>零扩展包装的无符号 16 位整数在 a 的低 4 字节到包装的 64 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtepu32_epi64.html" title="core::arch::x86::_mm_maskz_cvtepu32_epi64 fn">_mm_maskz_cvtepu32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 32 位整数零扩展为包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtepu32_pd.html" title="core::arch::x86::_mm_maskz_cvtepu32_pd fn">_mm_maskz_cvtepu32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtne2ps_pbh.html" title="core::arch::x86::_mm_maskz_cvtne2ps_pbh fn">_mm_maskz_cvtne2ps_pbh</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span><p>将两个 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在单个 vector dst 中 (当对应的掩码位不存在时，元素归零放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtpd_epi32.html" title="core::arch::x86::_mm_maskz_cvtpd_epi32 fn">_mm_maskz_cvtpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtpd_epu32.html" title="core::arch::x86::_mm_maskz_cvtpd_epu32 fn">_mm_maskz_cvtpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtpd_ps.html" title="core::arch::x86::_mm_maskz_cvtpd_ps fn">_mm_maskz_cvtpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtph_ps.html" title="core::arch::x86::_mm_maskz_cvtph_ps fn">_mm_maskz_cvtph_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装后的半精度 (16-bit) 浮点元素转换为包装后的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtps_epi32.html" title="core::arch::x86::_mm_maskz_cvtps_epi32 fn">_mm_maskz_cvtps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtps_epu32.html" title="core::arch::x86::_mm_maskz_cvtps_epu32 fn">_mm_maskz_cvtps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtps_ph.html" title="core::arch::x86::_mm_maskz_cvtps_ph fn">_mm_maskz_cvtps_ph</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtsd_ss.html" title="core::arch::x86::_mm_maskz_cvtsd_ss fn">_mm_maskz_cvtsd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的下部双精度 (64-bit) 浮点元素转换为单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtsepi16_epi8.html" title="core::arch::x86::_mm_maskz_cvtsepi16_epi8 fn">_mm_maskz_cvtsepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的包装有符号 16 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtsepi32_epi8.html" title="core::arch::x86::_mm_maskz_cvtsepi32_epi8 fn">_mm_maskz_cvtsepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtsepi32_epi16.html" title="core::arch::x86::_mm_maskz_cvtsepi32_epi16 fn">_mm_maskz_cvtsepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtsepi64_epi8.html" title="core::arch::x86::_mm_maskz_cvtsepi64_epi8 fn">_mm_maskz_cvtsepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装有符号 64 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtsepi64_epi16.html" title="core::arch::x86::_mm_maskz_cvtsepi64_epi16 fn">_mm_maskz_cvtsepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtsepi64_epi32.html" title="core::arch::x86::_mm_maskz_cvtsepi64_epi32 fn">_mm_maskz_cvtsepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtss_sd.html" title="core::arch::x86::_mm_maskz_cvtss_sd fn">_mm_maskz_cvtss_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的下部单精度 (32-bit) 浮点元素转换为双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后将上层元素从 a 复制到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvttpd_epi32.html" title="core::arch::x86::_mm_maskz_cvttpd_epi32 fn">_mm_maskz_cvttpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvttpd_epu32.html" title="core::arch::x86::_mm_maskz_cvttpd_epu32 fn">_mm_maskz_cvttpd_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvttps_epi32.html" title="core::arch::x86::_mm_maskz_cvttps_epi32 fn">_mm_maskz_cvttps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将带有 a 的包装的单精度 (32-bit) 浮点元素转换为带有截断的包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvttps_epu32.html" title="core::arch::x86::_mm_maskz_cvttps_epu32 fn">_mm_maskz_cvttps_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtusepi16_epi8.html" title="core::arch::x86::_mm_maskz_cvtusepi16_epi8 fn">_mm_maskz_cvtusepi16_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtusepi32_epi8.html" title="core::arch::x86::_mm_maskz_cvtusepi32_epi8 fn">_mm_maskz_cvtusepi32_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtusepi32_epi16.html" title="core::arch::x86::_mm_maskz_cvtusepi32_epi16 fn">_mm_maskz_cvtusepi32_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtusepi64_epi8.html" title="core::arch::x86::_mm_maskz_cvtusepi64_epi8 fn">_mm_maskz_cvtusepi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtusepi64_epi16.html" title="core::arch::x86::_mm_maskz_cvtusepi64_epi16 fn">_mm_maskz_cvtusepi64_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_cvtusepi64_epi32.html" title="core::arch::x86::_mm_maskz_cvtusepi64_epi32 fn">_mm_maskz_cvtusepi64_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_dbsad_epu8.html" title="core::arch::x86::_mm_maskz_dbsad_epu8 fn">_mm_maskz_dbsad_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 中与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs) 的总和，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将 16 位结果存储在 dst 中。对于每个 64 位通道，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中通道的低 8 位四元组，而后两个 SAD 使用 a 中通道的较高 8 位四元组。根据 imm8 中的控件，从 128 位通道中选择 b 中的四元组，并且每个 64 位通道中的每个 SAD 使用 8 位偏移量的选定四元组。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_div_pd.html" title="core::arch::x86::_mm_maskz_div_pd fn">_mm_maskz_div_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_div_ps.html" title="core::arch::x86::_mm_maskz_div_ps fn">_mm_maskz_div_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素除以 b 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_div_round_sd.html" title="core::arch::x86::_mm_maskz_div_round_sd fn">_mm_maskz_div_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的较低双精度 (64-bit) 浮点元素除以 b 中的较低双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 为 0 时，该元素归零 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_div_round_ss.html" title="core::arch::x86::_mm_maskz_div_round_ss fn">_mm_maskz_div_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的下部单精度 (32-bit) 浮点元素除以 b 中的下部单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当掩码位 0 为 0 时，该元素清零) (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_div_sd.html" title="core::arch::x86::_mm_maskz_div_sd fn">_mm_maskz_div_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的较低双精度 (64-bit) 浮点元素除以 b 中的较低双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 为 0 时，该元素归零 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_div_ss.html" title="core::arch::x86::_mm_maskz_div_ss fn">_mm_maskz_div_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 中的下部单精度 (32-bit) 浮点元素除以 b 中的下部单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当掩码位 0 为 0 时，该元素清零) (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_dpbf16_ps.html" title="core::arch::x86::_mm_maskz_dpbf16_ps fn">_mm_maskz_dpbf16_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bf16,avx512vl` only"><code>avx512bf16,avx512vl</code></span><p>计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间单精度 (32-bit) 浮点元素与 src 中的元素进行累加，并将结果存储在 dst 中使用 zeromask k (当对应的掩码为位未设置)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_dpbusd_epi32.html" title="core::arch::x86::_mm_maskz_dpbusd_epi32 fn">_mm_maskz_dpbusd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span><p>将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果使用 zeromask k 存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_dpbusds_epi32.html" title="core::arch::x86::_mm_maskz_dpbusds_epi32 fn">_mm_maskz_dpbusds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span><p>将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数用带符号饱和求和，并将包装的 32 位结果用 zeromask k 存储在 dst 中 (当对应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_dpwssd_epi32.html" title="core::arch::x86::_mm_maskz_dpwssd_epi32 fn">_mm_maskz_dpwssd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span><p>将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中对应的 32 位整数相加，并使用 zeromask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_dpwssds_epi32.html" title="core::arch::x86::_mm_maskz_dpwssds_epi32 fn">_mm_maskz_dpwssds_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vnni,avx512vl` only"><code>avx512vnni,avx512vl</code></span><p>将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并使用 zeromask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_expand_epi8.html" title="core::arch::x86::_mm_maskz_expand_epi8 fn">_mm_maskz_expand_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>从 a 加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_expand_epi16.html" title="core::arch::x86::_mm_maskz_expand_epi16 fn">_mm_maskz_expand_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>从 a 加载连续的活动 16 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_expand_epi32.html" title="core::arch::x86::_mm_maskz_expand_epi32 fn">_mm_maskz_expand_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中加载连续的有效 32 位整数 (它们各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_expand_epi64.html" title="core::arch::x86::_mm_maskz_expand_epi64 fn">_mm_maskz_expand_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中加载连续的有效 64 位整数 (它们各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_expand_pd.html" title="core::arch::x86::_mm_maskz_expand_pd fn">_mm_maskz_expand_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中加载连续的活动双精度 (64-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_expand_ps.html" title="core::arch::x86::_mm_maskz_expand_ps fn">_mm_maskz_expand_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中加载连续的活动单精度 (32-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fixupimm_pd.html" title="core::arch::x86::_mm_maskz_fixupimm_pd fn">_mm_maskz_fixupimm_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 c 中的包装 64 位整数修复 a 和 b 中的包装双精度 (64-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fixupimm_ps.html" title="core::arch::x86::_mm_maskz_fixupimm_ps fn">_mm_maskz_fixupimm_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 c 中的包装 32 位整数修复 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fixupimm_round_sd.html" title="core::arch::x86::_mm_maskz_fixupimm_round_sd fn">_mm_maskz_fixupimm_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 c 中的较低 64 位整数修复 a 和 b 中的较低双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 的较低元素中 (当不使用掩码位 0 时该元素清零) set)，然后将上层元素从 a 复制到 dst 的上层元素。imm8 用于设置所需的标志报告。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fixupimm_round_ss.html" title="core::arch::x86::_mm_maskz_fixupimm_round_ss fn">_mm_maskz_fixupimm_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 c 中的较低 32 位整数固定 a 和 b 中的较低单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 的较低元素中 (当未使用掩码 bit 0 时该元素被清零) 设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。imm8 用于设置所需的标志报告。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fixupimm_sd.html" title="core::arch::x86::_mm_maskz_fixupimm_sd fn">_mm_maskz_fixupimm_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 c 中的较低 64 位整数修复 a 和 b 中的较低双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 的较低元素中 (当不使用掩码位 0 时该元素清零) set)，然后将上层元素从 a 复制到 dst 的上层元素。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fixupimm_ss.html" title="core::arch::x86::_mm_maskz_fixupimm_ss fn">_mm_maskz_fixupimm_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 c 中的较低 32 位整数固定 a 和 b 中的较低单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 的较低元素中 (当未使用掩码 bit 0 时该元素被清零) 设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。imm8 用于设置所需的标志报告。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fmadd_pd.html" title="core::arch::x86::_mm_maskz_fmadd_pd fn">_mm_maskz_fmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fmadd_ps.html" title="core::arch::x86::_mm_maskz_fmadd_ps fn">_mm_maskz_fmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fmadd_round_sd.html" title="core::arch::x86::_mm_maskz_fmadd_round_sd fn">_mm_maskz_fmadd_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后使用零掩码 k 将中间结果与较低元素 in c. Store 的结果加到 dst 较低元素中 (当未设置掩码位 0 时该元素归零) )，然后将上层元素从 a 复制到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fmadd_round_ss.html" title="core::arch::x86::_mm_maskz_fmadd_round_ss fn">_mm_maskz_fmadd_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用零掩码 k 将中间结果与较低元素 in c. Store 的中间结果相加到 dst 较低元素中 (未设置掩码位 0 时该元素归零) )，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fmadd_sd.html" title="core::arch::x86::_mm_maskz_fmadd_sd fn">_mm_maskz_fmadd_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后使用零掩码 k 将中间结果与较低元素 in c. Store 的结果加到 dst 较低元素中 (当未设置掩码位 0 时该元素归零) )，然后将上层元素从 a 复制到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fmadd_ss.html" title="core::arch::x86::_mm_maskz_fmadd_ss fn">_mm_maskz_fmadd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用零掩码 k 将中间结果与较低元素 in c. Store 的中间结果相加到 dst 较低元素中 (未设置掩码位 0 时该元素归零) )，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fmaddsub_pd.html" title="core::arch::x86::_mm_maskz_fmaddsub_pd fn">_mm_maskz_fmaddsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或减去，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fmaddsub_ps.html" title="core::arch::x86::_mm_maskz_fmaddsub_ps fn">_mm_maskz_fmaddsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fmsub_pd.html" title="core::arch::x86::_mm_maskz_fmsub_pd fn">_mm_maskz_fmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fmsub_ps.html" title="core::arch::x86::_mm_maskz_fmsub_ps fn">_mm_maskz_fmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fmsub_round_sd.html" title="core::arch::x86::_mm_maskz_fmsub_round_sd fn">_mm_maskz_fmsub_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用 zeromask k 将结果存储在 dst 的下元素中 (当掩码位 0 未设置时元素被清零)，并将上元素从 a 复制到 dst 的上元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fmsub_round_ss.html" title="core::arch::x86::_mm_maskz_fmsub_round_ss fn">_mm_maskz_fmsub_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用 zeromask k 将结果存储在 dst 的下元素中 (当未设置掩码位 0 时，元素被清零)，并将上 3 个打包元素从 a 复制到 dst 的上元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fmsub_sd.html" title="core::arch::x86::_mm_maskz_fmsub_sd fn">_mm_maskz_fmsub_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用 zeromask k 将结果存储在 dst 的下元素中 (当掩码位 0 未设置时元素被清零)，并将上元素从 a 复制到 dst 的上元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fmsub_ss.html" title="core::arch::x86::_mm_maskz_fmsub_ss fn">_mm_maskz_fmsub_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用 zeromask k 将结果存储在 dst 的下元素中 (当未设置掩码位 0 时，元素被清零)，并将上 3 个打包元素从 a 复制到 dst 的上元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fmsubadd_pd.html" title="core::arch::x86::_mm_maskz_fmsubadd_pd fn">_mm_maskz_fmsubadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或减去，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fmsubadd_ps.html" title="core::arch::x86::_mm_maskz_fmsubadd_ps fn">_mm_maskz_fmsubadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，或者将 C from/to 中的包装元素相减并相加，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fnmadd_pd.html" title="core::arch::x86::_mm_maskz_fnmadd_pd fn">_mm_maskz_fnmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fnmadd_ps.html" title="core::arch::x86::_mm_maskz_fnmadd_ps fn">_mm_maskz_fnmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fnmadd_round_sd.html" title="core::arch::x86::_mm_maskz_fnmadd_round_sd fn">_mm_maskz_fnmadd_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，然后使用零掩码 k 将求反的中间结果与较低的元素 in c. Store 的结果加到 dst 的较低元素中 (当未使用掩码位 0 时该元素清零) set)，然后将上层元素从 a 复制到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fnmadd_round_ss.html" title="core::arch::x86::_mm_maskz_fnmadd_round_ss fn">_mm_maskz_fnmadd_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用零掩码 k 将求反的中间结果与较低元素 in c. Store 的结果相加到 dst 的较低元素中 (当未使用掩码位 0 时该元素清零) 设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fnmadd_sd.html" title="core::arch::x86::_mm_maskz_fnmadd_sd fn">_mm_maskz_fnmadd_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，然后使用零掩码 k 将求反的中间结果与较低的元素 in c. Store 的结果加到 dst 的较低元素中 (当未使用掩码位 0 时该元素清零) set)，然后将上层元素从 a 复制到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fnmadd_ss.html" title="core::arch::x86::_mm_maskz_fnmadd_ss fn">_mm_maskz_fnmadd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用零掩码 k 将求反的中间结果与较低元素 in c. Store 的结果相加到 dst 的较低元素中 (当未使用掩码位 0 时该元素清零) 设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fnmsub_pd.html" title="core::arch::x86::_mm_maskz_fnmsub_pd fn">_mm_maskz_fnmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fnmsub_ps.html" title="core::arch::x86::_mm_maskz_fnmsub_ps fn">_mm_maskz_fnmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fnmsub_round_sd.html" title="core::arch::x86::_mm_maskz_fnmsub_round_sd fn">_mm_maskz_fnmsub_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用 zeromask k 将结果存储在 dst 中 (当未设置掩码位 0 时元素被清零)，并将上元素从 a 复制到 dst 的上元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fnmsub_round_ss.html" title="core::arch::x86::_mm_maskz_fnmsub_round_ss fn">_mm_maskz_fnmsub_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用 zeromask k 将结果存储在 dst 的下元素中 (当未设置掩码位 0 时，元素被清零)，并将上 3 个打包元素从 a 复制到 dst 的上元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fnmsub_sd.html" title="core::arch::x86::_mm_maskz_fnmsub_sd fn">_mm_maskz_fnmsub_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用 zeromask k 将结果存储在 dst 中 (当未设置掩码位 0 时元素被清零)，并将上元素从 a 复制到 dst 的上元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_fnmsub_ss.html" title="core::arch::x86::_mm_maskz_fnmsub_ss fn">_mm_maskz_fnmsub_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用 zeromask k 将结果存储在 dst 的下元素中 (当未设置掩码位 0 时，元素被清零)，并将上 3 个打包元素从 a 复制到 dst 的上元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_getexp_pd.html" title="core::arch::x86::_mm_maskz_getexp_pd fn">_mm_maskz_getexp_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并使用 zeromask k 将结果存储在 dst 中 (当相应的 mask 位为零时，元素被清零未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_getexp_ps.html" title="core::arch::x86::_mm_maskz_getexp_ps fn">_mm_maskz_getexp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为代表整数指数的单精度 (32-bit) 浮点数，并使用 zeromask k 将结果存储在 dst 中 (当相应的 mask 位为零时，元素被清零未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_getexp_round_sd.html" title="core::arch::x86::_mm_maskz_getexp_round_sd fn">_mm_maskz_getexp_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中较低的双精度 (64-bit) 浮点元素的指数转换为表示整数指数的双精度 (64-bit) 浮点数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 未设置)，然后将较高的元素从 a 复制到 dst 的较高的元素。本质上，此内联函数计算下部元素的 floor(log2(x))。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_getexp_round_ss.html" title="core::arch::x86::_mm_maskz_getexp_round_ss fn">_mm_maskz_getexp_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中较低的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 未设置)，并将高 3 个包装的元素从 a 复制到 dst 的高元素。本质上，此内联函数计算下部元素的 floor(log2(x))。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_getexp_sd.html" title="core::arch::x86::_mm_maskz_getexp_sd fn">_mm_maskz_getexp_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中较低的双精度 (64-bit) 浮点元素的指数转换为表示整数指数的双精度 (64-bit) 浮点数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 未设置)，然后将较高的元素从 a 复制到 dst 的较高的元素。本质上，此内联函数计算下部元素的 floor(log2(x))。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_getexp_ss.html" title="core::arch::x86::_mm_maskz_getexp_ss fn">_mm_maskz_getexp_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中较低的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 未设置)，并将高 3 个包装的元素从 a 复制到 dst 的高元素。本质上，此内联函数计算下部元素的 floor(log2(x))。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_getmant_pd.html" title="core::arch::x86::_mm_maskz_getmant_pd fn">_mm_maskz_getmant_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的双精度 (64-bit) 浮点元素的尾数标准化，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_getmant_ps.html" title="core::arch::x86::_mm_maskz_getmant_ps fn">_mm_maskz_getmant_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素的尾数规格化，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_getmant_round_sd.html" title="core::arch::x86::_mm_maskz_getmant_round_sd fn">_mm_maskz_getmant_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>标准化 b 中较低的双精度 (64-bit) 浮点元素的尾数，使用零掩码 k 将结果存储在 dst 的较低元素中 (未设置掩码位 0 时该元素归零)，然后从中复制较高元素。a 到 dst 的高位元素。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_getmant_round_ss.html" title="core::arch::x86::_mm_maskz_getmant_round_ss fn">_mm_maskz_getmant_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>标准化 b 中较低单精度 (32-bit) 浮点元素的尾数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素清零)，然后复制高位 3 从 a 到 dst 的高位元素。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_getmant_sd.html" title="core::arch::x86::_mm_maskz_getmant_sd fn">_mm_maskz_getmant_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>标准化 b 中较低的双精度 (64-bit) 浮点元素的尾数，使用零掩码 k 将结果存储在 dst 的较低元素中 (未设置掩码位 0 时该元素归零)，然后从中复制较高元素。a 到 dst 的高位元素。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_getmant_ss.html" title="core::arch::x86::_mm_maskz_getmant_ss fn">_mm_maskz_getmant_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>标准化 b 中较低单精度 (32-bit) 浮点元素的尾数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素清零)，然后复制高位 3 从 a 到 dst 的高位元素。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。<br />
尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值:<br />
_MM_MANT_NORM_1_2     // interval [1, 2)<br />
_MM_MANT_NORM_p5_2    // interval [0.5, 2)<br />
_MM_MANT_NORM_p5_1    // interval [0.5, 1)<br />
_MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)<br />
该符号由 sc 确定，可以采用以下值:<br />
_MM_MANT_SIGN_src     // sign = sign(src)<br />
_MM_MANT_SIGN_zero    // sign = 0<br />
_MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_gf2p8affine_epi64_epi8.html" title="core::arch::x86::_mm_maskz_gf2p8affine_epi64_epi8 fn">_mm_maskz_gf2p8affine_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span><p>对 x 中的包装字节执行仿射变换。
也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_gf2p8affineinv_epi64_epi8.html" title="core::arch::x86::_mm_maskz_gf2p8affineinv_epi64_epi8 fn">_mm_maskz_gf2p8affineinv_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span><p>对 x 中的反向包装的字节执行仿射变换。
也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_gf2p8mul_epi8.html" title="core::arch::x86::_mm_maskz_gf2p8mul_epi8 fn">_mm_maskz_gf2p8mul_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512gfni,avx512bw,avx512vl` only"><code>avx512gfni,avx512bw,avx512vl</code></span><p>在包装的字节上执行 GF(2^8) 乘法。
该字段以多项式表示，具有约数多项式 x^8 + x^4 + x^3 + x + 1。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_lzcnt_epi32.html" title="core::arch::x86::_mm_maskz_lzcnt_epi32 fn">_mm_maskz_lzcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>计算 a 中每个包装的 32 位整数中前导零位的数目，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_lzcnt_epi64.html" title="core::arch::x86::_mm_maskz_lzcnt_epi64 fn">_mm_maskz_lzcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512cd,avx512vl` only"><code>avx512cd,avx512vl</code></span><p>计算 a 中每个包装的 64 位整数中前导零位的数目，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_madd_epi16.html" title="core::arch::x86::_mm_maskz_madd_epi16 fn">_mm_maskz_madd_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。水平添加相邻的中间 32 位整数对，并使用 zeromask k 将结果打包到 dst (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_maddubs_epi16.html" title="core::arch::x86::_mm_maskz_maddubs_epi16 fn">_mm_maskz_maddubs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的包装无符号 8 位整数与 b 中的包装有符号 8 位整数相乘，生成中间有符号的 16 位整数。水平添加相邻的中间有符号 16 位整数对，并使用 zeromask k 将饱和结果打包到 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_max_epi8.html" title="core::arch::x86::_mm_maskz_max_epi8 fn">_mm_maskz_max_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_max_epi16.html" title="core::arch::x86::_mm_maskz_max_epi16 fn">_mm_maskz_max_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_max_epi32.html" title="core::arch::x86::_mm_maskz_max_epi32 fn">_mm_maskz_max_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 32 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_max_epi64.html" title="core::arch::x86::_mm_maskz_max_epi64 fn">_mm_maskz_max_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_max_epu8.html" title="core::arch::x86::_mm_maskz_max_epu8 fn">_mm_maskz_max_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_max_epu16.html" title="core::arch::x86::_mm_maskz_max_epu16 fn">_mm_maskz_max_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_max_epu32.html" title="core::arch::x86::_mm_maskz_max_epu32 fn">_mm_maskz_max_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_max_epu64.html" title="core::arch::x86::_mm_maskz_max_epu64 fn">_mm_maskz_max_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_max_pd.html" title="core::arch::x86::_mm_maskz_max_pd fn">_mm_maskz_max_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_max_ps.html" title="core::arch::x86::_mm_maskz_max_ps fn">_mm_maskz_max_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_max_round_sd.html" title="core::arch::x86::_mm_maskz_max_round_sd fn">_mm_maskz_max_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用零掩码 k 将最大值存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后从中复制较高元素。a 到 dst 的高位元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_max_round_ss.html" title="core::arch::x86::_mm_maskz_max_round_ss fn">_mm_maskz_max_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用零掩码 k 将最大值存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后复制包装后的高 3 位从 a 到 dst 的高位元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_max_sd.html" title="core::arch::x86::_mm_maskz_max_sd fn">_mm_maskz_max_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用零掩码 k 将最大值存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后从中复制较高元素。a 到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_max_ss.html" title="core::arch::x86::_mm_maskz_max_ss fn">_mm_maskz_max_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用零掩码 k 将最大值存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后复制包装后的高 3 位从 a 到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_min_epi8.html" title="core::arch::x86::_mm_maskz_min_epi8 fn">_mm_maskz_min_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_min_epi16.html" title="core::arch::x86::_mm_maskz_min_epi16 fn">_mm_maskz_min_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_min_epi32.html" title="core::arch::x86::_mm_maskz_min_epi32 fn">_mm_maskz_min_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号 32 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_min_epu8.html" title="core::arch::x86::_mm_maskz_min_epu8 fn">_mm_maskz_min_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 8 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_min_epu16.html" title="core::arch::x86::_mm_maskz_min_epu16 fn">_mm_maskz_min_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_min_epu32.html" title="core::arch::x86::_mm_maskz_min_epu32 fn">_mm_maskz_min_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 32 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_min_epu64.html" title="core::arch::x86::_mm_maskz_min_epu64 fn">_mm_maskz_min_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_min_pd.html" title="core::arch::x86::_mm_maskz_min_pd fn">_mm_maskz_min_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_min_ps.html" title="core::arch::x86::_mm_maskz_min_ps fn">_mm_maskz_min_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_min_round_sd.html" title="core::arch::x86::_mm_maskz_min_round_sd fn">_mm_maskz_min_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用零掩码 k 将最小值存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素清零)，然后从中复制较高元素。a 到 dst 的高位元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_min_round_ss.html" title="core::arch::x86::_mm_maskz_min_round_ss fn">_mm_maskz_min_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用零掩码 k 将最小值存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后复制包装后的高 3 位从 a 到 dst 的高位元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_min_sd.html" title="core::arch::x86::_mm_maskz_min_sd fn">_mm_maskz_min_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用零掩码 k 将最小值存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素清零)，然后从中复制较高元素。a 到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_min_ss.html" title="core::arch::x86::_mm_maskz_min_ss fn">_mm_maskz_min_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用零掩码 k 将最小值存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后复制包装后的高 3 位从 a 到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_mov_epi8.html" title="core::arch::x86::_mm_maskz_mov_epi8 fn">_mm_maskz_mov_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用零掩码 k 将包装的 8 位整数从 a 移到 dst (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_mov_epi16.html" title="core::arch::x86::_mm_maskz_mov_epi16 fn">_mm_maskz_mov_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用零掩码 k 将包装的 16 位整数从 a 移到 dst (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_mov_epi32.html" title="core::arch::x86::_mm_maskz_mov_epi32 fn">_mm_maskz_mov_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用零掩码 k 将包装的 32 位整数从 a 移至 dst (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_mov_epi64.html" title="core::arch::x86::_mm_maskz_mov_epi64 fn">_mm_maskz_mov_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用零掩码 k 将包装的 64 位整数从 a 移到 dst (未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_mov_pd.html" title="core::arch::x86::_mm_maskz_mov_pd fn">_mm_maskz_mov_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用零掩码 k 将包装的双精度 (64-bit) 浮点元素从 a 移到 dst (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_mov_ps.html" title="core::arch::x86::_mm_maskz_mov_ps fn">_mm_maskz_mov_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用零掩码 k 将包装的单精度 (32-bit) 浮点元素从 a 移到 dst (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_move_sd.html" title="core::arch::x86::_mm_maskz_move_sd fn">_mm_maskz_move_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用零掩码 k 将较低的双精度 (64-bit) 浮点元素从 b 移动到 dst 的较低元素 (未设置掩码位 0 时将该元素清零)，然后将较高的元素从 a 复制到 dst 的较高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_move_ss.html" title="core::arch::x86::_mm_maskz_move_ss fn">_mm_maskz_move_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用零掩码 k 将较低的单精度 (32-bit) 浮点元素从 b 移动到 dst 的较低元素 (未设置掩码位 0 时将该元素清零)，然后将较高的 3 个包装的元素从 a 复制到较高的元素 dst。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_movedup_pd.html" title="core::arch::x86::_mm_maskz_movedup_pd fn">_mm_maskz_movedup_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 复制偶数索引的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_movehdup_ps.html" title="core::arch::x86::_mm_maskz_movehdup_ps fn">_mm_maskz_movehdup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 复制奇数索引的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_moveldup_ps.html" title="core::arch::x86::_mm_maskz_moveldup_ps fn">_mm_maskz_moveldup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 复制偶数索引的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_mul_epi32.html" title="core::arch::x86::_mm_maskz_mul_epi32 fn">_mm_maskz_mul_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中每个包装的 64 位元素的低位有符号 32 位整数相乘，并使用零掩码 k 将有符号的 64 位结果存储在 dst 中 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_mul_epu32.html" title="core::arch::x86::_mm_maskz_mul_epu32 fn">_mm_maskz_mul_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中每个包装的 64 位元素的低无符号 32 位整数相乘，并使用零掩码 k 将无符号 64 位结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_mul_pd.html" title="core::arch::x86::_mm_maskz_mul_pd fn">_mm_maskz_mul_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_mul_ps.html" title="core::arch::x86::_mm_maskz_mul_ps fn">_mm_maskz_mul_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_mul_round_sd.html" title="core::arch::x86::_mm_maskz_mul_round_sd fn">_mm_maskz_mul_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的低位双精度 (64-bit) 浮点元素相乘，使用零掩码 k 将结果存储在 dst 的低位元素中 (当未设置掩码位 0 时该元素归零)，然后从 a 中复制高位元素到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_mul_round_ss.html" title="core::arch::x86::_mm_maskz_mul_round_ss fn">_mm_maskz_mul_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的下部单精度 (32-bit) 浮点元素相乘，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，并复制上部 3 个包装的元素从 a 到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_mul_sd.html" title="core::arch::x86::_mm_maskz_mul_sd fn">_mm_maskz_mul_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的低位双精度 (64-bit) 浮点元素相乘，使用零掩码 k 将结果存储在 dst 的低位元素中 (当未设置掩码位 0 时该元素归零)，然后从 a 中复制高位元素到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_mul_ss.html" title="core::arch::x86::_mm_maskz_mul_ss fn">_mm_maskz_mul_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的下部单精度 (32-bit) 浮点元素相乘，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，并复制上部 3 个包装的元素从 a 到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_mulhi_epi16.html" title="core::arch::x86::_mm_maskz_mulhi_epi16 fn">_mm_maskz_mulhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 和 b 中包装的带符号的 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_mulhi_epu16.html" title="core::arch::x86::_mm_maskz_mulhi_epu16 fn">_mm_maskz_mulhi_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 和 b 中包装的无符号 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_mulhrs_epi16.html" title="core::arch::x86::_mm_maskz_mulhrs_epi16 fn">_mm_maskz_mulhrs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。将每个中间整数截断为 18 个最高有效位，通过加 1 舍入，并使用 zeromask k 将位 [16:1] 存储到 dst (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_mullo_epi16.html" title="core::arch::x86::_mm_maskz_mullo_epi16 fn">_mm_maskz_mullo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 和 b 中的包装的 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的低 16 位存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_mullo_epi32.html" title="core::arch::x86::_mm_maskz_mullo_epi32 fn">_mm_maskz_mullo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 和 b 中的包装的 32 位整数相乘，生成中间 64 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将中间整数的低 32 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_multishift_epi64_epi8.html" title="core::arch::x86::_mm_maskz_multishift_epi64_epi8 fn">_mm_maskz_multishift_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span><p>对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并使用 zeromask k (元素当相应的屏蔽位未设置时被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_or_epi32.html" title="core::arch::x86::_mm_maskz_or_epi32 fn">_mm_maskz_or_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 32 位整数的按位或，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_or_epi64.html" title="core::arch::x86::_mm_maskz_or_epi64 fn">_mm_maskz_or_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 64 位整数的按位或，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_packs_epi16.html" title="core::arch::x86::_mm_maskz_packs_epi16 fn">_mm_maskz_packs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用带符号的饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_packs_epi32.html" title="core::arch::x86::_mm_maskz_packs_epi32 fn">_mm_maskz_packs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用带符号的饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_packus_epi16.html" title="core::arch::x86::_mm_maskz_packus_epi16 fn">_mm_maskz_packus_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用无符号饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_packus_epi32.html" title="core::arch::x86::_mm_maskz_packus_epi32 fn">_mm_maskz_packus_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用无符号饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_permute_pd.html" title="core::arch::x86::_mm_maskz_permute_pd fn">_mm_maskz_permute_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件在 128 位通道内对双精度 (64-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_permute_ps.html" title="core::arch::x86::_mm_maskz_permute_ps fn">_mm_maskz_permute_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_permutevar_pd.html" title="core::arch::x86::_mm_maskz_permutevar_pd fn">_mm_maskz_permutevar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 b 中的控件在 128 位通道内将 a 中的双精度 (64-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_permutevar_ps.html" title="core::arch::x86::_mm_maskz_permutevar_ps fn">_mm_maskz_permutevar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 b 中的控件在 128 位通道内将 a 的单精度 (32-bit) 浮点元素打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_permutex2var_epi8.html" title="core::arch::x86::_mm_maskz_permutex2var_epi8 fn">_mm_maskz_permutex2var_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span><p>使用 idx 中的相应选择器和索引将 a 和 b 中的 8 位整数跨通道打乱，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_permutex2var_epi16.html" title="core::arch::x86::_mm_maskz_permutex2var_epi16 fn">_mm_maskz_permutex2var_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用相应的选择器和 idx 中的索引在通道中的 a 和 b 中对 16 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_permutex2var_epi32.html" title="core::arch::x86::_mm_maskz_permutex2var_epi32 fn">_mm_maskz_permutex2var_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中对 32 位整数进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_permutex2var_epi64.html" title="core::arch::x86::_mm_maskz_permutex2var_epi64 fn">_mm_maskz_permutex2var_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中对 64 位整数进行混洗，并使用 zeromask k (未设置相应的 mask 位时将元素清零) 将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_permutex2var_pd.html" title="core::arch::x86::_mm_maskz_permutex2var_pd fn">_mm_maskz_permutex2var_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用对应的选择器和 idx 中的索引在通道中的通道 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_permutex2var_ps.html" title="core::arch::x86::_mm_maskz_permutex2var_ps fn">_mm_maskz_permutex2var_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对单精度 (32-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_permutexvar_epi8.html" title="core::arch::x86::_mm_maskz_permutexvar_epi8 fn">_mm_maskz_permutexvar_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span><p>使用 idx 中的相应索引在跨通道的 a 中打乱 8 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_permutexvar_epi16.html" title="core::arch::x86::_mm_maskz_permutexvar_epi16 fn">_mm_maskz_permutexvar_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用 idx 中的相应索引在跨通道中对 16 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_popcnt_epi8.html" title="core::arch::x86::_mm_maskz_popcnt_epi8 fn">_mm_maskz_popcnt_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span><p>对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_popcnt_epi16.html" title="core::arch::x86::_mm_maskz_popcnt_epi16 fn">_mm_maskz_popcnt_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span><p>对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_popcnt_epi32.html" title="core::arch::x86::_mm_maskz_popcnt_epi32 fn">_mm_maskz_popcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq,avx512vl` only"><code>avx512vpopcntdq,avx512vl</code></span><p>对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_popcnt_epi64.html" title="core::arch::x86::_mm_maskz_popcnt_epi64 fn">_mm_maskz_popcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq,avx512vl` only"><code>avx512vpopcntdq,avx512vl</code></span><p>对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_rcp14_pd.html" title="core::arch::x86::_mm_maskz_rcp14_pd fn">_mm_maskz_rcp14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_rcp14_ps.html" title="core::arch::x86::_mm_maskz_rcp14_ps fn">_mm_maskz_rcp14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_rcp14_sd.html" title="core::arch::x86::_mm_maskz_rcp14_sd fn">_mm_maskz_rcp14_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 b 中较低的双精度 (64-bit) 浮点元素的近似倒数，使用零掩码 k 将结果存储在 dst 的较低元素中 (未设置掩码位 0 时该元素归零)，然后复制较高元素从 a 到 dst 的高位元素。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_rcp14_ss.html" title="core::arch::x86::_mm_maskz_rcp14_ss fn">_mm_maskz_rcp14_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 b 中较低的单精度 (32-bit) 浮点元素的近似倒数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素归零)，并复制较高的 3 从 a 到 dst 的上层元素的包装的元素。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_rol_epi32.html" title="core::arch::x86::_mm_maskz_rol_epi32 fn">_mm_maskz_rol_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_rol_epi64.html" title="core::arch::x86::_mm_maskz_rol_epi64 fn">_mm_maskz_rol_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_rolv_epi32.html" title="core::arch::x86::_mm_maskz_rolv_epi32 fn">_mm_maskz_rolv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的 32 位整数中的位向左旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_rolv_epi64.html" title="core::arch::x86::_mm_maskz_rolv_epi64 fn">_mm_maskz_rolv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的 64 位整数中的位向左旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_ror_epi32.html" title="core::arch::x86::_mm_maskz_ror_epi32 fn">_mm_maskz_ror_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 X 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_ror_epi64.html" title="core::arch::x86::_mm_maskz_ror_epi64 fn">_mm_maskz_ror_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 X 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_rorv_epi32.html" title="core::arch::x86::_mm_maskz_rorv_epi32 fn">_mm_maskz_rorv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的 32 位整数中的位向右旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_rorv_epi64.html" title="core::arch::x86::_mm_maskz_rorv_epi64 fn">_mm_maskz_rorv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_roundscale_pd.html" title="core::arch::x86::_mm_maskz_roundscale_pd fn">_mm_maskz_roundscale_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 x 中的包装双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_roundscale_ps.html" title="core::arch::x86::_mm_maskz_roundscale_ps fn">_mm_maskz_roundscale_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_roundscale_round_sd.html" title="core::arch::x86::_mm_maskz_roundscale_round_sd fn">_mm_maskz_roundscale_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的下部双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时该元素清零)，并将上一个元素从 a 复制到 dst 的上一个元素。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_roundscale_round_ss.html" title="core::arch::x86::_mm_maskz_roundscale_round_ss fn">_mm_maskz_roundscale_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的下部单精度 (32-bit) 浮点元素四舍五入为 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时该元素清零)，并将上面的 3 个包装的元素从 a 复制到 dst 的上面的元素。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_roundscale_sd.html" title="core::arch::x86::_mm_maskz_roundscale_sd fn">_mm_maskz_roundscale_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的下部双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时该元素清零)，并将上一个元素从 a 复制到 dst 的上一个元素。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_roundscale_ss.html" title="core::arch::x86::_mm_maskz_roundscale_ss fn">_mm_maskz_roundscale_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的下部单精度 (32-bit) 浮点元素四舍五入为 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时该元素清零)，并将上面的 3 个包装的元素从 a 复制到 dst 的上面的元素。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_rsqrt14_pd.html" title="core::arch::x86::_mm_maskz_rsqrt14_pd fn">_mm_maskz_rsqrt14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中的包装的双精度 (64-bit) 浮点元素的近似倒数平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_rsqrt14_ps.html" title="core::arch::x86::_mm_maskz_rsqrt14_ps fn">_mm_maskz_rsqrt14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_rsqrt14_sd.html" title="core::arch::x86::_mm_maskz_rsqrt14_sd fn">_mm_maskz_rsqrt14_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 b 中较低的双精度 (64-bit) 浮点元素的近似倒数平方根，使用零掩码 k 将结果存储在 dst 的较低元素中 (未设置掩码位 0 时该元素归零)，然后复制从 a 到 dst 的上元素的上元素。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_rsqrt14_ss.html" title="core::arch::x86::_mm_maskz_rsqrt14_ss fn">_mm_maskz_rsqrt14_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 b 中较低单精度 (32-bit) 浮点元素的近似倒数平方根，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素归零)，然后复制从 a 到 dst 的上层元素的上 3 个包装的元素。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_scalef_pd.html" title="core::arch::x86::_mm_maskz_scalef_pd fn">_mm_maskz_scalef_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_scalef_ps.html" title="core::arch::x86::_mm_maskz_scalef_ps fn">_mm_maskz_scalef_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_scalef_round_sd.html" title="core::arch::x86::_mm_maskz_scalef_round_sd fn">_mm_maskz_scalef_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的值缩放 a 中的包装双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后复制上部元素从 a 到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_scalef_round_ss.html" title="core::arch::x86::_mm_maskz_scalef_round_ss fn">_mm_maskz_scalef_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，并复制上部 3 从 a 到 dst 的上层元素的包装的元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_scalef_sd.html" title="core::arch::x86::_mm_maskz_scalef_sd fn">_mm_maskz_scalef_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的值缩放 a 中的包装双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后复制上部元素从 a 到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_scalef_ss.html" title="core::arch::x86::_mm_maskz_scalef_ss fn">_mm_maskz_scalef_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，并复制上部 3 从 a 到 dst 的上层元素的包装的元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_set1_epi8.html" title="core::arch::x86::_mm_maskz_set1_epi8 fn">_mm_maskz_set1_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用零掩码 k 将 8 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_set1_epi16.html" title="core::arch::x86::_mm_maskz_set1_epi16 fn">_mm_maskz_set1_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用零掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_set1_epi32.html" title="core::arch::x86::_mm_maskz_set1_epi32 fn">_mm_maskz_set1_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用零掩码 k 将 32 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_set1_epi64.html" title="core::arch::x86::_mm_maskz_set1_epi64 fn">_mm_maskz_set1_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用零掩码 k 将 64 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_shldi_epi16.html" title="core::arch::x86::_mm_maskz_shldi_epi16 fn">_mm_maskz_shldi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_shldi_epi32.html" title="core::arch::x86::_mm_maskz_shldi_epi32 fn">_mm_maskz_shldi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_shldi_epi64.html" title="core::arch::x86::_mm_maskz_shldi_epi64 fn">_mm_maskz_shldi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_shldv_epi16.html" title="core::arch::x86::_mm_maskz_shldv_epi16 fn">_mm_maskz_shldv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_shldv_epi32.html" title="core::arch::x86::_mm_maskz_shldv_epi32 fn">_mm_maskz_shldv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_shldv_epi64.html" title="core::arch::x86::_mm_maskz_shldv_epi64 fn">_mm_maskz_shldv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_shrdi_epi16.html" title="core::arch::x86::_mm_maskz_shrdi_epi16 fn">_mm_maskz_shrdi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_shrdi_epi32.html" title="core::arch::x86::_mm_maskz_shrdi_epi32 fn">_mm_maskz_shrdi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_shrdi_epi64.html" title="core::arch::x86::_mm_maskz_shrdi_epi64 fn">_mm_maskz_shrdi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_shrdv_epi16.html" title="core::arch::x86::_mm_maskz_shrdv_epi16 fn">_mm_maskz_shrdv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_shrdv_epi32.html" title="core::arch::x86::_mm_maskz_shrdv_epi32 fn">_mm_maskz_shrdv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_shrdv_epi64.html" title="core::arch::x86::_mm_maskz_shrdv_epi64 fn">_mm_maskz_shrdv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_shuffle_epi8.html" title="core::arch::x86::_mm_maskz_shuffle_epi8 fn">_mm_maskz_shuffle_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 b 的相应 8 位元素中的打乱控制掩码对 a 中的包装 8 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_shuffle_epi32.html" title="core::arch::x86::_mm_maskz_shuffle_epi32 fn">_mm_maskz_shuffle_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件在 128 位通道中的 32 位整数中混洗 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_shuffle_pd.html" title="core::arch::x86::_mm_maskz_shuffle_pd fn">_mm_maskz_shuffle_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件对 128 位通道内的双精度 (64-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_shuffle_ps.html" title="core::arch::x86::_mm_maskz_shuffle_ps fn">_mm_maskz_shuffle_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 imm8 中的控件对 a 中的单精度 (32-bit) 浮点元素进行打乱，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素会被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_shufflehi_epi16.html" title="core::arch::x86::_mm_maskz_shufflehi_epi16 fn">_mm_maskz_shufflehi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用 imm8 中的控件在 a 的 128 位通道的高 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的高 64 位中，将 128 位通道的低 64 位从 a 复制到 dst，使用 zeromask k (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_shufflelo_epi16.html" title="core::arch::x86::_mm_maskz_shufflelo_epi16 fn">_mm_maskz_shufflelo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用 imm8 中的控件在 a 的 128 位通道的低 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的低 64 位中，并使用写掩码 k 将 128 位通道的高 64 位从 a 复制到 dst (当未使用相应的掩码位时，元素从 src 复制) 放)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sll_epi16.html" title="core::arch::x86::_mm_maskz_sll_epi16 fn">_mm_maskz_sll_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数按计数左移，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sll_epi32.html" title="core::arch::x86::_mm_maskz_sll_epi32 fn">_mm_maskz_sll_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 32 位整数左移计数，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sll_epi64.html" title="core::arch::x86::_mm_maskz_sll_epi64 fn">_mm_maskz_sll_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将填充的 64 位整数左移计数，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_slli_epi16.html" title="core::arch::x86::_mm_maskz_slli_epi16 fn">_mm_maskz_slli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_slli_epi32.html" title="core::arch::x86::_mm_maskz_slli_epi32 fn">_mm_maskz_slli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 32 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_slli_epi64.html" title="core::arch::x86::_mm_maskz_slli_epi64 fn">_mm_maskz_slli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 64 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sllv_epi16.html" title="core::arch::x86::_mm_maskz_sllv_epi16 fn">_mm_maskz_sllv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数左移由 count 中的相应元素指定的数量，同时移入零，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sllv_epi32.html" title="core::arch::x86::_mm_maskz_sllv_epi32 fn">_mm_maskz_sllv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在将移位的 32 位整数左移零时，将其对应计数指定的数量左移，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sllv_epi64.html" title="core::arch::x86::_mm_maskz_sllv_epi64 fn">_mm_maskz_sllv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在将移位的 64 位整数左移零时，将其对应计数指定的数量左移，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sqrt_pd.html" title="core::arch::x86::_mm_maskz_sqrt_pd fn">_mm_maskz_sqrt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并使用零掩码 k (将结果置零，当未设置相应的掩码位时将元素清零) 将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sqrt_ps.html" title="core::arch::x86::_mm_maskz_sqrt_ps fn">_mm_maskz_sqrt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sqrt_round_sd.html" title="core::arch::x86::_mm_maskz_sqrt_round_sd fn">_mm_maskz_sqrt_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 b 中下部双精度 (64-bit) 浮点元素的平方根，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后复制上部元素从 a 到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sqrt_round_ss.html" title="core::arch::x86::_mm_maskz_sqrt_round_ss fn">_mm_maskz_sqrt_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 b 中较低的单精度 (32-bit) 浮点元素的平方根，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后复制高 3 从 a 到 dst 的上层元素的包装的元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sqrt_sd.html" title="core::arch::x86::_mm_maskz_sqrt_sd fn">_mm_maskz_sqrt_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 b 中下部双精度 (64-bit) 浮点元素的平方根，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后复制上部元素从 a 到 dst 的高位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sqrt_ss.html" title="core::arch::x86::_mm_maskz_sqrt_ss fn">_mm_maskz_sqrt_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 b 中较低的单精度 (32-bit) 浮点元素的平方根，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后复制高 3 从 a 到 dst 的上层元素的包装的元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sra_epi16.html" title="core::arch::x86::_mm_maskz_sra_epi16 fn">_mm_maskz_sra_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数按计数右移，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sra_epi32.html" title="core::arch::x86::_mm_maskz_sra_epi32 fn">_mm_maskz_sra_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在移动符号位的同时右移计数包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sra_epi64.html" title="core::arch::x86::_mm_maskz_sra_epi64 fn">_mm_maskz_sra_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在移动符号位的同时右移计数包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_srai_epi16.html" title="core::arch::x86::_mm_maskz_srai_epi16 fn">_mm_maskz_srai_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_srai_epi32.html" title="core::arch::x86::_mm_maskz_srai_epi32 fn">_mm_maskz_srai_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 32 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_srai_epi64.html" title="core::arch::x86::_mm_maskz_srai_epi64 fn">_mm_maskz_srai_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 64 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_srav_epi16.html" title="core::arch::x86::_mm_maskz_srav_epi16 fn">_mm_maskz_srav_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数右移由 count 中的相应元素指定的数量，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_srav_epi32.html" title="core::arch::x86::_mm_maskz_srav_epi32 fn">_mm_maskz_srav_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在将符号位移位的同时，将已包装的 32 位整数向右移动计数中相应元素指定的数量，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_srav_epi64.html" title="core::arch::x86::_mm_maskz_srav_epi64 fn">_mm_maskz_srav_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在移入符号位的同时，将包装的 64 位整数右移由 count 中相应元素指定的数量，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_srl_epi16.html" title="core::arch::x86::_mm_maskz_srl_epi16 fn">_mm_maskz_srl_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数右移，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_srl_epi32.html" title="core::arch::x86::_mm_maskz_srl_epi32 fn">_mm_maskz_srl_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将移位的 32 位整数右移，同时移零，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_srl_epi64.html" title="core::arch::x86::_mm_maskz_srl_epi64 fn">_mm_maskz_srl_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 64 位整数右移计数，同时移入零，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_srli_epi16.html" title="core::arch::x86::_mm_maskz_srli_epi16 fn">_mm_maskz_srli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_srli_epi32.html" title="core::arch::x86::_mm_maskz_srli_epi32 fn">_mm_maskz_srli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 32 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_srli_epi64.html" title="core::arch::x86::_mm_maskz_srli_epi64 fn">_mm_maskz_srli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 64 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_srlv_epi16.html" title="core::arch::x86::_mm_maskz_srlv_epi16 fn">_mm_maskz_srlv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_srlv_epi32.html" title="core::arch::x86::_mm_maskz_srlv_epi32 fn">_mm_maskz_srlv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>向右移动已包装的 32 位整数，偏移量为相应元素在计数中指定的数量，同时向零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_srlv_epi64.html" title="core::arch::x86::_mm_maskz_srlv_epi64 fn">_mm_maskz_srlv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>向右移位包装的 64 位整数，其数量为计数中相应元素指定的数量，同时移位为零，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sub_epi8.html" title="core::arch::x86::_mm_maskz_sub_epi8 fn">_mm_maskz_sub_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>从 a 中的包装 8 位整数中减去 b 中的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sub_epi16.html" title="core::arch::x86::_mm_maskz_sub_epi16 fn">_mm_maskz_sub_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>从 a 中的包装的 16 位整数中减去 b 中的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sub_epi32.html" title="core::arch::x86::_mm_maskz_sub_epi32 fn">_mm_maskz_sub_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中的包装 32 位整数中减去 b 中的包装 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sub_epi64.html" title="core::arch::x86::_mm_maskz_sub_epi64 fn">_mm_maskz_sub_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中的包装 64 位整数中减去 b 中的包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sub_pd.html" title="core::arch::x86::_mm_maskz_sub_pd fn">_mm_maskz_sub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sub_ps.html" title="core::arch::x86::_mm_maskz_sub_ps fn">_mm_maskz_sub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 b 中的包装后的单精度 (32-bit) 浮点元素减去 a 中的包装后的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sub_round_sd.html" title="core::arch::x86::_mm_maskz_sub_round_sd fn">_mm_maskz_sub_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中的较低双精度 (64-bit) 浮点元素中减去 b 中的较低双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码 bit 0 为 0 时，该元素将被清零。(未设置)，然后将上层元素从 a 复制到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sub_round_ss.html" title="core::arch::x86::_mm_maskz_sub_round_ss fn">_mm_maskz_sub_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中的较低单精度 (32-bit) 浮点元素中减去 b 中的较低单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码 bit 0 为 0 时，该元素将被清零。(未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sub_sd.html" title="core::arch::x86::_mm_maskz_sub_sd fn">_mm_maskz_sub_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中的较低双精度 (64-bit) 浮点元素中减去 b 中的较低双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码 bit 0 为 0 时，该元素将被清零。(未设置)，然后将上层元素从 a 复制到 dst 的上层元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_sub_ss.html" title="core::arch::x86::_mm_maskz_sub_ss fn">_mm_maskz_sub_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中的较低单精度 (32-bit) 浮点元素中减去 b 中的较低单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码 bit 0 为 0 时，该元素将被清零。(未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_subs_epi8.html" title="core::arch::x86::_mm_maskz_subs_epi8 fn">_mm_maskz_subs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用饱和度从包装的 8 位整数中减去 b 中的包装有符号的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_subs_epi16.html" title="core::arch::x86::_mm_maskz_subs_epi16 fn">_mm_maskz_subs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用饱和度将 b 中的包装 16 位整数减去 b 中的包装有符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_subs_epu8.html" title="core::arch::x86::_mm_maskz_subs_epu8 fn">_mm_maskz_subs_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用 a 饱和度从 b 中的包装无符号 8 位整数减去 b 中的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_subs_epu16.html" title="core::arch::x86::_mm_maskz_subs_epu16 fn">_mm_maskz_subs_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用 a 饱和度将 b 中的包装无符号 16 位整数减去 b 中的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_ternarylogic_epi32.html" title="core::arch::x86::_mm_maskz_ternarylogic_epi32 fn">_mm_maskz_ternarylogic_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 32 位整数中的每一位，来自 a、b 和 c 的相应位用于形成 imm8 的 3 位索引，并使用零掩码将 imm8 中该位的值写入 dst 中的相应位 k 在 32 位粒度 (当未设置相应的掩码位时，32 位元素被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_ternarylogic_epi64.html" title="core::arch::x86::_mm_maskz_ternarylogic_epi64 fn">_mm_maskz_ternarylogic_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 64 位整数中的每一位，来自 a、b 和 c 的相应位用于在 imm8 中形成 3 位索引，并使用零掩码将 imm8 中该位的值写入 dst 中的相应位 k 在 64 位粒度 (当未设置相应的掩码位时，64 位元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_unpackhi_epi8.html" title="core::arch::x86::_mm_maskz_unpackhi_epi8 fn">_mm_maskz_unpackhi_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的高半部分拆包和交织 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_unpackhi_epi16.html" title="core::arch::x86::_mm_maskz_unpackhi_epi16 fn">_mm_maskz_unpackhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的高半部分拆包和交织 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_unpackhi_epi32.html" title="core::arch::x86::_mm_maskz_unpackhi_epi32 fn">_mm_maskz_unpackhi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_unpackhi_epi64.html" title="core::arch::x86::_mm_maskz_unpackhi_epi64 fn">_mm_maskz_unpackhi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_unpackhi_pd.html" title="core::arch::x86::_mm_maskz_unpackhi_pd fn">_mm_maskz_unpackhi_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_unpackhi_ps.html" title="core::arch::x86::_mm_maskz_unpackhi_ps fn">_mm_maskz_unpackhi_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的高半部分解包和交织单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_unpacklo_epi8.html" title="core::arch::x86::_mm_maskz_unpacklo_epi8 fn">_mm_maskz_unpacklo_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的下半部分拆包和交织 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_unpacklo_epi16.html" title="core::arch::x86::_mm_maskz_unpacklo_epi16 fn">_mm_maskz_unpacklo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的下半部分拆包和交织 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_unpacklo_epi32.html" title="core::arch::x86::_mm_maskz_unpacklo_epi32 fn">_mm_maskz_unpacklo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包和交织 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_unpacklo_epi64.html" title="core::arch::x86::_mm_maskz_unpacklo_epi64 fn">_mm_maskz_unpacklo_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包和交织 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_unpacklo_pd.html" title="core::arch::x86::_mm_maskz_unpacklo_pd fn">_mm_maskz_unpacklo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包和交织双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_unpacklo_ps.html" title="core::arch::x86::_mm_maskz_unpacklo_ps fn">_mm_maskz_unpacklo_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>从 a 和 b 中每个 128 位通道的下半部分解包和交织单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_xor_epi32.html" title="core::arch::x86::_mm_maskz_xor_epi32 fn">_mm_maskz_xor_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 32 位整数的按位 XOR，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_maskz_xor_epi64.html" title="core::arch::x86::_mm_maskz_xor_epi64 fn">_mm_maskz_xor_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 64 位整数的按位 XOR，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_max_epi64.html" title="core::arch::x86::_mm_max_epi64 fn">_mm_max_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的带符号的 64 位整数，并将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_max_epu64.html" title="core::arch::x86::_mm_max_epu64 fn">_mm_max_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数，并将包装的最大值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_max_round_sd.html" title="core::arch::x86::_mm_max_round_sd fn">_mm_max_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，将最大值存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_max_round_ss.html" title="core::arch::x86::_mm_max_round_ss fn">_mm_max_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，将最大值存储在 dst 的较低元素中，并将较高的 3 个包装的元素从 a 复制到 dst 的较高元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_min_epu64.html" title="core::arch::x86::_mm_min_epu64 fn">_mm_min_epu64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>比较 a 和 b 中包装的无符号 64 位整数，并将包装的最小值存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_min_round_sd.html" title="core::arch::x86::_mm_min_round_sd fn">_mm_min_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，将最小值存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_min_round_ss.html" title="core::arch::x86::_mm_min_round_ss fn">_mm_min_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，将最小值存储在 dst 的较低元素中，并将较高的 3 个包装的元素从 a 复制到 dst 的较高元素。<br />
可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_movepi8_mask.html" title="core::arch::x86::_mm_movepi8_mask fn">_mm_movepi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 a 中相应包装的 8 位整数的最高有效位设置掩码寄存器 k 的每个位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_movepi16_mask.html" title="core::arch::x86::_mm_movepi16_mask fn">_mm_movepi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 a 中相应的包装的 16 位整数的最高有效位设置掩码寄存器 k 的每一位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_movm_epi8.html" title="core::arch::x86::_mm_movm_epi8 fn">_mm_movm_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 k 中相应位的值，将 dst 中每个包装的 8 位整数设置为全 1 或全 0。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_movm_epi16.html" title="core::arch::x86::_mm_movm_epi16 fn">_mm_movm_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>根据 k 中相应位的值，将 dst 中每个包装的 16 位整数设置为全 1 或全 0。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mul_round_sd.html" title="core::arch::x86::_mm_mul_round_sd fn">_mm_mul_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的下部双精度 (64-bit) 浮点元素相乘，将结果存储在 dst 的下部元素中，然后将 a 的上部元素复制到 dst 的上部元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_mul_round_ss.html" title="core::arch::x86::_mm_mul_round_ss fn">_mm_mul_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 a 和 b 中的下部单精度 (32-bit) 浮点元素相乘，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到 dst 的上部元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_multishift_epi64_epi8.html" title="core::arch::x86::_mm_multishift_epi64_epi8 fn">_mm_multishift_epi64_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span><p>对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并将 8 个组装字节存储到 dst 的相应 64 位元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_or_epi32.html" title="core::arch::x86::_mm_or_epi32 fn">_mm_or_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 32 位整数的按位或，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_or_epi64.html" title="core::arch::x86::_mm_or_epi64 fn">_mm_or_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 64 位整数的按位或，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_permutex2var_epi8.html" title="core::arch::x86::_mm_permutex2var_epi8 fn">_mm_permutex2var_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span><p>使用 idx 中的相应选择器和索引将 a 和 b 中的 8 位整数跨通道打乱，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_permutex2var_epi16.html" title="core::arch::x86::_mm_permutex2var_epi16 fn">_mm_permutex2var_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中对 16 位整数进行打乱，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_permutex2var_epi32.html" title="core::arch::x86::_mm_permutex2var_epi32 fn">_mm_permutex2var_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中随机排列 32 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_permutex2var_epi64.html" title="core::arch::x86::_mm_permutex2var_epi64 fn">_mm_permutex2var_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的相应选择器和索引在通道中的 a 和 b 中随机排列 64 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_permutex2var_pd.html" title="core::arch::x86::_mm_permutex2var_pd fn">_mm_permutex2var_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_permutex2var_ps.html" title="core::arch::x86::_mm_permutex2var_ps fn">_mm_permutex2var_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对单精度 (32-bit) 浮点元素进行混洗，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_permutexvar_epi8.html" title="core::arch::x86::_mm_permutexvar_epi8 fn">_mm_permutexvar_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi,avx512vl` only"><code>avx512vbmi,avx512vl</code></span><p>使用 idx 中的相应索引将 a 中的 8 位整数打乱到通道中，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_permutexvar_epi16.html" title="core::arch::x86::_mm_permutexvar_epi16 fn">_mm_permutexvar_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>使用 idx 中的相应索引在跨通道中对 16 位整数进行打乱，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_popcnt_epi8.html" title="core::arch::x86::_mm_popcnt_epi8 fn">_mm_popcnt_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span><p>对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_popcnt_epi16.html" title="core::arch::x86::_mm_popcnt_epi16 fn">_mm_popcnt_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bitalg,avx512vl` only"><code>avx512bitalg,avx512vl</code></span><p>对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_popcnt_epi32.html" title="core::arch::x86::_mm_popcnt_epi32 fn">_mm_popcnt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq,avx512vl` only"><code>avx512vpopcntdq,avx512vl</code></span><p>对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_popcnt_epi64.html" title="core::arch::x86::_mm_popcnt_epi64 fn">_mm_popcnt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vpopcntdq,avx512vl` only"><code>avx512vpopcntdq,avx512vl</code></span><p>对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_rcp14_pd.html" title="core::arch::x86::_mm_rcp14_pd fn">_mm_rcp14_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并将结果存储在 dst 中。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_rcp14_ps.html" title="core::arch::x86::_mm_rcp14_ps fn">_mm_rcp14_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并将结果存储在 dst 中。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_rcp14_sd.html" title="core::arch::x86::_mm_rcp14_sd fn">_mm_rcp14_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 b 中较低的双精度 (64-bit) 浮点元素的近似倒数，将结果存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_rcp14_ss.html" title="core::arch::x86::_mm_rcp14_ss fn">_mm_rcp14_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 b 中较低的单精度 (32-bit) 浮点元素的近似倒数，将结果存储在 dst 的较低元素中，并将高 3 个包装的元素从 a 复制到 dst 的较高元素。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_rol_epi32.html" title="core::arch::x86::_mm_rol_epi32 fn">_mm_rol_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 X 中每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_rol_epi64.html" title="core::arch::x86::_mm_rol_epi64 fn">_mm_rol_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 X 中每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_rolv_epi32.html" title="core::arch::x86::_mm_rolv_epi32 fn">_mm_rolv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的 32 位整数中的位向左旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_rolv_epi64.html" title="core::arch::x86::_mm_rolv_epi64 fn">_mm_rolv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的 64 位整数中的位向左旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_ror_epi32.html" title="core::arch::x86::_mm_ror_epi32 fn">_mm_ror_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 X 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_ror_epi64.html" title="core::arch::x86::_mm_ror_epi64 fn">_mm_ror_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 X 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_rorv_epi32.html" title="core::arch::x86::_mm_rorv_epi32 fn">_mm_rorv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的 32 位整数中的位向右旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_rorv_epi64.html" title="core::arch::x86::_mm_rorv_epi64 fn">_mm_rorv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_roundscale_pd.html" title="core::arch::x86::_mm_roundscale_pd fn">_mm_roundscale_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 x 中的包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并将结果存储在 dst 中。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_roundscale_ps.html" title="core::arch::x86::_mm_roundscale_ps fn">_mm_roundscale_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的小数位数，然后将结果存储在 dst 中。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_roundscale_round_sd.html" title="core::arch::x86::_mm_roundscale_round_sd fn">_mm_roundscale_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的下部双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，将结果存储在 dst 的下部元素中，并将上部的元素从 a 复制到 dst 的上部元素。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_roundscale_round_ss.html" title="core::arch::x86::_mm_roundscale_round_ss fn">_mm_roundscale_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的下部单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到 dst 的上部元素。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_roundscale_sd.html" title="core::arch::x86::_mm_roundscale_sd fn">_mm_roundscale_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的下部双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，将结果存储在 dst 的下部元素中，并将上部的元素从 a 复制到 dst 的上部元素。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_roundscale_ss.html" title="core::arch::x86::_mm_roundscale_ss fn">_mm_roundscale_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将 b 中的下部单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到 dst 的上部元素。<br />
根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一:<br />
_MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值<br />
_MM_FROUND_TO_NEG_INF     // 向下取整<br />
_MM_FROUND_TO_POS_INF     // 向上舍入<br />
_MM_FROUND_TO_ZERO        // 截断<br />
_MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_rsqrt14_sd.html" title="core::arch::x86::_mm_rsqrt14_sd fn">_mm_rsqrt14_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 b 中较低的双精度 (64-bit) 浮点元素的近似倒数平方根，将结果存储在 dst 的较低元素中，并将较高的元素从 a 复制到 dst 的较高元素。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_rsqrt14_ss.html" title="core::arch::x86::_mm_rsqrt14_ss fn">_mm_rsqrt14_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 b 中较低单精度 (32-bit) 浮点元素的近似倒数平方根，将结果存储在 dst 的较低元素中，并将高 3 个包装的元素从 a 复制到 dst 的较高元素。该近似值的最大相对误差小于 2^-14。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_scalef_pd.html" title="core::arch::x86::_mm_scalef_pd fn">_mm_scalef_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_scalef_ps.html" title="core::arch::x86::_mm_scalef_ps fn">_mm_scalef_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_scalef_round_sd.html" title="core::arch::x86::_mm_scalef_round_sd fn">_mm_scalef_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，将结果存储在 dst 的下部元素中，然后将 a 的上部元素复制到 dst 的上部元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_scalef_round_ss.html" title="core::arch::x86::_mm_scalef_round_ss fn">_mm_scalef_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的值缩放 a 中的包装的单精度 (32-bit) 浮点元素，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到 dst 的上部元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_scalef_sd.html" title="core::arch::x86::_mm_scalef_sd fn">_mm_scalef_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，将结果存储在 dst 的下部元素中，然后将 a 的上部元素复制到 dst 的上部元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_scalef_ss.html" title="core::arch::x86::_mm_scalef_ss fn">_mm_scalef_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>使用 b 中的值缩放 a 中的包装的单精度 (32-bit) 浮点元素，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到 dst 的上部元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_shldi_epi16.html" title="core::arch::x86::_mm_shldi_epi16 fn">_mm_shldi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并将高 16 位存储在 dst 中)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_shldi_epi32.html" title="core::arch::x86::_mm_shldi_epi32 fn">_mm_shldi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并将高 32 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_shldi_epi64.html" title="core::arch::x86::_mm_shldi_epi64 fn">_mm_shldi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并将高 64 位存储在 dst 中)。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_shldv_epi16.html" title="core::arch::x86::_mm_shldv_epi16 fn">_mm_shldv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的对应元素中指定的量，并将高 16 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_shldv_epi32.html" title="core::arch::x86::_mm_shldv_epi32 fn">_mm_shldv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的对应元素中指定的量，并将高 32 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_shldv_epi64.html" title="core::arch::x86::_mm_shldv_epi64 fn">_mm_shldv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的对应元素中指定的量，并将高 64 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_shrdi_epi16.html" title="core::arch::x86::_mm_shrdi_epi16 fn">_mm_shrdi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并将低 16 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_shrdi_epi32.html" title="core::arch::x86::_mm_shrdi_epi32 fn">_mm_shrdi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并将低 32 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_shrdi_epi64.html" title="core::arch::x86::_mm_shrdi_epi64 fn">_mm_shrdi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并将低 64 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_shrdv_epi16.html" title="core::arch::x86::_mm_shrdv_epi16 fn">_mm_shrdv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的对应元素中指定的量，并将低 16 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_shrdv_epi32.html" title="core::arch::x86::_mm_shrdv_epi32 fn">_mm_shrdv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的对应元素中指定的量，并将低 32 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_shrdv_epi64.html" title="core::arch::x86::_mm_shrdv_epi64 fn">_mm_shrdv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512vbmi2,avx512vl` only"><code>avx512vbmi2,avx512vl</code></span><p>将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的对应元素中指定的量，并将低 64 位存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_sllv_epi16.html" title="core::arch::x86::_mm_sllv_epi16 fn">_mm_sllv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数按 count 中相应元素指定的数量向左移位，同时将零移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_sqrt_round_sd.html" title="core::arch::x86::_mm_sqrt_round_sd fn">_mm_sqrt_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 b 中较低的双精度 (64-bit) 浮点元素的平方根，将结果存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_sqrt_round_ss.html" title="core::arch::x86::_mm_sqrt_round_ss fn">_mm_sqrt_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>计算 b 中较低的单精度 (32-bit) 浮点元素的平方根，将结果存储在 dst 的较低元素中，并将高 3 个包装的元素从 a 复制到 dst 的较高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_sra_epi64.html" title="core::arch::x86::_mm_sra_epi64 fn">_mm_sra_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>在移动符号位的同时按计数右移包装的 64 位整数，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_srai_epi64.html" title="core::arch::x86::_mm_srai_epi64 fn">_mm_srai_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将包装的 64 位整数右移 imm8，同时将符号位移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_srav_epi16.html" title="core::arch::x86::_mm_srav_epi16 fn">_mm_srav_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数右移 count 中相应元素指定的数量，同时移入符号位，然后将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_srav_epi64.html" title="core::arch::x86::_mm_srav_epi64 fn">_mm_srav_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将移位的 64 位整数向右移动计数中相应元素指定的数量，同时移入符号位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_srlv_epi16.html" title="core::arch::x86::_mm_srlv_epi16 fn">_mm_srlv_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_store_epi32.html" title="core::arch::x86::_mm_store_epi32 fn">_mm_store_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的 128 位 (由 4 个包装的 32 位整数组成) 存储到内存中。mem_addr 必须在 16 字节边界上对齐，否则可能会生成一般保护异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_store_epi64.html" title="core::arch::x86::_mm_store_epi64 fn">_mm_store_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的 128 位 (由 2 个包装的 64 位整数组成) 存储到内存中。mem_addr 必须在 16 字节边界上对齐，否则可能会生成一般保护异常。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_storeu_epi8.html" title="core::arch::x86::_mm_storeu_epi8 fn">_mm_storeu_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的 128 位 (由 16 个包装的 8 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_storeu_epi16.html" title="core::arch::x86::_mm_storeu_epi16 fn">_mm_storeu_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>将 a 中的 128 位 (由 8 个包装的 16 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_storeu_epi32.html" title="core::arch::x86::_mm_storeu_epi32 fn">_mm_storeu_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的 128 位 (由 4 个包装的 32 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_storeu_epi64.html" title="core::arch::x86::_mm_storeu_epi64 fn">_mm_storeu_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>将 a 中的 128 位 (由 2 个包装的 64 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_sub_round_sd.html" title="core::arch::x86::_mm_sub_round_sd fn">_mm_sub_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中的较低双精度 (64-bit) 浮点元素中减去 b 中较低的双精度 (64-bit) 浮点元素，将结果存储在 dst 的较低元素中，并将较高的元素从 a 复制到 dst 的较高元素。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_sub_round_ss.html" title="core::arch::x86::_mm_sub_round_ss fn">_mm_sub_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>从 a 中的下部单精度 (32-bit) 浮点元素中减去 b 中的下部单精度 (32-bit) 浮点元素，将结果存储在 dst 的下部元素中，并将上部 3 个包装的元素从 a 复制到上部元素 dst。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_ternarylogic_epi32.html" title="core::arch::x86::_mm_ternarylogic_epi32 fn">_mm_ternarylogic_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个包装的 32 位整数中的每个位，来自 a，b 和 c 的相应位用于形成到 imm8 的 3 位索引，并且将 imm8 中该位的值写入 dst 中的相应位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_ternarylogic_epi64.html" title="core::arch::x86::_mm_ternarylogic_epi64 fn">_mm_ternarylogic_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 64 位整数中的每一位，a、b 和 c 中的相应位用于形成 imm8 中的 3 位索引，并将 imm8 中该位的值写入 dst 中的相应位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_test_epi8_mask.html" title="core::arch::x86::_mm_test_epi8_mask fn">_mm_test_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 和 b 中包装的 8 位整数的按位与，生成中间 8 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_test_epi16_mask.html" title="core::arch::x86::_mm_test_epi16_mask fn">_mm_test_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 和 b 中包装的 16 位整数的按位与，生成中间的 16 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_test_epi32_mask.html" title="core::arch::x86::_mm_test_epi32_mask fn">_mm_test_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 32 位整数的按位与，生成中间的 32 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_test_epi64_mask.html" title="core::arch::x86::_mm_test_epi64_mask fn">_mm_test_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 64 位整数的按位与，生成中间 64 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_testn_epi8_mask.html" title="core::arch::x86::_mm_testn_epi8_mask fn">_mm_testn_epi8_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 和 b 中包装的 8 位整数的按位 NAND，生成中间的 8 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_testn_epi16_mask.html" title="core::arch::x86::_mm_testn_epi16_mask fn">_mm_testn_epi16_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw,avx512vl` only"><code>avx512bw,avx512vl</code></span><p>计算 a 和 b 中包装的 16 位整数的按位 NAND，生成中间的 16 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_testn_epi32_mask.html" title="core::arch::x86::_mm_testn_epi32_mask fn">_mm_testn_epi32_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 32 位整数的按位 NAND，生成中间的 32 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_testn_epi64_mask.html" title="core::arch::x86::_mm_testn_epi64_mask fn">_mm_testn_epi64_mask</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 64 位整数的按位 NAND，生成中间的 64 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_xor_epi32.html" title="core::arch::x86::_mm_xor_epi32 fn">_mm_xor_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 32 位整数的按位 XOR，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._mm_xor_epi64.html" title="core::arch::x86::_mm_xor_epi64 fn">_mm_xor_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512f,avx512vl` only"><code>avx512f,avx512vl</code></span><p>计算 a 和 b 中包装的 64 位整数的按位 XOR，并将结果存储在 dst 中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._store_mask32.html" title="core::arch::x86::_store_mask32 fn">_store_mask32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 32 位掩码从 a 存储到内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._store_mask64.html" title="core::arch::x86::_store_mask64 fn">_store_mask64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `avx512bw` only"><code>avx512bw</code></span><p>将 64 位掩码从 a 存储到内存中。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._xabort.html" title="core::arch::x86::_xabort fn">_xabort</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `rtm` only"><code>rtm</code></span><p>强制将受限制的事务内存 (RTM) 区域终止。
<a href="https://software.intel.com/en-us/cpp-compiler-developer-guide-and-reference-xabort">Intel’s documentation</a>.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._xabort_code.html" title="core::arch::x86::_xabort_code fn">_xabort_code</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>当 <a href="fn._xbegin.html" title="_xbegin"><code>_xbegin</code></a> 的状态设置为 <code>_XABORT_EXPLICIT</code> 标志时，检索传递给 <a href="fn._xabort.html" title="_xabort"><code>_xabort</code></a> 的参数。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._xbegin.html" title="core::arch::x86::_xbegin fn">_xbegin</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `rtm` only"><code>rtm</code></span><p>指定受限制的事务性存储器 (RTM) 代码区域的开始，并返回一个指示状态的值。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._xend.html" title="core::arch::x86::_xend fn">_xend</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `rtm` only"><code>rtm</code></span><p>指定受限制的事务性存储器 (RTM) 代码区域的结尾。
<a href="https://software.intel.com/en-us/cpp-compiler-developer-guide-and-reference-xend">Intel’s documentation</a>.</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn._xtest.html" title="core::arch::x86::_xtest fn">_xtest</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><span class="stab portability" title="This is supported with target feature `rtm` only"><code>rtm</code></span><p>查询处理器是在由受限事务存储器 (RTM) 还是硬件锁定扩展 (HLE) 标识的事务区域中执行。</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.has_cpuid.html" title="core::arch::x86::has_cpuid fn">has_cpuid</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>主机是否支持 <code>cpuid</code> 指令?</p>
</td></tr><tr class="unstable module-item"><td><a class="fn" href="fn.ud2.html" title="core::arch::x86::ud2 fn">ud2</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>生成陷阱指令 <code>UD2</code></p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._MM_GET_EXCEPTION_MASK.html" title="core::arch::x86::_MM_GET_EXCEPTION_MASK fn">_MM_GET_EXCEPTION_MASK</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._MM_GET_EXCEPTION_STATE.html" title="core::arch::x86::_MM_GET_EXCEPTION_STATE fn">_MM_GET_EXCEPTION_STATE</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._MM_GET_FLUSH_ZERO_MODE.html" title="core::arch::x86::_MM_GET_FLUSH_ZERO_MODE fn">_MM_GET_FLUSH_ZERO_MODE</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._MM_GET_ROUNDING_MODE.html" title="core::arch::x86::_MM_GET_ROUNDING_MODE fn">_MM_GET_ROUNDING_MODE</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._MM_SET_EXCEPTION_MASK.html" title="core::arch::x86::_MM_SET_EXCEPTION_MASK fn">_MM_SET_EXCEPTION_MASK</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._MM_SET_EXCEPTION_STATE.html" title="core::arch::x86::_MM_SET_EXCEPTION_STATE fn">_MM_SET_EXCEPTION_STATE</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._MM_SET_FLUSH_ZERO_MODE.html" title="core::arch::x86::_MM_SET_FLUSH_ZERO_MODE fn">_MM_SET_FLUSH_ZERO_MODE</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._MM_SET_ROUNDING_MODE.html" title="core::arch::x86::_MM_SET_ROUNDING_MODE fn">_MM_SET_ROUNDING_MODE</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>请参见 <a href="fn._mm_setcsr.html"><code>_mm_setcsr</code></a></p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._MM_TRANSPOSE4_PS.html" title="core::arch::x86::_MM_TRANSPOSE4_PS fn">_MM_TRANSPOSE4_PS</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>将由 4 行 __m128 组成的 4x4 矩阵转置到位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.__cpuid.html" title="core::arch::x86::__cpuid fn">__cpuid</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><p>请参见 <a href="fn.__cpuid_count.html"><code>__cpuid_count</code></a>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.__cpuid_count.html" title="core::arch::x86::__cpuid_count fn">__cpuid_count</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><p>返回给定 <code>leaf</code> (<code>EAX</code>) 和 <code>sub_leaf</code> (<code>ECX</code>) 的 <code>cpuid</code> 指令的结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.__get_cpuid_max.html" title="core::arch::x86::__get_cpuid_max fn">__get_cpuid_max</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><p>返回最高支持的 <code>leaf</code> (<code>EAX</code>) 和子叶 (<code>ECX</code>) <code>cpuid</code> 值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.__rdtscp.html" title="core::arch::x86::__rdtscp fn">__rdtscp</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><p>读取处理器时间戳计数器和 <code>IA32_TSC_AUX MSR</code> 的当前值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._addcarry_u32.html" title="core::arch::x86::_addcarry_u32 fn">_addcarry_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><p>将无符号的 32 位整数 <code>a</code> 和 <code>b</code> 与无符号的 8 位进位 <code>c_in</code> (进位标志) 相加，并将无符号的 32 位结果存储在 <code>out</code> 中，并返回进位 (进位或溢出标志)。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._addcarryx_u32.html" title="core::arch::x86::_addcarryx_u32 fn">_addcarryx_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `adx` only"><code>adx</code></span><p>将无符号的 32 位整数 <code>a</code> 和 <code>b</code> 与无符号的 8 位进位 <code>c_in</code> (进位或溢出标志) 相加，并将无符号的 32 位结果存储在 <code>out</code> 中，并返回进位 (进位或溢出标志)。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._andn_u32.html" title="core::arch::x86::_andn_u32 fn">_andn_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `bmi1` only"><code>bmi1</code></span><p><code>a</code> 和 <code>b</code> 的按位逻辑 <code>AND</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._bextr2_u32.html" title="core::arch::x86::_bextr2_u32 fn">_bextr2_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `bmi1` only"><code>bmi1</code></span><p>将 <code>control</code> 指定的 <code>a</code> 的位提取到结果的最低有效位中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._bextr_u32.html" title="core::arch::x86::_bextr_u32 fn">_bextr_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `bmi1` only"><code>bmi1</code></span><p>从 <code>a</code> 提取范围为 [start，<code>start</code> + <code>length</code>) 的位到结果的最低有效位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._bittest.html" title="core::arch::x86::_bittest fn">_bittest</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><p>返回由 <code>p</code> 寻址的存储器的位置 <code>b</code> 中的位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._bittestandcomplement.html" title="core::arch::x86::_bittestandcomplement fn">_bittestandcomplement</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><p>返回由 <code>p</code> 寻址的存储器的位置 <code>b</code> 中的位，然后将该位取反。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._bittestandreset.html" title="core::arch::x86::_bittestandreset fn">_bittestandreset</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><p>返回由 <code>p</code> 寻址的存储器的位置 <code>b</code> 中的位，然后将该位重置为 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._bittestandset.html" title="core::arch::x86::_bittestandset fn">_bittestandset</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><p>返回由 <code>p</code> 寻址的存储器的位置 <code>b</code> 中的位，然后将该位设置为 <code>1</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._blcfill_u32.html" title="core::arch::x86::_blcfill_u32 fn">_blcfill_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span><p>清除 <code>x</code> 的最低有效零位以下的所有位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._blcfill_u64.html" title="core::arch::x86::_blcfill_u64 fn">_blcfill_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span><p>清除 <code>x</code> 的最低有效零位以下的所有位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._blci_u32.html" title="core::arch::x86::_blci_u32 fn">_blci_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span><p>将 <code>x</code> 的所有位 (最低有效零位除外) 设置为 1。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._blci_u64.html" title="core::arch::x86::_blci_u64 fn">_blci_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span><p>将 <code>x</code> 的所有位 (最低有效零位除外) 设置为 1。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._blcic_u32.html" title="core::arch::x86::_blcic_u32 fn">_blcic_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span><p>设置 <code>x</code> 的最低有效零位并清除所有其他位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._blcic_u64.html" title="core::arch::x86::_blcic_u64 fn">_blcic_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span><p>设置 <code>x</code> 的最低有效零位并清除所有其他位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._blcmsk_u32.html" title="core::arch::x86::_blcmsk_u32 fn">_blcmsk_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span><p>设置 <code>x</code> 的最低有效零位，并清除该位上方的所有位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._blcmsk_u64.html" title="core::arch::x86::_blcmsk_u64 fn">_blcmsk_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span><p>设置 <code>x</code> 的最低有效零位，并清除该位上方的所有位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._blcs_u32.html" title="core::arch::x86::_blcs_u32 fn">_blcs_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span><p>设置 <code>x</code> 的最低有效零位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._blcs_u64.html" title="core::arch::x86::_blcs_u64 fn">_blcs_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span><p>设置 <code>x</code> 的最低有效零位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._blsfill_u32.html" title="core::arch::x86::_blsfill_u32 fn">_blsfill_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span><p>将 <code>x</code> 的所有位设置在最低有效位以下。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._blsfill_u64.html" title="core::arch::x86::_blsfill_u64 fn">_blsfill_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span><p>将 <code>x</code> 的所有位设置在最低有效位以下。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._blsi_u32.html" title="core::arch::x86::_blsi_u32 fn">_blsi_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `bmi1` only"><code>bmi1</code></span><p>提取最低位隔离位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._blsic_u32.html" title="core::arch::x86::_blsic_u32 fn">_blsic_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span><p>清除最低有效位并设置所有其他位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._blsic_u64.html" title="core::arch::x86::_blsic_u64 fn">_blsic_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span><p>清除最低有效位并设置所有其他位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._blsmsk_u32.html" title="core::arch::x86::_blsmsk_u32 fn">_blsmsk_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `bmi1` only"><code>bmi1</code></span><p>将掩码提高到最低设置位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._blsr_u32.html" title="core::arch::x86::_blsr_u32 fn">_blsr_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `bmi1` only"><code>bmi1</code></span><p>复位 <code>x</code> 的最低位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._bswap.html" title="core::arch::x86::_bswap fn">_bswap</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><p>返回整数，其字节顺序为 x</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._bzhi_u32.html" title="core::arch::x86::_bzhi_u32 fn">_bzhi_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `bmi2` only"><code>bmi2</code></span><p>将 <code>a</code> &gt;= <code>index</code> 的高位清零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._fxrstor.html" title="core::arch::x86::_fxrstor fn">_fxrstor</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fxsr` only"><code>fxsr</code></span><p>从以下位置恢复 <code>XMM</code>，<code>MMX</code>，<code>MXCSR</code> 和 <code>x87</code> FPU 寄存器
512 字节长，16 字节对齐的内存区域 <code>mem_addr</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._fxsave.html" title="core::arch::x86::_fxsave fn">_fxsave</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fxsr` only"><code>fxsr</code></span><p>将 <code>x87</code> FPU，<code>MMX</code> 技术，<code>XMM</code> 和 <code>MXCSR</code> 寄存器保存到
512 字节长，16 字节对齐的内存区域 <code>mem_addr</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._lzcnt_u32.html" title="core::arch::x86::_lzcnt_u32 fn">_lzcnt_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `lzcnt` only"><code>lzcnt</code></span><p>计算前导最高有效零位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_abs_epi8.html" title="core::arch::x86::_mm256_abs_epi8 fn">_mm256_abs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>计算 <code>a</code> 中包装的 8 位整数的绝对值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_abs_epi16.html" title="core::arch::x86::_mm256_abs_epi16 fn">_mm256_abs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>计算 <code>a</code> 中包装的 16 位整数的绝对值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_abs_epi32.html" title="core::arch::x86::_mm256_abs_epi32 fn">_mm256_abs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>计算 <code>a</code> 中包装的 32 位整数的绝对值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_add_epi8.html" title="core::arch::x86::_mm256_add_epi8 fn">_mm256_add_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>在 <code>a</code> 和 <code>b</code> 中添加包装的 8 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_add_epi16.html" title="core::arch::x86::_mm256_add_epi16 fn">_mm256_add_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>在 <code>a</code> 和 <code>b</code> 中添加包装的 16 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_add_epi32.html" title="core::arch::x86::_mm256_add_epi32 fn">_mm256_add_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>在 <code>a</code> 和 <code>b</code> 中添加包装的 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_add_epi64.html" title="core::arch::x86::_mm256_add_epi64 fn">_mm256_add_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>在 <code>a</code> 和 <code>b</code> 中添加包装的 64 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_add_pd.html" title="core::arch::x86::_mm256_add_pd fn">_mm256_add_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>在 <code>a</code> 和 <code>b</code> 中添加包装的双精度 (64-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_add_ps.html" title="core::arch::x86::_mm256_add_ps fn">_mm256_add_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>在 <code>a</code> 和 <code>b</code> 中添加包装的单精度 (32-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_adds_epi8.html" title="core::arch::x86::_mm256_adds_epi8 fn">_mm256_adds_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用饱和度在 <code>a</code> 和 <code>b</code> 中添加包装的 8 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_adds_epi16.html" title="core::arch::x86::_mm256_adds_epi16 fn">_mm256_adds_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用饱和度在 <code>a</code> 和 <code>b</code> 中添加包装的 16 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_adds_epu8.html" title="core::arch::x86::_mm256_adds_epu8 fn">_mm256_adds_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用饱和度在 <code>a</code> 和 <code>b</code> 中添加包装的无符号 8 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_adds_epu16.html" title="core::arch::x86::_mm256_adds_epu16 fn">_mm256_adds_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用饱和度在 <code>a</code> 和 <code>b</code> 中添加包装的无符号 16 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_addsub_pd.html" title="core::arch::x86::_mm256_addsub_pd fn">_mm256_addsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>或者，将<code>a</code>中的包装双精度（64位）浮点元素与<code>b</code>中的包装元素进行加减。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_addsub_ps.html" title="core::arch::x86::_mm256_addsub_ps fn">_mm256_addsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>或者，将<code>a</code>中的包装的单精度（32位）浮点元素与<code>b</code>中的包装的元素进行加减。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_alignr_epi8.html" title="core::arch::x86::_mm256_alignr_epi8 fn">_mm256_alignr_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 和 <code>b</code> 中的 16 字节块对连接成一个 32 字节的临时结果，将结果右移 <code>n</code> 字节，然后返回低 16 字节。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_and_pd.html" title="core::arch::x86::_mm256_and_pd fn">_mm256_and_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 和 <code>b</code> 中包装的双精度 (64-bit) 浮点元素的按位与。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_and_ps.html" title="core::arch::x86::_mm256_and_ps fn">_mm256_and_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 和 <code>b</code> 中包装的单精度 (32-bit) 浮点元素的按位与。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_and_si256.html" title="core::arch::x86::_mm256_and_si256 fn">_mm256_and_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>计算 <code>a</code> 和 <code>b</code> 中 256 位 (代表整数数据) 的按位与。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_andnot_pd.html" title="core::arch::x86::_mm256_andnot_pd fn">_mm256_andnot_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 中包装的双精度 (64-bit) 浮点元素的按位 NOT，然后计算 <code>b</code> 的 AND。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_andnot_ps.html" title="core::arch::x86::_mm256_andnot_ps fn">_mm256_andnot_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 中包装的单精度 (32-bit) 浮点元素的按位非，然后计算 <code>b</code> 的 AND。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_andnot_si256.html" title="core::arch::x86::_mm256_andnot_si256 fn">_mm256_andnot_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>计算 <code>a</code> 中 256 位 (代表整数数据) 的按位非，然后计算 <code>b</code> 的与。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_avg_epu8.html" title="core::arch::x86::_mm256_avg_epu8 fn">_mm256_avg_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p><code>a</code> 和 <code>b</code> 中的包装无符号 8 位整数的平均值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_avg_epu16.html" title="core::arch::x86::_mm256_avg_epu16 fn">_mm256_avg_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p><code>a</code> 和 <code>b</code> 中的包装无符号 16 位整数的平均值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_blend_epi16.html" title="core::arch::x86::_mm256_blend_epi16 fn">_mm256_blend_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用控制掩码 <code>IMM8</code> 混合包装来自 <code>a</code> 和 <code>b</code> 的 16 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_blend_epi32.html" title="core::arch::x86::_mm256_blend_epi32 fn">_mm256_blend_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用控制掩码 <code>IMM8</code> 混合来自 <code>a</code> 和 <code>b</code> 的包装的 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_blend_pd.html" title="core::arch::x86::_mm256_blend_pd fn">_mm256_blend_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用控制掩码 <code>imm8</code> 混合来自 <code>a</code> 和 <code>b</code> 的包装后的双精度 (64-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_blend_ps.html" title="core::arch::x86::_mm256_blend_ps fn">_mm256_blend_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用控制掩码 <code>imm8</code> 混合来自 <code>a</code> 和 <code>b</code> 的包装的单精度 (32-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_blendv_epi8.html" title="core::arch::x86::_mm256_blendv_epi8 fn">_mm256_blendv_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用 <code>mask</code> 混合来自 <code>a</code> 和 <code>b</code> 的包装的 8 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_blendv_pd.html" title="core::arch::x86::_mm256_blendv_pd fn">_mm256_blendv_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用 <code>c</code> 作为掩码，混合来自 <code>a</code> 和 <code>b</code> 的包装后的双精度 (64-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_blendv_ps.html" title="core::arch::x86::_mm256_blendv_ps fn">_mm256_blendv_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用 <code>c</code> 作为掩码，混合来自 <code>a</code> 和 <code>b</code> 的包装的单精度 (32-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_broadcast_pd.html" title="core::arch::x86::_mm256_broadcast_pd fn">_mm256_broadcast_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将内存中的 128 位 (由 2 个包装的双精度 (64-bit) 浮点元素组成) 广播到返回的 vector 的所有元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_broadcast_ps.html" title="core::arch::x86::_mm256_broadcast_ps fn">_mm256_broadcast_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>从内存 (由 4 个包装的单精度 (32-bit) 浮点元素组成) 向广播的 vector 的所有元素广播 128 位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_broadcast_sd.html" title="core::arch::x86::_mm256_broadcast_sd fn">_mm256_broadcast_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>从内存向返回的 vector 的所有元素广播双精度 (64-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_broadcast_ss.html" title="core::arch::x86::_mm256_broadcast_ss fn">_mm256_broadcast_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>从内存向返回的 vector 的所有元素广播单精度 (32-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_broadcastb_epi8.html" title="core::arch::x86::_mm256_broadcastb_epi8 fn">_mm256_broadcastb_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 的低位包装 8 位整数广播到 256 位返回值的所有元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_broadcastd_epi32.html" title="core::arch::x86::_mm256_broadcastd_epi32 fn">_mm256_broadcastd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 的低位包装 32 位整数广播到 256 位返回值的所有元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_broadcastq_epi64.html" title="core::arch::x86::_mm256_broadcastq_epi64 fn">_mm256_broadcastq_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 的低位包装 64 位整数广播到 256 位返回值的所有元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_broadcastsd_pd.html" title="core::arch::x86::_mm256_broadcastsd_pd fn">_mm256_broadcastsd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将低双精度 (64-bit) 浮点元素从 <code>a</code> 广播到 256 位返回值的所有元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_broadcastsi128_si256.html" title="core::arch::x86::_mm256_broadcastsi128_si256 fn">_mm256_broadcastsi128_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 a 广播 128 位整数数据到 256 位返回值中的所有 128 位通道。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_broadcastss_ps.html" title="core::arch::x86::_mm256_broadcastss_ps fn">_mm256_broadcastss_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将低单精度 (32-bit) 浮点元素从 <code>a</code> 广播到 256 位返回值的所有元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_broadcastw_epi16.html" title="core::arch::x86::_mm256_broadcastw_epi16 fn">_mm256_broadcastw_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将低位包装的 16 位整数从 a 广播到 256 位返回值的所有元素</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_bslli_epi128.html" title="core::arch::x86::_mm256_bslli_epi128 fn">_mm256_bslli_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的 128 位通道向左移 <code>imm8</code> 字节，同时向零移位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_bsrli_epi128.html" title="core::arch::x86::_mm256_bsrli_epi128 fn">_mm256_bsrli_epi128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的 128 位通道右移 <code>imm8</code> 字节，同时将其移位为零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_castpd128_pd256.html" title="core::arch::x86::_mm256_castpd128_pd256 fn">_mm256_castpd128_pd256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将类型 __m128d 的 vector 转换为 __m256d 类型;
结果的高 128 位未定义。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_castpd256_pd128.html" title="core::arch::x86::_mm256_castpd256_pd128 fn">_mm256_castpd256_pd128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将类型为 __m256d 的 vector 强制转换为类型为 __m128d 的 vector。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_castpd_ps.html" title="core::arch::x86::_mm256_castpd_ps fn">_mm256_castpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将类型为 __m256d 的 vector 强制转换为类型为 __m256 的 vector。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_castpd_si256.html" title="core::arch::x86::_mm256_castpd_si256 fn">_mm256_castpd_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将类型为 __m256d 的 vector 强制转换为类型为 __m256i 的 vector。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_castps128_ps256.html" title="core::arch::x86::_mm256_castps128_ps256 fn">_mm256_castps128_ps256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将类型 __m128 的 vector 转换为 __m256 类型;
结果的高 128 位未定义。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_castps256_ps128.html" title="core::arch::x86::_mm256_castps256_ps128 fn">_mm256_castps256_ps128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将类型为 __m256 的 vector 强制转换为类型为 __m128 的 vector。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_castps_pd.html" title="core::arch::x86::_mm256_castps_pd fn">_mm256_castps_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将类型为 __m256 的 vector 强制转换为类型为 __m256d 的 vector。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_castps_si256.html" title="core::arch::x86::_mm256_castps_si256 fn">_mm256_castps_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将类型为 __m256 的 vector 强制转换为类型为 __m256i 的 vector。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_castsi128_si256.html" title="core::arch::x86::_mm256_castsi128_si256 fn">_mm256_castsi128_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将类型为 __m128i 的 vector 强制转换为类型 __m256i;
结果的高 128 位未定义。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_castsi256_pd.html" title="core::arch::x86::_mm256_castsi256_pd fn">_mm256_castsi256_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将类型为 __m256i 的 vector 强制转换为类型为 __m256d 的 vector。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_castsi256_ps.html" title="core::arch::x86::_mm256_castsi256_ps fn">_mm256_castsi256_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将类型为 __m256i 的 vector 强制转换为类型为 __m256 的 vector。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_castsi256_si128.html" title="core::arch::x86::_mm256_castsi256_si128 fn">_mm256_castsi256_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将类型为 __m256i 的 vector 强制转换为类型为 __m128i 的 vector。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_ceil_pd.html" title="core::arch::x86::_mm256_ceil_pd fn">_mm256_ceil_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素四舍五入为正无穷大。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_ceil_ps.html" title="core::arch::x86::_mm256_ceil_ps fn">_mm256_ceil_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将 <code>a</code> 中的包装的单精度 (32-bit) 浮点元素四舍五入为正无穷大。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cmp_pd.html" title="core::arch::x86::_mm256_cmp_pd fn">_mm256_cmp_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>根据 <code>IMM5</code> 指定的比较操作数比较 <code>a</code> 和 <code>b</code> 中包装的双精度 (64-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cmp_ps.html" title="core::arch::x86::_mm256_cmp_ps fn">_mm256_cmp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>根据 <code>IMM5</code> 指定的比较操作数比较 <code>a</code> 和 <code>b</code> 中包装的单精度 (32-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cmpeq_epi8.html" title="core::arch::x86::_mm256_cmpeq_epi8 fn">_mm256_cmpeq_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装 8 位整数是否相等。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cmpeq_epi16.html" title="core::arch::x86::_mm256_cmpeq_epi16 fn">_mm256_cmpeq_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的 16 位整数是否相等。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cmpeq_epi32.html" title="core::arch::x86::_mm256_cmpeq_epi32 fn">_mm256_cmpeq_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装 32 位整数是否相等。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cmpeq_epi64.html" title="core::arch::x86::_mm256_cmpeq_epi64 fn">_mm256_cmpeq_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装 64 位整数是否相等。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cmpgt_epi8.html" title="core::arch::x86::_mm256_cmpgt_epi8 fn">_mm256_cmpgt_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的 8 位整数是否大于。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cmpgt_epi16.html" title="core::arch::x86::_mm256_cmpgt_epi16 fn">_mm256_cmpgt_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的 16 位整数是否大于。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cmpgt_epi32.html" title="core::arch::x86::_mm256_cmpgt_epi32 fn">_mm256_cmpgt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的 32 位整数是否大于。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cmpgt_epi64.html" title="core::arch::x86::_mm256_cmpgt_epi64 fn">_mm256_cmpgt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装 64 位整数是否大于。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cvtepi8_epi16.html" title="core::arch::x86::_mm256_cvtepi8_epi16 fn">_mm256_cvtepi8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 8 位整数符号扩展为 16 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cvtepi8_epi32.html" title="core::arch::x86::_mm256_cvtepi8_epi32 fn">_mm256_cvtepi8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 8 位整数符号扩展为 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cvtepi8_epi64.html" title="core::arch::x86::_mm256_cvtepi8_epi64 fn">_mm256_cvtepi8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 8 位整数符号扩展为 64 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cvtepi16_epi32.html" title="core::arch::x86::_mm256_cvtepi16_epi32 fn">_mm256_cvtepi16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 16 位整数符号扩展为 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cvtepi16_epi64.html" title="core::arch::x86::_mm256_cvtepi16_epi64 fn">_mm256_cvtepi16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 16 位整数符号扩展为 64 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cvtepi32_epi64.html" title="core::arch::x86::_mm256_cvtepi32_epi64 fn">_mm256_cvtepi32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 32 位整数符号扩展为 64 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cvtepi32_pd.html" title="core::arch::x86::_mm256_cvtepi32_pd fn">_mm256_cvtepi32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将 <code>a</code> 中的包装的 32 位整数转换为包装的双精度 (64-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cvtepi32_ps.html" title="core::arch::x86::_mm256_cvtepi32_ps fn">_mm256_cvtepi32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将 <code>a</code> 中的包装的 32 位整数转换为包装的单精度 (32-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cvtepu8_epi16.html" title="core::arch::x86::_mm256_cvtepu8_epi16 fn">_mm256_cvtepu8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的无符号 8 位整数零扩展为 16 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cvtepu8_epi32.html" title="core::arch::x86::_mm256_cvtepu8_epi32 fn">_mm256_cvtepu8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的低八位无符号 8 位整数零扩展为 32 位整数。
<code>a</code> 的前八个元素未使用。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cvtepu8_epi64.html" title="core::arch::x86::_mm256_cvtepu8_epi64 fn">_mm256_cvtepu8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的低四位无符号 8 位整数零扩展到 64 位整数。
<code>a</code> 的前十二个元素未使用。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cvtepu16_epi32.html" title="core::arch::x86::_mm256_cvtepu16_epi32 fn">_mm256_cvtepu16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>零将 <code>a</code> 中的包装的无符号 16 位整数扩展为包装的 32 位整数，并将结果存储在 <code>dst</code> 中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cvtepu16_epi64.html" title="core::arch::x86::_mm256_cvtepu16_epi64 fn">_mm256_cvtepu16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的低四位无符号 16 位整数零扩展到 64 位整数。
<code>a</code> 的前四个元素未使用。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cvtepu32_epi64.html" title="core::arch::x86::_mm256_cvtepu32_epi64 fn">_mm256_cvtepu32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的无符号 32 位整数零扩展为 64 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cvtpd_epi32.html" title="core::arch::x86::_mm256_cvtpd_epi32 fn">_mm256_cvtpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素转换为包装的 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cvtpd_ps.html" title="core::arch::x86::_mm256_cvtpd_ps fn">_mm256_cvtpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cvtps_epi32.html" title="core::arch::x86::_mm256_cvtps_epi32 fn">_mm256_cvtps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将 <code>a</code> 中的包装的单精度 (32-bit) 浮点元素转换为包装的 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cvtps_pd.html" title="core::arch::x86::_mm256_cvtps_pd fn">_mm256_cvtps_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将 <code>a</code> 中的包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cvtsd_f64.html" title="core::arch::x86::_mm256_cvtsd_f64 fn">_mm256_cvtsd_f64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>返回 <code>[4 x double]</code> 的输入 vector 的第一个元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cvtsi256_si32.html" title="core::arch::x86::_mm256_cvtsi256_si32 fn">_mm256_cvtsi256_si32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>返回 <code>[8 x i32]</code> 的输入 vector 的第一个元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cvtss_f32.html" title="core::arch::x86::_mm256_cvtss_f32 fn">_mm256_cvtss_f32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>返回 <code>[8 x float]</code> 的输入 vector 的第一个元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cvttpd_epi32.html" title="core::arch::x86::_mm256_cvttpd_epi32 fn">_mm256_cvttpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_cvttps_epi32.html" title="core::arch::x86::_mm256_cvttps_epi32 fn">_mm256_cvttps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将 <code>a</code> 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_div_pd.html" title="core::arch::x86::_mm256_div_pd fn">_mm256_div_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 中的 4 个包装的 64 位浮点元素中的每一个除以 <code>b</code> 中相应的封装元素的除法。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_div_ps.html" title="core::arch::x86::_mm256_div_ps fn">_mm256_div_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 中的 8 个包装的 32 位浮点元素中的每一个除以 <code>b</code> 中相应的封装元素的除法。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_dp_ps.html" title="core::arch::x86::_mm256_dp_ps fn">_mm256_dp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用 <code>imm8</code> 的高 4 位有条件地将 <code>a</code> 和 <code>b</code> 中的包装的单精度 (32-bit) 浮点元素相乘，对四个乘积求和，并使用 <code>imm8</code> 的低 4 位有条件地返回总和。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_extract_epi8.html" title="core::arch::x86::_mm256_extract_epi8 fn">_mm256_extract_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>a</code> 中提取一个 8 位整数，用 <code>INDEX</code> 选择。
返回包含零扩展整数数据的 32 位整数。
See <a href="https://reviews.llvm.org/D20468">LLVM commit D20468</a>.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_extract_epi16.html" title="core::arch::x86::_mm256_extract_epi16 fn">_mm256_extract_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>a</code> 中提取一个 16 位整数，用 <code>INDEX</code> 选择。
返回包含零扩展整数数据的 32 位整数。
See <a href="https://reviews.llvm.org/D20468">LLVM commit D20468</a>.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_extract_epi32.html" title="core::arch::x86::_mm256_extract_epi32 fn">_mm256_extract_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>a</code> 中提取一个 32 位整数，用 <code>INDEX</code> 选择。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_extractf128_pd.html" title="core::arch::x86::_mm256_extractf128_pd fn">_mm256_extractf128_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>从 <code>a</code> 提取 128 位 (由 2 个包装的双精度 (64-bit) 浮点元素组成)，并使用 <code>imm8</code> 进行选择。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_extractf128_ps.html" title="core::arch::x86::_mm256_extractf128_ps fn">_mm256_extractf128_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>从 <code>a</code> 提取 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并用 <code>imm8</code> 选择。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_extractf128_si256.html" title="core::arch::x86::_mm256_extractf128_si256 fn">_mm256_extractf128_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>从 <code>a</code> 中提取 128 位 (由整数数据组成)，并用 <code>imm8</code> 选择。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_extracti128_si256.html" title="core::arch::x86::_mm256_extracti128_si256 fn">_mm256_extracti128_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>IMM1</code> 选择的 <code>a</code> 中提取 128 位 (整数数据)。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_floor_pd.html" title="core::arch::x86::_mm256_floor_pd fn">_mm256_floor_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素四舍五入为负无穷大。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_floor_ps.html" title="core::arch::x86::_mm256_floor_ps fn">_mm256_floor_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将 <code>a</code> 中的包装的单精度 (32-bit) 浮点元素四舍五入为负无穷大。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_fmadd_pd.html" title="core::arch::x86::_mm256_fmadd_pd fn">_mm256_fmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素相乘，并将中间结果与 <code>c</code> 中的包装的元素相加。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_fmadd_ps.html" title="core::arch::x86::_mm256_fmadd_ps fn">_mm256_fmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装单精度 (32-bit) 浮点元素相乘，并将中间结果添加到 <code>c</code> 中的包装元素中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_fmaddsub_pd.html" title="core::arch::x86::_mm256_fmaddsub_pd fn">_mm256_fmaddsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素相乘，或者在 <code>c</code> to/from 中将包装的元素相加或减去中间结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_fmaddsub_ps.html" title="core::arch::x86::_mm256_fmaddsub_ps fn">_mm256_fmaddsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中包装的单精度 (32-bit) 浮点元素相乘，或者将 <code>c</code> 中包装的元素加/减到中间结果中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_fmsub_pd.html" title="core::arch::x86::_mm256_fmsub_pd fn">_mm256_fmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素相乘，并从中间结果中减去 <code>c</code> 中的包装的双精度元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_fmsub_ps.html" title="core::arch::x86::_mm256_fmsub_ps fn">_mm256_fmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装的单精度 (32-bit) 浮点元素相乘，并从中间结果中减去 <code>c</code> 中的包装元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_fmsubadd_pd.html" title="core::arch::x86::_mm256_fmsubadd_pd fn">_mm256_fmsubadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素相乘，也可以从中间结果中减去或加上 <code>c</code> 中的包装元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_fmsubadd_ps.html" title="core::arch::x86::_mm256_fmsubadd_ps fn">_mm256_fmsubadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装单精度 (32-bit) 浮点元素相乘，或者将 <code>c</code> 中的包装元素从中间结果中减去或加上。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_fnmadd_pd.html" title="core::arch::x86::_mm256_fnmadd_pd fn">_mm256_fnmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装双精度 (64-bit) 浮点元素相乘，然后将取反的中间结果添加到 <code>c</code> 中的包装元素中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_fnmadd_ps.html" title="core::arch::x86::_mm256_fnmadd_ps fn">_mm256_fnmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装单精度 (32-bit) 浮点元素相乘，并将取反的中间结果添加到 <code>c</code> 中的包装元素中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_fnmsub_pd.html" title="core::arch::x86::_mm256_fnmsub_pd fn">_mm256_fnmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素相乘，并从取反的中间结果中减去 <code>c</code> 中的包装的元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_fnmsub_ps.html" title="core::arch::x86::_mm256_fnmsub_ps fn">_mm256_fnmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装的单精度 (32-bit) 浮点元素相乘，并从取反的中间结果中减去 <code>c</code> 中的包装的元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_hadd_epi16.html" title="core::arch::x86::_mm256_hadd_epi16 fn">_mm256_hadd_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>在 <code>a</code> 和 <code>b</code> 中水平添加相邻的 16 位整数对。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_hadd_epi32.html" title="core::arch::x86::_mm256_hadd_epi32 fn">_mm256_hadd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>在 <code>a</code> 和 <code>b</code> 中水平添加相邻的 32 位整数对。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_hadd_pd.html" title="core::arch::x86::_mm256_hadd_pd fn">_mm256_hadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>在 4 个 64 位浮点 <code>a</code> 和 <code>b</code> 的两个包装的 vectors 中水平相加相邻对。
结果，来自 <code>a</code> 的元素之和在偶数位置返回，而来自 <code>b</code> 的元素之和在奇数位置返回。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_hadd_ps.html" title="core::arch::x86::_mm256_hadd_ps fn">_mm256_hadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>在 8 个 32 位浮点 <code>a</code> 和 <code>b</code> 的两个包装的 vectors 中水平相加相邻对。
结果，来自 <code>a</code> 的元素之和返回到索引 0、1、4、5 的位置; 而 <code>b</code> 中的元素总和是位置</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_hadds_epi16.html" title="core::arch::x86::_mm256_hadds_epi16 fn">_mm256_hadds_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用饱和度在 <code>a</code> 和 <code>b</code> 中水平添加相邻的 16 位整数对。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_hsub_epi16.html" title="core::arch::x86::_mm256_hsub_epi16 fn">_mm256_hsub_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>水平减去 <code>a</code> 和 <code>b</code> 中相邻的 16 位整数对。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_hsub_epi32.html" title="core::arch::x86::_mm256_hsub_epi32 fn">_mm256_hsub_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>水平减去 <code>a</code> 和 <code>b</code> 中相邻的 32 位整数对。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_hsub_pd.html" title="core::arch::x86::_mm256_hsub_pd fn">_mm256_hsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>在 4 个 64 位浮点 <code>a</code> 和 <code>b</code> 的两个包装的 vectors 中对相邻对进行水平减法。
结果，来自 <code>a</code> 的元素之和在偶数位置返回，而来自 <code>b</code> 的元素之和在奇数位置返回。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_hsub_ps.html" title="core::arch::x86::_mm256_hsub_ps fn">_mm256_hsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将 8 个 32 位浮点 <code>a</code> 和 <code>b</code> 的两个包装的 vectors 中的相邻对进行水平减法。
结果，来自 <code>a</code> 的元素之和返回到索引 0、1、4、5 的位置; 而 <code>b</code> 中的元素总和是位置</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_hsubs_epi16.html" title="core::arch::x86::_mm256_hsubs_epi16 fn">_mm256_hsubs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用饱和度水平减去 <code>a</code> 和 <code>b</code> 中相邻的 16 位整数对。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_i32gather_epi32.html" title="core::arch::x86::_mm256_i32gather_epi32 fn">_mm256_i32gather_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_i32gather_epi64.html" title="core::arch::x86::_mm256_i32gather_epi64 fn">_mm256_i32gather_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应为 1、2、4 和 8。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_i32gather_pd.html" title="core::arch::x86::_mm256_i32gather_pd fn">_mm256_i32gather_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_i32gather_ps.html" title="core::arch::x86::_mm256_i32gather_ps fn">_mm256_i32gather_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_i64gather_epi32.html" title="core::arch::x86::_mm256_i64gather_epi32 fn">_mm256_i64gather_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_i64gather_epi64.html" title="core::arch::x86::_mm256_i64gather_epi64 fn">_mm256_i64gather_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_i64gather_pd.html" title="core::arch::x86::_mm256_i64gather_pd fn">_mm256_i64gather_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_i64gather_ps.html" title="core::arch::x86::_mm256_i64gather_ps fn">_mm256_i64gather_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_insert_epi8.html" title="core::arch::x86::_mm256_insert_epi8 fn">_mm256_insert_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>复制 <code>a</code> 到结果，并在 <code>index</code> 指定的位置将 8 位整数 <code>i</code> 插入到结果中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_insert_epi16.html" title="core::arch::x86::_mm256_insert_epi16 fn">_mm256_insert_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>复制 <code>a</code> 到结果，并在 <code>index</code> 指定的位置将 16 位整数 <code>i</code> 插入到 result 中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_insert_epi32.html" title="core::arch::x86::_mm256_insert_epi32 fn">_mm256_insert_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>复制 <code>a</code> 到结果，然后在 <code>index</code> 指定的位置将 32 位整数 <code>i</code> 插入到结果中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_insertf128_pd.html" title="core::arch::x86::_mm256_insertf128_pd fn">_mm256_insertf128_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将 <code>a</code> 复制到结果中，然后将 <code>b</code> 中的 128 位 (由 2 个包装的双精度 (64-bit) 浮点元素组成) 插入 <code>imm8</code> 指定的位置的结果中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_insertf128_ps.html" title="core::arch::x86::_mm256_insertf128_ps fn">_mm256_insertf128_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将 <code>a</code> 复制到结果中，然后将 <code>b</code> 中的 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成) 插入 <code>imm8</code> 指定的位置的结果中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_insertf128_si256.html" title="core::arch::x86::_mm256_insertf128_si256 fn">_mm256_insertf128_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>复制 <code>a</code> 到结果，然后将 <code>b</code> 中的 128 位插入到 <code>imm8</code> 指定的位置的结果中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_inserti128_si256.html" title="core::arch::x86::_mm256_inserti128_si256 fn">_mm256_inserti128_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 复制到 <code>dst</code>，然后在 <code>IMM1</code> 指定的位置插入来自 <code>b</code> 的 128 位 (整数数据)。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_lddqu_si256.html" title="core::arch::x86::_mm256_lddqu_si256 fn">_mm256_lddqu_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>从未对齐的内存中将 256 位整数数据加载到结果中。
当数据越过缓存行边界时，此内联函数可能比 <code>_mm256_loadu_si256</code> 更好。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_load_pd.html" title="core::arch::x86::_mm256_load_pd fn">_mm256_load_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>从内存中将 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成) 加载到结果中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_load_ps.html" title="core::arch::x86::_mm256_load_ps fn">_mm256_load_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>从内存中将 256 位 (由 8 个包装的单精度 (32-bit) 浮点元素组成) 加载到结果中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_load_si256.html" title="core::arch::x86::_mm256_load_si256 fn">_mm256_load_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>从内存中将 256 位整数数据加载到结果中。
<code>mem_addr</code> 必须在 32 字节边界上对齐，否则可能会产生一般保护异常。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_loadu2_m128.html" title="core::arch::x86::_mm256_loadu2_m128 fn">_mm256_loadu2_m128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx,sse` only"><code>avx,sse</code></span><p>从内存中加载两个 128 位值 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并将它们组合为 256 位值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_loadu2_m128d.html" title="core::arch::x86::_mm256_loadu2_m128d fn">_mm256_loadu2_m128d</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx,sse2` only"><code>avx,sse2</code></span><p>从内存中加载两个 128 位值 (由 2 个包装的双精度 (64-bit) 浮点元素组成)，并将它们组合为 256 位值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_loadu2_m128i.html" title="core::arch::x86::_mm256_loadu2_m128i fn">_mm256_loadu2_m128i</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx,sse2` only"><code>avx,sse2</code></span><p>从内存中加载两个 128 位值 (由整数数据组成)，并将它们组合为 256 位值。
<code>hiaddr</code> <code>loaddr</code> 和 <code>loaddr</code> 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_loadu_pd.html" title="core::arch::x86::_mm256_loadu_pd fn">_mm256_loadu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>从内存中将 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成) 加载到结果中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_loadu_ps.html" title="core::arch::x86::_mm256_loadu_ps fn">_mm256_loadu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>从内存中将 256 位 (由 8 个包装的单精度 (32-bit) 浮点元素组成) 加载到结果中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_loadu_si256.html" title="core::arch::x86::_mm256_loadu_si256 fn">_mm256_loadu_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>从内存中将 256 位整数数据加载到结果中。
<code>mem_addr</code> 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_madd_epi16.html" title="core::arch::x86::_mm256_madd_epi16 fn">_mm256_madd_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 和 <code>b</code> 中包装的带符号的 16 位整数相乘，产生中间的带符号的 32 位整数。
水平添加相邻的中间 32 位整数对。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_maddubs_epi16.html" title="core::arch::x86::_mm256_maddubs_epi16 fn">_mm256_maddubs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的每个无符号 8 位整数与 <code>b</code> 中的相应带符号 8 位整数垂直相乘，生成中间带符号的 16 位整数。
水平相加相邻的中间带符号的 16 位整数对</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_mask_i32gather_epi32.html" title="core::arch::x86::_mm256_mask_i32gather_epi32 fn">_mm256_mask_i32gather_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_mask_i32gather_epi64.html" title="core::arch::x86::_mm256_mask_i32gather_epi64 fn">_mm256_mask_i32gather_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_mask_i32gather_pd.html" title="core::arch::x86::_mm256_mask_i32gather_pd fn">_mm256_mask_i32gather_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_mask_i32gather_ps.html" title="core::arch::x86::_mm256_mask_i32gather_ps fn">_mm256_mask_i32gather_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_mask_i64gather_epi32.html" title="core::arch::x86::_mm256_mask_i64gather_epi32 fn">_mm256_mask_i64gather_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_mask_i64gather_epi64.html" title="core::arch::x86::_mm256_mask_i64gather_epi64 fn">_mm256_mask_i64gather_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_mask_i64gather_pd.html" title="core::arch::x86::_mm256_mask_i64gather_pd fn">_mm256_mask_i64gather_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_mask_i64gather_ps.html" title="core::arch::x86::_mm256_mask_i64gather_ps fn">_mm256_mask_i64gather_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_maskload_epi32.html" title="core::arch::x86::_mm256_maskload_epi32 fn">_mm256_maskload_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用 <code>mask</code> 从 <code>mem_addr</code> 指向的内存中加载包装的 32 位整数 (当未在相应元素中设置最高位时，元素清零)。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_maskload_epi64.html" title="core::arch::x86::_mm256_maskload_epi64 fn">_mm256_maskload_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用 <code>mask</code> 从 <code>mem_addr</code> 指向的内存中加载包装的 64 位整数 (当未在相应元素中设置最高位时，元素清零)。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_maskload_pd.html" title="core::arch::x86::_mm256_maskload_pd fn">_mm256_maskload_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用 <code>mask</code> 将包装的双精度 (64-bit) 浮点元素从内存加载到结果中 (当未设置相应元素的高位时，元素清零)。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_maskload_ps.html" title="core::arch::x86::_mm256_maskload_ps fn">_mm256_maskload_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用 <code>mask</code> 将包装的单精度 (32-bit) 浮点元素从内存加载到结果中 (当未设置相应元素的高位时，元素清零)。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_maskstore_epi32.html" title="core::arch::x86::_mm256_maskstore_epi32 fn">_mm256_maskstore_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用 <code>mask</code> 将 <code>a</code> 中的包装后的 32 位整数存储到 <code>mem_addr</code> 指向的内存中 (当在相应元素中未设置最高位时，不存储元素)。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_maskstore_epi64.html" title="core::arch::x86::_mm256_maskstore_epi64 fn">_mm256_maskstore_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用 <code>mask</code> 将 <code>a</code> 中的包装 64 位整数存储到 <code>mem_addr</code> 指向的内存中 (当未在相应元素中设置最高位时，不存储元素)。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_maskstore_pd.html" title="core::arch::x86::_mm256_maskstore_pd fn">_mm256_maskstore_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用 <code>mask</code> 将包装的双精度 (64-bit) 浮点元素从 <code>a</code> 存储到内存中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_maskstore_ps.html" title="core::arch::x86::_mm256_maskstore_ps fn">_mm256_maskstore_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用 <code>mask</code> 将包装的单精度 (32-bit) 浮点元素从 <code>a</code> 存储到内存中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_max_epi8.html" title="core::arch::x86::_mm256_max_epi8 fn">_mm256_max_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的 8 位整数，并返回包装的最大值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_max_epi16.html" title="core::arch::x86::_mm256_max_epi16 fn">_mm256_max_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的 16 位整数，并返回包装的最大值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_max_epi32.html" title="core::arch::x86::_mm256_max_epi32 fn">_mm256_max_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的 32 位整数，并返回包装的最大值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_max_epu8.html" title="core::arch::x86::_mm256_max_epu8 fn">_mm256_max_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中包装的无符号 8 位整数，并返回包装的最大值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_max_epu16.html" title="core::arch::x86::_mm256_max_epu16 fn">_mm256_max_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中包装的无符号 16 位整数，并返回包装的最大值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_max_epu32.html" title="core::arch::x86::_mm256_max_epu32 fn">_mm256_max_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的无符号 32 位整数，并返回包装的最大值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_max_pd.html" title="core::arch::x86::_mm256_max_pd fn">_mm256_max_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素，并返回包装的最大值</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_max_ps.html" title="core::arch::x86::_mm256_max_ps fn">_mm256_max_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的单精度 (32-bit) 浮点元素，并返回包装的最大值</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_min_epi8.html" title="core::arch::x86::_mm256_min_epi8 fn">_mm256_min_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的 8 位整数，并返回包装的最小值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_min_epi16.html" title="core::arch::x86::_mm256_min_epi16 fn">_mm256_min_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中包装的 16 位整数，并返回包装的最小值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_min_epi32.html" title="core::arch::x86::_mm256_min_epi32 fn">_mm256_min_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的 32 位整数，并返回包装的最小值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_min_epu8.html" title="core::arch::x86::_mm256_min_epu8 fn">_mm256_min_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中包装的无符号 8 位整数，并返回包装的最小值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_min_epu16.html" title="core::arch::x86::_mm256_min_epu16 fn">_mm256_min_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中包装的无符号 16 位整数，并返回包装的最小值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_min_epu32.html" title="core::arch::x86::_mm256_min_epu32 fn">_mm256_min_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中包装的无符号 32 位整数，并返回包装的最小值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_min_pd.html" title="core::arch::x86::_mm256_min_pd fn">_mm256_min_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素，并返回包装的最小值</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_min_ps.html" title="core::arch::x86::_mm256_min_ps fn">_mm256_min_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的单精度 (32-bit) 浮点元素，并返回包装的最小值</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_movedup_pd.html" title="core::arch::x86::_mm256_movedup_pd fn">_mm256_movedup_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>从 <code>a</code> 复制偶数索引的双精度 (64-bit) 浮点元素，并返回结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_movehdup_ps.html" title="core::arch::x86::_mm256_movehdup_ps fn">_mm256_movehdup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>从 <code>a</code> 复制奇数索引的单精度 (32-bit) 浮点元素，并返回结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_moveldup_ps.html" title="core::arch::x86::_mm256_moveldup_ps fn">_mm256_moveldup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>从 <code>a</code> 复制偶数索引的单精度 (32-bit) 浮点元素，并返回结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_movemask_epi8.html" title="core::arch::x86::_mm256_movemask_epi8 fn">_mm256_movemask_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>a</code> 中每个 8 位元素的最高有效位创建掩码，并返回结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_movemask_pd.html" title="core::arch::x86::_mm256_movemask_pd fn">_mm256_movemask_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>根据 <code>a</code> 中相应的包装的双精度 (64-bit) 浮点元素的最高有效位设置返回掩码的每一位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_movemask_ps.html" title="core::arch::x86::_mm256_movemask_ps fn">_mm256_movemask_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>基于 <code>a</code> 中相应的包装单精度 (32-bit) 浮点元素的最高有效位来设置返回掩码的每一位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_mpsadbw_epu8.html" title="core::arch::x86::_mm256_mpsadbw_epu8 fn">_mm256_mpsadbw_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>计算无符号四元组的绝对差之和 (SADs)
<code>a</code> 中的 8 位整数与 <code>b</code> 中的 8 位整数相比较，并将 16 位结果存储在 dst 中。
使用来自 <code>b</code> 的一个四元组和来自 <code>a</code> 的八个四元组，对每个 128 位通道执行八个 SAD。
从 <code>b</code> 中指定的偏移量开始，从 <code>b</code> 中选择一个四元组。
从 <code>a</code> 中选择的有序 8 位整数开始的 8 个四元组，起始于 <code>imm8</code> 中指定的偏移量。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_mul_epi32.html" title="core::arch::x86::_mm256_mul_epi32 fn">_mm256_mul_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 和 <code>b</code> 中每个包装的 64 位元素的低位 32 位整数相乘</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_mul_epu32.html" title="core::arch::x86::_mm256_mul_epu32 fn">_mm256_mul_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 和 <code>b</code> 中每个包装的 64 位元素的低位无符号 32 位整数相乘</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_mul_pd.html" title="core::arch::x86::_mm256_mul_pd fn">_mm256_mul_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素相乘。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_mul_ps.html" title="core::arch::x86::_mm256_mul_ps fn">_mm256_mul_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装的单精度 (32-bit) 浮点元素相乘。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_mulhi_epi16.html" title="core::arch::x86::_mm256_mulhi_epi16 fn">_mm256_mulhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装的 16 位整数相乘，产生 32 位中间整数，并返回中间整数的高 16 位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_mulhi_epu16.html" title="core::arch::x86::_mm256_mulhi_epu16 fn">_mm256_mulhi_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 和 <code>b</code> 中包装的无符号 16 位整数相乘，生成中间的 32 位整数，并返回中间整数的高 16 位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_mulhrs_epi16.html" title="core::arch::x86::_mm256_mulhrs_epi16 fn">_mm256_mulhrs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装的 16 位整数相乘，生成中间带符号的 32 位整数。
将每个中间整数截断为 18 个最高有效位，再加 1 取整，然后返回 <code>[16:1]</code> 位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_mullo_epi16.html" title="core::arch::x86::_mm256_mullo_epi16 fn">_mm256_mullo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装的 16 位整数相乘，产生 32 位中间整数，并返回中间整数的低 16 位</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_mullo_epi32.html" title="core::arch::x86::_mm256_mullo_epi32 fn">_mm256_mullo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装的 32 位整数相乘，生成中间 64 位整数，并返回中间整数的低 32 位</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_or_pd.html" title="core::arch::x86::_mm256_or_pd fn">_mm256_or_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 和 <code>b</code> 中按位或包装的双精度 (64-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_or_ps.html" title="core::arch::x86::_mm256_or_ps fn">_mm256_or_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 和 <code>b</code> 中按位或包装的单精度 (32-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_or_si256.html" title="core::arch::x86::_mm256_or_si256 fn">_mm256_or_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>计算 <code>a</code> 和 <code>b</code> 中 256 位 (表示整数数据) 的按位或</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_packs_epi16.html" title="core::arch::x86::_mm256_packs_epi16 fn">_mm256_packs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用带符号的饱和度将包装的 16 位整数从 <code>a</code> 和 <code>b</code> 转换为包装的 8 位整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_packs_epi32.html" title="core::arch::x86::_mm256_packs_epi32 fn">_mm256_packs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用带符号的饱和度将包装的 32 位整数从 <code>a</code> 和 <code>b</code> 转换为包装的 16 位整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_packus_epi16.html" title="core::arch::x86::_mm256_packus_epi16 fn">_mm256_packus_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用无符号饱和度将包装的 16 位整数从 <code>a</code> 和 <code>b</code> 转换为包装的 8 位整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_packus_epi32.html" title="core::arch::x86::_mm256_packus_epi32 fn">_mm256_packus_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用无符号饱和度将包装的 32 位整数从 <code>a</code> 和 <code>b</code> 转换为包装的 16 位整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_permute2f128_pd.html" title="core::arch::x86::_mm256_permute2f128_pd fn">_mm256_permute2f128_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>混洗 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成)，由 <code>imm8</code> 从 <code>a</code> 和 <code>b</code> 中选择。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_permute2f128_ps.html" title="core::arch::x86::_mm256_permute2f128_ps fn">_mm256_permute2f128_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>混洗 256 位 (由 8 个包装的单精度 (32-bit) 浮点元素组成)，由 <code>imm8</code> 从 <code>a</code> 和 <code>b</code> 中选择。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_permute2f128_si256.html" title="core::arch::x86::_mm256_permute2f128_si256 fn">_mm256_permute2f128_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>重排 <code>imm8</code> 从 <code>a</code> 和 <code>b</code> 选择的 128 位 (由整数数据组成)。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_permute2x128_si256.html" title="core::arch::x86::_mm256_permute2x128_si256 fn">_mm256_permute2x128_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>打乱由 <code>imm8</code> 从 <code>a</code> 和 <code>b</code> 选择的 128 位整数数据。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_permute4x64_epi64.html" title="core::arch::x86::_mm256_permute4x64_epi64 fn">_mm256_permute4x64_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用控制掩码 <code>imm8</code> 从 <code>a</code> 置换 64 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_permute4x64_pd.html" title="core::arch::x86::_mm256_permute4x64_pd fn">_mm256_permute4x64_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用 <code>imm8</code> 中的控件对 <code>a</code> 中的 64 位浮点元素进行打乱。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_permute_pd.html" title="core::arch::x86::_mm256_permute_pd fn">_mm256_permute_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用 <code>imm8</code> 中的控件在 128 位通道内对 <code>a</code> 中的双精度 (64-bit) 浮点元素进行混洗。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_permute_ps.html" title="core::arch::x86::_mm256_permute_ps fn">_mm256_permute_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用 <code>imm8</code> 中的控件在 128 位通道内对 <code>a</code> 中的单精度 (32-bit) 浮点元素进行混洗。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_permutevar8x32_epi32.html" title="core::arch::x86::_mm256_permutevar8x32_epi32 fn">_mm256_permutevar8x32_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>根据 <code>b</code> 的内容，对 <code>a</code> 的 32 位整数进行包装的排列。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_permutevar8x32_ps.html" title="core::arch::x86::_mm256_permutevar8x32_ps fn">_mm256_permutevar8x32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用 <code>idx</code> 中相应的 32 位整数索引跨通道对 <code>a</code> 中的八个 32 位浮点元素进行打乱。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_permutevar_pd.html" title="core::arch::x86::_mm256_permutevar_pd fn">_mm256_permutevar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用 <code>b</code> 中的控件在 256 位通道内对 <code>a</code> 中的双精度 (64-bit) 浮点元素进行混洗。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_permutevar_ps.html" title="core::arch::x86::_mm256_permutevar_ps fn">_mm256_permutevar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用 <code>b</code> 中的控件在 128 位通道内对 <code>a</code> 中的单精度 (32-bit) 浮点元素进行混洗。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_rcp_ps.html" title="core::arch::x86::_mm256_rcp_ps fn">_mm256_rcp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 中包装的单精度 (32-bit) 浮点元素的近似倒数，并返回结果。
该近似值的最大相对误差小于 1.5*2^-12。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_round_pd.html" title="core::arch::x86::_mm256_round_pd fn">_mm256_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>根据 <code>ROUNDING</code> 标志对 <code>a</code> 中的双精度 (64-bit) 浮点包装的 (64-bit) 浮点元素进行舍入。
<code>ROUNDING</code> 的值可能如下:</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_round_ps.html" title="core::arch::x86::_mm256_round_ps fn">_mm256_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>根据标志 <code>ROUNDING</code> 对 <code>a</code> 中的单精度 (32-bit) 浮点包装元素进行舍入。
<code>ROUNDING</code> 的值可能如下:</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_rsqrt_ps.html" title="core::arch::x86::_mm256_rsqrt_ps fn">_mm256_rsqrt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并返回结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_sad_epu8.html" title="core::arch::x86::_mm256_sad_epu8 fn">_mm256_sad_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>计算 <code>a</code> 和 <code>b</code> 中包装的无符号 8 位整数的绝对差，然后将每个连续的 8 个差水平求和，产生四个无符号的 16 位整数，并将这些无符号的 16 位整数包装在 64 位返回值的低 16 位中</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_set1_epi8.html" title="core::arch::x86::_mm256_set1_epi8 fn">_mm256_set1_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>向返回的 vector 的所有元素广播 8 位整数 <code>a</code>。
此内联函数可能会生成 <code>vpbroadcastb</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_set1_epi16.html" title="core::arch::x86::_mm256_set1_epi16 fn">_mm256_set1_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>向返回的 vector 的所有所有元素广播 16 位整数 <code>a</code>。
此内联函数可能会生成 <code>vpbroadcastw</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_set1_epi32.html" title="core::arch::x86::_mm256_set1_epi32 fn">_mm256_set1_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>向返回的 vector 的所有元素广播 32 位整数 <code>a</code>。
此内联函数可能会生成 <code>vpbroadcastd</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_set1_epi64x.html" title="core::arch::x86::_mm256_set1_epi64x fn">_mm256_set1_epi64x</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>向返回的 vector 的所有元素广播 64 位整数 <code>a</code>。
此内联函数可能会生成 <code>vpbroadcastq</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_set1_pd.html" title="core::arch::x86::_mm256_set1_pd fn">_mm256_set1_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>向返回的 vector 的所有元素广播双精度 (64-bit) 浮点值 <code>a</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_set1_ps.html" title="core::arch::x86::_mm256_set1_ps fn">_mm256_set1_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>向返回的 vector 的所有元素广播单精度 (32-bit) 浮点值 <code>a</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_set_epi8.html" title="core::arch::x86::_mm256_set_epi8 fn">_mm256_set_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>在返回的 vector 中设置包装的 8 位整数，并以相反的顺序提供所提供的值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_set_epi16.html" title="core::arch::x86::_mm256_set_epi16 fn">_mm256_set_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用提供的值在返回的 vector 中设置包装的 16 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_set_epi32.html" title="core::arch::x86::_mm256_set_epi32 fn">_mm256_set_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用提供的值在返回的 vector 中设置包装的 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_set_epi64x.html" title="core::arch::x86::_mm256_set_epi64x fn">_mm256_set_epi64x</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用提供的值在返回的 vector 中设置包装的 64 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_set_m128.html" title="core::arch::x86::_mm256_set_m128 fn">_mm256_set_m128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>设置包装的 __m256 返回的 vector 与提供的值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_set_m128d.html" title="core::arch::x86::_mm256_set_m128d fn">_mm256_set_m128d</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>设置包装的 __m256d 返回的 vector 具有提供的值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_set_m128i.html" title="core::arch::x86::_mm256_set_m128i fn">_mm256_set_m128i</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>包装的 __m256i 集合使用提供的值返回 vector。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_set_pd.html" title="core::arch::x86::_mm256_set_pd fn">_mm256_set_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用提供的值在返回的 vector 中设置包装的双精度 (64-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_set_ps.html" title="core::arch::x86::_mm256_set_ps fn">_mm256_set_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用提供的值在返回的 vector 中设置包装的单精度 (32-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_setr_epi8.html" title="core::arch::x86::_mm256_setr_epi8 fn">_mm256_setr_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>在返回的 vector 中设置包装的 8 位整数，并以相反的顺序提供所提供的值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_setr_epi16.html" title="core::arch::x86::_mm256_setr_epi16 fn">_mm256_setr_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>在返回的 vector 中设置包装的 16 位整数，其提供的值的顺序相反。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_setr_epi32.html" title="core::arch::x86::_mm256_setr_epi32 fn">_mm256_setr_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>在返回的 vector 中设置包装的 32 位整数，并以相反的顺序提供所提供的值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_setr_epi64x.html" title="core::arch::x86::_mm256_setr_epi64x fn">_mm256_setr_epi64x</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>在返回的 vector 中设置包装的 64 位整数，其提供的值的顺序相反。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_setr_m128.html" title="core::arch::x86::_mm256_setr_m128 fn">_mm256_setr_m128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>设置包装的 __m256 返回的 vector 与提供的值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_setr_m128d.html" title="core::arch::x86::_mm256_setr_m128d fn">_mm256_setr_m128d</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>设置包装的 __m256d 返回的 vector 具有提供的值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_setr_m128i.html" title="core::arch::x86::_mm256_setr_m128i fn">_mm256_setr_m128i</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>包装的 __m256i 集合使用提供的值返回 vector。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_setr_pd.html" title="core::arch::x86::_mm256_setr_pd fn">_mm256_setr_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>在返回的 vector 中使用反向提供的值设置包装的双精度 (64-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_setr_ps.html" title="core::arch::x86::_mm256_setr_ps fn">_mm256_setr_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>在返回的 vector 中使用反向提供的值设置包装的单精度 (32-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_setzero_pd.html" title="core::arch::x86::_mm256_setzero_pd fn">_mm256_setzero_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>返回 __m256d 类型的 vector，所有元素均设置为零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_setzero_ps.html" title="core::arch::x86::_mm256_setzero_ps fn">_mm256_setzero_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>返回 __m256 类型的 vector，所有元素都设置为零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_setzero_si256.html" title="core::arch::x86::_mm256_setzero_si256 fn">_mm256_setzero_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>返回类型为 __m256i 的 vector，所有元素均设置为零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_shuffle_epi8.html" title="core::arch::x86::_mm256_shuffle_epi8 fn">_mm256_shuffle_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>根据 <code>b</code> 的内容，打乱 <code>a</code> 中的字节。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_shuffle_epi32.html" title="core::arch::x86::_mm256_shuffle_epi32 fn">_mm256_shuffle_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用 <code>imm8</code> 中的控件，在 <code>a</code> 的 128 位通道中打乱 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_shuffle_pd.html" title="core::arch::x86::_mm256_shuffle_pd fn">_mm256_shuffle_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用 <code>imm8</code> 中的控件对 128 位通道中的双精度 (64-bit) 浮点元素进行混洗。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_shuffle_ps.html" title="core::arch::x86::_mm256_shuffle_ps fn">_mm256_shuffle_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将 <code>a</code> 中的单精度 (32-bit) 浮点元素改组为
使用 <code>imm8</code> 中的控件的 128 位通道。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_shufflehi_epi16.html" title="core::arch::x86::_mm256_shufflehi_epi16 fn">_mm256_shufflehi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用 <code>imm8</code> 中的控件，在 <code>a</code> 的 128 位通道的高 64 位中打乱 16 位整数。
<code>a</code> 的 128 位通道的低 64 位被复制到输出中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_shufflelo_epi16.html" title="core::arch::x86::_mm256_shufflelo_epi16 fn">_mm256_shufflelo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用 <code>imm8</code> 中的控件在 <code>a</code> 的 128 位通道的低 64 位中打乱 16 位整数。
<code>a</code> 的 128 位通道的高 64 位被复制到输出中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_sign_epi8.html" title="core::arch::x86::_mm256_sign_epi8 fn">_mm256_sign_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>当相应的带符号时，将 <code>a</code> 中的包装的 8 位整数取反
<code>b</code> 中的 8 位整数为负，并返回结果。
当 <code>b</code> 中的相应元素为零时，结果归零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_sign_epi16.html" title="core::arch::x86::_mm256_sign_epi16 fn">_mm256_sign_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>当相应的带符号时，将 <code>a</code> 中的 16 位整数包装为无效
<code>b</code> 中的 16 位整数为负，并返回结果。
当 <code>b</code> 中的相应元素为零时，结果归零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_sign_epi32.html" title="core::arch::x86::_mm256_sign_epi32 fn">_mm256_sign_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>当相应的带符号时，将 <code>a</code> 中的包装的 32 位整数取反
<code>b</code> 中的 32 位整数为负，并返回结果。
当 <code>b</code> 中的相应元素为零时，结果归零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_sll_epi16.html" title="core::arch::x86::_mm256_sll_epi16 fn">_mm256_sll_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>count</code> 左移的 <code>a</code> 中的包装的 16 位整数移位，同时移零，并返回结果</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_sll_epi32.html" title="core::arch::x86::_mm256_sll_epi32 fn">_mm256_sll_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>count</code> 左移的 <code>a</code> 中的包装的 32 位整数移位，同时移零，并返回结果</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_sll_epi64.html" title="core::arch::x86::_mm256_sll_epi64 fn">_mm256_sll_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>count</code> 左移的 <code>a</code> 中的包装的 64 位整数移位，同时移零，并返回结果</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_slli_epi16.html" title="core::arch::x86::_mm256_slli_epi16 fn">_mm256_slli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中包装的 16 位整数在 <code>IMM8</code> 左移同时移零，返回结果;</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_slli_epi32.html" title="core::arch::x86::_mm256_slli_epi32 fn">_mm256_slli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的包装的 32 位整数在 <code>IMM8</code> 左移同时移零，返回结果;</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_slli_epi64.html" title="core::arch::x86::_mm256_slli_epi64 fn">_mm256_slli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的包装的 64 位整数在 <code>IMM8</code> 左移同时移零，返回结果;</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_slli_si256.html" title="core::arch::x86::_mm256_slli_si256 fn">_mm256_slli_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的 128 位通道向左移 <code>imm8</code> 字节，同时向零移位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_sllv_epi32.html" title="core::arch::x86::_mm256_sllv_epi32 fn">_mm256_sllv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的包装的 32 位整数左移 <code>count</code> 中相应元素所指定的数量，同时将零移位，并返回结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_sllv_epi64.html" title="core::arch::x86::_mm256_sllv_epi64 fn">_mm256_sllv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的包装的 64 位整数左移 <code>count</code> 中相应元素所指定的数量，同时将零移位，并返回结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_sqrt_pd.html" title="core::arch::x86::_mm256_sqrt_pd fn">_mm256_sqrt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>返回 <code>a</code> 中包装的双精度 (64-bit) 浮点元素的平方根。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_sqrt_ps.html" title="core::arch::x86::_mm256_sqrt_ps fn">_mm256_sqrt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>返回 <code>a</code> 中包装的单精度 (32-bit) 浮点元素的平方根。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_sra_epi16.html" title="core::arch::x86::_mm256_sra_epi16 fn">_mm256_sra_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将符号位移入时，将 <code>a</code> 中的包装的 16 位整数右移 <code>count</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_sra_epi32.html" title="core::arch::x86::_mm256_sra_epi32 fn">_mm256_sra_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将符号位移位时，将 <code>a</code> 中的包装的 32 位整数右移 <code>count</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_srai_epi16.html" title="core::arch::x86::_mm256_srai_epi16 fn">_mm256_srai_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中包装的 16 位整数右移 <code>IMM8</code>，同时移入符号位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_srai_epi32.html" title="core::arch::x86::_mm256_srai_epi32 fn">_mm256_srai_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中包装的 32 位整数右移 <code>IMM8</code>，同时移入符号位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_srav_epi32.html" title="core::arch::x86::_mm256_srav_epi32 fn">_mm256_srav_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的32位整数向右移动，移动量由 <code>count</code> 中的相应元素指定，同时移入符号位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_srl_epi16.html" title="core::arch::x86::_mm256_srl_epi16 fn">_mm256_srl_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的包装的 16 位整数右移 <code>count</code>，同时将零移位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_srl_epi32.html" title="core::arch::x86::_mm256_srl_epi32 fn">_mm256_srl_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的包装的 32 位整数右移 <code>count</code>，同时将零移位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_srl_epi64.html" title="core::arch::x86::_mm256_srl_epi64 fn">_mm256_srl_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的包装的 64 位整数右移 <code>count</code>，同时将零移位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_srli_epi16.html" title="core::arch::x86::_mm256_srli_epi16 fn">_mm256_srli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中包装的 16 位整数右移 <code>IMM8</code>，同时将其移入零</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_srli_epi32.html" title="core::arch::x86::_mm256_srli_epi32 fn">_mm256_srli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中包装的 32 位整数右移 <code>IMM8</code>，同时将其移入零</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_srli_epi64.html" title="core::arch::x86::_mm256_srli_epi64 fn">_mm256_srli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中包装的 64 位整数右移 <code>IMM8</code>，同时将其移入零</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_srli_si256.html" title="core::arch::x86::_mm256_srli_si256 fn">_mm256_srli_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的 128 位通道右移 <code>imm8</code> 字节，同时将其移位为零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_srlv_epi32.html" title="core::arch::x86::_mm256_srlv_epi32 fn">_mm256_srlv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的包装的 32 位整数右移 <code>count</code> 中相应元素所指定的数量，同时将零移位，</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_srlv_epi64.html" title="core::arch::x86::_mm256_srlv_epi64 fn">_mm256_srlv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的包装的 64 位整数右移 <code>count</code> 中相应元素所指定的数量，同时将零移位，</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_store_pd.html" title="core::arch::x86::_mm256_store_pd fn">_mm256_store_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将来自 <code>a</code> 的 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_store_ps.html" title="core::arch::x86::_mm256_store_ps fn">_mm256_store_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将来自 <code>a</code> 的 256 位 (由 8 个包装的单精度 (32-bit) 浮点元素组成) 存储到内存中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_store_si256.html" title="core::arch::x86::_mm256_store_si256 fn">_mm256_store_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将来自 <code>a</code> 的 256 位整数数据存储到内存中。
<code>mem_addr</code> 必须在 32 字节边界上对齐，否则可能会产生一般保护异常。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_storeu2_m128.html" title="core::arch::x86::_mm256_storeu2_m128 fn">_mm256_storeu2_m128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx,sse` only"><code>avx,sse</code></span><p>将来自 <code>a</code> 的高和低 128 位半部分 (每个半部分由 4 个包装的单精度 (32-bit) 浮点元素组成) 存储到内存中两个不同的 128 位位置。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_storeu2_m128d.html" title="core::arch::x86::_mm256_storeu2_m128d fn">_mm256_storeu2_m128d</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx,sse2` only"><code>avx,sse2</code></span><p>将来自 <code>a</code> 的高和低 128 位半部分 (每个半部分由 2 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中两个不同的 128 位位置。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_storeu2_m128i.html" title="core::arch::x86::_mm256_storeu2_m128i fn">_mm256_storeu2_m128i</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx,sse2` only"><code>avx,sse2</code></span><p>将来自 <code>a</code> 的高 128 位和低 128 位 (分别由整数数据组成) 存储到内存中两个不同的 128 位位置。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_storeu_pd.html" title="core::arch::x86::_mm256_storeu_pd fn">_mm256_storeu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将来自 <code>a</code> 的 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_storeu_ps.html" title="core::arch::x86::_mm256_storeu_ps fn">_mm256_storeu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将来自 <code>a</code> 的 256 位 (由 8 个包装的单精度 (32-bit) 浮点元素组成) 存储到内存中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_storeu_si256.html" title="core::arch::x86::_mm256_storeu_si256 fn">_mm256_storeu_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将来自 <code>a</code> 的 256 位整数数据存储到内存中。
<code>mem_addr</code> 不需要在任何特定边界上对齐。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_stream_pd.html" title="core::arch::x86::_mm256_stream_pd fn">_mm256_stream_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将双精度值从 <code>[4 x double]</code> 的 256 位 vector 移动到 32 字节对齐的内存位置。
为了最大程度地减少缓存，数据被标记为非时间性的 (不太可能很快再次使用)。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_stream_ps.html" title="core::arch::x86::_mm256_stream_ps fn">_mm256_stream_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将单精度浮点值从 <code>[8 x float]</code> 的 256 位 vector 移到 32 字节对齐的内存位置。
为了最大程度地减少缓存，数据被标记为非时间性的 (不太可能很快再次使用)。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_stream_si256.html" title="core::arch::x86::_mm256_stream_si256 fn">_mm256_stream_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将整数数据从 256 位整数 vector 移动到 32 字节对齐的内存位置。
为了最大程度地减少缓存，数据被标记为非时间性的 (不太可能很快再次使用)</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_sub_epi8.html" title="core::arch::x86::_mm256_sub_epi8 fn">_mm256_sub_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>a</code> 中的包装的 8 位整数中减去 <code>b</code> 中的包装的 8 位整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_sub_epi16.html" title="core::arch::x86::_mm256_sub_epi16 fn">_mm256_sub_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>a</code> 中的包装的 16 位整数减去 <code>b</code> 中的包装的 16 位整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_sub_epi32.html" title="core::arch::x86::_mm256_sub_epi32 fn">_mm256_sub_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>a</code> 中的包装的 32 位整数减去 <code>b</code> 中的包装的 32 位整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_sub_epi64.html" title="core::arch::x86::_mm256_sub_epi64 fn">_mm256_sub_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>a</code> 中的包装的 64 位整数减去 <code>b</code> 中的包装的 64 位整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_sub_pd.html" title="core::arch::x86::_mm256_sub_pd fn">_mm256_sub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>从 <code>a</code> 中的包装的元素中减去 <code>b</code> 中的包装后的双精度 (64-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_sub_ps.html" title="core::arch::x86::_mm256_sub_ps fn">_mm256_sub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>从 <code>a</code> 中的包装元素中减去 <code>b</code> 中的包装的单精度 (32-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_subs_epi8.html" title="core::arch::x86::_mm256_subs_epi8 fn">_mm256_subs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用饱和度从 <code>a</code> 的包装的 8 位整数减去 <code>b</code> 的包装的 8 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_subs_epi16.html" title="core::arch::x86::_mm256_subs_epi16 fn">_mm256_subs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用饱和度从 <code>a</code> 的包装的 16 位整数减去 <code>b</code> 的包装的 16 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_subs_epu8.html" title="core::arch::x86::_mm256_subs_epu8 fn">_mm256_subs_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用饱和度从 <code>a</code> 的包装的 8 位整数减去 <code>b</code> 的包装的无符号 8 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_subs_epu16.html" title="core::arch::x86::_mm256_subs_epu16 fn">_mm256_subs_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用饱和度从 <code>a</code> 的包装的 16 位整数减去 <code>b</code> 的包装的无符号 16 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_testc_pd.html" title="core::arch::x86::_mm256_testc_pd fn">_mm256_testc_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 和 <code>b</code> 中 256 位 (表示双精度 (64-bit) 浮点元素) 的按位与，生成中间 256 位值，如果中间值中每个 64 位元素的符号位都将 <code>ZF</code> 设置为 1 为零，否则将 <code>ZF</code> 设置为 0。
计算 <code>a</code> 的按位 NOT，然后与 <code>b</code> 进行与运算，得到一个中间值，如果中间值中每个 64 位元素的符号位为零，则将 <code>CF</code> 设置为 1，否则将 <code>CF</code> 设置为 0。
返回 <code>CF</code> 值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_testc_ps.html" title="core::arch::x86::_mm256_testc_ps fn">_mm256_testc_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 和 <code>b</code> 中 256 位 (表示单精度 (32-bit) 浮点元素) 的按位与，生成中间 256 位值，如果中间值中每个 32 位元素的符号位都将 <code>ZF</code> 设置为 1 为零，否则将 <code>ZF</code> 设置为 0。
计算 <code>a</code> 的按位非，然后与 <code>b</code> 进行与运算，产生一个中间值，如果中间值中每个 32 位元素的符号位为零，则将 <code>CF</code> 设置为 1，否则将 <code>CF</code> 设置为 0。
返回 <code>CF</code> 值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_testc_si256.html" title="core::arch::x86::_mm256_testc_si256 fn">_mm256_testc_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 和 <code>b</code> 中 256 位 (表示整数数据) 的按位与，如果结果为零，则将 <code>ZF</code> 设置为 1，否则将 <code>ZF</code> 设置为 0。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_testnzc_pd.html" title="core::arch::x86::_mm256_testnzc_pd fn">_mm256_testnzc_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 和 <code>b</code> 中 256 位 (表示双精度 (64-bit) 浮点元素) 的按位与，生成中间 256 位值，如果中间值中每个 64 位元素的符号位都将 <code>ZF</code> 设置为 1 为零，否则将 <code>ZF</code> 设置为 0。
计算 <code>a</code> 的按位 NOT，然后与 <code>b</code> 进行与运算，得到一个中间值，如果中间值中每个 64 位元素的符号位为零，则将 <code>CF</code> 设置为 1，否则将 <code>CF</code> 设置为 0。
如果 <code>ZF</code> 和 <code>CF</code> 的值均为零，则返回 1，否则返回 0。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_testnzc_ps.html" title="core::arch::x86::_mm256_testnzc_ps fn">_mm256_testnzc_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 和 <code>b</code> 中 256 位 (表示单精度 (32-bit) 浮点元素) 的按位与，生成中间 256 位值，如果中间值中每个 32 位元素的符号位都将 <code>ZF</code> 设置为 1 为零，否则将 <code>ZF</code> 设置为 0。
计算 <code>a</code> 的按位非，然后与 <code>b</code> 进行与运算，产生一个中间值，如果中间值中每个 32 位元素的符号位为零，则将 <code>CF</code> 设置为 1，否则将 <code>CF</code> 设置为 0。
如果 <code>ZF</code> 和 <code>CF</code> 的值均为零，则返回 1，否则返回 0。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_testnzc_si256.html" title="core::arch::x86::_mm256_testnzc_si256 fn">_mm256_testnzc_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 和 <code>b</code> 中 256 位 (表示整数数据) 的按位与，如果结果为零，则将 <code>ZF</code> 设置为 1，否则将 <code>ZF</code> 设置为 0。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_testz_pd.html" title="core::arch::x86::_mm256_testz_pd fn">_mm256_testz_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 和 <code>b</code> 中 256 位 (表示双精度 (64-bit) 浮点元素) 的按位与，生成中间 256 位值，如果中间值中每个 64 位元素的符号位都将 <code>ZF</code> 设置为 1 为零，否则将 <code>ZF</code> 设置为 0。
计算 <code>a</code> 的按位 NOT，然后与 <code>b</code> 进行与运算，得到一个中间值，如果中间值中每个 64 位元素的符号位为零，则将 <code>CF</code> 设置为 1，否则将 <code>CF</code> 设置为 0。
返回 <code>ZF</code> 值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_testz_ps.html" title="core::arch::x86::_mm256_testz_ps fn">_mm256_testz_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 和 <code>b</code> 中 256 位 (表示单精度 (32-bit) 浮点元素) 的按位与，生成中间 256 位值，如果中间值中每个 32 位元素的符号位都将 <code>ZF</code> 设置为 1 为零，否则将 <code>ZF</code> 设置为 0。
计算 <code>a</code> 的按位非，然后与 <code>b</code> 进行与运算，产生一个中间值，如果中间值中每个 32 位元素的符号位为零，则将 <code>CF</code> 设置为 1，否则将 <code>CF</code> 设置为 0。
返回 <code>ZF</code> 值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_testz_si256.html" title="core::arch::x86::_mm256_testz_si256 fn">_mm256_testz_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 和 <code>b</code> 中 256 位 (表示整数数据) 的按位与，如果结果为零，则将 <code>ZF</code> 设置为 1，否则将 <code>ZF</code> 设置为 0。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_undefined_pd.html" title="core::arch::x86::_mm256_undefined_pd fn">_mm256_undefined_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>返回带有未定义元素的 <code>__m256d</code> 类型的 vector。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_undefined_ps.html" title="core::arch::x86::_mm256_undefined_ps fn">_mm256_undefined_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>返回带有未定义元素的 <code>__m256</code> 类型的 vector。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_undefined_si256.html" title="core::arch::x86::_mm256_undefined_si256 fn">_mm256_undefined_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>返回带有未定义元素的 __m256i 类型的 vector。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_unpackhi_epi8.html" title="core::arch::x86::_mm256_unpackhi_epi8 fn">_mm256_unpackhi_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从每个高位的一半拆包并交织 8 位整数
<code>a</code> 和 <code>b</code> 中的 128 位通道。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_unpackhi_epi16.html" title="core::arch::x86::_mm256_unpackhi_epi16 fn">_mm256_unpackhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从每个高位的一半拆包并交织 16 位整数
<code>a</code> 和 <code>b</code> 的 128 位通道</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_unpackhi_epi32.html" title="core::arch::x86::_mm256_unpackhi_epi32 fn">_mm256_unpackhi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从每个高位的一半拆包并交织 32 位整数
<code>a</code> 和 <code>b</code> 的 128 位通道</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_unpackhi_epi64.html" title="core::arch::x86::_mm256_unpackhi_epi64 fn">_mm256_unpackhi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从每个高位的一半拆包并交织 64 位整数
<code>a</code> 和 <code>b</code> 的 128 位通道</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_unpackhi_pd.html" title="core::arch::x86::_mm256_unpackhi_pd fn">_mm256_unpackhi_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>从 <code>a</code> 和 <code>b</code> 中每个 128 位通道的上半部分解包并交织双精度 (64-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_unpackhi_ps.html" title="core::arch::x86::_mm256_unpackhi_ps fn">_mm256_unpackhi_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>从 <code>a</code> 和 <code>b</code> 中每个 128 位通道的高半部分解包并交织单精度 (32-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_unpacklo_epi8.html" title="core::arch::x86::_mm256_unpacklo_epi8 fn">_mm256_unpacklo_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从每个低位拆包并交织 8 位整数
<code>a</code> 和 <code>b</code> 的 128 位通道</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_unpacklo_epi16.html" title="core::arch::x86::_mm256_unpacklo_epi16 fn">_mm256_unpacklo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从每个低位拆包并交织 16 位整数
<code>a</code> 和 <code>b</code> 的 128 位通道</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_unpacklo_epi32.html" title="core::arch::x86::_mm256_unpacklo_epi32 fn">_mm256_unpacklo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从每个低位拆包并交织 32 位整数
<code>a</code> 和 <code>b</code> 的 128 位通道</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_unpacklo_epi64.html" title="core::arch::x86::_mm256_unpacklo_epi64 fn">_mm256_unpacklo_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从每个字节的下半部分拆包并交织 64 位整数
<code>a</code> 和 <code>b</code> 的 128 位通道</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_unpacklo_pd.html" title="core::arch::x86::_mm256_unpacklo_pd fn">_mm256_unpacklo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>从 <code>a</code> 和 <code>b</code> 中每个 128 位通道的下半部分解包并交织双精度 (64-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_unpacklo_ps.html" title="core::arch::x86::_mm256_unpacklo_ps fn">_mm256_unpacklo_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>从 <code>a</code> 和 <code>b</code> 中每个 128 位通道的下半部分解包并交织单精度 (32-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_xor_pd.html" title="core::arch::x86::_mm256_xor_pd fn">_mm256_xor_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 和 <code>b</code> 中包装的双精度 (64-bit) 浮点元素的按位 XOR。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_xor_ps.html" title="core::arch::x86::_mm256_xor_ps fn">_mm256_xor_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 和 <code>b</code> 中包装的单精度 (32-bit) 浮点元素的按位 XOR。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_xor_si256.html" title="core::arch::x86::_mm256_xor_si256 fn">_mm256_xor_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>计算 <code>a</code> 和 <code>b</code> 中 256 位 (表示整数数据) 的按位 XOR</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_zeroall.html" title="core::arch::x86::_mm256_zeroall fn">_mm256_zeroall</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将所有 XMM 或 YMM 寄存器的内容清零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_zeroupper.html" title="core::arch::x86::_mm256_zeroupper fn">_mm256_zeroupper</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>将所有 YMM 寄存器的高 128 位清零;
寄存器的低 128 位保持不变。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_zextpd128_pd256.html" title="core::arch::x86::_mm256_zextpd128_pd256 fn">_mm256_zextpd128_pd256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx,sse2` only"><code>avx,sse2</code></span><p>从 a 创建一个 <code>[4 x double]</code> 的 256 位浮点 vector
<code>[2 x double]</code> 的 128 位浮点 vector。低 128 位包含源 vector 的值。
高 128 位设置为零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_zextps128_ps256.html" title="core::arch::x86::_mm256_zextps128_ps256 fn">_mm256_zextps128_ps256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx,sse` only"><code>avx,sse</code></span><p>从 a 创建一个 <code>[8 x float]</code> 的 256 位浮点 vector
<code>[4 x float]</code> 的 128 位浮点 vector。低 128 位包含源 vector 的值。
高 128 位设置为零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm256_zextsi128_si256.html" title="core::arch::x86::_mm256_zextsi128_si256 fn">_mm256_zextsi128_si256</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx,sse2` only"><code>avx,sse2</code></span><p>从 128 位整数 vector 创建一个 256 位整数 vector。
低 128 位包含源 vector 的值。上层
128 位设置为零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm512_storeu_ps.html" title="core::arch::x86::_mm512_storeu_ps fn">_mm512_storeu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx512f` only"><code>avx512f</code></span><p>将来自 <code>a</code> 的 512 位 (由 16 个包装的单精度 (32-bit) 浮点元素组成) 存储到内存中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_abs_epi8.html" title="core::arch::x86::_mm_abs_epi8 fn">_mm_abs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span><p>计算 <code>a</code> 中包装的 8 位带符号整数的绝对值，并返回无符号结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_abs_epi16.html" title="core::arch::x86::_mm_abs_epi16 fn">_mm_abs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span><p>计算 <code>a</code> 中每个包装的 16 位有符号整数的绝对值，并返回 16 位无符号整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_abs_epi32.html" title="core::arch::x86::_mm_abs_epi32 fn">_mm_abs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span><p>计算 <code>a</code> 中每个包装的 32 位有符号整数的绝对值，并返回 32 位无符号整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_add_epi8.html" title="core::arch::x86::_mm_add_epi8 fn">_mm_add_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>在 <code>a</code> 和 <code>b</code> 中添加包装的 8 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_add_epi16.html" title="core::arch::x86::_mm_add_epi16 fn">_mm_add_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>在 <code>a</code> 和 <code>b</code> 中添加包装的 16 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_add_epi32.html" title="core::arch::x86::_mm_add_epi32 fn">_mm_add_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>在 <code>a</code> 和 <code>b</code> 中添加包装的 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_add_epi64.html" title="core::arch::x86::_mm_add_epi64 fn">_mm_add_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>在 <code>a</code> 和 <code>b</code> 中添加包装的 64 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_add_pd.html" title="core::arch::x86::_mm_add_pd fn">_mm_add_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>在 <code>a</code> 和 <code>b</code> 中添加包装的双精度 (64-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_add_ps.html" title="core::arch::x86::_mm_add_ps fn">_mm_add_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>添加 __m128 vectors。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_add_sd.html" title="core::arch::x86::_mm_add_sd fn">_mm_add_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回一个新的 vector，其中 <code>a</code> 的低位元素替换为 <code>a</code> 和 <code>b</code> 的低位元素之和。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_add_ss.html" title="core::arch::x86::_mm_add_ss fn">_mm_add_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>添加 <code>a</code> 和 <code>b</code> 的第一个组件，其他组件从 <code>a</code> 复制。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_adds_epi8.html" title="core::arch::x86::_mm_adds_epi8 fn">_mm_adds_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>使用饱和度在 <code>a</code> 和 <code>b</code> 中添加包装的 8 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_adds_epi16.html" title="core::arch::x86::_mm_adds_epi16 fn">_mm_adds_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>使用饱和度在 <code>a</code> 和 <code>b</code> 中添加包装的 16 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_adds_epu8.html" title="core::arch::x86::_mm_adds_epu8 fn">_mm_adds_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>使用饱和度在 <code>a</code> 和 <code>b</code> 中添加包装的无符号 8 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_adds_epu16.html" title="core::arch::x86::_mm_adds_epu16 fn">_mm_adds_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>使用饱和度在 <code>a</code> 和 <code>b</code> 中添加包装的无符号 16 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_addsub_pd.html" title="core::arch::x86::_mm_addsub_pd fn">_mm_addsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse3` only"><code>sse3</code></span><p>或者，在 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素中加减 <code>b</code> 中的 to/from 包装的元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_addsub_ps.html" title="core::arch::x86::_mm_addsub_ps fn">_mm_addsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse3` only"><code>sse3</code></span><p>或者，在 <code>a</code> 中的包装的单精度 (32-bit) 浮点元素上加减 <code>b</code> 中的包装的元素 to/from。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_aesdec_si128.html" title="core::arch::x86::_mm_aesdec_si128 fn">_mm_aesdec_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `aes` only"><code>aes</code></span><p>对 <code>a</code> 中的数据 (state) 执行一轮 AES 解密流程。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_aesdeclast_si128.html" title="core::arch::x86::_mm_aesdeclast_si128 fn">_mm_aesdeclast_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `aes` only"><code>aes</code></span><p>对 <code>a</code> 中的数据 (state) 执行 AES 解密流的最后一轮。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_aesenc_si128.html" title="core::arch::x86::_mm_aesenc_si128 fn">_mm_aesenc_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `aes` only"><code>aes</code></span><p>对 <code>a</code> 中的数据 (state) 执行一轮 AES 加密流程。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_aesenclast_si128.html" title="core::arch::x86::_mm_aesenclast_si128 fn">_mm_aesenclast_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `aes` only"><code>aes</code></span><p>对 <code>a</code> 中的数据 (state) 执行最后一轮 AES 加密流程。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_aesimc_si128.html" title="core::arch::x86::_mm_aesimc_si128 fn">_mm_aesimc_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `aes` only"><code>aes</code></span><p>在 <code>a</code> 上执行 <code>InvMixColumns</code> 转换。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_aeskeygenassist_si128.html" title="core::arch::x86::_mm_aeskeygenassist_si128 fn">_mm_aeskeygenassist_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `aes` only"><code>aes</code></span><p>协助扩展 AES 密钥。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_alignr_epi8.html" title="core::arch::x86::_mm_alignr_epi8 fn">_mm_alignr_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span><p>将 <code>a</code> 和 <code>b</code> 中的 16 字节块连接成一个 32 字节的临时结果，将结果右移 <code>n</code> 字节，然后返回低 16 字节。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_and_pd.html" title="core::arch::x86::_mm_and_pd fn">_mm_and_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>计算 <code>a</code> 和 <code>b</code> 中包装的双精度 (64-bit) 浮点元素的按位与。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_and_ps.html" title="core::arch::x86::_mm_and_ps fn">_mm_and_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>包装的单精度 (32-bit) 浮点元素的按位与。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_and_si128.html" title="core::arch::x86::_mm_and_si128 fn">_mm_and_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>计算 <code>a</code> 和 <code>b</code> 中 128 位 (表示整数数据) 的按位与。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_andnot_pd.html" title="core::arch::x86::_mm_andnot_pd fn">_mm_andnot_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>计算 <code>a</code> 的按位 NOT，然后计算 <code>b</code> 的 AND。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_andnot_ps.html" title="core::arch::x86::_mm_andnot_ps fn">_mm_andnot_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>包装的单精度 (32-bit) 浮点元素的按位与非运算。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_andnot_si128.html" title="core::arch::x86::_mm_andnot_si128 fn">_mm_andnot_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>计算 <code>a</code> 中 128 位 (代表整数数据) 的按位非，然后计算 <code>b</code> 的与。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_avg_epu8.html" title="core::arch::x86::_mm_avg_epu8 fn">_mm_avg_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p><code>a</code> 和 <code>b</code> 中的包装无符号 8 位整数的平均值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_avg_epu16.html" title="core::arch::x86::_mm_avg_epu16 fn">_mm_avg_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p><code>a</code> 和 <code>b</code> 中的包装无符号 16 位整数的平均值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_blend_epi16.html" title="core::arch::x86::_mm_blend_epi16 fn">_mm_blend_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>使用掩码 <code>IMM8</code> 混合来自 <code>a</code> 和 <code>b</code> 的 16 位整数包装。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_blend_epi32.html" title="core::arch::x86::_mm_blend_epi32 fn">_mm_blend_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用控制掩码 <code>IMM4</code> 混合来自 <code>a</code> 和 <code>b</code> 的包装的 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_blend_pd.html" title="core::arch::x86::_mm_blend_pd fn">_mm_blend_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>使用控制掩码 <code>IMM2</code> 从 <code>a</code> 和 <code>b</code> 混合包装的双精度 (64-bit) 浮点元素</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_blend_ps.html" title="core::arch::x86::_mm_blend_ps fn">_mm_blend_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>使用掩码 <code>IMM4</code> 从 <code>a</code> 和 <code>b</code> 混合包装的单精度 (32-bit) 浮点元素</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_blendv_epi8.html" title="core::arch::x86::_mm_blendv_epi8 fn">_mm_blendv_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>使用 <code>mask</code> 混合 <code>a</code> 和 <code>b</code> 中的包装 8 位整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_blendv_pd.html" title="core::arch::x86::_mm_blendv_pd fn">_mm_blendv_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>使用 <code>mask</code> 混合来自 <code>a</code> 和 <code>b</code> 的包装的双精度 (64-bit) 浮点元素</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_blendv_ps.html" title="core::arch::x86::_mm_blendv_ps fn">_mm_blendv_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>使用 <code>mask</code> 混合来自 <code>a</code> 和 <code>b</code> 的包装的单精度 (32-bit) 浮点元素</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_broadcast_ss.html" title="core::arch::x86::_mm_broadcast_ss fn">_mm_broadcast_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>从内存向返回的 vector 的所有元素广播单精度 (32-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_broadcastb_epi8.html" title="core::arch::x86::_mm_broadcastb_epi8 fn">_mm_broadcastb_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 的低位包装 8 位整数广播到 128 位返回值的所有元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_broadcastd_epi32.html" title="core::arch::x86::_mm_broadcastd_epi32 fn">_mm_broadcastd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 的低位包装 32 位整数广播到 128 位返回值的所有元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_broadcastq_epi64.html" title="core::arch::x86::_mm_broadcastq_epi64 fn">_mm_broadcastq_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 的低位包装 64 位整数广播到 128 位返回值的所有元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_broadcastsd_pd.html" title="core::arch::x86::_mm_broadcastsd_pd fn">_mm_broadcastsd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将低双精度 (64-bit) 浮点元素从 <code>a</code> 广播到 128 位返回值的所有元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_broadcastss_ps.html" title="core::arch::x86::_mm_broadcastss_ps fn">_mm_broadcastss_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将低单精度 (32-bit) 浮点元素从 <code>a</code> 广播到 128 位返回值的所有元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_broadcastw_epi16.html" title="core::arch::x86::_mm_broadcastw_epi16 fn">_mm_broadcastw_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将低包装的 16 位整数从 a 广播到 128 位返回值的所有元素</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_bslli_si128.html" title="core::arch::x86::_mm_bslli_si128 fn">_mm_bslli_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 左移 <code>IMM8</code> 个字节，同时移入零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_bsrli_si128.html" title="core::arch::x86::_mm_bsrli_si128 fn">_mm_bsrli_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 右移 <code>IMM8</code> 个字节，同时移入零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_castpd_ps.html" title="core::arch::x86::_mm_castpd_ps fn">_mm_castpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>[2 x double]</code> 的 128 位浮点 vector 转换为 <code>[4 x float]</code> 的 128 位浮点 vector。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_castpd_si128.html" title="core::arch::x86::_mm_castpd_si128 fn">_mm_castpd_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>[2 x double]</code> 的 128 位浮点 vector 转换为 128 位整数 vector。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_castps_pd.html" title="core::arch::x86::_mm_castps_pd fn">_mm_castps_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>[4 x float]</code> 的 128 位浮点 vector 转换为 <code>[2 x double]</code> 的 128 位浮点 vector。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_castps_si128.html" title="core::arch::x86::_mm_castps_si128 fn">_mm_castps_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>[4 x float]</code> 的 128 位浮点 vector 转换为 128 位整数 vector。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_castsi128_pd.html" title="core::arch::x86::_mm_castsi128_pd fn">_mm_castsi128_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 128 位整数 vector 转换为 <code>[2 x double]</code> 的 128 位浮点 vector。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_castsi128_ps.html" title="core::arch::x86::_mm_castsi128_ps fn">_mm_castsi128_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 128 位整数 vector 转换为 <code>[4 x float]</code> 的 128 位浮点 vector。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_ceil_pd.html" title="core::arch::x86::_mm_ceil_pd fn">_mm_ceil_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>将 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素四舍五入为整数，并将结果存储为包装的双精度浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_ceil_ps.html" title="core::arch::x86::_mm_ceil_ps fn">_mm_ceil_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>将 <code>a</code> 中的包装的单精度 (32-bit) 浮点元素四舍五入为整数，并将结果存储为包装的单精度浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_ceil_sd.html" title="core::arch::x86::_mm_ceil_sd fn">_mm_ceil_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>将 <code>b</code> 中的下部双精度 (64-bit) 浮点元素四舍五入为整数，将结果作为双精度浮点元素存储在本征结果的下部元素中，并将上部元素从 <code>a</code> 复制到上部内在结果的元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_ceil_ss.html" title="core::arch::x86::_mm_ceil_ss fn">_mm_ceil_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>将 <code>b</code> 中的下部单精度 (32-bit) 浮点元素四舍五入为整数，将结果作为单精度浮点元素存储在内部结果的下部元素中，并将高 3 个包装的元素从 <code>a</code> 复制到内在结果的上层要素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_clflush.html" title="core::arch::x86::_mm_clflush fn">_mm_clflush</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>使高速缓存层次结构中所有级别的包含 <code>p</code> 的高速缓存行失效并刷新。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_clmulepi64_si128.html" title="core::arch::x86::_mm_clmulepi64_si128 fn">_mm_clmulepi64_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `pclmulqdq` only"><code>pclmulqdq</code></span><p>在有限域 GF(2^k) 上执行两个 64 位多项式的无进位乘法。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmp_pd.html" title="core::arch::x86::_mm_cmp_pd fn">_mm_cmp_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx,sse2` only"><code>avx,sse2</code></span><p>根据 <code>IMM5</code> 指定的比较操作数比较 <code>a</code> 和 <code>b</code> 中包装的双精度 (64-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmp_ps.html" title="core::arch::x86::_mm_cmp_ps fn">_mm_cmp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx,sse` only"><code>avx,sse</code></span><p>根据 <code>IMM5</code> 指定的比较操作数比较 <code>a</code> 和 <code>b</code> 中包装的单精度 (32-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmp_sd.html" title="core::arch::x86::_mm_cmp_sd fn">_mm_cmp_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx,sse2` only"><code>avx,sse2</code></span><p>根据 <code>IMM5</code> 指定的比较操作数，比较 <code>a</code> 和 <code>b</code> 中的低位双精度浮点元素 (64-bit)，将结果存入返回的 vector 的低位元素，并将 <code>a</code> 的高位元素复制到返回的 vector 的高位元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmp_ss.html" title="core::arch::x86::_mm_cmp_ss fn">_mm_cmp_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx,sse` only"><code>avx,sse</code></span><p>根据 <code>IMM5</code> 指定的比较操作数比较 <code>a</code> 和 <code>b</code> 中的低位单精度 (32-bit) 浮点元素，将结果存储在返回的 vector 的低位元素中，并将高 3 个包装的元素从 <code>a</code> 复制到返回 vector。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpeq_epi8.html" title="core::arch::x86::_mm_cmpeq_epi8 fn">_mm_cmpeq_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装 8 位整数是否相等。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpeq_epi16.html" title="core::arch::x86::_mm_cmpeq_epi16 fn">_mm_cmpeq_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的 16 位整数是否相等。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpeq_epi32.html" title="core::arch::x86::_mm_cmpeq_epi32 fn">_mm_cmpeq_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装 32 位整数是否相等。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpeq_epi64.html" title="core::arch::x86::_mm_cmpeq_epi64 fn">_mm_cmpeq_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装 64 位整数是否相等</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpeq_pd.html" title="core::arch::x86::_mm_cmpeq_pd fn">_mm_cmpeq_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的相应元素是否相等。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpeq_ps.html" title="core::arch::x86::_mm_cmpeq_ps fn">_mm_cmpeq_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>将 <code>a</code> 中的四个浮点数中的每个与 <code>b</code> 中的对应元素进行比较。
如果输入元素相等，则输出 vector 中的结果将为 <code>0xffffffff</code>，否则为 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpeq_sd.html" title="core::arch::x86::_mm_cmpeq_sd fn">_mm_cmpeq_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素的相等比较取代。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpeq_ss.html" title="core::arch::x86::_mm_cmpeq_ss fn">_mm_cmpeq_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较两个输入中的最低 <code>f32</code> 是否相等。
如果两个输入相等，结果的最低 32 位将为 <code>0xffffffff</code>，否则为 <code>0</code>。
结果的高 96 位是 <code>a</code> 的高 96 位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpestra.html" title="core::arch::x86::_mm_cmpestra fn">_mm_cmpestra</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span><p>使用 <code>IMM8</code> 中的控件将 <code>a</code> 和 <code>b</code> 中的包装字符串与长度 <code>la</code> 和 <code>lb</code> 进行比较，如果 <code>b</code> 不包含空字符且结果掩码为零，则返回 <code>1</code>，否则返回 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpestrc.html" title="core::arch::x86::_mm_cmpestrc fn">_mm_cmpestrc</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span><p>使用 <code>IMM8</code> 中的控件将 <code>a</code> 和 <code>b</code> 中的包装字符串与长度 <code>la</code> 和 <code>lb</code> 进行比较，如果结果掩码非零则返回 <code>1</code>，否则返回 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpestri.html" title="core::arch::x86::_mm_cmpestri fn">_mm_cmpestri</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span><p>使用 <code>IMM8</code> 中的控件将包装的字符串 <code>a</code> 和 <code>b</code> 与长度 <code>la</code> 和 <code>lb</code> 进行比较，并返回生成的索引。
与 <a href="fn._mm_cmpistri.html"><code>_mm_cmpistri</code></a> 相似，但 <a href="fn._mm_cmpistri.html"><code>_mm_cmpistri</code></a> 隐式确定 <code>a</code> 和 <code>b</code> 的长度。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpestrm.html" title="core::arch::x86::_mm_cmpestrm fn">_mm_cmpestrm</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span><p>使用 <code>IMM8</code> 中的控件将 <code>a</code> 和 <code>b</code> 中包装的字符串与长度 <code>la</code> 和 <code>lb</code> 进行比较，并返回生成的掩码。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpestro.html" title="core::arch::x86::_mm_cmpestro fn">_mm_cmpestro</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span><p>使用 <code>IMM8</code> 中的控件将 <code>a</code> 和 <code>b</code> 中的包装字符串与长度 <code>la</code> 和 <code>lb</code> 进行比较，并返回结果位掩码的位 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpestrs.html" title="core::arch::x86::_mm_cmpestrs fn">_mm_cmpestrs</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span><p>使用 <code>IMM8</code> 中的控件将 <code>a</code> 和 <code>b</code> 中的包装字符串与长度 <code>la</code> 和 <code>lb</code> 进行比较，如果 a 中的任何字符为空，则返回 <code>1</code>，否则返回 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpestrz.html" title="core::arch::x86::_mm_cmpestrz fn">_mm_cmpestrz</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span><p>使用 <code>IMM8</code> 中的控件将 <code>a</code> 和 <code>b</code> 中的包装字符串与长度 <code>la</code> 和 <code>lb</code> 进行比较，如果 <code>b</code> 中的任何字符为空，则返回 <code>1</code>，否则返回 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpge_pd.html" title="core::arch::x86::_mm_cmpge_pd fn">_mm_cmpge_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的对应元素是否大于等于。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpge_ps.html" title="core::arch::x86::_mm_cmpge_ps fn">_mm_cmpge_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>将 <code>a</code> 中的四个浮点数中的每个与 <code>b</code> 中的对应元素进行比较。
如果 <code>a</code> 中的输入元素大于或等于 <code>b</code> 中的相应元素，则输出 vector 中的结果将为 <code>0xffffffff</code>，否则为 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpge_sd.html" title="core::arch::x86::_mm_cmpge_sd fn">_mm_cmpge_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素大于或等于的比较所取代。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpge_ss.html" title="core::arch::x86::_mm_cmpge_ss fn">_mm_cmpge_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较两个输入的最低 <code>f32</code> 大于或等于。
如果 <code>a.extract(0)</code> 大于或等于 <code>b.extract(0)</code>，则结果的最低 32 位将为 <code>0xffffffff</code>，否则为 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpgt_epi8.html" title="core::arch::x86::_mm_cmpgt_epi8 fn">_mm_cmpgt_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的 8 位整数是否大于。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpgt_epi16.html" title="core::arch::x86::_mm_cmpgt_epi16 fn">_mm_cmpgt_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的 16 位整数是否大于。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpgt_epi32.html" title="core::arch::x86::_mm_cmpgt_epi32 fn">_mm_cmpgt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的 32 位整数是否大于。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpgt_epi64.html" title="core::arch::x86::_mm_cmpgt_epi64 fn">_mm_cmpgt_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的 64 位整数是否大于，返回结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpgt_pd.html" title="core::arch::x86::_mm_cmpgt_pd fn">_mm_cmpgt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的对应元素是否大于。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpgt_ps.html" title="core::arch::x86::_mm_cmpgt_ps fn">_mm_cmpgt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>将 <code>a</code> 中的四个浮点数中的每个与 <code>b</code> 中的对应元素进行比较。
如果 <code>a</code> 中的输入元素大于 <code>b</code> 中的相应元素，则输出 vector 中的结果将为 <code>0xffffffff</code>，否则为 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpgt_sd.html" title="core::arch::x86::_mm_cmpgt_sd fn">_mm_cmpgt_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素大于的比较所代替。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpgt_ss.html" title="core::arch::x86::_mm_cmpgt_ss fn">_mm_cmpgt_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较两个输入的最低 <code>f32</code> 大于。
如果 <code>a.extract(0)</code> 大于 <code>b.extract(0)</code>，则结果的最低 32 位将为 <code>0xffffffff</code>，否则为 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpistra.html" title="core::arch::x86::_mm_cmpistra fn">_mm_cmpistra</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span><p>使用 <code>IMM8</code> 中的控件比较 <code>a</code> 和 <code>b</code> 中隐含长度的包装字符串，如果 <code>b</code> 不包含空字符且结果掩码为零，则返回 <code>1</code>，否则返回 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpistrc.html" title="core::arch::x86::_mm_cmpistrc fn">_mm_cmpistrc</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span><p>使用 <code>IMM8</code> 中的控件将包装的字符串与 <code>a</code> 和 <code>b</code> 中的隐式长度进行比较，如果结果掩码不为零，则返回 <code>1</code>，否则返回 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpistri.html" title="core::arch::x86::_mm_cmpistri fn">_mm_cmpistri</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span><p>使用 <code>IMM8</code> 中的控件比较 <code>a</code> 和 <code>b</code> 中隐含长度的包装字符串，并返回生成的索引。
与 <a href="fn._mm_cmpestri.html" title="_mm_cmpestri"><code>_mm_cmpestri</code></a> 相似，不同之处在于 <a href="fn._mm_cmpestri.html" title="_mm_cmpestri"><code>_mm_cmpestri</code></a> 需要明确指定 <code>a</code> 和 <code>b</code> 的长度。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpistrm.html" title="core::arch::x86::_mm_cmpistrm fn">_mm_cmpistrm</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span><p>使用 <code>IMM8</code> 中的控件比较 <code>a</code> 和 <code>b</code> 中隐含长度的包装的字符串，并返回生成的掩码。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpistro.html" title="core::arch::x86::_mm_cmpistro fn">_mm_cmpistro</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span><p>使用 <code>IMM8</code> 中的控件比较 <code>a</code> 和 <code>b</code> 中隐含长度的包装字符串，并返回结果位掩码的位 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpistrs.html" title="core::arch::x86::_mm_cmpistrs fn">_mm_cmpistrs</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span><p>使用 <code>IMM8</code> 中的控件比较 <code>a</code> 和 <code>b</code> 中隐含长度的包装字符串，如果 <code>a</code> 中的任何字符为空，则返回 <code>1</code>，否则返回 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpistrz.html" title="core::arch::x86::_mm_cmpistrz fn">_mm_cmpistrz</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span><p>使用 <code>IMM8</code> 中的控件比较 <code>a</code> 和 <code>b</code> 中隐含长度的包装字符串，如果 <code>b</code> 中的任何字符为空，则返回 <code>1</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmple_pd.html" title="core::arch::x86::_mm_cmple_pd fn">_mm_cmple_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的对应元素是否小于等于</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmple_ps.html" title="core::arch::x86::_mm_cmple_ps fn">_mm_cmple_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>将 <code>a</code> 中的四个浮点数中的每个与 <code>b</code> 中的对应元素进行比较。
如果 <code>a</code> 中的输入元素小于或等于 <code>b</code> 中的相应元素，则输出 vector 中的结果将为 <code>0xffffffff</code>，否则为 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmple_sd.html" title="core::arch::x86::_mm_cmple_sd fn">_mm_cmple_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素小于或等于的比较所取代。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmple_ss.html" title="core::arch::x86::_mm_cmple_ss fn">_mm_cmple_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较两个输入中的最低 <code>f32</code> 小于或等于。最低的
如果 <code>a.extract(0)</code> 小于或等于 <code>b.extract(0)</code>，则结果的 32 位将为 <code>0xffffffff</code>，否则为 <code>0</code>。
结果的高 96 位是 <code>a</code> 的高 96 位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmplt_epi8.html" title="core::arch::x86::_mm_cmplt_epi8 fn">_mm_cmplt_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中小于 8 的包装的 8 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmplt_epi16.html" title="core::arch::x86::_mm_cmplt_epi16 fn">_mm_cmplt_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的 16 位整数小于。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmplt_epi32.html" title="core::arch::x86::_mm_cmplt_epi32 fn">_mm_cmplt_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的 32 位整数是否小于。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmplt_pd.html" title="core::arch::x86::_mm_cmplt_pd fn">_mm_cmplt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的对应元素小于。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmplt_ps.html" title="core::arch::x86::_mm_cmplt_ps fn">_mm_cmplt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>将 <code>a</code> 中的四个浮点数中的每个与 <code>b</code> 中的对应元素进行比较。
如果 <code>a</code> 中的输入元素小于 <code>b</code> 中的相应元素，则输出 vector 中的结果将为 <code>0xffffffff</code>，否则为 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmplt_sd.html" title="core::arch::x86::_mm_cmplt_sd fn">_mm_cmplt_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素的小于比较所代替。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmplt_ss.html" title="core::arch::x86::_mm_cmplt_ss fn">_mm_cmplt_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较两个输入的最低 <code>f32</code> 小于。
如果 <code>a.extract(0)</code> 小于 <code>b.extract(0)</code>，则结果的最低 32 位将为 <code>0xffffffff</code>，否则为 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpneq_pd.html" title="core::arch::x86::_mm_cmpneq_pd fn">_mm_cmpneq_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的对应元素是否相等。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpneq_ps.html" title="core::arch::x86::_mm_cmpneq_ps fn">_mm_cmpneq_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>将 <code>a</code> 中的四个浮点数中的每个与 <code>b</code> 中的对应元素进行比较。
如果输入元素不相等，则输出 vector 中的结果将为 <code>0xffffffff</code>，否则为 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpneq_sd.html" title="core::arch::x86::_mm_cmpneq_sd fn">_mm_cmpneq_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素的不相等比较代替。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpneq_ss.html" title="core::arch::x86::_mm_cmpneq_ss fn">_mm_cmpneq_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较两个输入中最低的 <code>f32</code> 是否不相等。
如果 <code>a.extract(0)</code> 不等于 <code>b.extract(0)</code>，则结果的最低 32 位将为 <code>0xffffffff</code>，否则为 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpnge_pd.html" title="core::arch::x86::_mm_cmpnge_pd fn">_mm_cmpnge_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的对应元素是否大于等于。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpnge_ps.html" title="core::arch::x86::_mm_cmpnge_ps fn">_mm_cmpnge_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>将 <code>a</code> 中的四个浮点数中的每个与 <code>b</code> 中的对应元素进行比较。
如果 <code>a</code> 中的输入元素不大于或等于 <code>b</code> 中的相应元素，则输出 vector 中的结果将为 <code>0xffffffff</code>，否则为 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpnge_sd.html" title="core::arch::x86::_mm_cmpnge_sd fn">_mm_cmpnge_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素的不大于等于相等的比较所取代。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpnge_ss.html" title="core::arch::x86::_mm_cmpnge_ss fn">_mm_cmpnge_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较两个输入中的最低 <code>f32</code>，以得出不大于等于。
如果 <code>a.extract(0)</code> 不大于或等于 <code>b.extract(0)</code>，则结果的最低 32 位将为 <code>0xffffffff</code>，否则为 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpngt_pd.html" title="core::arch::x86::_mm_cmpngt_pd fn">_mm_cmpngt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的对应元素是否大于。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpngt_ps.html" title="core::arch::x86::_mm_cmpngt_ps fn">_mm_cmpngt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>将 <code>a</code> 中的四个浮点数中的每个与 <code>b</code> 中的对应元素进行比较。
如果 <code>a</code> 中的输入元素不大于 <code>b</code> 中的相应元素，则输出 vector 中的结果将为 <code>0xffffffff</code>，否则为 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpngt_sd.html" title="core::arch::x86::_mm_cmpngt_sd fn">_mm_cmpngt_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素的不大于比较所代替。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpngt_ss.html" title="core::arch::x86::_mm_cmpngt_ss fn">_mm_cmpngt_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较两个输入的最低 <code>f32</code>，以得出不大于。
如果 <code>a.extract(0)</code> 不大于 <code>b.extract(0)</code>，则结果的最低 32 位将为 <code>0xffffffff</code>，否则为 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpnle_pd.html" title="core::arch::x86::_mm_cmpnle_pd fn">_mm_cmpnle_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的对应元素是否等于或大于等于。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpnle_ps.html" title="core::arch::x86::_mm_cmpnle_ps fn">_mm_cmpnle_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>将 <code>a</code> 中的四个浮点数中的每个与 <code>b</code> 中的对应元素进行比较。
如果 <code>a</code> 中的输入元素不小于或等于 <code>b</code> 中的相应元素，则输出 vector 中的结果将为 <code>0xffffffff</code>，否则为 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpnle_sd.html" title="core::arch::x86::_mm_cmpnle_sd fn">_mm_cmpnle_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素相等或不小于的比较所取代。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpnle_ss.html" title="core::arch::x86::_mm_cmpnle_ss fn">_mm_cmpnle_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较两个输入的最低 <code>f32</code> 等于或小于等于。
如果 <code>a.extract(0)</code> 不小于 <code>b.extract(0)</code>，则结果的最低 32 位将为 <code>0xffffffff</code>，否则为 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpnlt_pd.html" title="core::arch::x86::_mm_cmpnlt_pd fn">_mm_cmpnlt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的对应元素不少于。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpnlt_ps.html" title="core::arch::x86::_mm_cmpnlt_ps fn">_mm_cmpnlt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>将 <code>a</code> 中的四个浮点数中的每个与 <code>b</code> 中的对应元素进行比较。
如果 <code>a</code> 中的输入元素不小于 <code>b</code> 中的相应元素，则输出 vector 中的结果将为 <code>0xffffffff</code>，否则为 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpnlt_sd.html" title="core::arch::x86::_mm_cmpnlt_sd fn">_mm_cmpnlt_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素相当的比较所取代。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpnlt_ss.html" title="core::arch::x86::_mm_cmpnlt_ss fn">_mm_cmpnlt_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较两个输入中的最低 <code>f32</code> 不少于。
如果 <code>a.extract(0)</code> 不小于 <code>b.extract(0)</code>，则结果的最低 32 位将为 <code>0xffffffff</code>，否则为 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpord_pd.html" title="core::arch::x86::_mm_cmpord_pd fn">_mm_cmpord_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的相应元素以查看 <code>NaN</code> 是否都不是。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpord_ps.html" title="core::arch::x86::_mm_cmpord_ps fn">_mm_cmpord_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>将 <code>a</code> 中的四个浮点数中的每个与 <code>b</code> 中的对应元素进行比较。
返回具有两个可能的位模式之一的四个浮点数。
如果 <code>a</code> 和 <code>b</code> 中的输入元素是有序的 (即，它们都不是 NaN)，则输出 vector 中的元素将为 <code>0xffffffff</code>，否则为 0。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpord_sd.html" title="core::arch::x86::_mm_cmpord_sd fn">_mm_cmpord_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素都与 <code>NaN</code> 进行比较的结果所代替。
如果两者都不等于 <code>NaN</code>，则使用 <code>0xFFFFFFFFFFFFFFFF</code>，否则使用 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpord_ss.html" title="core::arch::x86::_mm_cmpord_ss fn">_mm_cmpord_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>检查两个输入中最低的 <code>f32</code> 是否已订购。
如果 <code>a.extract(0)</code> 或 <code>b.extract(0)</code> 都不是 NaN，则结果的最低 32 位将为 <code>0xffffffff</code>，否则为 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpunord_pd.html" title="core::arch::x86::_mm_cmpunord_pd fn">_mm_cmpunord_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的相应元素，以查看是否为 <code>NaN</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpunord_ps.html" title="core::arch::x86::_mm_cmpunord_ps fn">_mm_cmpunord_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>将 <code>a</code> 中的四个浮点数中的每个与 <code>b</code> 中的对应元素进行比较。
返回具有两个可能的位模式之一的四个浮点数。
如果 <code>a</code> 和 <code>b</code> 中的输入元素无序 (即，至少其中一个是 NaN)，则输出 vector 中的元素将为 <code>0xffffffff</code>，否则为 0。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpunord_sd.html" title="core::arch::x86::_mm_cmpunord_sd fn">_mm_cmpunord_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素都与 <code>NaN</code> 进行比较的结果所代替。
如果其中一个等于 <code>NaN</code>，则使用 <code>0xFFFFFFFFFFFFFFFF</code>，否则使用 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cmpunord_ss.html" title="core::arch::x86::_mm_cmpunord_ss fn">_mm_cmpunord_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>检查两个输入中最低的 <code>f32</code> 是否无序。
如果 <code>a.extract(0)</code> 或 <code>b.extract(0)</code> 中的任何一个为 NaN，则结果的最低 32 位将为 <code>0xffffffff</code>，否则为 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_comieq_sd.html" title="core::arch::x86::_mm_comieq_sd fn">_mm_comieq_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 的下部元素是否相等。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_comieq_ss.html" title="core::arch::x86::_mm_comieq_ss fn">_mm_comieq_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较 <code>a</code> 和 <code>b</code> 的低位的两个 32 位浮点数。
如果相等则返回 <code>1</code>，否则返回 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_comige_sd.html" title="core::arch::x86::_mm_comige_sd fn">_mm_comige_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 的下限元素是否大于等于。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_comige_ss.html" title="core::arch::x86::_mm_comige_ss fn">_mm_comige_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较 <code>a</code> 和 <code>b</code> 的低位的两个 32 位浮点数。
如果 <code>a</code> 中的值大于或等于 <code>b</code> 中的值，则返回 <code>1</code>，否则返回 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_comigt_sd.html" title="core::arch::x86::_mm_comigt_sd fn">_mm_comigt_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 的下限元素是否大于。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_comigt_ss.html" title="core::arch::x86::_mm_comigt_ss fn">_mm_comigt_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较 <code>a</code> 和 <code>b</code> 的低位的两个 32 位浮点数。
如果 <code>a</code> 中的值大于 <code>b</code> 中的值，则返回 <code>1</code>，否则返回 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_comile_sd.html" title="core::arch::x86::_mm_comile_sd fn">_mm_comile_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 的下限元素是否等于或小于等于。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_comile_ss.html" title="core::arch::x86::_mm_comile_ss fn">_mm_comile_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较 <code>a</code> 和 <code>b</code> 的低位的两个 32 位浮点数。
如果 <code>a</code> 中的值小于或等于 <code>b</code> 中的值，则返回 <code>1</code>，否则返回 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_comilt_sd.html" title="core::arch::x86::_mm_comilt_sd fn">_mm_comilt_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 的下限元素小于。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_comilt_ss.html" title="core::arch::x86::_mm_comilt_ss fn">_mm_comilt_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较 <code>a</code> 和 <code>b</code> 的低位的两个 32 位浮点数。
如果 <code>a</code> 中的值小于 <code>b</code> 中的值，则返回 <code>1</code>，否则返回 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_comineq_sd.html" title="core::arch::x86::_mm_comineq_sd fn">_mm_comineq_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 的下部元素是否相等。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_comineq_ss.html" title="core::arch::x86::_mm_comineq_ss fn">_mm_comineq_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较 <code>a</code> 和 <code>b</code> 的低位的两个 32 位浮点数。
如果它们不相等，则返回 <code>1</code>，否则返回 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_crc32_u8.html" title="core::arch::x86::_mm_crc32_u8 fn">_mm_crc32_u8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span><p>从 <code>crc</code> 中的初始值开始，返回无符号 8 位整数 <code>v</code> 的累积 CRC32 值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_crc32_u16.html" title="core::arch::x86::_mm_crc32_u16 fn">_mm_crc32_u16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span><p>从 <code>crc</code> 中的初始值开始，返回无符号 16 位整数 <code>v</code> 的累积 CRC32 值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_crc32_u32.html" title="core::arch::x86::_mm_crc32_u32 fn">_mm_crc32_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.2` only"><code>sse4.2</code></span><p>从 <code>crc</code> 中的初始值开始，返回无符号 32 位整数 <code>v</code> 的累积 CRC32 值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvt_si2ss.html" title="core::arch::x86::_mm_cvt_si2ss fn">_mm_cvt_si2ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p><a href="fn._mm_cvtsi32_ss.html"><code>_mm_cvtsi32_ss</code></a> 的别名。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvt_ss2si.html" title="core::arch::x86::_mm_cvt_ss2si fn">_mm_cvt_ss2si</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p><a href="fn._mm_cvtss_si32.html"><code>_mm_cvtss_si32</code></a> 的别名。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtepi8_epi16.html" title="core::arch::x86::_mm_cvtepi8_epi16 fn">_mm_cvtepi8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>符号将 <code>a</code> 中的包装 8 位整数扩展为包装 16 位整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtepi8_epi32.html" title="core::arch::x86::_mm_cvtepi8_epi32 fn">_mm_cvtepi8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>符号将 <code>a</code> 中的包装 8 位整数扩展为包装 32 位整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtepi8_epi64.html" title="core::arch::x86::_mm_cvtepi8_epi64 fn">_mm_cvtepi8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>符号将 <code>a</code> 的低 8 字节中的包装的 8 位整数扩展为包装的
64 位整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtepi16_epi32.html" title="core::arch::x86::_mm_cvtepi16_epi32 fn">_mm_cvtepi16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>符号将 <code>a</code> 中的包装的 16 位整数扩展为包装的 32 位整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtepi16_epi64.html" title="core::arch::x86::_mm_cvtepi16_epi64 fn">_mm_cvtepi16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>符号将 <code>a</code> 中的包装 16 位整数扩展为包装 64 位整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtepi32_epi64.html" title="core::arch::x86::_mm_cvtepi32_epi64 fn">_mm_cvtepi32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>符号将 <code>a</code> 中的包装 32 位整数扩展为包装 64 位整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtepi32_pd.html" title="core::arch::x86::_mm_cvtepi32_pd fn">_mm_cvtepi32_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 中的低位两个包装的 32 位整数转换为包装的双精度 (64-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtepi32_ps.html" title="core::arch::x86::_mm_cvtepi32_ps fn">_mm_cvtepi32_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 中的包装的 32 位整数转换为包装的单精度 (32-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtepu8_epi16.html" title="core::arch::x86::_mm_cvtepu8_epi16 fn">_mm_cvtepu8_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>零将 <code>a</code> 中的包装的无符号 8 位整数扩展为包装的 16 位整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtepu8_epi32.html" title="core::arch::x86::_mm_cvtepu8_epi32 fn">_mm_cvtepu8_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>零将 <code>a</code> 中的包装无符号 8 位整数扩展为包装 32 位整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtepu8_epi64.html" title="core::arch::x86::_mm_cvtepu8_epi64 fn">_mm_cvtepu8_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>零将 <code>a</code> 中的包装无符号 8 位整数扩展为包装 64 位整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtepu16_epi32.html" title="core::arch::x86::_mm_cvtepu16_epi32 fn">_mm_cvtepu16_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>零将 <code>a</code> 中的包装的无符号 16 位整数扩展为包装的 32 位整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtepu16_epi64.html" title="core::arch::x86::_mm_cvtepu16_epi64 fn">_mm_cvtepu16_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>零将 <code>a</code> 中的包装的无符号 16 位整数扩展为包装的 64 位整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtepu32_epi64.html" title="core::arch::x86::_mm_cvtepu32_epi64 fn">_mm_cvtepu32_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>零将 <code>a</code> 中的包装无符号 32 位整数扩展为包装 64 位整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtpd_epi32.html" title="core::arch::x86::_mm_cvtpd_epi32 fn">_mm_cvtpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素转换为包装的 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtpd_ps.html" title="core::arch::x86::_mm_cvtpd_ps fn">_mm_cvtpd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtps_epi32.html" title="core::arch::x86::_mm_cvtps_epi32 fn">_mm_cvtps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 中的包装的单精度 (32-bit) 浮点元素转换为包装的 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtps_pd.html" title="core::arch::x86::_mm_cvtps_pd fn">_mm_cvtps_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 中的包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtsd_f64.html" title="core::arch::x86::_mm_cvtsd_f64 fn">_mm_cvtsd_f64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回 <code>a</code> 的较低的双精度 (64-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtsd_si32.html" title="core::arch::x86::_mm_cvtsd_si32 fn">_mm_cvtsd_si32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 a 中的较低双精度 (64-bit) 浮点元素转换为 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtsd_ss.html" title="core::arch::x86::_mm_cvtsd_ss fn">_mm_cvtsd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>b</code> 中的下部双精度 (64-bit) 浮点元素转换为单精度 (32-bit) 浮点元素，将结果存储在返回值的下部元素中，并将上部元素从 <code>a</code> 复制到返回值的上部元素中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtsi32_sd.html" title="core::arch::x86::_mm_cvtsi32_sd fn">_mm_cvtsi32_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 的下位元素转换为 <code>f64</code> 后，返回其下位元素为 <code>b</code> 的 <code>a</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtsi32_si128.html" title="core::arch::x86::_mm_cvtsi32_si128 fn">_mm_cvtsi32_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回 vector，其最低元素为 <code>a</code>，所有更高元素为 <code>0</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtsi32_ss.html" title="core::arch::x86::_mm_cvtsi32_ss fn">_mm_cvtsi32_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>将 32 位整数转换为 32 位浮点型。
结果 vector 是输入 vector <code>a</code>，其最低 32 位浮点数已由转换后的整数替换。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtsi128_si32.html" title="core::arch::x86::_mm_cvtsi128_si32 fn">_mm_cvtsi128_si32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回 <code>a</code> 的最低元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtss_f32.html" title="core::arch::x86::_mm_cvtss_f32 fn">_mm_cvtss_f32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>从输入 vector 中提取最低的 32 位浮点数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtss_sd.html" title="core::arch::x86::_mm_cvtss_sd fn">_mm_cvtss_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>b</code> 中的下部单精度 (32-bit) 浮点元素转换为双精度 (64-bit) 浮点元素，将结果存储在返回值的下部元素中，然后将 <code>a</code> 的上部元素复制到返回值的上部元素中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtss_si32.html" title="core::arch::x86::_mm_cvtss_si32 fn">_mm_cvtss_si32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>将输入 vector 中的最低 32 位浮点型转换为 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvtt_ss2si.html" title="core::arch::x86::_mm_cvtt_ss2si fn">_mm_cvtt_ss2si</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p><a href="fn._mm_cvttss_si32.html"><code>_mm_cvttss_si32</code></a> 的别名。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvttpd_epi32.html" title="core::arch::x86::_mm_cvttpd_epi32 fn">_mm_cvttpd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvttps_epi32.html" title="core::arch::x86::_mm_cvttps_epi32 fn">_mm_cvttps_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvttsd_si32.html" title="core::arch::x86::_mm_cvttsd_si32 fn">_mm_cvttsd_si32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 中较低的双精度 (64-bit) 浮点元素转换为带截断的 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_cvttss_si32.html" title="core::arch::x86::_mm_cvttss_si32 fn">_mm_cvttss_si32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>将输入 vector 中的最低 32 位浮点型转换为带有截断的 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_div_pd.html" title="core::arch::x86::_mm_div_pd fn">_mm_div_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素除以 <code>b</code> 中的包装的元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_div_ps.html" title="core::arch::x86::_mm_div_ps fn">_mm_div_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>除 __m128 vectors。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_div_sd.html" title="core::arch::x86::_mm_div_sd fn">_mm_div_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回一个新的 vector，其中 <code>a</code> 的下限元素被 <code>a</code> 的下限元素除以 <code>b</code> 的下限元素所代替。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_div_ss.html" title="core::arch::x86::_mm_div_ss fn">_mm_div_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>将 <code>b</code> 的第一个组件除以 <code>a</code>，其他组件则从 <code>a</code> 复制。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_dp_pd.html" title="core::arch::x86::_mm_dp_pd fn">_mm_dp_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>返回两个 __m128d vectors 的点积。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_dp_ps.html" title="core::arch::x86::_mm_dp_ps fn">_mm_dp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>返回两个 __m128 vectors 的点积。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_extract_epi8.html" title="core::arch::x86::_mm_extract_epi8 fn">_mm_extract_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>从 <code>a</code> 中提取一个 8 位整数，用 <code>IMM8</code> 选择。
返回包含零扩展整数数据的 32 位整数。
See <a href="https://reviews.llvm.org/D20468">LLVM commit D20468</a>.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_extract_epi16.html" title="core::arch::x86::_mm_extract_epi16 fn">_mm_extract_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回 <code>a</code> 的 <code>imm8</code> 元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_extract_epi32.html" title="core::arch::x86::_mm_extract_epi32 fn">_mm_extract_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>从 <code>IMM8</code> 选择的 <code>a</code> 中提取 32 位整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_extract_ps.html" title="core::arch::x86::_mm_extract_ps fn">_mm_extract_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>从 <code>a</code> 中提取单精度 (32-bit) 浮点元素，用 <code>IMM8</code> 选择</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_extract_si64.html" title="core::arch::x86::_mm_extract_si64 fn">_mm_extract_si64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4a` only"><code>sse4a</code></span><p>从 <code>x</code> 的低 64 位提取 <code>y</code> 指定的位范围。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_floor_pd.html" title="core::arch::x86::_mm_floor_pd fn">_mm_floor_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>将 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素四舍五入为整数，并将结果存储为包装的双精度浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_floor_ps.html" title="core::arch::x86::_mm_floor_ps fn">_mm_floor_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>将 <code>a</code> 中的包装的单精度 (32-bit) 浮点元素四舍五入为整数，并将结果存储为包装的单精度浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_floor_sd.html" title="core::arch::x86::_mm_floor_sd fn">_mm_floor_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>将 <code>b</code> 中的下部双精度 (64-bit) 浮点元素四舍五入为整数值，将结果作为双精度浮点元素存储在内部结果的下部元素中，并将上部元素从 <code>a</code> 复制到上部内在结果的元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_floor_ss.html" title="core::arch::x86::_mm_floor_ss fn">_mm_floor_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>将 <code>b</code> 中的下部单精度 (32-bit) 浮点元素四舍五入为整数值，将结果作为单精度浮点元素存储在内部结果的下部元素中，然后将 <code>a</code> 的上部 3 个包装的元素复制到内在结果的上层要素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_fmadd_pd.html" title="core::arch::x86::_mm_fmadd_pd fn">_mm_fmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素相乘，并将中间结果与 <code>c</code> 中的包装的元素相加。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_fmadd_ps.html" title="core::arch::x86::_mm_fmadd_ps fn">_mm_fmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装单精度 (32-bit) 浮点元素相乘，并将中间结果添加到 <code>c</code> 中的包装元素中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_fmadd_sd.html" title="core::arch::x86::_mm_fmadd_sd fn">_mm_fmadd_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的较低的双精度 (64-bit) 浮点元素相乘，并将中间结果与 <code>c</code> 中的较低的元素相加。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_fmadd_ss.html" title="core::arch::x86::_mm_fmadd_ss fn">_mm_fmadd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中较低的单精度 (32-bit) 浮点元素相乘，并将中间结果与 <code>c</code> 中的较低元素相加。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_fmaddsub_pd.html" title="core::arch::x86::_mm_fmaddsub_pd fn">_mm_fmaddsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素相乘，或者在 <code>c</code> to/from 中将包装的元素相加或减去中间结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_fmaddsub_ps.html" title="core::arch::x86::_mm_fmaddsub_ps fn">_mm_fmaddsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中包装的单精度 (32-bit) 浮点元素相乘，或者将 <code>c</code> 中包装的元素加/减到中间结果中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_fmsub_pd.html" title="core::arch::x86::_mm_fmsub_pd fn">_mm_fmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素相乘，并从中间结果中减去 <code>c</code> 中的包装的双精度元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_fmsub_ps.html" title="core::arch::x86::_mm_fmsub_ps fn">_mm_fmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装的单精度 (32-bit) 浮点元素相乘，并从中间结果中减去 <code>c</code> 中的包装元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_fmsub_sd.html" title="core::arch::x86::_mm_fmsub_sd fn">_mm_fmsub_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的较低的双精度 (64-bit) 浮点元素相乘，并从中间结果中减去 <code>c</code> 中的较低的元素。
将结果存储在返回值的低位元素中，并将高位元素从 <code>a</code> 复制到结果的高位元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_fmsub_ss.html" title="core::arch::x86::_mm_fmsub_ss fn">_mm_fmsub_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的较低单精度 (32-bit) 浮点元素相乘，并从中间结果中减去 <code>c</code> 中的较低元素。
将结果存储在返回值的低位元素中，并将 3 个高位元素从 <code>a</code> 复制到结果的高位元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_fmsubadd_pd.html" title="core::arch::x86::_mm_fmsubadd_pd fn">_mm_fmsubadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素相乘，也可以从中间结果中减去或加上 <code>c</code> 中的包装元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_fmsubadd_ps.html" title="core::arch::x86::_mm_fmsubadd_ps fn">_mm_fmsubadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装单精度 (32-bit) 浮点元素相乘，或者将 <code>c</code> 中的包装元素从中间结果中减去或加上。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_fnmadd_pd.html" title="core::arch::x86::_mm_fnmadd_pd fn">_mm_fnmadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装双精度 (64-bit) 浮点元素相乘，然后将取反的中间结果添加到 <code>c</code> 中的包装元素中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_fnmadd_ps.html" title="core::arch::x86::_mm_fnmadd_ps fn">_mm_fnmadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装单精度 (32-bit) 浮点元素相乘，并将取反的中间结果添加到 <code>c</code> 中的包装元素中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_fnmadd_sd.html" title="core::arch::x86::_mm_fnmadd_sd fn">_mm_fnmadd_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中较低的双精度 (64-bit) 浮点元素相乘，并将取反的中间结果添加到 <code>c</code> 中的较低元素。
将结果存储在返回值的低位元素中，并将高位元素从 <code>a</code> 复制到结果的高位元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_fnmadd_ss.html" title="core::arch::x86::_mm_fnmadd_ss fn">_mm_fnmadd_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中较低的单精度 (32-bit) 浮点元素相乘，并将取反的中间结果与 <code>c</code> 中的较低元素相加。
将结果存储在返回值的低位元素中，并将 3 个高位元素从 <code>a</code> 复制到结果的高位元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_fnmsub_pd.html" title="core::arch::x86::_mm_fnmsub_pd fn">_mm_fnmsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素相乘，并从取反的中间结果中减去 <code>c</code> 中的包装的元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_fnmsub_ps.html" title="core::arch::x86::_mm_fnmsub_ps fn">_mm_fnmsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装的单精度 (32-bit) 浮点元素相乘，并从取反的中间结果中减去 <code>c</code> 中的包装的元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_fnmsub_sd.html" title="core::arch::x86::_mm_fnmsub_sd fn">_mm_fnmsub_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中较低的双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 <code>c</code> 中的包装的元素。
将结果存储在返回值的低位元素中，并将高位元素从 <code>a</code> 复制到结果的高位元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_fnmsub_ss.html" title="core::arch::x86::_mm_fnmsub_ss fn">_mm_fnmsub_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `fma` only"><code>fma</code></span><p>将 <code>a</code> 和 <code>b</code> 中较低的单精度 (32-bit) 浮点元素相乘，然后从取反的中间结果中减去 <code>c</code> 中的包装元素。
将结果存储在返回值的低位元素中，并将 3 个高位元素从 <code>a</code> 复制到结果的高位元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_getcsr.html" title="core::arch::x86::_mm_getcsr fn">_mm_getcsr</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>获取 MXCSR 控制和状态寄存器的无符号 32 位值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_hadd_epi16.html" title="core::arch::x86::_mm_hadd_epi16 fn">_mm_hadd_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span><p>水平相加 2 个包装的包中包含的相邻值对
<code>[8 x i16]</code> 的 128 位 vectors。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_hadd_epi32.html" title="core::arch::x86::_mm_hadd_epi32 fn">_mm_hadd_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span><p>水平相加 2 个包装的包中包含的相邻值对
<code>[4 x i32]</code> 的 128 位 vectors。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_hadd_pd.html" title="core::arch::x86::_mm_hadd_pd fn">_mm_hadd_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse3` only"><code>sse3</code></span><p>在 <code>a</code> 和 <code>b</code> 中水平添加相邻对的双精度 (64-bit) 浮点元素，并包装结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_hadd_ps.html" title="core::arch::x86::_mm_hadd_ps fn">_mm_hadd_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse3` only"><code>sse3</code></span><p>在 <code>a</code> 和 <code>b</code> 中水平添加相邻对的单精度 (32-bit) 浮点元素对，并包装结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_hadds_epi16.html" title="core::arch::x86::_mm_hadds_epi16 fn">_mm_hadds_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span><p>水平相加 2 个包装的包中包含的相邻值对
<code>[8 x i16]</code> 的 128 位 vectors。大于 7FFFh 的正和饱和到 7FFFh。
小于 8000h 的负数和将饱和到 8000h。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_hsub_epi16.html" title="core::arch::x86::_mm_hsub_epi16 fn">_mm_hsub_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span><p>水平减去 <code>[8 x i16]</code> 的 2 个包装的 128 位 vectors 中包含的相邻值对。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_hsub_epi32.html" title="core::arch::x86::_mm_hsub_epi32 fn">_mm_hsub_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span><p>水平减去 <code>[4 x i32]</code> 的 2 个包装的 128 位 vectors 中包含的相邻值对。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_hsub_pd.html" title="core::arch::x86::_mm_hsub_pd fn">_mm_hsub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse3` only"><code>sse3</code></span><p>水平减去 <code>a</code> 和 <code>b</code> 中相邻的双精度 (64-bit) 浮点元素对，然后包装结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_hsub_ps.html" title="core::arch::x86::_mm_hsub_ps fn">_mm_hsub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse3` only"><code>sse3</code></span><p>在 <code>a</code> 和 <code>b</code> 中水平添加相邻对的单精度 (32-bit) 浮点元素对，并包装结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_hsubs_epi16.html" title="core::arch::x86::_mm_hsubs_epi16 fn">_mm_hsubs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span><p>水平减去 <code>[8 x i16]</code> 的 2 个包装的 128 位 vectors 中包含的相邻值对。
正差异大于
7FFFh 饱和到 7FFFh。小于 8000h 的负差会饱和到 8000h。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_i32gather_epi32.html" title="core::arch::x86::_mm_i32gather_epi32 fn">_mm_i32gather_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_i32gather_epi64.html" title="core::arch::x86::_mm_i32gather_epi64 fn">_mm_i32gather_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_i32gather_pd.html" title="core::arch::x86::_mm_i32gather_pd fn">_mm_i32gather_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_i32gather_ps.html" title="core::arch::x86::_mm_i32gather_ps fn">_mm_i32gather_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_i64gather_epi32.html" title="core::arch::x86::_mm_i64gather_epi32 fn">_mm_i64gather_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_i64gather_epi64.html" title="core::arch::x86::_mm_i64gather_epi64 fn">_mm_i64gather_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_i64gather_pd.html" title="core::arch::x86::_mm_i64gather_pd fn">_mm_i64gather_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_i64gather_ps.html" title="core::arch::x86::_mm_i64gather_ps fn">_mm_i64gather_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_insert_epi8.html" title="core::arch::x86::_mm_insert_epi8 fn">_mm_insert_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>返回 <code>a</code> 的副本，其中 <code>i</code> 的 8 位整数插入到 <code>IMM8</code> 指定的位置。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_insert_epi16.html" title="core::arch::x86::_mm_insert_epi16 fn">_mm_insert_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回一个新的 vector，其中 <code>a</code> 的 <code>imm8</code> 元素替换为 <code>i</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_insert_epi32.html" title="core::arch::x86::_mm_insert_epi32 fn">_mm_insert_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>返回 <code>a</code> 的副本，其中 <code>i</code> 的 32 位整数插入到 <code>IMM8</code> 指定的位置。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_insert_ps.html" title="core::arch::x86::_mm_insert_ps fn">_mm_insert_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>在 <code>a</code> 中选择单个值存储在 <code>b</code> 中的某个位置，然后根据 <code>IMM8</code> 将元素归零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_insert_si64.html" title="core::arch::x86::_mm_insert_si64 fn">_mm_insert_si64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4a` only"><code>sse4a</code></span><p>将 <code>y</code> 的 <code>[length:0]</code> 位插入 <code>index</code> 处的 <code>x</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_lddqu_si128.html" title="core::arch::x86::_mm_lddqu_si128 fn">_mm_lddqu_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse3` only"><code>sse3</code></span><p>从未对齐的内存中加载 128 位整数数据。
当数据越过缓存行边界时，此内联函数可能比 <code>_mm_loadu_si128</code> 更好。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_lfence.html" title="core::arch::x86::_mm_lfence fn">_mm_lfence</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>对在此指令之前发布的所有内存加载指令执行序列化操作。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_load1_pd.html" title="core::arch::x86::_mm_load1_pd fn">_mm_load1_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将内存中的双精度 (64-bit) 浮点元素加载到返回的 vector 的两个元素中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_load1_ps.html" title="core::arch::x86::_mm_load1_ps fn">_mm_load1_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>通过将从 <code>p</code> 读取的值复制到所有元素中来构造 <code>__m128</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_load_pd.html" title="core::arch::x86::_mm_load_pd fn">_mm_load_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>从内存中将 128 位 (由 2 个包装的双精度 (64-bit) 浮点元素组成) 加载到返回的 vector 中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_load_pd1.html" title="core::arch::x86::_mm_load_pd1 fn">_mm_load_pd1</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将内存中的双精度 (64-bit) 浮点元素加载到返回的 vector 的两个元素中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_load_ps.html" title="core::arch::x86::_mm_load_ps fn">_mm_load_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>将 <em>aligned</em> 内存中的四个 <code>f32</code> 值加载到 <code>__m128</code> 中。
如果指针未与 128 位边界 (16 个字节) 对齐，则将触发一般保护错误 (致命程序崩溃)。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_load_ps1.html" title="core::arch::x86::_mm_load_ps1 fn">_mm_load_ps1</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p><a href="fn._mm_load1_ps.html"><code>_mm_load1_ps</code></a> 的别名</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_load_sd.html" title="core::arch::x86::_mm_load_sd fn">_mm_load_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 64 位双精度值加载到
128 位整数 vector 并清除高位元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_load_si128.html" title="core::arch::x86::_mm_load_si128 fn">_mm_load_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>从内存中将 128 位整数数据加载到新的 vector 中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_load_ss.html" title="core::arch::x86::_mm_load_ss fn">_mm_load_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>使用从 <code>p</code> 读取的最低元素并将其他元素设置为零来构造 <code>__m128</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_loaddup_pd.html" title="core::arch::x86::_mm_loaddup_pd fn">_mm_loaddup_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse3` only"><code>sse3</code></span><p>将内存中的双精度 (64-bit) 浮点元素加载到返回 vector 的两个元素中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_loadh_pd.html" title="core::arch::x86::_mm_loadh_pd fn">_mm_loadh_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将双精度值加载到 <code>[2 x double]</code> 的 128 位 vector 的高阶位中。
低位从第一个操作数的低位复制而来。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_loadl_epi64.html" title="core::arch::x86::_mm_loadl_epi64 fn">_mm_loadl_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将内存中的 64 位整数加载到返回的 vector 的第一个元素中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_loadl_pd.html" title="core::arch::x86::_mm_loadl_pd fn">_mm_loadl_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将双精度值加载到 <code>[2 x double]</code> 的 128 位 vector 的低位中。
高阶位是从第一个操作数的高阶位复制而来的。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_loadr_pd.html" title="core::arch::x86::_mm_loadr_pd fn">_mm_loadr_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>以相反的顺序将 2 个双精度 (64-bit) 浮点元素从内存加载到返回的 vector 中。
<code>mem_addr</code> 必须对齐
可能会生成 16 字节边界或一般保护异常。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_loadr_ps.html" title="core::arch::x86::_mm_loadr_ps fn">_mm_loadr_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>从对齐的内存中以相反的顺序将四个 <code>f32</code> 值加载到 <code>__m128</code> 中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_loadu_pd.html" title="core::arch::x86::_mm_loadu_pd fn">_mm_loadu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>从内存中将 128 位 (由 2 个包装的双精度 (64-bit) 浮点元素组成) 加载到返回的 vector 中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_loadu_ps.html" title="core::arch::x86::_mm_loadu_ps fn">_mm_loadu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>从内存中将四个 <code>f32</code> 值加载到 <code>__m128</code> 中。内存对齐没有任何限制。
对于对齐的内存
<a href="fn._mm_load_ps.html"><code>_mm_load_ps</code></a>
可能更快。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_loadu_si64.html" title="core::arch::x86::_mm_loadu_si64 fn">_mm_loadu_si64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>将未对齐的 64 位整数数据从内存加载到新的 vector 中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_loadu_si128.html" title="core::arch::x86::_mm_loadu_si128 fn">_mm_loadu_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>从内存中将 128 位整数数据加载到新的 vector 中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_madd_epi16.html" title="core::arch::x86::_mm_madd_epi16 fn">_mm_madd_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>在 <code>a</code> 和 <code>b</code> 中相乘，然后水平相加带符号的 16 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_maddubs_epi16.html" title="core::arch::x86::_mm_maddubs_epi16 fn">_mm_maddubs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span><p>将第一个源操作数中包含的包装的 8 位无符号整数值与第二个源操作数中包含的包装的 8 位有符号整数值的对应对相乘，相加具有符号饱和度的连续乘积对，并将 16 位和写入到目标中的相应位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_mask_i32gather_epi32.html" title="core::arch::x86::_mm_mask_i32gather_epi32 fn">_mm_mask_i32gather_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_mask_i32gather_epi64.html" title="core::arch::x86::_mm_mask_i32gather_epi64 fn">_mm_mask_i32gather_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_mask_i32gather_pd.html" title="core::arch::x86::_mm_mask_i32gather_pd fn">_mm_mask_i32gather_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_mask_i32gather_ps.html" title="core::arch::x86::_mm_mask_i32gather_ps fn">_mm_mask_i32gather_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_mask_i64gather_epi32.html" title="core::arch::x86::_mm_mask_i64gather_epi32 fn">_mm_mask_i64gather_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_mask_i64gather_epi64.html" title="core::arch::x86::_mm_mask_i64gather_epi64 fn">_mm_mask_i64gather_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_mask_i64gather_pd.html" title="core::arch::x86::_mm_mask_i64gather_pd fn">_mm_mask_i64gather_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_mask_i64gather_ps.html" title="core::arch::x86::_mm_mask_i64gather_ps fn">_mm_mask_i64gather_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>从 <code>slice</code> 返回由 <code>offsets * scale</code> 确定的偏移量的值，其中 <code>scale</code> 应该为 1、2、4 或 8。
如果设置了掩码，请从该位置从 <code>src</code> 加载值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_maskload_epi32.html" title="core::arch::x86::_mm_maskload_epi32 fn">_mm_maskload_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用 <code>mask</code> 从 <code>mem_addr</code> 指向的内存中加载包装的 32 位整数 (当未在相应元素中设置最高位时，元素清零)。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_maskload_epi64.html" title="core::arch::x86::_mm_maskload_epi64 fn">_mm_maskload_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用 <code>mask</code> 从 <code>mem_addr</code> 指向的内存中加载包装的 64 位整数 (当未在相应元素中设置最高位时，元素清零)。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_maskload_pd.html" title="core::arch::x86::_mm_maskload_pd fn">_mm_maskload_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用 <code>mask</code> 将包装的双精度 (64-bit) 浮点元素从内存加载到结果中 (当未设置相应元素的高位时，元素清零)。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_maskload_ps.html" title="core::arch::x86::_mm_maskload_ps fn">_mm_maskload_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用 <code>mask</code> 将包装的单精度 (32-bit) 浮点元素从内存加载到结果中 (当未设置相应元素的高位时，元素清零)。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_maskmoveu_si128.html" title="core::arch::x86::_mm_maskmoveu_si128 fn">_mm_maskmoveu_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>使用 <code>mask</code> 有条件地将 <code>a</code> 中的 8 位整数元素存储到内存中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_maskstore_epi32.html" title="core::arch::x86::_mm_maskstore_epi32 fn">_mm_maskstore_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用 <code>mask</code> 将 <code>a</code> 中的包装后的 32 位整数存储到 <code>mem_addr</code> 指向的内存中 (当在相应元素中未设置最高位时，不存储元素)。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_maskstore_epi64.html" title="core::arch::x86::_mm_maskstore_epi64 fn">_mm_maskstore_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>使用 <code>mask</code> 将 <code>a</code> 中的包装 64 位整数存储到 <code>mem_addr</code> 指向的内存中 (当未在相应元素中设置最高位时，不存储元素)。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_maskstore_pd.html" title="core::arch::x86::_mm_maskstore_pd fn">_mm_maskstore_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用 <code>mask</code> 将包装的双精度 (64-bit) 浮点元素从 <code>a</code> 存储到内存中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_maskstore_ps.html" title="core::arch::x86::_mm_maskstore_ps fn">_mm_maskstore_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用 <code>mask</code> 将包装的单精度 (32-bit) 浮点元素从 <code>a</code> 存储到内存中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_max_epi8.html" title="core::arch::x86::_mm_max_epi8 fn">_mm_max_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的 8 位整数，并以 dst 返回包装的最大值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_max_epi16.html" title="core::arch::x86::_mm_max_epi16 fn">_mm_max_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的 16 位整数，并返回包装的最大值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_max_epi32.html" title="core::arch::x86::_mm_max_epi32 fn">_mm_max_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的 32 位整数，并返回包装的最大值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_max_epu8.html" title="core::arch::x86::_mm_max_epu8 fn">_mm_max_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中包装的无符号 8 位整数，并返回包装的最大值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_max_epu16.html" title="core::arch::x86::_mm_max_epu16 fn">_mm_max_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>比较 <code>a</code> 和 <code>b</code> 中包装的无符号 16 位整数，并返回包装的最大值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_max_epu32.html" title="core::arch::x86::_mm_max_epu32 fn">_mm_max_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装无符号 32 位整数，并返回包装最大值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_max_pd.html" title="core::arch::x86::_mm_max_pd fn">_mm_max_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回一个新的 vector，它具有 <code>a</code> 和 <code>b</code> 中相应元素的最大值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_max_ps.html" title="core::arch::x86::_mm_max_ps fn">_mm_max_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较 <code>a</code> 和 <code>b</code> 中包装的单精度 (32-bit) 浮点元素，并返回相应的最大值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_max_sd.html" title="core::arch::x86::_mm_max_sd fn">_mm_max_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素最大值取代。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_max_ss.html" title="core::arch::x86::_mm_max_ss fn">_mm_max_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较 <code>a</code> 和 <code>b</code> 的第一个单精度 (32-bit) 浮点元素，并在返回值的第一个元素中返回最大值，从 <code>a</code> 复制其他元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_mfence.html" title="core::arch::x86::_mm_mfence fn">_mm_mfence</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>对在此指令之前发布的所有从内存加载和存储到内存指令执行序列化操作。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_min_epi8.html" title="core::arch::x86::_mm_min_epi8 fn">_mm_min_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的 8 位整数，并以 dst 返回包装的最小值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_min_epi16.html" title="core::arch::x86::_mm_min_epi16 fn">_mm_min_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中包装的 16 位整数，并返回包装的最小值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_min_epi32.html" title="core::arch::x86::_mm_min_epi32 fn">_mm_min_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的 32 位整数，并返回包装的最小值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_min_epu8.html" title="core::arch::x86::_mm_min_epu8 fn">_mm_min_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 中包装的无符号 8 位整数，并返回包装的最小值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_min_epu16.html" title="core::arch::x86::_mm_min_epu16 fn">_mm_min_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的无符号 16 位整数，并返回包装的最小值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_min_epu32.html" title="core::arch::x86::_mm_min_epu32 fn">_mm_min_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>比较 <code>a</code> 和 <code>b</code> 中的包装的无符号 32 位整数，并返回包装的最小值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_min_pd.html" title="core::arch::x86::_mm_min_pd fn">_mm_min_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回一个新的 vector，它具有 <code>a</code> 和 <code>b</code> 中相应元素的最小值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_min_ps.html" title="core::arch::x86::_mm_min_ps fn">_mm_min_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较 <code>a</code> 和 <code>b</code> 中包装的单精度 (32-bit) 浮点元素，并返回相应的最小值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_min_sd.html" title="core::arch::x86::_mm_min_sd fn">_mm_min_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素的最小值替换。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_min_ss.html" title="core::arch::x86::_mm_min_ss fn">_mm_min_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较 <code>a</code> 和 <code>b</code> 的第一个单精度 (32-bit) 浮点元素，并在返回值的第一个元素中返回最小值，从 <code>a</code> 复制其他元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_minpos_epu16.html" title="core::arch::x86::_mm_minpos_epu16 fn">_mm_minpos_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>在 128 位 __m128i vector 中查找最小的无符号 16 位元素，并返回一个 vector，其中在第一个位置包含其值，在第二个位置包含其索引; 所有其他元素都设置为零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_move_epi64.html" title="core::arch::x86::_mm_move_epi64 fn">_mm_move_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回 vector，其中从 <code>a</code> 提取低位元素，其高位元素为零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_move_sd.html" title="core::arch::x86::_mm_move_sd fn">_mm_move_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>构造 <code>[2 x double]</code> 的 128 位浮点 vector。下层
将 64 位设置为第二个参数的低 64 位。上层
将 64 位设置为第一个参数的高 64 位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_move_ss.html" title="core::arch::x86::_mm_move_ss fn">_mm_move_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>返回 <code>__m128</code>，其中第一个组件来自 <code>b</code>，其余组件来自 <code>a</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_movedup_pd.html" title="core::arch::x86::_mm_movedup_pd fn">_mm_movedup_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse3` only"><code>sse3</code></span><p>从 <code>a</code> 复制低双精度 (64-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_movehdup_ps.html" title="core::arch::x86::_mm_movehdup_ps fn">_mm_movehdup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse3` only"><code>sse3</code></span><p><code>a</code> 中重复的奇数索引单精度 (32-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_movehl_ps.html" title="core::arch::x86::_mm_movehl_ps fn">_mm_movehl_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>合并 <code>a</code> 和 <code>b</code> 的上半部分。<code>b</code> 的上半部分占据结果的下半部分。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_moveldup_ps.html" title="core::arch::x86::_mm_moveldup_ps fn">_mm_moveldup_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse3` only"><code>sse3</code></span><p><code>a</code> 中重复的偶数索引单精度 (32-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_movelh_ps.html" title="core::arch::x86::_mm_movelh_ps fn">_mm_movelh_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>合并 <code>a</code> 和 <code>b</code> 的下半部分。<code>b</code> 的下半部分占据结果的上半部分。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_movemask_epi8.html" title="core::arch::x86::_mm_movemask_epi8 fn">_mm_movemask_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回 <code>a</code> 中每个元素的最高有效位的掩码。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_movemask_pd.html" title="core::arch::x86::_mm_movemask_pd fn">_mm_movemask_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回 <code>a</code> 中每个元素的最高有效位的掩码。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_movemask_ps.html" title="core::arch::x86::_mm_movemask_ps fn">_mm_movemask_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>返回 <code>a</code> 中每个元素的最高有效位的掩码。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_mpsadbw_epu8.html" title="core::arch::x86::_mm_mpsadbw_epu8 fn">_mm_mpsadbw_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>减去 8 位无符号整数值，然后将差的绝对值计算为目标中的相应位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_mul_epi32.html" title="core::arch::x86::_mm_mul_epi32 fn">_mm_mul_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>将 <code>a</code> 和 <code>b</code> 中每个包装的 64 位元素的低 32 位整数相乘，并返回带符号的 64 位结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_mul_epu32.html" title="core::arch::x86::_mm_mul_epu32 fn">_mm_mul_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 和 <code>b</code> 中每个包装的 64 位元素中的低 32 位无符号整数相乘。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_mul_pd.html" title="core::arch::x86::_mm_mul_pd fn">_mm_mul_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素相乘。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_mul_ps.html" title="core::arch::x86::_mm_mul_ps fn">_mm_mul_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>乘以 __m128 vectors。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_mul_sd.html" title="core::arch::x86::_mm_mul_sd fn">_mm_mul_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回一个新的 vector，其中 <code>a</code> 的低位元素被 <code>a</code> 和 <code>b</code> 的低位元素相乘。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_mul_ss.html" title="core::arch::x86::_mm_mul_ss fn">_mm_mul_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>将 <code>a</code> 和 <code>b</code> 的第一个组件相乘，然后从 <code>a</code> 复制其他组件。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_mulhi_epi16.html" title="core::arch::x86::_mm_mulhi_epi16 fn">_mm_mulhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装的 16 位整数相乘。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_mulhi_epu16.html" title="core::arch::x86::_mm_mulhi_epu16 fn">_mm_mulhi_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 和 <code>b</code> 中包装的无符号 16 位整数相乘。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_mulhrs_epi16.html" title="core::arch::x86::_mm_mulhrs_epi16 fn">_mm_mulhrs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span><p>将包装的 16 位带符号整数值相乘，通过右移将 32 位乘积截断为 18 个最高有效位，通过加 1 舍入舍入后的值，并将 <code>[16:1]</code> 位写入目标位置。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_mullo_epi16.html" title="core::arch::x86::_mm_mullo_epi16 fn">_mm_mullo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 和 <code>b</code> 中的包装的 16 位整数相乘。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_mullo_epi32.html" title="core::arch::x86::_mm_mullo_epi32 fn">_mm_mullo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>将 <code>a</code> 和 <code>b</code> 中包装的 32 位整数相乘，产生中间值
64 位整数，并返回最低的 32 位 (无论它们是什么)，都将重新解释为有符号整数。
虽然 <code>pmulld __m128i::splat(2), __m128i::splat(2)</code> 返回明显的 <code>__m128i::splat(4)</code>，但由于包装算术，<code>pmulld __m128i::splat(i32::MAX), __m128i::splat(2)</code> 将返回负数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_or_pd.html" title="core::arch::x86::_mm_or_pd fn">_mm_or_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>计算 <code>a</code> 和 <code>b</code> 的按位或。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_or_ps.html" title="core::arch::x86::_mm_or_ps fn">_mm_or_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>包装的单精度 (32-bit) 浮点元素的按位或。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_or_si128.html" title="core::arch::x86::_mm_or_si128 fn">_mm_or_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>计算 <code>a</code> 和 <code>b</code> 中 128 位 (表示整数数据) 的按位或。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_packs_epi16.html" title="core::arch::x86::_mm_packs_epi16 fn">_mm_packs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>使用带符号的饱和度将包装的 16 位整数从 <code>a</code> 和 <code>b</code> 转换为包装的 8 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_packs_epi32.html" title="core::arch::x86::_mm_packs_epi32 fn">_mm_packs_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>使用带符号的饱和度将包装的 32 位整数从 <code>a</code> 和 <code>b</code> 转换为包装的 16 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_packus_epi16.html" title="core::arch::x86::_mm_packus_epi16 fn">_mm_packus_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>使用无符号饱和度将 <code>a</code> 和 <code>b</code> 的包装的 16 位整数转换为包装的 8 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_packus_epi32.html" title="core::arch::x86::_mm_packus_epi32 fn">_mm_packus_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>使用无符号饱和度将包装的 32 位整数从 <code>a</code> 和 <code>b</code> 转换为包装的 16 位整数</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_pause.html" title="core::arch::x86::_mm_pause fn">_mm_pause</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><p>向处理器提示代码序列是自旋等待循环。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_permute_pd.html" title="core::arch::x86::_mm_permute_pd fn">_mm_permute_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx,sse2` only"><code>avx,sse2</code></span><p>使用 <code>imm8</code> 中的控件对 <code>a</code> 中的双精度 (64-bit) 浮点元素进行混洗。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_permute_ps.html" title="core::arch::x86::_mm_permute_ps fn">_mm_permute_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx,sse` only"><code>avx,sse</code></span><p>使用 <code>imm8</code> 中的控件对 <code>a</code> 中的单精度 (32-bit) 浮点元素进行混洗。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_permutevar_pd.html" title="core::arch::x86::_mm_permutevar_pd fn">_mm_permutevar_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用 <code>b</code> 中的控件对 <code>a</code> 中的双精度 (64-bit) 浮点元素进行混洗。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_permutevar_ps.html" title="core::arch::x86::_mm_permutevar_ps fn">_mm_permutevar_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>使用 <code>b</code> 中的控件对 <code>a</code> 中的单精度 (32-bit) 浮点元素进行混洗。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_prefetch.html" title="core::arch::x86::_mm_prefetch fn">_mm_prefetch</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>使用给定的 <code>STRATEGY</code> 获取包含地址 <code>p</code> 的缓存行。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_rcp_ps.html" title="core::arch::x86::_mm_rcp_ps fn">_mm_rcp_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>返回 <code>a</code> 中包装的单精度 (32-bit) 浮点元素的近似倒数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_rcp_ss.html" title="core::arch::x86::_mm_rcp_ss fn">_mm_rcp_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>返回 <code>a</code> 中第一个单精度 (32-bit) 浮点元素的近似倒数，其他元素不变。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_round_pd.html" title="core::arch::x86::_mm_round_pd fn">_mm_round_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>使用 <code>ROUNDING</code> 参数将 <code>a</code> 中的包装的双精度 (64-bit) 浮点元素舍入，并将结果存储为包装的双精度浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_round_ps.html" title="core::arch::x86::_mm_round_ps fn">_mm_round_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>使用 <code>ROUNDING</code> 参数将 <code>a</code> 中的包装的单精度 (32-bit) 浮点元素舍入，并将结果存储为包装的单精度浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_round_sd.html" title="core::arch::x86::_mm_round_sd fn">_mm_round_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>使用 <code>ROUNDING</code> 参数将 <code>b</code> 中的低位双精度浮点元素 (64-bit) 舍入，将结果作为双精度浮点元素存储在内部结果的低位元素中，并将高位元素从 <code>a</code> 复制到高位元素的内在结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_round_ss.html" title="core::arch::x86::_mm_round_ss fn">_mm_round_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>使用 <code>ROUNDING</code> 参数将 <code>b</code> 中的低位单精度 (32-bit) 浮点元素四舍五入，将结果作为单精度浮点元素存储在内部结果的低位元素中，并将高 3 个包装的元素从 <code>a</code> 复制到内在结果的上层元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_rsqrt_ps.html" title="core::arch::x86::_mm_rsqrt_ps fn">_mm_rsqrt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>返回 <code>a</code> 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_rsqrt_ss.html" title="core::arch::x86::_mm_rsqrt_ss fn">_mm_rsqrt_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>返回 <code>a</code> 中第一个单精度 (32-bit) 浮点元素的近似倒数平方根，其他元素不变。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sad_epu8.html" title="core::arch::x86::_mm_sad_epu8 fn">_mm_sad_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>包装无符号 8 位整数的绝对差之和。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_set1_epi8.html" title="core::arch::x86::_mm_set1_epi8 fn">_mm_set1_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>向所有元素广播 8 位整数 <code>a</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_set1_epi16.html" title="core::arch::x86::_mm_set1_epi16 fn">_mm_set1_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>向所有元素广播 16 位整数 <code>a</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_set1_epi32.html" title="core::arch::x86::_mm_set1_epi32 fn">_mm_set1_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>向所有元素广播 32 位整数 <code>a</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_set1_epi64x.html" title="core::arch::x86::_mm_set1_epi64x fn">_mm_set1_epi64x</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>向所有元素广播 64 位整数 <code>a</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_set1_pd.html" title="core::arch::x86::_mm_set1_pd fn">_mm_set1_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>向返回值的所有元素广播双精度 (64-bit) 浮点值 a。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_set1_ps.html" title="core::arch::x86::_mm_set1_ps fn">_mm_set1_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>创建一个 <code>__m128</code>，并将所有元素设置为 <code>a</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_set_epi8.html" title="core::arch::x86::_mm_set_epi8 fn">_mm_set_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>使用提供的值设置包装的 8 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_set_epi16.html" title="core::arch::x86::_mm_set_epi16 fn">_mm_set_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>使用提供的值设置包装的 16 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_set_epi32.html" title="core::arch::x86::_mm_set_epi32 fn">_mm_set_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>使用提供的值设置包装的 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_set_epi64x.html" title="core::arch::x86::_mm_set_epi64x fn">_mm_set_epi64x</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>使用提供的值 (从最高到最低) 设置包装的 64 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_set_pd.html" title="core::arch::x86::_mm_set_pd fn">_mm_set_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>使用提供的值在返回值中设置包装的双精度 (64-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_set_pd1.html" title="core::arch::x86::_mm_set_pd1 fn">_mm_set_pd1</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>向返回值的所有元素广播双精度 (64-bit) 浮点值 a。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_set_ps.html" title="core::arch::x86::_mm_set_ps fn">_mm_set_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>从最高到最低的四个浮点值构造 <code>__m128</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_set_ps1.html" title="core::arch::x86::_mm_set_ps1 fn">_mm_set_ps1</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p><a href="fn._mm_set1_ps.html"><code>_mm_set1_ps</code></a> 的别名</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_set_sd.html" title="core::arch::x86::_mm_set_sd fn">_mm_set_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将双精度 (64-bit) 浮点元素 <code>a</code> 复制到包装的 64 位返回值的低位元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_set_ss.html" title="core::arch::x86::_mm_set_ss fn">_mm_set_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>创建一个 <code>__m128</code>，将最低元素设置为 <code>a</code>，将剩余部分设置为零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_setcsr.html" title="core::arch::x86::_mm_setcsr fn">_mm_setcsr</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>用 32 位无符号整数值设置 MXCSR 寄存器。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_setr_epi8.html" title="core::arch::x86::_mm_setr_epi8 fn">_mm_setr_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>以相反的顺序设置提供的值的包装 8 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_setr_epi16.html" title="core::arch::x86::_mm_setr_epi16 fn">_mm_setr_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>以相反的顺序设置提供的值的包装 16 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_setr_epi32.html" title="core::arch::x86::_mm_setr_epi32 fn">_mm_setr_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>以相反的顺序设置提供的值的包装 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_setr_pd.html" title="core::arch::x86::_mm_setr_pd fn">_mm_setr_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>在返回值中设置包装的双精度 (64-bit) 浮点元素，并以相反的顺序提供提供的值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_setr_ps.html" title="core::arch::x86::_mm_setr_ps fn">_mm_setr_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>从四个最低到最高的浮点值构造 <code>__m128</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_setzero_pd.html" title="core::arch::x86::_mm_setzero_pd fn">_mm_setzero_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回全零的包装的双精度 (64-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_setzero_ps.html" title="core::arch::x86::_mm_setzero_ps fn">_mm_setzero_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>创建一个 <code>__m128</code>，并将所有元素初始化为零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_setzero_si128.html" title="core::arch::x86::_mm_setzero_si128 fn">_mm_setzero_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回所有元素均设置为零的 vector。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sfence.html" title="core::arch::x86::_mm_sfence fn">_mm_sfence</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>对在此指令之前发出的所有存储到内存指令执行序列化操作。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sha1msg1_epu32.html" title="core::arch::x86::_mm_sha1msg1_epu32 fn">_mm_sha1msg1_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sha` only"><code>sha</code></span><p>使用来自 <code>a</code> 和 <code>b</code> 的先前消息值，对接下来的四个 SHA1 消息值 (无符号的 32 位整数) 执行中间计算，并返回结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sha1msg2_epu32.html" title="core::arch::x86::_mm_sha1msg2_epu32 fn">_mm_sha1msg2_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sha` only"><code>sha</code></span><p>使用 <code>a</code> 中的中间结果和 <code>b</code> 中的先前消息值，对接下来的四个 SHA1 消息值 (无符号的 32 位整数) 执行最终计算，并返回结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sha1nexte_epu32.html" title="core::arch::x86::_mm_sha1nexte_epu32 fn">_mm_sha1nexte_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sha` only"><code>sha</code></span><p>经过四轮运算后，从当前 SHA1 状态变量 <code>a</code> 计算 SHA1 状态变量 E，将该值添加到 <code>b</code> 中的计划值 (无符号 32 位整数)，然后返回结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sha1rnds4_epu32.html" title="core::arch::x86::_mm_sha1rnds4_epu32 fn">_mm_sha1rnds4_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sha` only"><code>sha</code></span><p>使用来自 <code>a</code> 的初始 SHA1 状态 (A,B,C,D) 以及接下来的 4 个回合消息值 (一些无符号的 32 位整数) 和来自 <code>b</code> 的状态变量 E 的一些预先计算的总和，执行四轮 SHA1 操作，并返回更新的 SHA1 状态 (A,B,C,D)。
<code>FUNC</code> 包含逻辑函数和舍入常量。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sha256msg1_epu32.html" title="core::arch::x86::_mm_sha256msg1_epu32 fn">_mm_sha256msg1_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sha` only"><code>sha</code></span><p>使用来自 <code>a</code> 和 <code>b</code> 的先前消息值，对接下来的四个 SHA256 消息值 (无符号的 32 位整数) 执行中间计算，并返回结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sha256msg2_epu32.html" title="core::arch::x86::_mm_sha256msg2_epu32 fn">_mm_sha256msg2_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sha` only"><code>sha</code></span><p>使用以前的 <code>a</code> 和 <code>b</code> 的消息值，对接下来的四个 SHA256 消息值 (无符号的 32 位整数) 执行最终计算，并返回结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sha256rnds2_epu32.html" title="core::arch::x86::_mm_sha256rnds2_epu32 fn">_mm_sha256rnds2_epu32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sha` only"><code>sha</code></span><p>使用来自 <code>a</code> 的初始 SHA256 状态 (C,D,G,H)，来自 <code>b</code> 的初始 SHA256 状态 (A,B,E,F) 以及接下来的 2 个回合消息值 (无符号的 32 位整数) 和来自 <code>k</code> 的相应回合常量的预先计算的总和，执行 2 轮 SHA256 操作。，并将更新的 SHA256 状态 (A,B,E,F) 存储在 dst 中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_shuffle_epi8.html" title="core::arch::x86::_mm_shuffle_epi8 fn">_mm_shuffle_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span><p>根据 <code>b</code> 的内容，打乱 <code>a</code> 中的字节。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_shuffle_epi32.html" title="core::arch::x86::_mm_shuffle_epi32 fn">_mm_shuffle_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>使用 <code>IMM8</code> 中的控件在 <code>a</code> 中打乱 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_shuffle_pd.html" title="core::arch::x86::_mm_shuffle_pd fn">_mm_shuffle_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>从两个创建一个 <code>[2 x double]</code> 的 128 位浮点 vector
<code>[2 x double]</code> 的 128 位 vector 参数，使用立即值参数作为说明符。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_shuffle_ps.html" title="core::arch::x86::_mm_shuffle_ps fn">_mm_shuffle_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>使用 <code>MASK</code> 在 <code>a</code> 和 <code>b</code> 中打乱包装的单精度 (32-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_shufflehi_epi16.html" title="core::arch::x86::_mm_shufflehi_epi16 fn">_mm_shufflehi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>使用 <code>IMM8</code> 中的控件在 <code>a</code> 的高 64 位中打乱 16 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_shufflelo_epi16.html" title="core::arch::x86::_mm_shufflelo_epi16 fn">_mm_shufflelo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>使用 <code>IMM8</code> 中的控件在 <code>a</code> 的低 64 位中打乱 16 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sign_epi8.html" title="core::arch::x86::_mm_sign_epi8 fn">_mm_sign_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span><p>当 <code>b</code> 中相应的带符号 8 位整数为负时，对 <code>a</code> 中的 8 位包装整数取反，并返回结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sign_epi16.html" title="core::arch::x86::_mm_sign_epi16 fn">_mm_sign_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span><p>当 <code>b</code> 中相应的带符号 16 位整数为负时，将 <code>a</code> 中的 16 位整数包装为无效，并返回结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sign_epi32.html" title="core::arch::x86::_mm_sign_epi32 fn">_mm_sign_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `ssse3` only"><code>ssse3</code></span><p>当 <code>b</code> 中相应的带符号 32 位整数为负时，对 <code>a</code> 中的包装 32 位整数求反，并返回结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sll_epi16.html" title="core::arch::x86::_mm_sll_epi16 fn">_mm_sll_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>count</code> 左移的 <code>a</code> 中的包装的 16 位整数移位，同时将零移位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sll_epi32.html" title="core::arch::x86::_mm_sll_epi32 fn">_mm_sll_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>count</code> 左移的 <code>a</code> 中的包装的 32 位整数移位，同时将零移位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sll_epi64.html" title="core::arch::x86::_mm_sll_epi64 fn">_mm_sll_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>count</code> 左移的 <code>a</code> 中的包装的 64 位整数移位，同时将零移位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_slli_epi16.html" title="core::arch::x86::_mm_slli_epi16 fn">_mm_slli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 中包装的 16 位整数左移 <code>IMM8</code>，同时将其移入零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_slli_epi32.html" title="core::arch::x86::_mm_slli_epi32 fn">_mm_slli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 中包装的 32 位整数左移 <code>IMM8</code>，同时将其移入零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_slli_epi64.html" title="core::arch::x86::_mm_slli_epi64 fn">_mm_slli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 中包装的 64 位整数左移 <code>IMM8</code>，同时将其移入零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_slli_si128.html" title="core::arch::x86::_mm_slli_si128 fn">_mm_slli_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 左移 <code>IMM8</code> 个字节，同时移入零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sllv_epi32.html" title="core::arch::x86::_mm_sllv_epi32 fn">_mm_sllv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的包装的 32 位整数左移 <code>count</code> 中相应元素所指定的数量，同时将零移位，并返回结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sllv_epi64.html" title="core::arch::x86::_mm_sllv_epi64 fn">_mm_sllv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的包装的 64 位整数左移 <code>count</code> 中相应元素所指定的数量，同时将零移位，并返回结果。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sqrt_pd.html" title="core::arch::x86::_mm_sqrt_pd fn">_mm_sqrt_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回一个新的 vector，它具有 <code>a</code> 中每个值的平方根。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sqrt_ps.html" title="core::arch::x86::_mm_sqrt_ps fn">_mm_sqrt_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>返回 <code>a</code> 中包装的单精度 (32-bit) 浮点元素的平方根。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sqrt_sd.html" title="core::arch::x86::_mm_sqrt_sd fn">_mm_sqrt_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回一个新的 vector，其中 <code>a</code> 的低端元素替换为下部元素 <code>b</code> 的平方根。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sqrt_ss.html" title="core::arch::x86::_mm_sqrt_ss fn">_mm_sqrt_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>返回 <code>a</code> 中第一个单精度 (32-bit) 浮点元素的平方根，其他元素保持不变。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sra_epi16.html" title="core::arch::x86::_mm_sra_epi16 fn">_mm_sra_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将符号位移入时，将 <code>a</code> 中的包装的 16 位整数右移 <code>count</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sra_epi32.html" title="core::arch::x86::_mm_sra_epi32 fn">_mm_sra_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将符号位移位时，将 <code>a</code> 中的包装的 32 位整数右移 <code>count</code>。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_srai_epi16.html" title="core::arch::x86::_mm_srai_epi16 fn">_mm_srai_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 中包装的 16 位整数右移 <code>IMM8</code>，同时移入符号位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_srai_epi32.html" title="core::arch::x86::_mm_srai_epi32 fn">_mm_srai_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 中包装的 32 位整数右移 <code>IMM8</code>，同时移入符号位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_srav_epi32.html" title="core::arch::x86::_mm_srav_epi32 fn">_mm_srav_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的32位整数向右移动，移动量由 <code>count</code> 中的相应元素指定，同时移入符号位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_srl_epi16.html" title="core::arch::x86::_mm_srl_epi16 fn">_mm_srl_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 中的包装的 16 位整数右移 <code>count</code>，同时将零移位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_srl_epi32.html" title="core::arch::x86::_mm_srl_epi32 fn">_mm_srl_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 中的包装的 32 位整数右移 <code>count</code>，同时将零移位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_srl_epi64.html" title="core::arch::x86::_mm_srl_epi64 fn">_mm_srl_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 中的包装的 64 位整数右移 <code>count</code>，同时将零移位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_srli_epi16.html" title="core::arch::x86::_mm_srli_epi16 fn">_mm_srli_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 中包装的 16 位整数右移 <code>IMM8</code>，同时将其移入零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_srli_epi32.html" title="core::arch::x86::_mm_srli_epi32 fn">_mm_srli_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 中包装的 32 位整数右移 <code>IMM8</code>，同时将其移入零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_srli_epi64.html" title="core::arch::x86::_mm_srli_epi64 fn">_mm_srli_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 中包装的 64 位整数右移 <code>IMM8</code>，同时将其移入零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_srli_si128.html" title="core::arch::x86::_mm_srli_si128 fn">_mm_srli_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 右移 <code>IMM8</code> 个字节，同时移入零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_srlv_epi32.html" title="core::arch::x86::_mm_srlv_epi32 fn">_mm_srlv_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的包装的 32 位整数右移 <code>count</code> 中相应元素所指定的数量，同时将零移位，</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_srlv_epi64.html" title="core::arch::x86::_mm_srlv_epi64 fn">_mm_srlv_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx2` only"><code>avx2</code></span><p>将 <code>a</code> 中的包装的 64 位整数右移 <code>count</code> 中相应元素所指定的数量，同时将零移位，</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_store1_pd.html" title="core::arch::x86::_mm_store1_pd fn">_mm_store1_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将来自 <code>a</code> 的较低的双精度 (64-bit) 浮点元素存储到内存中的 2 个连续元素中。
<code>mem_addr</code> 必须对齐
可能会生成 16 字节边界或一般保护异常。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_store1_ps.html" title="core::arch::x86::_mm_store1_ps fn">_mm_store1_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>将 <code>a</code> 的最低 32 位浮点数重复存储四次到 <em>aligned</em> 存储器中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_store_pd.html" title="core::arch::x86::_mm_store_pd fn">_mm_store_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将来自 <code>a</code> 的 128 位 (由 2 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。
<code>mem_addr</code> 必须在 16 字节边界上对齐，否则可能会产生一般保护异常。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_store_pd1.html" title="core::arch::x86::_mm_store_pd1 fn">_mm_store_pd1</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将来自 <code>a</code> 的较低的双精度 (64-bit) 浮点元素存储到内存中的 2 个连续元素中。
<code>mem_addr</code> 必须对齐
可能会生成 16 字节边界或一般保护异常。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_store_ps.html" title="core::arch::x86::_mm_store_ps fn">_mm_store_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>将四个 32 位浮点数存储到 <em>aligned</em> 存储器中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_store_ps1.html" title="core::arch::x86::_mm_store_ps1 fn">_mm_store_ps1</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p><a href="fn._mm_store1_ps.html"><code>_mm_store1_ps</code></a> 的别名</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_store_sd.html" title="core::arch::x86::_mm_store_sd fn">_mm_store_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>[2 x double]</code> 的 128 位 vector 的低 64 位存储到内存位置。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_store_si128.html" title="core::arch::x86::_mm_store_si128 fn">_mm_store_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将来自 <code>a</code> 的 128 位整数数据存储到内存中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_store_ss.html" title="core::arch::x86::_mm_store_ss fn">_mm_store_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>将 <code>a</code> 的最低 32 位浮点数存储到内存中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_storeh_pd.html" title="core::arch::x86::_mm_storeh_pd fn">_mm_storeh_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>[2 x double]</code> 的 128 位 vector 的高 64 位存储到存储位置。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_storel_epi64.html" title="core::arch::x86::_mm_storel_epi64 fn">_mm_storel_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将低 64 位整数 <code>a</code> 存储到内存位置。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_storel_pd.html" title="core::arch::x86::_mm_storel_pd fn">_mm_storel_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>[2 x double]</code> 的 128 位 vector 的低 64 位存储到内存位置。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_storer_pd.html" title="core::arch::x86::_mm_storer_pd fn">_mm_storer_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>a</code> 中的 2 个双精度 (64-bit) 浮点元素以相反的顺序存储到内存中。
<code>mem_addr</code> 必须在 16 字节边界上对齐，否则可能会产生一般保护异常。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_storer_ps.html" title="core::arch::x86::_mm_storer_ps fn">_mm_storer_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>以相反的顺序将四个 32 位浮点数存储到 <em>aligned</em> 存储器中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_storeu_pd.html" title="core::arch::x86::_mm_storeu_pd fn">_mm_storeu_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将来自 <code>a</code> 的 128 位 (由 2 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_storeu_ps.html" title="core::arch::x86::_mm_storeu_ps fn">_mm_storeu_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>将四个 32 位浮点数存储到内存中。内存对齐没有任何限制。
对于对齐的内存，<a href="fn._mm_store_ps.html"><code>_mm_store_ps</code></a> 可能更快。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_storeu_si128.html" title="core::arch::x86::_mm_storeu_si128 fn">_mm_storeu_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将来自 <code>a</code> 的 128 位整数数据存储到内存中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_stream_pd.html" title="core::arch::x86::_mm_stream_pd fn">_mm_stream_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 <code>[2 x double]</code> 的 128 位浮点 vector 存储到 128 位对齐的内存位置。
为了最大程度地减少缓存，数据被标记为非时间性的 (不太可能很快再次使用)。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_stream_ps.html" title="core::arch::x86::_mm_stream_ps fn">_mm_stream_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>使用非临时内存提示将 <code>a</code> 存储到 <code>mem_addr</code> 的内存中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_stream_sd.html" title="core::arch::x86::_mm_stream_sd fn">_mm_stream_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4a` only"><code>sse4a</code></span><p><code>a.0</code> 的非临时存储到 <code>p</code> 中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_stream_si32.html" title="core::arch::x86::_mm_stream_si32 fn">_mm_stream_si32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 32 位整数值存储在指定的内存位置。
为了最大程度地减少缓存，数据被标记为非时间性的 (不太可能很快再次使用)。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_stream_si128.html" title="core::arch::x86::_mm_stream_si128 fn">_mm_stream_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>将 128 位整数 vector 存储到 128 位对齐的内存位置。
为了最大程度地减少缓存，数据被标记为非时间性的 (不太可能很快再次使用)。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_stream_ss.html" title="core::arch::x86::_mm_stream_ss fn">_mm_stream_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4a` only"><code>sse4a</code></span><p><code>a.0</code> 的非临时存储到 <code>p</code> 中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sub_epi8.html" title="core::arch::x86::_mm_sub_epi8 fn">_mm_sub_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>从 <code>a</code> 中的包装的 8 位整数中减去 <code>b</code> 中的包装的 8 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sub_epi16.html" title="core::arch::x86::_mm_sub_epi16 fn">_mm_sub_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>从 <code>a</code> 中的包装的 16 位整数减去 <code>b</code> 中的包装的 16 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sub_epi32.html" title="core::arch::x86::_mm_sub_epi32 fn">_mm_sub_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>从 <code>a</code> 中的包装的 32 位整数中减去 <code>b</code> 中的包装的 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sub_epi64.html" title="core::arch::x86::_mm_sub_epi64 fn">_mm_sub_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>从 <code>a</code> 中的包装的 64 位整数中减去 <code>b</code> 中的包装的 64 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sub_pd.html" title="core::arch::x86::_mm_sub_pd fn">_mm_sub_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>从 <code>a</code> 中减去 <code>b</code> 中的包装的双精度 (64-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sub_ps.html" title="core::arch::x86::_mm_sub_ps fn">_mm_sub_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>减去 __m128 vectors。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sub_sd.html" title="core::arch::x86::_mm_sub_sd fn">_mm_sub_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回一个新的 vector，其中 <code>a</code> 的低端元素被 <code>a</code> 的低端元素减去 <code>b</code> 的低端元素所代替。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_sub_ss.html" title="core::arch::x86::_mm_sub_ss fn">_mm_sub_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>从 <code>a</code> 减去 <code>b</code> 的第一个组件，从 <code>a</code> 复制其他组件。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_subs_epi8.html" title="core::arch::x86::_mm_subs_epi8 fn">_mm_subs_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>使用饱和度从 <code>a</code> 的包装的 8 位整数减去 <code>b</code> 的包装的 8 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_subs_epi16.html" title="core::arch::x86::_mm_subs_epi16 fn">_mm_subs_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>使用饱和度从 <code>a</code> 的包装的 16 位整数减去 <code>b</code> 的包装的 16 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_subs_epu8.html" title="core::arch::x86::_mm_subs_epu8 fn">_mm_subs_epu8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>使用饱和度从 <code>a</code> 中的包装无符号 8 位整数减去 <code>b</code> 中的包装无符号 8 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_subs_epu16.html" title="core::arch::x86::_mm_subs_epu16 fn">_mm_subs_epu16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>使用饱和度从 <code>a</code> 中的包装的无符号 16 位整数减去 <code>b</code> 中的包装的无符号 16 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_test_all_ones.html" title="core::arch::x86::_mm_test_all_ones fn">_mm_test_all_ones</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>测试 <code>a</code> 128 位整数 vector 中的指定位是否全部为 1。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_test_all_zeros.html" title="core::arch::x86::_mm_test_all_zeros fn">_mm_test_all_zeros</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>测试 128 位整数 vector 中的指定位是否全部为零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_test_mix_ones_zeros.html" title="core::arch::x86::_mm_test_mix_ones_zeros fn">_mm_test_mix_ones_zeros</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>测试 128 位整数 vector 中的指定位是否既不是全零也不是全 1。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_testc_pd.html" title="core::arch::x86::_mm_testc_pd fn">_mm_testc_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 和 <code>b</code> 中 128 位 (表示双精度 (64-bit) 浮点元素) 的按位与，产生中间 128 位值，如果中间值中每个 64 位元素的符号位都将 <code>ZF</code> 设置为 1 为零，否则将 <code>ZF</code> 设置为 0。
计算 <code>a</code> 的按位 NOT，然后与 <code>b</code> 进行与运算，得到一个中间值，如果中间值中每个 64 位元素的符号位为零，则将 <code>CF</code> 设置为 1，否则将 <code>CF</code> 设置为 0。
返回 <code>CF</code> 值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_testc_ps.html" title="core::arch::x86::_mm_testc_ps fn">_mm_testc_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 和 <code>b</code> 中 128 位 (代表单精度 (32-bit) 浮点元素) 的 128 位按位与，生成中间 128 位值，如果中间值中每个 32 位元素的符号位都将 <code>ZF</code> 设置为 1 为零，否则将 <code>ZF</code> 设置为 0。
计算 <code>a</code> 的按位非，然后与 <code>b</code> 进行与运算，产生一个中间值，如果中间值中每个 32 位元素的符号位为零，则将 <code>CF</code> 设置为 1，否则将 <code>CF</code> 设置为 0。
返回 <code>CF</code> 值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_testc_si128.html" title="core::arch::x86::_mm_testc_si128 fn">_mm_testc_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>测试 128 位整数 vector 中的指定位是否全部为 1。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_testnzc_pd.html" title="core::arch::x86::_mm_testnzc_pd fn">_mm_testnzc_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 和 <code>b</code> 中 128 位 (表示双精度 (64-bit) 浮点元素) 的按位与，产生中间 128 位值，如果中间值中每个 64 位元素的符号位都将 <code>ZF</code> 设置为 1 为零，否则将 <code>ZF</code> 设置为 0。
计算 <code>a</code> 的按位 NOT，然后与 <code>b</code> 进行与运算，得到一个中间值，如果中间值中每个 64 位元素的符号位为零，则将 <code>CF</code> 设置为 1，否则将 <code>CF</code> 设置为 0。
如果 <code>ZF</code> 和 <code>CF</code> 的值均为零，则返回 1，否则返回 0。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_testnzc_ps.html" title="core::arch::x86::_mm_testnzc_ps fn">_mm_testnzc_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 和 <code>b</code> 中 128 位 (代表单精度 (32-bit) 浮点元素) 的 128 位按位与，生成中间 128 位值，如果中间值中每个 32 位元素的符号位都将 <code>ZF</code> 设置为 1 为零，否则将 <code>ZF</code> 设置为 0。
计算 <code>a</code> 的按位非，然后与 <code>b</code> 进行与运算，产生一个中间值，如果中间值中每个 32 位元素的符号位为零，则将 <code>CF</code> 设置为 1，否则将 <code>CF</code> 设置为 0。
如果 <code>ZF</code> 和 <code>CF</code> 的值均为零，则返回 1，否则返回 0。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_testnzc_si128.html" title="core::arch::x86::_mm_testnzc_si128 fn">_mm_testnzc_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>测试 128 位整数 vector 中的指定位是否既不是全零也不是全 1。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_testz_pd.html" title="core::arch::x86::_mm_testz_pd fn">_mm_testz_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 和 <code>b</code> 中 128 位 (表示双精度 (64-bit) 浮点元素) 的按位与，产生中间 128 位值，如果中间值中每个 64 位元素的符号位都将 <code>ZF</code> 设置为 1 为零，否则将 <code>ZF</code> 设置为 0。
计算 <code>a</code> 的按位 NOT，然后与 <code>b</code> 进行与运算，得到一个中间值，如果中间值中每个 64 位元素的符号位为零，则将 <code>CF</code> 设置为 1，否则将 <code>CF</code> 设置为 0。
返回 <code>ZF</code> 值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_testz_ps.html" title="core::arch::x86::_mm_testz_ps fn">_mm_testz_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `avx` only"><code>avx</code></span><p>计算 <code>a</code> 和 <code>b</code> 中 128 位 (代表单精度 (32-bit) 浮点元素) 的 128 位按位与，生成中间 128 位值，如果中间值中每个 32 位元素的符号位都将 <code>ZF</code> 设置为 1 为零，否则将 <code>ZF</code> 设置为 0。
计算 <code>a</code> 的按位非，然后与 <code>b</code> 进行与运算，产生一个中间值，如果中间值中每个 32 位元素的符号位为零，则将 <code>CF</code> 设置为 1，否则将 <code>CF</code> 设置为 0。
返回 <code>ZF</code> 值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_testz_si128.html" title="core::arch::x86::_mm_testz_si128 fn">_mm_testz_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse4.1` only"><code>sse4.1</code></span><p>测试 128 位整数 vector 中的指定位是否全部为零。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_tzcnt_32.html" title="core::arch::x86::_mm_tzcnt_32 fn">_mm_tzcnt_32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `bmi1` only"><code>bmi1</code></span><p>计算尾随的最低有效零位的数量。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_ucomieq_sd.html" title="core::arch::x86::_mm_ucomieq_sd fn">_mm_ucomieq_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 的下部元素是否相等。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_ucomieq_ss.html" title="core::arch::x86::_mm_ucomieq_ss fn">_mm_ucomieq_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较 <code>a</code> 和 <code>b</code> 的低位的两个 32 位浮点数。
如果相等则返回 <code>1</code>，否则返回 <code>0</code>。
如果任一参数是安静的 NaN，则该指令不会发出异常信号。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_ucomige_sd.html" title="core::arch::x86::_mm_ucomige_sd fn">_mm_ucomige_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 的下限元素是否大于等于。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_ucomige_ss.html" title="core::arch::x86::_mm_ucomige_ss fn">_mm_ucomige_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较 <code>a</code> 和 <code>b</code> 的低位的两个 32 位浮点数。
如果 <code>a</code> 中的值大于或等于 <code>b</code> 中的值，则返回 <code>1</code>，否则返回 <code>0</code>。
如果任一参数是安静的 NaN，则该指令不会发出异常信号。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_ucomigt_sd.html" title="core::arch::x86::_mm_ucomigt_sd fn">_mm_ucomigt_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 的下限元素是否大于。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_ucomigt_ss.html" title="core::arch::x86::_mm_ucomigt_ss fn">_mm_ucomigt_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较 <code>a</code> 和 <code>b</code> 的低位的两个 32 位浮点数。
如果 <code>a</code> 中的值大于 <code>b</code> 中的值，则返回 <code>1</code>，否则返回 <code>0</code>。
如果任一参数是安静的 NaN，则该指令不会发出异常信号。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_ucomile_sd.html" title="core::arch::x86::_mm_ucomile_sd fn">_mm_ucomile_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 的下限元素是否等于或小于等于。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_ucomile_ss.html" title="core::arch::x86::_mm_ucomile_ss fn">_mm_ucomile_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较 <code>a</code> 和 <code>b</code> 的低位的两个 32 位浮点数。
如果 <code>a</code> 中的值小于或等于 <code>b</code> 中的值，则返回 <code>1</code>，否则返回 <code>0</code>。
如果任一参数是安静的 NaN，则该指令不会发出异常信号。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_ucomilt_sd.html" title="core::arch::x86::_mm_ucomilt_sd fn">_mm_ucomilt_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 的下限元素小于。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_ucomilt_ss.html" title="core::arch::x86::_mm_ucomilt_ss fn">_mm_ucomilt_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较 <code>a</code> 和 <code>b</code> 的低位的两个 32 位浮点数。
如果 <code>a</code> 中的值小于 <code>b</code> 中的值，则返回 <code>1</code>，否则返回 <code>0</code>。
如果任一参数是安静的 NaN，则该指令不会发出异常信号。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_ucomineq_sd.html" title="core::arch::x86::_mm_ucomineq_sd fn">_mm_ucomineq_sd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>比较 <code>a</code> 和 <code>b</code> 的下部元素是否相等。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_ucomineq_ss.html" title="core::arch::x86::_mm_ucomineq_ss fn">_mm_ucomineq_ss</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>比较 <code>a</code> 和 <code>b</code> 的低位的两个 32 位浮点数。
如果它们不相等，则返回 <code>1</code>，否则返回 <code>0</code>。
如果任一参数是安静的 NaN，则该指令不会发出异常信号。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_undefined_pd.html" title="core::arch::x86::_mm_undefined_pd fn">_mm_undefined_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回带有未定义元素的 __m128d 类型的 vector。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_undefined_ps.html" title="core::arch::x86::_mm_undefined_ps fn">_mm_undefined_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>返回类型为 __m128 的 vector，其中包含未定义的元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_undefined_si128.html" title="core::arch::x86::_mm_undefined_si128 fn">_mm_undefined_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>返回带有未定义元素的 __m128i 类型的 vector。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_unpackhi_epi8.html" title="core::arch::x86::_mm_unpackhi_epi8 fn">_mm_unpackhi_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>从 <code>a</code> 和 <code>b</code> 的高半部分解包并交织 8 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_unpackhi_epi16.html" title="core::arch::x86::_mm_unpackhi_epi16 fn">_mm_unpackhi_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>从 <code>a</code> 和 <code>b</code> 的高半部分解包并交织 16 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_unpackhi_epi32.html" title="core::arch::x86::_mm_unpackhi_epi32 fn">_mm_unpackhi_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>从 <code>a</code> 和 <code>b</code> 的高半部分解包并交织 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_unpackhi_epi64.html" title="core::arch::x86::_mm_unpackhi_epi64 fn">_mm_unpackhi_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>从 <code>a</code> 和 <code>b</code> 的高半部分解包并交织 64 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_unpackhi_pd.html" title="core::arch::x86::_mm_unpackhi_pd fn">_mm_unpackhi_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>所得的 <code>__m128d</code> 元素由两个 <code>__m128d</code> 交错输入元素的低阶值组成，即:</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_unpackhi_ps.html" title="core::arch::x86::_mm_unpackhi_ps fn">_mm_unpackhi_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>从 <code>a</code> 和 <code>b</code> 的上半部分解包并交织单精度 (32-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_unpacklo_epi8.html" title="core::arch::x86::_mm_unpacklo_epi8 fn">_mm_unpacklo_epi8</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>从 <code>a</code> 和 <code>b</code> 的下半部分解包并交织 8 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_unpacklo_epi16.html" title="core::arch::x86::_mm_unpacklo_epi16 fn">_mm_unpacklo_epi16</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>从 <code>a</code> 和 <code>b</code> 的下半部分解包并交织 16 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_unpacklo_epi32.html" title="core::arch::x86::_mm_unpacklo_epi32 fn">_mm_unpacklo_epi32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>从 <code>a</code> 和 <code>b</code> 的下半部分解包并交织 32 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_unpacklo_epi64.html" title="core::arch::x86::_mm_unpacklo_epi64 fn">_mm_unpacklo_epi64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>从 <code>a</code> 和 <code>b</code> 的下半部分解包并交织 64 位整数。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_unpacklo_pd.html" title="core::arch::x86::_mm_unpacklo_pd fn">_mm_unpacklo_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>所得的 <code>__m128d</code> 元素由两个 <code>__m128d</code> 交错输入元素的高阶值组成，即:</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_unpacklo_ps.html" title="core::arch::x86::_mm_unpacklo_ps fn">_mm_unpacklo_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>从 <code>a</code> 和 <code>b</code> 的下半部分解包并交织单精度 (32-bit) 浮点元素。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_xor_pd.html" title="core::arch::x86::_mm_xor_pd fn">_mm_xor_pd</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>计算 <code>a</code> 和 <code>b</code> 的按位或。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_xor_ps.html" title="core::arch::x86::_mm_xor_ps fn">_mm_xor_ps</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse` only"><code>sse</code></span><p>包装的单精度 (32-bit) 浮点元素的按位异或。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mm_xor_si128.html" title="core::arch::x86::_mm_xor_si128 fn">_mm_xor_si128</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `sse2` only"><code>sse2</code></span><p>计算 <code>a</code> 和 <code>b</code> 中 128 位 (表示整数数据) 的按位 XOR。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._mulx_u32.html" title="core::arch::x86::_mulx_u32 fn">_mulx_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `bmi2` only"><code>bmi2</code></span><p>无符号乘法，且不影响标志。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._pdep_u32.html" title="core::arch::x86::_pdep_u32 fn">_pdep_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `bmi2` only"><code>bmi2</code></span><p>将 <code>a</code> 的连续低阶位分散到 <code>mask</code> 指定的位置处的结果中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._pext_u32.html" title="core::arch::x86::_pext_u32 fn">_pext_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `bmi2` only"><code>bmi2</code></span><p>将 <code>mask</code> 指定的 <code>x</code> 的位收集到结果的连续低阶位位置。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._popcnt32.html" title="core::arch::x86::_popcnt32 fn">_popcnt32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `popcnt` only"><code>popcnt</code></span><p>计算设置的位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._rdrand16_step.html" title="core::arch::x86::_rdrand16_step fn">_rdrand16_step</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `rdrand` only"><code>rdrand</code></span><p>读取硬件生成的 16 位随机值，并将结果存储在 val 中。
如果生成随机值，则返回 1，否则返回 0。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._rdrand32_step.html" title="core::arch::x86::_rdrand32_step fn">_rdrand32_step</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `rdrand` only"><code>rdrand</code></span><p>读取硬件生成的 32 位随机值，并将结果存储在 val 中。
如果生成随机值，则返回 1，否则返回 0。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._rdseed16_step.html" title="core::arch::x86::_rdseed16_step fn">_rdseed16_step</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `rdseed` only"><code>rdseed</code></span><p>读取符合 NIST SP800-90B 和 SP800-90C 的 16 位随机值，并存储在 val 中。
如果生成随机值，则返回 1，否则返回 0。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._rdseed32_step.html" title="core::arch::x86::_rdseed32_step fn">_rdseed32_step</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `rdseed` only"><code>rdseed</code></span><p>读取符合 NIST SP800-90B 和 SP800-90C 的 32 位随机值，并存储在 val 中。
如果生成随机值，则返回 1，否则返回 0。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._rdtsc.html" title="core::arch::x86::_rdtsc fn">_rdtsc</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><p>读取处理器时间戳计数器的当前值。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._subborrow_u32.html" title="core::arch::x86::_subborrow_u32 fn">_subborrow_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><p>将无符号的 32 位整数 <code>a</code> 和 <code>b</code> 与无符号的 8 位进位 <code>c_in</code> (进位或溢出标志) 相加，并将无符号的 32 位结果存储在 <code>out</code> 中，并返回进位 (进位或溢出标志)。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._t1mskc_u32.html" title="core::arch::x86::_t1mskc_u32 fn">_t1mskc_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span><p>清除 <code>x</code> 的最低有效零以下的所有位，并设置所有其他位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._t1mskc_u64.html" title="core::arch::x86::_t1mskc_u64 fn">_t1mskc_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span><p>清除 <code>x</code> 的最低有效零以下的所有位，并设置所有其他位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._tzcnt_u32.html" title="core::arch::x86::_tzcnt_u32 fn">_tzcnt_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `bmi1` only"><code>bmi1</code></span><p>计算尾随的最低有效零位的数量。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._tzmsk_u32.html" title="core::arch::x86::_tzmsk_u32 fn">_tzmsk_u32</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span><p>将所有位设置为低于 <code>x</code> 的最低有效位，并清除所有其他位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._tzmsk_u64.html" title="core::arch::x86::_tzmsk_u64 fn">_tzmsk_u64</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `tbm` only"><code>tbm</code></span><p>将所有位设置为低于 <code>x</code> 的最低有效位，并清除所有其他位。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._xgetbv.html" title="core::arch::x86::_xgetbv fn">_xgetbv</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `xsave` only"><code>xsave</code></span><p>读取 <code>xcr_no</code> 中指定的扩展控制寄存器 <code>XCR</code> 的内容。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._xrstor.html" title="core::arch::x86::_xrstor fn">_xrstor</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `xsave` only"><code>xsave</code></span><p>使用 <code>mem_addr</code> 内存中存储的状态信息执行已启用处理器状态的全部或部分还原。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._xrstors.html" title="core::arch::x86::_xrstors fn">_xrstors</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `xsave,xsaves` only"><code>xsave,xsaves</code></span><p>使用 <code>mem_addr</code> 内存中存储的状态信息执行已启用处理器状态的全部或部分还原。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._xsave.html" title="core::arch::x86::_xsave fn">_xsave</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `xsave` only"><code>xsave</code></span><p>将已启用的处理器状态全部或部分保存到 <code>mem_addr</code> 的内存中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._xsavec.html" title="core::arch::x86::_xsavec fn">_xsavec</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `xsave,xsavec` only"><code>xsave,xsavec</code></span><p>将已启用的处理器状态全部或部分保存到 <code>mem_addr</code> 的内存中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._xsaveopt.html" title="core::arch::x86::_xsaveopt fn">_xsaveopt</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `xsave,xsaveopt` only"><code>xsave,xsaveopt</code></span><p>将已启用的处理器状态全部或部分保存到 <code>mem_addr</code> 的内存中。</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._xsaves.html" title="core::arch::x86::_xsaves fn">_xsaves</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `xsave,xsaves` only"><code>xsave,xsaves</code></span><p>将启用的处理器状态全部或部分保存到以下位置的内存中:
<code>mem_addr</code></p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn._xsetbv.html" title="core::arch::x86::_xsetbv fn">_xsetbv</a><a title="unsafe function" href="#"><sup>⚠</sup></a></td><td class="docblock-short"><span class="stab portability" title="This is supported with target feature `xsave` only"><code>xsave</code></span><p>从 <code>val</code> 复制 64 位到 <code>a</code> 指定的扩展控制寄存器 (<code>XCR</code>)。</p>
</td></tr></table><h2 id="types" class="section-header"><a href="#types">Type Definitions</a></h2>
<table><tr class="unstable module-item"><td><a class="type" href="type._MM_CMPINT_ENUM.html" title="core::arch::x86::_MM_CMPINT_ENUM type">_MM_CMPINT_ENUM</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p><code>_MM_CMPINT_ENUM</code> 类型用于在 AVX-512 内联函数中指定比较操作。</p>
</td></tr><tr class="unstable module-item"><td><a class="type" href="type._MM_MANTISSA_NORM_ENUM.html" title="core::arch::x86::_MM_MANTISSA_NORM_ENUM type">_MM_MANTISSA_NORM_ENUM</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p><code>MM_MANTISSA_NORM_ENUM</code> 类型用于指定 AVX-512 内联函数中的尾数归一化操作。</p>
</td></tr><tr class="unstable module-item"><td><a class="type" href="type._MM_MANTISSA_SIGN_ENUM.html" title="core::arch::x86::_MM_MANTISSA_SIGN_ENUM type">_MM_MANTISSA_SIGN_ENUM</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p><code>MM_MANTISSA_SIGN_ENUM</code> 类型用于指定 AVX-512 内联函数中的尾数签名操作。</p>
</td></tr><tr class="unstable module-item"><td><a class="type" href="type._MM_PERM_ENUM.html" title="core::arch::x86::_MM_PERM_ENUM type">_MM_PERM_ENUM</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p><code>MM_PERM_ENUM</code> 类型用于在 AVX-512 内联函数中指定重排操作。</p>
</td></tr><tr class="unstable module-item"><td><a class="type" href="type.__mmask8.html" title="core::arch::x86::__mmask8 type">__mmask8</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>AVX-512 内联函数中使用的 <code>__mmask8</code> 类型，一个 8 位整数</p>
</td></tr><tr class="unstable module-item"><td><a class="type" href="type.__mmask16.html" title="core::arch::x86::__mmask16 type">__mmask16</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>AVX-512 内联函数中使用的 <code>__mmask16</code> 类型，一个 16 位整数</p>
</td></tr><tr class="unstable module-item"><td><a class="type" href="type.__mmask32.html" title="core::arch::x86::__mmask32 type">__mmask32</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>AVX-512 内联函数中使用的 <code>__mmask32</code> 类型，一个 32 位整数</p>
</td></tr><tr class="unstable module-item"><td><a class="type" href="type.__mmask64.html" title="core::arch::x86::__mmask64 type">__mmask64</a></td><td class="docblock-short"><span class="stab unstable" title="">Experimental</span><p>AVX-512 内联函数中使用的 <code>__mmask64</code> 类型，一个 64 位整数</p>
</td></tr></table></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="core" data-search-index-js="../../../search-index1.55.0.js" data-search-js="../../../search1.55.0.js"></div><script src="../../../main1.55.0.js"></script></body></html>