initSidebarItems({"constant":[["_CMP_EQ_OQ","相等 (有序，无信号)"],["_CMP_EQ_OS","相等 (有序，发信号)"],["_CMP_EQ_UQ","相等 (无序，无信号)"],["_CMP_EQ_US","相等 (无序，发信号)"],["_CMP_FALSE_OQ","错误 (有序，无信号)"],["_CMP_FALSE_OS","错误 (有序，发信号)"],["_CMP_GE_OQ","大于或等于 (有序，无信号)"],["_CMP_GE_OS","大于或等于 (有序，发信号)"],["_CMP_GT_OQ","大于 (有序，无信号)"],["_CMP_GT_OS","大于 (有序，发信号)"],["_CMP_LE_OQ","小于或等于 (有序，无信号)"],["_CMP_LE_OS","小于或等于 (有序，发信号)"],["_CMP_LT_OQ","小于 (有序，无信号)"],["_CMP_LT_OS","小于 (有序，发信号)"],["_CMP_NEQ_OQ","不相等 (有序，无信号)"],["_CMP_NEQ_OS","不相等 (有序，发信号)"],["_CMP_NEQ_UQ","不相等 (无序，无信号)"],["_CMP_NEQ_US","不相等 (无序，发信号)"],["_CMP_NGE_UQ","不大于等于 (无序，无信号)"],["_CMP_NGE_US","不大于等于 (无序，发信号)"],["_CMP_NGT_UQ","不大于 (无序，无信号)"],["_CMP_NGT_US","不大于 (无序，发信号)"],["_CMP_NLE_UQ","不小于等于 (无序，无信号)"],["_CMP_NLE_US","不小于等于 (无序，发信号)"],["_CMP_NLT_UQ","不少于 (无序，无信号)"],["_CMP_NLT_US","不少于 (无序，发信号)"],["_CMP_ORD_Q","订购 (无信号)"],["_CMP_ORD_S","订购 (发信号)"],["_CMP_TRUE_UQ","真 (无序，无信号)"],["_CMP_TRUE_US","真 (无序，发信号)"],["_CMP_UNORD_Q","无序 (无信号)"],["_CMP_UNORD_S","无序 (发信号)"],["_MM_CMPINT_EQ","Equal"],["_MM_CMPINT_FALSE","False"],["_MM_CMPINT_LE","Less-than-or-equal"],["_MM_CMPINT_LT","Less-than"],["_MM_CMPINT_NE","Not-equal"],["_MM_CMPINT_NLE","不小于等于"],["_MM_CMPINT_NLT","不小于"],["_MM_CMPINT_TRUE","True"],["_MM_EXCEPT_DENORM","请参见 `_mm_setcsr`"],["_MM_EXCEPT_DIV_ZERO","请参见 `_mm_setcsr`"],["_MM_EXCEPT_INEXACT","请参见 `_mm_setcsr`"],["_MM_EXCEPT_INVALID","请参见 `_mm_setcsr`"],["_MM_EXCEPT_MASK","请参见 `_MM_GET_EXCEPTION_STATE`"],["_MM_EXCEPT_OVERFLOW","请参见 `_mm_setcsr`"],["_MM_EXCEPT_UNDERFLOW","请参见 `_mm_setcsr`"],["_MM_FLUSH_ZERO_MASK","请参见 `_MM_GET_FLUSH_ZERO_MODE`"],["_MM_FLUSH_ZERO_OFF","请参见 `_mm_setcsr`"],["_MM_FLUSH_ZERO_ON","请参见 `_mm_setcsr`"],["_MM_FROUND_CEIL","四舍五入，不抑制异常"],["_MM_FROUND_CUR_DIRECTION","使用 MXCSR.RC; 见 `vendor::_MM_SET_ROUNDING_MODE`"],["_MM_FROUND_FLOOR","四舍五入，不抑制异常"],["_MM_FROUND_NEARBYINT","使用 MXCSR.RC 并抑制异常; 见 `vendor::_MM_SET_ROUNDING_MODE`"],["_MM_FROUND_NINT","四舍五入到最接近，不排除异常"],["_MM_FROUND_NO_EXC","抑制异常"],["_MM_FROUND_RAISE_EXC","不要抑制异常"],["_MM_FROUND_RINT","使用 MXCSR.RC 且不抑制异常; see `vendor::_MM_SET_ROUNDING_MODE`"],["_MM_FROUND_TO_NEAREST_INT","四舍五入到最接近的"],["_MM_FROUND_TO_NEG_INF","四舍五入"],["_MM_FROUND_TO_POS_INF","围捕"],["_MM_FROUND_TO_ZERO","truncate"],["_MM_FROUND_TRUNC","截断并且不抑制异常"],["_MM_HINT_ET0","请参见 `_mm_prefetch`。"],["_MM_HINT_ET1","请参见 `_mm_prefetch`。"],["_MM_HINT_NTA","请参见 `_mm_prefetch`。"],["_MM_HINT_T0","请参见 `_mm_prefetch`。"],["_MM_HINT_T1","请参见 `_mm_prefetch`。"],["_MM_HINT_T2","请参见 `_mm_prefetch`。"],["_MM_MANT_NORM_1_2","间隔 [1，2)"],["_MM_MANT_NORM_P5_1","间隔 [0.5，1)"],["_MM_MANT_NORM_P5_2","间隔 [0.5，2)"],["_MM_MANT_NORM_P75_1P5","间隔 [0.75，1.5)"],["_MM_MANT_SIGN_NAN","如果 sign(SRC) =1，则 DEST=NaN"],["_MM_MANT_SIGN_SRC","sign = sign(SRC)"],["_MM_MANT_SIGN_ZERO","sign = 0"],["_MM_MASK_DENORM","请参见 `_mm_setcsr`"],["_MM_MASK_DIV_ZERO","请参见 `_mm_setcsr`"],["_MM_MASK_INEXACT","请参见 `_mm_setcsr`"],["_MM_MASK_INVALID","请参见 `_mm_setcsr`"],["_MM_MASK_MASK","请参见 `_MM_GET_EXCEPTION_MASK`"],["_MM_MASK_OVERFLOW","请参见 `_mm_setcsr`"],["_MM_MASK_UNDERFLOW","请参见 `_mm_setcsr`"],["_MM_PERM_AAAA",""],["_MM_PERM_AAAB",""],["_MM_PERM_AAAC",""],["_MM_PERM_AAAD",""],["_MM_PERM_AABA",""],["_MM_PERM_AABB",""],["_MM_PERM_AABC",""],["_MM_PERM_AABD",""],["_MM_PERM_AACA",""],["_MM_PERM_AACB",""],["_MM_PERM_AACC",""],["_MM_PERM_AACD",""],["_MM_PERM_AADA",""],["_MM_PERM_AADB",""],["_MM_PERM_AADC",""],["_MM_PERM_AADD",""],["_MM_PERM_ABAA",""],["_MM_PERM_ABAB",""],["_MM_PERM_ABAC",""],["_MM_PERM_ABAD",""],["_MM_PERM_ABBA",""],["_MM_PERM_ABBB",""],["_MM_PERM_ABBC",""],["_MM_PERM_ABBD",""],["_MM_PERM_ABCA",""],["_MM_PERM_ABCB",""],["_MM_PERM_ABCC",""],["_MM_PERM_ABCD",""],["_MM_PERM_ABDA",""],["_MM_PERM_ABDB",""],["_MM_PERM_ABDC",""],["_MM_PERM_ABDD",""],["_MM_PERM_ACAA",""],["_MM_PERM_ACAB",""],["_MM_PERM_ACAC",""],["_MM_PERM_ACAD",""],["_MM_PERM_ACBA",""],["_MM_PERM_ACBB",""],["_MM_PERM_ACBC",""],["_MM_PERM_ACBD",""],["_MM_PERM_ACCA",""],["_MM_PERM_ACCB",""],["_MM_PERM_ACCC",""],["_MM_PERM_ACCD",""],["_MM_PERM_ACDA",""],["_MM_PERM_ACDB",""],["_MM_PERM_ACDC",""],["_MM_PERM_ACDD",""],["_MM_PERM_ADAA",""],["_MM_PERM_ADAB",""],["_MM_PERM_ADAC",""],["_MM_PERM_ADAD",""],["_MM_PERM_ADBA",""],["_MM_PERM_ADBB",""],["_MM_PERM_ADBC",""],["_MM_PERM_ADBD",""],["_MM_PERM_ADCA",""],["_MM_PERM_ADCB",""],["_MM_PERM_ADCC",""],["_MM_PERM_ADCD",""],["_MM_PERM_ADDA",""],["_MM_PERM_ADDB",""],["_MM_PERM_ADDC",""],["_MM_PERM_ADDD",""],["_MM_PERM_BAAA",""],["_MM_PERM_BAAB",""],["_MM_PERM_BAAC",""],["_MM_PERM_BAAD",""],["_MM_PERM_BABA",""],["_MM_PERM_BABB",""],["_MM_PERM_BABC",""],["_MM_PERM_BABD",""],["_MM_PERM_BACA",""],["_MM_PERM_BACB",""],["_MM_PERM_BACC",""],["_MM_PERM_BACD",""],["_MM_PERM_BADA",""],["_MM_PERM_BADB",""],["_MM_PERM_BADC",""],["_MM_PERM_BADD",""],["_MM_PERM_BBAA",""],["_MM_PERM_BBAB",""],["_MM_PERM_BBAC",""],["_MM_PERM_BBAD",""],["_MM_PERM_BBBA",""],["_MM_PERM_BBBB",""],["_MM_PERM_BBBC",""],["_MM_PERM_BBBD",""],["_MM_PERM_BBCA",""],["_MM_PERM_BBCB",""],["_MM_PERM_BBCC",""],["_MM_PERM_BBCD",""],["_MM_PERM_BBDA",""],["_MM_PERM_BBDB",""],["_MM_PERM_BBDC",""],["_MM_PERM_BBDD",""],["_MM_PERM_BCAA",""],["_MM_PERM_BCAB",""],["_MM_PERM_BCAC",""],["_MM_PERM_BCAD",""],["_MM_PERM_BCBA",""],["_MM_PERM_BCBB",""],["_MM_PERM_BCBC",""],["_MM_PERM_BCBD",""],["_MM_PERM_BCCA",""],["_MM_PERM_BCCB",""],["_MM_PERM_BCCC",""],["_MM_PERM_BCCD",""],["_MM_PERM_BCDA",""],["_MM_PERM_BCDB",""],["_MM_PERM_BCDC",""],["_MM_PERM_BCDD",""],["_MM_PERM_BDAA",""],["_MM_PERM_BDAB",""],["_MM_PERM_BDAC",""],["_MM_PERM_BDAD",""],["_MM_PERM_BDBA",""],["_MM_PERM_BDBB",""],["_MM_PERM_BDBC",""],["_MM_PERM_BDBD",""],["_MM_PERM_BDCA",""],["_MM_PERM_BDCB",""],["_MM_PERM_BDCC",""],["_MM_PERM_BDCD",""],["_MM_PERM_BDDA",""],["_MM_PERM_BDDB",""],["_MM_PERM_BDDC",""],["_MM_PERM_BDDD",""],["_MM_PERM_CAAA",""],["_MM_PERM_CAAB",""],["_MM_PERM_CAAC",""],["_MM_PERM_CAAD",""],["_MM_PERM_CABA",""],["_MM_PERM_CABB",""],["_MM_PERM_CABC",""],["_MM_PERM_CABD",""],["_MM_PERM_CACA",""],["_MM_PERM_CACB",""],["_MM_PERM_CACC",""],["_MM_PERM_CACD",""],["_MM_PERM_CADA",""],["_MM_PERM_CADB",""],["_MM_PERM_CADC",""],["_MM_PERM_CADD",""],["_MM_PERM_CBAA",""],["_MM_PERM_CBAB",""],["_MM_PERM_CBAC",""],["_MM_PERM_CBAD",""],["_MM_PERM_CBBA",""],["_MM_PERM_CBBB",""],["_MM_PERM_CBBC",""],["_MM_PERM_CBBD",""],["_MM_PERM_CBCA",""],["_MM_PERM_CBCB",""],["_MM_PERM_CBCC",""],["_MM_PERM_CBCD",""],["_MM_PERM_CBDA",""],["_MM_PERM_CBDB",""],["_MM_PERM_CBDC",""],["_MM_PERM_CBDD",""],["_MM_PERM_CCAA",""],["_MM_PERM_CCAB",""],["_MM_PERM_CCAC",""],["_MM_PERM_CCAD",""],["_MM_PERM_CCBA",""],["_MM_PERM_CCBB",""],["_MM_PERM_CCBC",""],["_MM_PERM_CCBD",""],["_MM_PERM_CCCA",""],["_MM_PERM_CCCB",""],["_MM_PERM_CCCC",""],["_MM_PERM_CCCD",""],["_MM_PERM_CCDA",""],["_MM_PERM_CCDB",""],["_MM_PERM_CCDC",""],["_MM_PERM_CCDD",""],["_MM_PERM_CDAA",""],["_MM_PERM_CDAB",""],["_MM_PERM_CDAC",""],["_MM_PERM_CDAD",""],["_MM_PERM_CDBA",""],["_MM_PERM_CDBB",""],["_MM_PERM_CDBC",""],["_MM_PERM_CDBD",""],["_MM_PERM_CDCA",""],["_MM_PERM_CDCB",""],["_MM_PERM_CDCC",""],["_MM_PERM_CDCD",""],["_MM_PERM_CDDA",""],["_MM_PERM_CDDB",""],["_MM_PERM_CDDC",""],["_MM_PERM_CDDD",""],["_MM_PERM_DAAA",""],["_MM_PERM_DAAB",""],["_MM_PERM_DAAC",""],["_MM_PERM_DAAD",""],["_MM_PERM_DABA",""],["_MM_PERM_DABB",""],["_MM_PERM_DABC",""],["_MM_PERM_DABD",""],["_MM_PERM_DACA",""],["_MM_PERM_DACB",""],["_MM_PERM_DACC",""],["_MM_PERM_DACD",""],["_MM_PERM_DADA",""],["_MM_PERM_DADB",""],["_MM_PERM_DADC",""],["_MM_PERM_DADD",""],["_MM_PERM_DBAA",""],["_MM_PERM_DBAB",""],["_MM_PERM_DBAC",""],["_MM_PERM_DBAD",""],["_MM_PERM_DBBA",""],["_MM_PERM_DBBB",""],["_MM_PERM_DBBC",""],["_MM_PERM_DBBD",""],["_MM_PERM_DBCA",""],["_MM_PERM_DBCB",""],["_MM_PERM_DBCC",""],["_MM_PERM_DBCD",""],["_MM_PERM_DBDA",""],["_MM_PERM_DBDB",""],["_MM_PERM_DBDC",""],["_MM_PERM_DBDD",""],["_MM_PERM_DCAA",""],["_MM_PERM_DCAB",""],["_MM_PERM_DCAC",""],["_MM_PERM_DCAD",""],["_MM_PERM_DCBA",""],["_MM_PERM_DCBB",""],["_MM_PERM_DCBC",""],["_MM_PERM_DCBD",""],["_MM_PERM_DCCA",""],["_MM_PERM_DCCB",""],["_MM_PERM_DCCC",""],["_MM_PERM_DCCD",""],["_MM_PERM_DCDA",""],["_MM_PERM_DCDB",""],["_MM_PERM_DCDC",""],["_MM_PERM_DCDD",""],["_MM_PERM_DDAA",""],["_MM_PERM_DDAB",""],["_MM_PERM_DDAC",""],["_MM_PERM_DDAD",""],["_MM_PERM_DDBA",""],["_MM_PERM_DDBB",""],["_MM_PERM_DDBC",""],["_MM_PERM_DDBD",""],["_MM_PERM_DDCA",""],["_MM_PERM_DDCB",""],["_MM_PERM_DDCC",""],["_MM_PERM_DDCD",""],["_MM_PERM_DDDA",""],["_MM_PERM_DDDB",""],["_MM_PERM_DDDC",""],["_MM_PERM_DDDD",""],["_MM_ROUND_DOWN","请参见 `_mm_setcsr`"],["_MM_ROUND_MASK","请参见 `_MM_GET_ROUNDING_MODE`"],["_MM_ROUND_NEAREST","请参见 `_mm_setcsr`"],["_MM_ROUND_TOWARD_ZERO","请参见 `_mm_setcsr`"],["_MM_ROUND_UP","请参见 `_mm_setcsr`"],["_SIDD_BIT_MASK","仅掩码: 返回位掩码"],["_SIDD_CMP_EQUAL_ANY","对于 `a` 中的每个字符，查找它是否在 `b` 中 (默认)"],["_SIDD_CMP_EQUAL_EACH","`a` 和 `b` 定义的字符串相等"],["_SIDD_CMP_EQUAL_ORDERED","在目标中搜索定义的子字符串"],["_SIDD_CMP_RANGES","对于 `a` 中的每个字符，确定是否 `b[0] <= c <= b[1] or b[1] <= c <= b[2]...`"],["_SIDD_LEAST_SIGNIFICANT","仅索引: 返回最低有效位 (默认)"],["_SIDD_MASKED_NEGATIVE_POLARITY","仅在字符串结尾之前取反结果"],["_SIDD_MASKED_POSITIVE_POLARITY","不要在字符串结尾之前取反结果"],["_SIDD_MOST_SIGNIFICANT","仅索引: 返回最高有效位"],["_SIDD_NEGATIVE_POLARITY","取反结果"],["_SIDD_POSITIVE_POLARITY","不取消结果 (默认)"],["_SIDD_SBYTE_OPS","字符串包含带符号的 8 位字符"],["_SIDD_SWORD_OPS","字符串包含无符号的 16 位字符"],["_SIDD_UBYTE_OPS","字符串包含无符号的 8 位字符 (默认)"],["_SIDD_UNIT_MASK","仅掩码: 返回字节掩码"],["_SIDD_UWORD_OPS","字符串包含无符号的 16 位字符"],["_XABORT_CAPACITY","事务终止，因为事务使用了过多的内存。"],["_XABORT_CONFLICT","由于与另一个线程发生内存冲突而导致事务终止。"],["_XABORT_DEBUG","事务由于调试陷阱而终止。"],["_XABORT_EXPLICIT","使用 xabort 显式中止了事务。 传递给 xabort 的参数可用于 `_xabort_code(status)`。"],["_XABORT_NESTED","内部嵌套事务中的事务终止。"],["_XABORT_RETRY","事务重试是可能的。"],["_XBEGIN_STARTED","事务成功开始。"],["_XCR_XFEATURE_ENABLED_MASK","`XFEATURE_ENABLED_MASK` 对于 `XCR`"]],"fn":[["_MM_GET_EXCEPTION_MASK","请参见 `_mm_setcsr`"],["_MM_GET_EXCEPTION_STATE","请参见 `_mm_setcsr`"],["_MM_GET_FLUSH_ZERO_MODE","请参见 `_mm_setcsr`"],["_MM_GET_ROUNDING_MODE","请参见 `_mm_setcsr`"],["_MM_SET_EXCEPTION_MASK","请参见 `_mm_setcsr`"],["_MM_SET_EXCEPTION_STATE","请参见 `_mm_setcsr`"],["_MM_SET_FLUSH_ZERO_MODE","请参见 `_mm_setcsr`"],["_MM_SET_ROUNDING_MODE","请参见 `_mm_setcsr`"],["_MM_SHUFFLE","一个实用程序函数，用于创建与 Intel 重排和置换内联函数一起使用的掩码。"],["_MM_TRANSPOSE4_PS","将由 4 行 __m128 组成的 4x4 矩阵转置到位。"],["__cpuid","请参见 `__cpuid_count`。"],["__cpuid_count","返回给定 `leaf` (`EAX`) 和 `sub_leaf` (`ECX`) 的 `cpuid` 指令的结果。"],["__get_cpuid_max","返回最高支持的 `leaf` (`EAX`) 和子叶 (`ECX`) `cpuid` 值。"],["__rdtscp","读取处理器时间戳计数器和 `IA32_TSC_AUX MSR` 的当前值。"],["_addcarry_u32","将无符号的 32 位整数 `a` 和 `b` 与无符号的 8 位进位 `c_in` (进位标志) 相加，并将无符号的 32 位结果存储在 `out` 中，并返回进位 (进位或溢出标志)。"],["_addcarryx_u32","将无符号的 32 位整数 `a` 和 `b` 与无符号的 8 位进位 `c_in` (进位或溢出标志) 相加，并将无符号的 32 位结果存储在 `out` 中，并返回进位 (进位或溢出标志)。"],["_andn_u32","`a` 和 `b` 的按位逻辑 `AND`。"],["_bextr2_u32","将 `control` 指定的 `a` 的位提取到结果的最低有效位中。"],["_bextr_u32","从 `a` 提取范围为 [start，`start` + `length`) 的位到结果的最低有效位。"],["_bittest","返回由 `p` 寻址的存储器的位置 `b` 中的位。"],["_bittestandcomplement","返回由 `p` 寻址的存储器的位置 `b` 中的位，然后将该位取反。"],["_bittestandreset","返回由 `p` 寻址的存储器的位置 `b` 中的位，然后将该位重置为 `0`。"],["_bittestandset","返回由 `p` 寻址的存储器的位置 `b` 中的位，然后将该位设置为 `1`。"],["_blcfill_u32","清除 `x` 的最低有效零位以下的所有位。"],["_blcfill_u64","清除 `x` 的最低有效零位以下的所有位。"],["_blci_u32","将 `x` 的所有位 (最低有效零位除外) 设置为 1。"],["_blci_u64","将 `x` 的所有位 (最低有效零位除外) 设置为 1。"],["_blcic_u32","设置 `x` 的最低有效零位并清除所有其他位。"],["_blcic_u64","设置 `x` 的最低有效零位并清除所有其他位。"],["_blcmsk_u32","设置 `x` 的最低有效零位，并清除该位上方的所有位。"],["_blcmsk_u64","设置 `x` 的最低有效零位，并清除该位上方的所有位。"],["_blcs_u32","设置 `x` 的最低有效零位。"],["_blcs_u64","设置 `x` 的最低有效零位。"],["_blsfill_u32","将 `x` 的所有位设置在最低有效位以下。"],["_blsfill_u64","将 `x` 的所有位设置在最低有效位以下。"],["_blsi_u32","提取最低位隔离位。"],["_blsic_u32","清除最低有效位并设置所有其他位。"],["_blsic_u64","清除最低有效位并设置所有其他位。"],["_blsmsk_u32","将掩码提高到最低设置位。"],["_blsr_u32","复位 `x` 的最低位。"],["_bswap","返回整数，其字节顺序为 x"],["_bzhi_u32","将 `a` >= `index` 的高位清零。"],["_fxrstor","从以下位置恢复 `XMM`，`MMX`，`MXCSR` 和 `x87` FPU 寄存器 512 字节长，16 字节对齐的内存区域 `mem_addr`。"],["_fxsave","将 `x87` FPU，`MMX` 技术，`XMM` 和 `MXCSR` 寄存器保存到 512 字节长，16 字节对齐的内存区域 `mem_addr`。"],["_kadd_mask32","在 a 和 b 中添加 32 位掩码，并将结果存储在 k 中。"],["_kadd_mask64","在 a 和 b 中添加 64 位掩码，并将结果存储在 k 中。"],["_kand_mask16","计算 16 位掩码 a 和 b 的按位与，并将结果存储在 k 中。"],["_kand_mask32","计算 32 位掩码 a 和 b 的按位与，并将结果存储在 k 中。"],["_kand_mask64","计算 64 位掩码 a 和 b 的按位与，并将结果存储在 k 中。"],["_kandn_mask16","计算 16 位掩码 a 的按位非，然后与 b 计算 AND，并将结果存储在 k 中。"],["_kandn_mask32","计算 32 位掩码 a 的按位非，然后与 b 计算 AND，并将结果存储在 k 中。"],["_kandn_mask64","计算 64 位掩码 a 的按位非，然后与 b 进行与运算，并将结果存储在 k 中。"],["_knot_mask16","计算 16 位掩码 a 的按位非，并将结果存储在 k 中。"],["_knot_mask32","计算 32 位掩码 a 的按位非，并将结果存储在 k 中。"],["_knot_mask64","计算 64 位掩码 a 的按位非，并将结果存储在 k 中。"],["_kor_mask16","计算 16 位掩码 a 和 b 的按位或，并将结果存储在 k 中。"],["_kor_mask32","计算 32 位掩码 a 和 b 的按位或，并将结果存储在 k 中。"],["_kor_mask64","计算 64 位掩码 a 和 b 的按位或，并将结果存储在 k 中。"],["_kxnor_mask16","计算 16 位掩码 a 和 b 的按位 XNOR，并将结果存储在 k 中。"],["_kxnor_mask32","计算 32 位掩码 a 和 b 的按位 XNOR，并将结果存储在 k 中。"],["_kxnor_mask64","计算 64 位掩码 a 和 b 的按位 XNOR，并将结果存储在 k 中。"],["_kxor_mask16","计算 16 位掩码 a 和 b 的按位 XOR，并将结果存储在 k 中。"],["_kxor_mask32","计算 32 位掩码 a 和 b 的按位 XOR，并将结果存储在 k 中。"],["_kxor_mask64","计算 64 位掩码 a 和 b 的按位 XOR，并将结果存储在 k 中。"],["_load_mask32","将内存中的 32 位掩码加载到 k 中。"],["_load_mask64","将内存中的 64 位掩码加载到 k 中。"],["_lzcnt_u32","计算前导最高有效零位。"],["_mm256_abs_epi16","计算 `a` 中包装的 16 位整数的绝对值。"],["_mm256_abs_epi32","计算 `a` 中包装的 32 位整数的绝对值。"],["_mm256_abs_epi64","计算 a 中包装的带符号的 64 位整数的绝对值，并将无符号的结果存储在 dst 中。"],["_mm256_abs_epi8","计算 `a` 中包装的 8 位整数的绝对值。"],["_mm256_add_epi16","在 `a` 和 `b` 中添加包装的 16 位整数。"],["_mm256_add_epi32","在 `a` 和 `b` 中添加包装的 32 位整数。"],["_mm256_add_epi64","在 `a` 和 `b` 中添加包装的 64 位整数。"],["_mm256_add_epi8","在 `a` 和 `b` 中添加包装的 8 位整数。"],["_mm256_add_pd","在 `a` 和 `b` 中添加包装的双精度 (64-bit) 浮点元素。"],["_mm256_add_ps","在 `a` 和 `b` 中添加包装的单精度 (32-bit) 浮点元素。"],["_mm256_adds_epi16","使用饱和度在 `a` 和 `b` 中添加包装的 16 位整数。"],["_mm256_adds_epi8","使用饱和度在 `a` 和 `b` 中添加包装的 8 位整数。"],["_mm256_adds_epu16","使用饱和度在 `a` 和 `b` 中添加包装的无符号 16 位整数。"],["_mm256_adds_epu8","使用饱和度在 `a` 和 `b` 中添加包装的无符号 8 位整数。"],["_mm256_addsub_pd","或者，将`a`中的包装双精度（64位）浮点元素与`b`中的包装元素进行加减。"],["_mm256_addsub_ps","或者，将`a`中的包装的单精度（32位）浮点元素与`b`中的包装的元素进行加减。"],["_mm256_aesdec_epi128","使用 `round_key` 中的相应 128 位字 (key) 对 `a` 中的每个 128 位字 (state) 执行一轮 AES 解密流程。"],["_mm256_aesdeclast_epi128","使用 `round_key` 中的相应 128 位字 (key) 对 `a` 中的每个 128 位字 (state) 执行最后一轮 AES 解密流程。"],["_mm256_aesenc_epi128","使用 `round_key` 中的相应 128 位字 (key) 对 `a` 中的每个 128 位字 (state) 执行一轮 AES 加密流程。"],["_mm256_aesenclast_epi128","使用 `round_key` 中的相应 128 位字 (key) 对 `a` 中的每个 128 位字 (state) 执行最后一轮 AES 加密流程。"],["_mm256_alignr_epi32","将 a 和 b 连接成一个 64 字节的 immediate 结果，将结果右移 imm8 个 32 位元素，并将低 32 字节 (8 个元素) 存储在 dst 中。"],["_mm256_alignr_epi64","将 a 和 b 连接成 64 字节的 immediate 结果，将结果右移 imm8 个 64 位元素，并将低 32 字节 (4 个元素) 存储在 dst 中。"],["_mm256_alignr_epi8","将 `a` 和 `b` 中的 16 字节块对连接成一个 32 字节的临时结果，将结果右移 `n` 字节，然后返回低 16 字节。"],["_mm256_and_pd","计算 `a` 和 `b` 中包装的双精度 (64-bit) 浮点元素的按位与。"],["_mm256_and_ps","计算 `a` 和 `b` 中包装的单精度 (32-bit) 浮点元素的按位与。"],["_mm256_and_si256","计算 `a` 和 `b` 中 256 位 (代表整数数据) 的按位与。"],["_mm256_andnot_pd","计算 `a` 中包装的双精度 (64-bit) 浮点元素的按位 NOT，然后计算 `b` 的 AND。"],["_mm256_andnot_ps","计算 `a` 中包装的单精度 (32-bit) 浮点元素的按位非，然后计算 `b` 的 AND。"],["_mm256_andnot_si256","计算 `a` 中 256 位 (代表整数数据) 的按位非，然后计算 `b` 的与。"],["_mm256_avg_epu16","`a` 和 `b` 中的包装无符号 16 位整数的平均值。"],["_mm256_avg_epu8","`a` 和 `b` 中的包装无符号 8 位整数的平均值。"],["_mm256_bitshuffle_epi64_mask","将输入 `b` 视为包装的 64 位整数，并将 `c` 视为包装的 8 位整数。 然后将来自 `c` 的 8 个 8 位值作为索引分组到相应的 64 位整数的位中。 然后，选择这些位并将其包装到输出中。"],["_mm256_blend_epi16","使用控制掩码 `IMM8` 混合包装来自 `a` 和 `b` 的 16 位整数。"],["_mm256_blend_epi32","使用控制掩码 `IMM8` 混合来自 `a` 和 `b` 的包装的 32 位整数。"],["_mm256_blend_pd","使用控制掩码 `imm8` 混合来自 `a` 和 `b` 的包装后的双精度 (64-bit) 浮点元素。"],["_mm256_blend_ps","使用控制掩码 `imm8` 混合来自 `a` 和 `b` 的包装的单精度 (32-bit) 浮点元素。"],["_mm256_blendv_epi8","使用 `mask` 混合来自 `a` 和 `b` 的包装的 8 位整数。"],["_mm256_blendv_pd","使用 `c` 作为掩码，混合来自 `a` 和 `b` 的包装后的双精度 (64-bit) 浮点元素。"],["_mm256_blendv_ps","使用 `c` 作为掩码，混合来自 `a` 和 `b` 的包装的单精度 (32-bit) 浮点元素。"],["_mm256_broadcast_f32x4","从 a 广播 4 个包装的单精度 (32-bit) 浮点元素到 dst 的所有元素。"],["_mm256_broadcast_i32x4","将 4 个包装的 32 位整数从 a 广播到 dst 的所有元素。"],["_mm256_broadcast_pd","将内存中的 128 位 (由 2 个包装的双精度 (64-bit) 浮点元素组成) 广播到返回的 vector 的所有元素。"],["_mm256_broadcast_ps","从内存 (由 4 个包装的单精度 (32-bit) 浮点元素组成) 向广播的 vector 的所有元素广播 128 位。"],["_mm256_broadcast_sd","从内存向返回的 vector 的所有元素广播双精度 (64-bit) 浮点元素。"],["_mm256_broadcast_ss","从内存向返回的 vector 的所有元素广播单精度 (32-bit) 浮点元素。"],["_mm256_broadcastb_epi8","将 `a` 的低位包装 8 位整数广播到 256 位返回值的所有元素。"],["_mm256_broadcastd_epi32","将 `a` 的低位包装 32 位整数广播到 256 位返回值的所有元素。"],["_mm256_broadcastmb_epi64","将输入掩码 k 的低 8 位广播到 dst 的所有 64 位元素。"],["_mm256_broadcastmw_epi32","将输入掩码 k 的低 16 位广播到 dst 的所有 32 位元素。"],["_mm256_broadcastq_epi64","将 `a` 的低位包装 64 位整数广播到 256 位返回值的所有元素。"],["_mm256_broadcastsd_pd","将低双精度 (64-bit) 浮点元素从 `a` 广播到 256 位返回值的所有元素。"],["_mm256_broadcastsi128_si256","从 a 广播 128 位整数数据到 256 位返回值中的所有 128 位通道。"],["_mm256_broadcastss_ps","将低单精度 (32-bit) 浮点元素从 `a` 广播到 256 位返回值的所有元素。"],["_mm256_broadcastw_epi16","将低位包装的 16 位整数从 a 广播到 256 位返回值的所有元素"],["_mm256_bslli_epi128","将 `a` 中的 128 位通道向左移 `imm8` 字节，同时向零移位。"],["_mm256_bsrli_epi128","将 `a` 中的 128 位通道右移 `imm8` 字节，同时将其移位为零。"],["_mm256_castpd128_pd256","将类型 __m128d 的 vector 转换为 __m256d 类型; 结果的高 128 位未定义。"],["_mm256_castpd256_pd128","将类型为 __m256d 的 vector 强制转换为类型为 __m128d 的 vector。"],["_mm256_castpd_ps","将类型为 __m256d 的 vector 强制转换为类型为 __m256 的 vector。"],["_mm256_castpd_si256","将类型为 __m256d 的 vector 强制转换为类型为 __m256i 的 vector。"],["_mm256_castps128_ps256","将类型 __m128 的 vector 转换为 __m256 类型; 结果的高 128 位未定义。"],["_mm256_castps256_ps128","将类型为 __m256 的 vector 强制转换为类型为 __m128 的 vector。"],["_mm256_castps_pd","将类型为 __m256 的 vector 强制转换为类型为 __m256d 的 vector。"],["_mm256_castps_si256","将类型为 __m256 的 vector 强制转换为类型为 __m256i 的 vector。"],["_mm256_castsi128_si256","将类型为 __m128i 的 vector 强制转换为类型 __m256i; 结果的高 128 位未定义。"],["_mm256_castsi256_pd","将类型为 __m256i 的 vector 强制转换为类型为 __m256d 的 vector。"],["_mm256_castsi256_ps","将类型为 __m256i 的 vector 强制转换为类型为 __m256 的 vector。"],["_mm256_castsi256_si128","将类型为 __m256i 的 vector 强制转换为类型为 __m128i 的 vector。"],["_mm256_ceil_pd","将 `a` 中的包装的双精度 (64-bit) 浮点元素四舍五入为正无穷大。"],["_mm256_ceil_ps","将 `a` 中的包装的单精度 (32-bit) 浮点元素四舍五入为正无穷大。"],["_mm256_clmulepi64_epi128","在 2 个 128 位通道中的每个通道中，在有限域 GF(2^k) 上执行两个 64 位多项式的无进位乘法。"],["_mm256_cmp_epi16_mask","根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号 16 位整数，并将结果存储在掩码 vector k 中。"],["_mm256_cmp_epi32_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装有符号 32 位整数，并将结果存储在掩码 vector k 中。"],["_mm256_cmp_epi64_mask","根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 64 位整数，并将结果存储在掩码 vector k 中。"],["_mm256_cmp_epi8_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装带符号 8 位整数，并将结果存储在掩码 vector k 中。"],["_mm256_cmp_epu16_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 16 位整数，并将结果存储在掩码 vector k 中。"],["_mm256_cmp_epu32_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 32 位整数，并将结果存储在掩码 vector k 中。"],["_mm256_cmp_epu64_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 64 位整数，并将结果存储在掩码 vector k 中。"],["_mm256_cmp_epu8_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 8 位整数，并将结果存储在掩码 vector k 中。"],["_mm256_cmp_pd","根据 `IMM5` 指定的比较操作数比较 `a` 和 `b` 中包装的双精度 (64-bit) 浮点元素。"],["_mm256_cmp_pd_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在掩码 vector k 中。"],["_mm256_cmp_ps","根据 `IMM5` 指定的比较操作数比较 `a` 和 `b` 中包装的单精度 (32-bit) 浮点元素。"],["_mm256_cmp_ps_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并将结果存储在掩码 vector k 中。"],["_mm256_cmpeq_epi16","比较 `a` 和 `b` 中的包装的 16 位整数是否相等。"],["_mm256_cmpeq_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm256_cmpeq_epi32","比较 `a` 和 `b` 中的包装 32 位整数是否相等。"],["_mm256_cmpeq_epi32_mask","比较 a 和 b 中包装的 32 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm256_cmpeq_epi64","比较 `a` 和 `b` 中的包装 64 位整数是否相等。"],["_mm256_cmpeq_epi64_mask","比较 a 和 b 中包装的 64 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm256_cmpeq_epi8","比较 `a` 和 `b` 中的包装 8 位整数是否相等。"],["_mm256_cmpeq_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm256_cmpeq_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm256_cmpeq_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm256_cmpeq_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm256_cmpeq_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm256_cmpge_epi16_mask","比较 a 和 b 中包装的带符号 16 位整数是否大于等于，并将结果存储在掩码 vector k 中。"],["_mm256_cmpge_epi32_mask","比较 a 和 b 中包装的带符号 32 位整数是否大于等于，并将结果存储在掩码 vector k 中。"],["_mm256_cmpge_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数是否大于等于，并将结果存储在掩码 vector k 中。"],["_mm256_cmpge_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否大于等于，并将结果存储在掩码 vector k 中。"],["_mm256_cmpge_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否大于等于，并将结果存储在掩码 vector k 中。"],["_mm256_cmpge_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否大于等于，并将结果存储在掩码 vector k 中。"],["_mm256_cmpge_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否大于等于，并将结果存储在掩码 vector k 中。"],["_mm256_cmpge_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否大于等于，并将结果存储在掩码 vector k 中。"],["_mm256_cmpgt_epi16","比较 `a` 和 `b` 中的包装的 16 位整数是否大于。"],["_mm256_cmpgt_epi16_mask","比较 a 和 b 中包装的带符号 16 位整数是否大于，并将结果存储在掩码 vector k 中。"],["_mm256_cmpgt_epi32","比较 `a` 和 `b` 中的包装的 32 位整数是否大于。"],["_mm256_cmpgt_epi32_mask","比较 a 和 b 中包装的带符号的 32 位整数是否大于，并将结果存储在掩码 vector k 中。"],["_mm256_cmpgt_epi64","比较 `a` 和 `b` 中的包装 64 位整数是否大于。"],["_mm256_cmpgt_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数是否大于，并将结果存储在掩码 vector k 中。"],["_mm256_cmpgt_epi8","比较 `a` 和 `b` 中的包装的 8 位整数是否大于。"],["_mm256_cmpgt_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否大于，并将结果存储在掩码 vector k 中。"],["_mm256_cmpgt_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否大于，并将结果存储在掩码 vector k 中。"],["_mm256_cmpgt_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否大于，并将结果存储在掩码 vector k 中。"],["_mm256_cmpgt_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否大于，并将结果存储在掩码 vector k 中。"],["_mm256_cmpgt_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否大于，并将结果存储在掩码 vector k 中。"],["_mm256_cmple_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数 (小于等于)，并将结果存储在掩码 vector k 中。"],["_mm256_cmple_epi32_mask","比较 a 和 b 中包装的带符号的 32 位整数 (小于等于)，并将结果存储在掩码 vector k 中。"],["_mm256_cmple_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数 (小于等于)，并将结果存储在掩码 vector k 中。"],["_mm256_cmple_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数 (小于等于)，并将结果存储在掩码 vector k 中。"],["_mm256_cmple_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否小于等于，并将结果存储在掩码 vector k 中。"],["_mm256_cmple_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否小于等于，并将结果存储在掩码 vector k 中。"],["_mm256_cmple_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否小于等于，并将结果存储在掩码 vector k 中。"],["_mm256_cmple_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数以得出小于或等于的结果，并将结果存储在掩码 vector k 中。"],["_mm256_cmplt_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数 (小于)，并将结果存储在掩码 vector k 中。"],["_mm256_cmplt_epi32_mask","比较 a 和 b 中包装的带符号的 32 位整数 (小于)，并将结果存储在掩码 vector k 中。"],["_mm256_cmplt_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数小于零，并将结果存储在掩码 vector k 中。"],["_mm256_cmplt_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数小于零，并将结果存储在掩码 vector k 中。"],["_mm256_cmplt_epu16_mask","比较 a 和 b 中包装后的无符号 16 位整数 (小于)，并将结果存储在掩码 vector k 中。"],["_mm256_cmplt_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否小于，并将结果存储在掩码 vector k 中。"],["_mm256_cmplt_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否小于，并将结果存储在掩码 vector k 中。"],["_mm256_cmplt_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数以得到小于，并将结果存储在掩码 vector k 中。"],["_mm256_cmpneq_epi16_mask","比较 a 和 b 中包装的带符号 16 位整数是否不相等，并将结果存储在掩码 vector k 中。"],["_mm256_cmpneq_epi32_mask","比较 a 和 b 中包装的 32 位整数是否不相等，并将结果存储在掩码 vector k 中。"],["_mm256_cmpneq_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数是否不相等，并将结果存储在掩码 vector k 中。"],["_mm256_cmpneq_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否不相等，并将结果存储在掩码 vector k 中。"],["_mm256_cmpneq_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否不相等，并将结果存储在掩码 vector k 中。"],["_mm256_cmpneq_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否不相等，并将结果存储在掩码 vector k 中。"],["_mm256_cmpneq_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否不相等，并将结果存储在掩码 vector k 中。"],["_mm256_cmpneq_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm256_conflict_epi32","测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。"],["_mm256_conflict_epi64","测试 a 的每个 64 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。"],["_mm256_cvtepi16_epi32","将 16 位整数符号扩展为 32 位整数。"],["_mm256_cvtepi16_epi64","将 16 位整数符号扩展为 64 位整数。"],["_mm256_cvtepi16_epi8","将 a 中的包装的 16 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。"],["_mm256_cvtepi32_epi16","将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并将结果存储在 dst 中。"],["_mm256_cvtepi32_epi64","将 32 位整数符号扩展为 64 位整数。"],["_mm256_cvtepi32_epi8","将带有 a 的包装的 32 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。"],["_mm256_cvtepi32_pd","将 `a` 中的包装的 32 位整数转换为包装的双精度 (64-bit) 浮点元素。"],["_mm256_cvtepi32_ps","将 `a` 中的包装的 32 位整数转换为包装的单精度 (32-bit) 浮点元素。"],["_mm256_cvtepi64_epi16","将带有 a 的包装的 64 位整数转换为带有截断的包装的 16 位整数，并将结果存储在 dst 中。"],["_mm256_cvtepi64_epi32","将带有 a 的包装的 64 位整数转换为带有截断的包装的 32 位整数，并将结果存储在 dst 中。"],["_mm256_cvtepi64_epi8","将带有 a 的包装的 64 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。"],["_mm256_cvtepi8_epi16","将 8 位整数符号扩展为 16 位整数。"],["_mm256_cvtepi8_epi32","将 8 位整数符号扩展为 32 位整数。"],["_mm256_cvtepi8_epi64","将 8 位整数符号扩展为 64 位整数。"],["_mm256_cvtepu16_epi32","零将 `a` 中的包装的无符号 16 位整数扩展为包装的 32 位整数，并将结果存储在 `dst` 中。"],["_mm256_cvtepu16_epi64","将 `a` 中的低四位无符号 16 位整数零扩展到 64 位整数。 `a` 的前四个元素未使用。"],["_mm256_cvtepu32_epi64","将 `a` 中的无符号 32 位整数零扩展为 64 位整数。"],["_mm256_cvtepu32_pd","将 A 中的包装的无符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm256_cvtepu8_epi16","将 `a` 中的无符号 8 位整数零扩展为 16 位整数。"],["_mm256_cvtepu8_epi32","将 `a` 中的低八位无符号 8 位整数零扩展为 32 位整数。 `a` 的前八个元素未使用。"],["_mm256_cvtepu8_epi64","将 `a` 中的低四位无符号 8 位整数零扩展到 64 位整数。 `a` 的前十二个元素未使用。"],["_mm256_cvtne2ps_pbh","将两个 256 位 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并将结果存入 a"],["_mm256_cvtneps_pbh","将包装在 a 中的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并将结果存储在 dst 中。 Intel’s documentation"],["_mm256_cvtpd_epi32","将 `a` 中的包装的双精度 (64-bit) 浮点元素转换为包装的 32 位整数。"],["_mm256_cvtpd_epu32","将包装的双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并将结果存储在 dst 中。"],["_mm256_cvtpd_ps","将 `a` 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素。"],["_mm256_cvtph_ps","将 128 位 vector `a` 中的 8 x 16 位半精度浮点值转换为存储在 256 位宽 vector 中的 8 x 32 位浮点值。"],["_mm256_cvtps_epi32","将 `a` 中的包装的单精度 (32-bit) 浮点元素转换为包装的 32 位整数。"],["_mm256_cvtps_epu32","将包装的单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并将结果存储在 dst 中。"],["_mm256_cvtps_pd","将 `a` 中的包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素。"],["_mm256_cvtps_ph","将 256 位 vector `a` 中的 8 x 32 位浮点值转换为 8 x 16 位半精度浮点值存储在 128 位宽的 vector 中。"],["_mm256_cvtsd_f64","返回 `[4 x double]` 的输入 vector 的第一个元素。"],["_mm256_cvtsepi16_epi8","将 A 中的包装有符号 16 位整数转换为带符号饱和的包装 8 位整数，并将结果存储在 dst 中。"],["_mm256_cvtsepi32_epi16","将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并将结果存储在 dst 中。"],["_mm256_cvtsepi32_epi8","将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并将结果存储在 dst 中。"],["_mm256_cvtsepi64_epi16","将包装的带符号的 64 位整数转换为带符号饱和的包装的 16 位整数，并将结果存储在 dst 中。"],["_mm256_cvtsepi64_epi32","将包装的带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并将结果存储在 dst 中。"],["_mm256_cvtsepi64_epi8","将包装的带符号的 64 位整数转换为带符号饱和的包装的 8 位整数，并将结果存储在 dst 中。"],["_mm256_cvtsi256_si32","返回 `[8 x i32]` 的输入 vector 的第一个元素。"],["_mm256_cvtss_f32","返回 `[8 x float]` 的输入 vector 的第一个元素。"],["_mm256_cvttpd_epi32","将 `a` 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数。"],["_mm256_cvttpd_epu32","将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并将结果存储在 dst 中。"],["_mm256_cvttps_epi32","将 `a` 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数。"],["_mm256_cvttps_epu32","将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并将结果存储在 dst 中。"],["_mm256_cvtusepi16_epi8","将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。"],["_mm256_cvtusepi32_epi16","将 A 中的包装无符号 32 位整数转换为具有无符号饱和度的包装无符号 16 位整数，并将结果存储在 dst 中。"],["_mm256_cvtusepi32_epi8","将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。"],["_mm256_cvtusepi64_epi16","将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并将结果存储在 dst 中。"],["_mm256_cvtusepi64_epi32","将 A 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并将结果存储在 dst 中。"],["_mm256_cvtusepi64_epi8","将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。"],["_mm256_dbsad_epu8","计算 a 中与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs)，并将 16 位结果存储在 dst 中。对于每个 64 位通道，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中通道的低 8 位四元组，而后两个 SAD 使用 a 中通道的较高 8 位四元组。根据 imm8 中的控件，从 128 位通道中选择 b 中的四元组，并且每个 64 位通道中的每个 SAD 使用 8 位偏移量的选定四元组。"],["_mm256_div_pd","计算 `a` 中的 4 个包装的 64 位浮点元素中的每一个除以 `b` 中相应的封装元素的除法。"],["_mm256_div_ps","计算 `a` 中的 8 个包装的 32 位浮点元素中的每一个除以 `b` 中相应的封装元素的除法。"],["_mm256_dp_ps","使用 `imm8` 的高 4 位有条件地将 `a` 和 `b` 中的包装的单精度 (32-bit) 浮点元素相乘，对四个乘积求和，并使用 `imm8` 的低 4 位有条件地返回总和。"],["_mm256_dpbf16_ps","计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间单精度 (32-bit) 浮点元素与 src 中的元素相加，并将结果存储在 dst 中。"],["_mm256_dpbusd_epi32","将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果存入 dst。"],["_mm256_dpbusds_epi32","将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。使用有符号饱和将这 4 个结果与 src 中相应的 32 位整数相加，并将包装的 32 位结果存储在 dst 中。"],["_mm256_dpwssd_epi32","将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果存入 dst。"],["_mm256_dpwssds_epi32","将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并将包装的 32 位结果存储在 dst 中。"],["_mm256_extract_epi16","从 `a` 中提取一个 16 位整数，用 `INDEX` 选择。 返回包含零扩展整数数据的 32 位整数。 See LLVM commit D20468."],["_mm256_extract_epi32","从 `a` 中提取一个 32 位整数，用 `INDEX` 选择。"],["_mm256_extract_epi8","从 `a` 中提取一个 8 位整数，用 `INDEX` 选择。 返回包含零扩展整数数据的 32 位整数。 See LLVM commit D20468."],["_mm256_extractf128_pd","从 `a` 提取 128 位 (由 2 个包装的双精度 (64-bit) 浮点元素组成)，并使用 `imm8` 进行选择。"],["_mm256_extractf128_ps","从 `a` 提取 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并用 `imm8` 选择。"],["_mm256_extractf128_si256","从 `a` 中提取 128 位 (由整数数据组成)，并用 `imm8` 选择。"],["_mm256_extractf32x4_ps","从 a 提取 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并用 imm8 进行选择，并将结果存储在 dst 中。"],["_mm256_extracti128_si256","从 `IMM1` 选择的 `a` 中提取 128 位 (整数数据)。"],["_mm256_extracti32x4_epi32","从 a 中提取 128 位 (由 4 个包装的 32 位整数组成)，用 IMM1 选中，结果存入 dst。"],["_mm256_fixupimm_pd","使用 c 中的包装的 64 位整数修复 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。imm8 用于设置所需的标志报告。"],["_mm256_fixupimm_ps","使用 c 中的包装 32 位整数修复 a 和 b 中包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。imm8 用于设置所需的标志报告。"],["_mm256_floor_pd","将 `a` 中的包装的双精度 (64-bit) 浮点元素四舍五入为负无穷大。"],["_mm256_floor_ps","将 `a` 中的包装的单精度 (32-bit) 浮点元素四舍五入为负无穷大。"],["_mm256_fmadd_pd","将 `a` 和 `b` 中的包装的双精度 (64-bit) 浮点元素相乘，并将中间结果与 `c` 中的包装的元素相加。"],["_mm256_fmadd_ps","将 `a` 和 `b` 中的包装单精度 (32-bit) 浮点元素相乘，并将中间结果添加到 `c` 中的包装元素中。"],["_mm256_fmaddsub_pd","将 `a` 和 `b` 中的包装的双精度 (64-bit) 浮点元素相乘，或者在 `c` to/from 中将包装的元素相加或减去中间结果。"],["_mm256_fmaddsub_ps","将 `a` 和 `b` 中包装的单精度 (32-bit) 浮点元素相乘，或者将 `c` 中包装的元素加/减到中间结果中。"],["_mm256_fmsub_pd","将 `a` 和 `b` 中的包装的双精度 (64-bit) 浮点元素相乘，并从中间结果中减去 `c` 中的包装的双精度元素。"],["_mm256_fmsub_ps","将 `a` 和 `b` 中的包装的单精度 (32-bit) 浮点元素相乘，并从中间结果中减去 `c` 中的包装元素。"],["_mm256_fmsubadd_pd","将 `a` 和 `b` 中的包装的双精度 (64-bit) 浮点元素相乘，也可以从中间结果中减去或加上 `c` 中的包装元素。"],["_mm256_fmsubadd_ps","将 `a` 和 `b` 中的包装单精度 (32-bit) 浮点元素相乘，或者将 `c` 中的包装元素从中间结果中减去或加上。"],["_mm256_fnmadd_pd","将 `a` 和 `b` 中的包装双精度 (64-bit) 浮点元素相乘，然后将取反的中间结果添加到 `c` 中的包装元素中。"],["_mm256_fnmadd_ps","将 `a` 和 `b` 中的包装单精度 (32-bit) 浮点元素相乘，并将取反的中间结果添加到 `c` 中的包装元素中。"],["_mm256_fnmsub_pd","将 `a` 和 `b` 中的包装的双精度 (64-bit) 浮点元素相乘，并从取反的中间结果中减去 `c` 中的包装的元素。"],["_mm256_fnmsub_ps","将 `a` 和 `b` 中的包装的单精度 (32-bit) 浮点元素相乘，并从取反的中间结果中减去 `c` 中的包装的元素。"],["_mm256_getexp_pd","将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并将结果存储在 dst 中。本质上，此内联函数为每个元素计算 floor(log2(x))。"],["_mm256_getexp_ps","将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，并将结果存储在 dst 中。本质上，此内联函数为每个元素计算 floor(log2(x))。"],["_mm256_getmant_pd","将 a 中的包装的双精度 (64-bit) 浮点元素的尾数规格化，并将结果存储在 dst 中。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1"],["_mm256_getmant_ps","将 a 中的包装的单精度 (32-bit) 浮点元素的尾数标准化，并将结果存储在 dst 中。 此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) The sign is determined by sc which can take the following values:"],["_mm256_gf2p8affine_epi64_epi8","对 x 中的包装字节执行仿射变换。 也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。"],["_mm256_gf2p8affineinv_epi64_epi8","对 x 中的反向包装的字节执行仿射变换。 也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。"],["_mm256_gf2p8mul_epi8","在包装的字节上执行 GF(2^8) 乘法。 该字段以多项式表示，具有约数多项式 x^8 + x^4 + x^3 + x + 1。"],["_mm256_hadd_epi16","在 `a` 和 `b` 中水平添加相邻的 16 位整数对。"],["_mm256_hadd_epi32","在 `a` 和 `b` 中水平添加相邻的 32 位整数对。"],["_mm256_hadd_pd","在 4 个 64 位浮点 `a` 和 `b` 的两个包装的 vectors 中水平相加相邻对。 结果，来自 `a` 的元素之和在偶数位置返回，而来自 `b` 的元素之和在奇数位置返回。"],["_mm256_hadd_ps","在 8 个 32 位浮点 `a` 和 `b` 的两个包装的 vectors 中水平相加相邻对。 结果，来自 `a` 的元素之和返回到索引 0、1、4、5 的位置; 而 `b` 中的元素总和是位置"],["_mm256_hadds_epi16","使用饱和度在 `a` 和 `b` 中水平添加相邻的 16 位整数对。"],["_mm256_hsub_epi16","水平减去 `a` 和 `b` 中相邻的 16 位整数对。"],["_mm256_hsub_epi32","水平减去 `a` 和 `b` 中相邻的 32 位整数对。"],["_mm256_hsub_pd","在 4 个 64 位浮点 `a` 和 `b` 的两个包装的 vectors 中对相邻对进行水平减法。 结果，来自 `a` 的元素之和在偶数位置返回，而来自 `b` 的元素之和在奇数位置返回。"],["_mm256_hsub_ps","将 8 个 32 位浮点 `a` 和 `b` 的两个包装的 vectors 中的相邻对进行水平减法。 结果，来自 `a` 的元素之和返回到索引 0、1、4、5 的位置; 而 `b` 中的元素总和是位置"],["_mm256_hsubs_epi16","使用饱和度水平减去 `a` 和 `b` 中相邻的 16 位整数对。"],["_mm256_i32gather_epi32","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。"],["_mm256_i32gather_epi64","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应为 1、2、4 和 8。"],["_mm256_i32gather_pd","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。"],["_mm256_i32gather_ps","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。"],["_mm256_i64gather_epi32","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。"],["_mm256_i64gather_epi64","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。"],["_mm256_i64gather_pd","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。"],["_mm256_i64gather_ps","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。"],["_mm256_insert_epi16","复制 `a` 到结果，并在 `index` 指定的位置将 16 位整数 `i` 插入到 result 中。"],["_mm256_insert_epi32","复制 `a` 到结果，然后在 `index` 指定的位置将 32 位整数 `i` 插入到结果中。"],["_mm256_insert_epi8","复制 `a` 到结果，并在 `index` 指定的位置将 8 位整数 `i` 插入到结果中。"],["_mm256_insertf128_pd","将 `a` 复制到结果中，然后将 `b` 中的 128 位 (由 2 个包装的双精度 (64-bit) 浮点元素组成) 插入 `imm8` 指定的位置的结果中。"],["_mm256_insertf128_ps","将 `a` 复制到结果中，然后将 `b` 中的 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成) 插入 `imm8` 指定的位置的结果中。"],["_mm256_insertf128_si256","复制 `a` 到结果，然后将 `b` 中的 128 位插入到 `imm8` 指定的位置的结果中。"],["_mm256_insertf32x4","将 a 复制到 dst，然后在 x00X 指定的位置将 d 的 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成) 插入 dst。"],["_mm256_inserti128_si256","将 `a` 复制到 `dst`，然后在 `IMM1` 指定的位置插入来自 `b` 的 128 位 (整数数据)。"],["_mm256_inserti32x4","将 a 复制到 dst，然后在 x00X 指定的位置将 d 的 128 位 (由 4 个包装的 32 位整数组成) 插入 dst。"],["_mm256_lddqu_si256","从未对齐的内存中将 256 位整数数据加载到结果中。 当数据越过缓存行边界时，此内联函数可能比 `_mm256_loadu_si256` 更好。"],["_mm256_load_epi32","将 256 位 (由 8 个包装的 32 位整数组成) 从内存加载到 dst 中。mem_addr 必须在 32 字节边界上对齐，否则可能会生成一般保护异常。"],["_mm256_load_epi64","将 256 位 (由 4 个包装的 64 位整数组成) 从内存加载到 dst 中。mem_addr 必须在 32 字节边界上对齐，否则可能会生成一般保护异常。"],["_mm256_load_pd","从内存中将 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成) 加载到结果中。"],["_mm256_load_ps","从内存中将 256 位 (由 8 个包装的单精度 (32-bit) 浮点元素组成) 加载到结果中。"],["_mm256_load_si256","从内存中将 256 位整数数据加载到结果中。 `mem_addr` 必须在 32 字节边界上对齐，否则可能会产生一般保护异常。"],["_mm256_loadu2_m128","从内存中加载两个 128 位值 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并将它们组合为 256 位值。"],["_mm256_loadu2_m128d","从内存中加载两个 128 位值 (由 2 个包装的双精度 (64-bit) 浮点元素组成)，并将它们组合为 256 位值。"],["_mm256_loadu2_m128i","从内存中加载两个 128 位值 (由整数数据组成)，并将它们组合为 256 位值。 `hiaddr` `loaddr` 和 `loaddr` 不需要在任何特定边界上对齐。"],["_mm256_loadu_epi16","将 256 位 (由 16 个包装的 16 位整数组成) 从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。"],["_mm256_loadu_epi32","将 256 位 (由 8 个包装的 32 位整数组成) 从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。"],["_mm256_loadu_epi64","将 256 位 (由 4 个包装的 64 位整数组成) 从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。"],["_mm256_loadu_epi8","将 256 位 (由 32 个包装的 8 位整数组成) 从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。"],["_mm256_loadu_pd","从内存中将 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成) 加载到结果中。"],["_mm256_loadu_ps","从内存中将 256 位 (由 8 个包装的单精度 (32-bit) 浮点元素组成) 加载到结果中。"],["_mm256_loadu_si256","从内存中将 256 位整数数据加载到结果中。 `mem_addr` 不需要在任何特定边界上对齐。"],["_mm256_lzcnt_epi32","计算 a 中每个包装的 32 位整数中前导零位的数目，并将结果存储在 dst 中。"],["_mm256_lzcnt_epi64","计算 a 中每个包装的 64 位整数中前导零位的数目，并将结果存储在 dst 中。"],["_mm256_madd52hi_epu64","将 `b` 和 `c` 的每个 64 位元素中的包装无符号 52 位整数相乘以形成 104 位中间结果。 将中间结果的高 52 位无符号整数与 `a` 中的相应无符号 64 位整数相加，并将结果存储在 `dst` 中。"],["_mm256_madd52lo_epu64","将 `b` 和 `c` 的每个 64 位元素中的包装无符号 52 位整数相乘以形成 104 位中间结果。 将中间结果的低 52 位无符号整数与 `a` 中的相应无符号 64 位整数相加，并将结果存储在 `dst` 中。"],["_mm256_madd_epi16","将 `a` 和 `b` 中包装的带符号的 16 位整数相乘，产生中间的带符号的 32 位整数。 水平添加相邻的中间 32 位整数对。"],["_mm256_maddubs_epi16","将 `a` 中的每个无符号 8 位整数与 `b` 中的相应带符号 8 位整数垂直相乘，生成中间带符号的 16 位整数。 水平相加相邻的中间带符号的 16 位整数对"],["_mm256_mask2_permutex2var_epi16","使用相应的选择器和 idx 中的索引在通道中的 a 和 b 中对 16 位整数进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 idx 复制元素)。"],["_mm256_mask2_permutex2var_epi32","使用相应的选择器和 idx 中的索引在通道中的 a 和 b 中对 32 位整数进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 idx 复制元素)。"],["_mm256_mask2_permutex2var_epi64","使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中随机排列 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 idx 复制元素)。"],["_mm256_mask2_permutex2var_epi8","使用相应的选择器和 idx 中的索引将 a 和 b 中的 8 位整数跨通道打乱，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。"],["_mm256_mask2_permutex2var_pd","使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 idx 复制元素)"],["_mm256_mask2_permutex2var_ps","使用 idx 中的对应选择器和索引在 a 和 b 中的通道中对 a 和 b 中的单精度 (32-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 idx 复制元素)。"],["_mm256_mask3_fmadd_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 c 复制元素)。"],["_mm256_mask3_fmadd_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。"],["_mm256_mask3_fmaddsub_pd","在 a 和 b 中分别乘以包装的单精度 (32-bit) 浮点元素，或者在 to/from 中将中间结果乘以包装的元素加减乘以 x，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 c 复制元素) 放)。"],["_mm256_mask3_fmaddsub_ps","在 a 和 b 中分别乘以包装的单精度 (32-bit) 浮点元素，或者在 to/from 中将中间结果乘以包装的元素加减乘以 x，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 c 复制元素) 放)。"],["_mm256_mask3_fmsub_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。"],["_mm256_mask3_fmsub_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。"],["_mm256_mask3_fmsubadd_pd","将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，并使用 writemask k 将结果存储在 dst 中 (当未使用相应的 mask 位时从 c 复制元素) 放)。"],["_mm256_mask3_fmsubadd_ps","在 a 和 b 中乘以包装的单精度 (32-bit) 浮点元素，或者在中间结果中减去并在 c from/to 中包装的元素相乘，然后使用 writemask k 将结果存储在 dst 中 (当未使用相应的 mask 位时从 c 复制元素) 放)。"],["_mm256_mask3_fnmadd_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 c 复制元素)。"],["_mm256_mask3_fnmadd_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 c 复制)。"],["_mm256_mask3_fnmsub_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 c 复制元素)。"],["_mm256_mask3_fnmsub_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 c 复制元素)。"],["_mm256_mask_abs_epi16","计算 a 中包装的带符号的 16 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_abs_epi32","计算 a 中包装的有符号 32 位整数的绝对值，并使用 writemask k 将无符号结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm256_mask_abs_epi64","计算 a 中包装的带符号的 64 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_abs_epi8","计算 a 中包装的带符号的 8 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_add_epi16","在 a 和 b 中添加包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_add_epi32","在 a 和 b 中添加包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_add_epi64","在 a 和 b 中添加包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_add_epi8","在 a 和 b 中添加包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_add_pd","在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_add_ps","在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_adds_epi16","使用饱和度在 a 和 b 中添加包装的带符号的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_adds_epi8","使用饱和度在 a 和 b 中添加包装的带符号的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_adds_epu16","使用饱和度在 a 和 b 中添加包装的无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_adds_epu8","使用饱和度在 a 和 b 中添加包装的无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_alignr_epi32","将 a 和 b 连接成 64 字节的 immediate 结果，将结果右移 imm8 个 32 位元素，并使用 writemask k 将低 32 字节 (8 个元素) 存储在 dst 中 (当相应的掩码位为没有设置)。"],["_mm256_mask_alignr_epi64","将 a 和 b 连接成 64 字节的 immediate 结果，将结果右移 imm8 个 64 位元素，并使用 writemask k 将低 32 字节 (4 个元素) 存储在 dst 中 (当相应的掩码位为没有设置)。"],["_mm256_mask_alignr_epi8","将 a 和 b 中的 16 字节块对连接成 32 字节的临时结果，将结果右移 imm8 字节，并使用写掩码 k 将低 16 个字节存储在 dst 中 (当相应的掩码位为 1 时，元素从 src 复制没有设置)。"],["_mm256_mask_and_epi32","在包装的 a 和 b 的 32 位整数元素之间执行逐个元素的按位 AND，使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm256_mask_and_epi64","计算 a 和 b 中包装的 64 位整数的按位与，并使用写掩码 k 将结果存储在 dst 中 (如果未设置相应的掩码位，则从 src 复制元素)。"],["_mm256_mask_andnot_epi32","计算 a 中包装的 32 位整数的按位 NOT，然后与 b 计算 AND，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_andnot_epi64","计算 a 中包装的 64 位整数的按位 NOT，然后与 b 计算 AND，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_avg_epu16","将 a 和 b 中包装的无符号 16 位整数进行平均，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_avg_epu8","将 a 和 b 中包装的无符号 8 位整数平均，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_bitshuffle_epi64_mask","将输入 `b` 视为包装的 64 位整数，并将 `c` 视为包装的 8 位整数。 然后将来自 `c` 的 8 个 8 位值作为索引分组到相应的 64 位整数的位中。 然后，选择这些位并将其包装到输出中。"],["_mm256_mask_blend_epi16","使用控制掩码 k 混合来自 a 和 b 的包装的 16 位整数，并将结果存储在 dst 中。"],["_mm256_mask_blend_epi32","使用控制掩码 k 混合 a 和 b 中的包装 32 位整数，并将结果存储在 dst 中。"],["_mm256_mask_blend_epi64","使用控制掩码 k 混合 a 和 b 中的包装 64 位整数，并将结果存储在 dst 中。"],["_mm256_mask_blend_epi8","使用控制掩码 k 混合 a 和 b 中的包装 8 位整数，并将结果存储在 dst 中。"],["_mm256_mask_blend_pd","使用控制掩码 k 混合来自 a 和 b 的包装后的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm256_mask_blend_ps","使用控制掩码 k 混合来自 a 和 b 的包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm256_mask_broadcast_f32x4","使用写掩码 k 将 4 个包装的单精度 (32-bit) 浮点元素从 a 广播到 dst 的所有元素 (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm256_mask_broadcast_i32x4","使用写掩码 k 将 a 的 4 个包装的 32 位整数广播到 dst 的所有元素 (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm256_mask_broadcastb_epi8","使用写掩码 k 将 d 的低包装的 8 位整数广播到 dst 的所有元素 (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm256_mask_broadcastd_epi32","使用写掩码 k 将低包装的 32 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_broadcastq_epi64","使用写掩码 k 将低包装的 64 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_broadcastsd_pd","使用写掩码 k 将低双精度 (64-bit) 浮点型元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。"],["_mm256_mask_broadcastss_ps","使用写掩码 k 将低单精度 (32-bit) 浮点型元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将元素从 src 复制)。"],["_mm256_mask_broadcastw_epi16","使用写掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm256_mask_cmp_epi16_mask","根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmp_epi32_mask","根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 32 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_mask_cmp_epi64_mask","根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_mask_cmp_epi8_mask","根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmp_epu16_mask","根据 imm8 指定的比较操作数比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmp_epu32_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 32 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmp_epu64_mask","根据 imm8 指定的比较操作数比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmp_epu8_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 8 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_mask_cmp_pd_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_mask_cmp_ps_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_mask_cmpeq_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数是否相等，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpeq_epi32_mask","比较 a 和 b 中包装的 32 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_mask_cmpeq_epi64_mask","比较 a 和 b 中包装的 64 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpeq_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpeq_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpeq_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpeq_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpeq_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpge_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpge_epi32_mask","比较 a 和 b 中包装的带符号的 32 位整数是否等于或大于等于，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpge_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpge_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpge_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否大于等于，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpge_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpge_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpge_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpgt_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpgt_epi32_mask","比较 a 和 b 中包装的带符号的 32 位整数是否大于，并将结果使用零掩码 k1 存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpgt_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpgt_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpgt_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpgt_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpgt_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpgt_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmple_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数 (小于或等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_mask_cmple_epi32_mask","比较 a 和 b 中包装的带符号的 32 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmple_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数 (小于等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_mask_cmple_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmple_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmple_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmple_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmple_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmplt_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmplt_epi32_mask","比较 a 和 b 中包装的带符号的 32 位整数 (小于或等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_mask_cmplt_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmplt_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmplt_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数以得到小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmplt_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmplt_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmplt_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpneq_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpneq_epi32_mask","比较 a 和 b 中包装的 32 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpneq_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm256_mask_cmpneq_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_mask_cmpneq_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpneq_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpneq_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_cmpneq_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_mask_compress_epi16","将 a 中的活动 16 位整数 (它们各自的位设置在写掩码 k 中) 连续存储到 dst，并通过 src 中的其余元素。"],["_mm256_mask_compress_epi32","将活动的 32 位整数连续存储在 dst 中 (它们各自的位在写掩码 k 中设置的整数) 到 dst，并通过 src 中的其余元素。"],["_mm256_mask_compress_epi64","将活动的 64 位整数连续存储在 dst 中 (它们各自的位在写掩码 k 中设置的整数) 到 dst，并通过 src 中的其余元素。"],["_mm256_mask_compress_epi8","将 a 中的活动 8 位整数 (它们各自的位设置在写掩码 k 中) 连续存储到 dst，并通过 src 中的其余元素。"],["_mm256_mask_compress_pd","将活动的双精度 (64-bit) 浮点元素连续存储在 dst 中 (它们各自的位在写掩码 k 中设置) 到 dst，并通过 src 中的其余元素。"],["_mm256_mask_compress_ps","将活动的单精度 (32-bit) 浮点元素连续存储在 dst 中 (将其各自的位设置在写掩码 k 中的那些元素中) 存储到 dst，并通过 src 中的其余元素。"],["_mm256_mask_conflict_epi32","使用写掩码 k (在未设置相应的掩码位时从 src 复制元素)，测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。"],["_mm256_mask_conflict_epi64","使用写掩码 k 测试 a 的每个 64 位元素是否与所有其他元素相等 (更接近最低有效位) (当未设置相应的掩码位时，从 src 复制元素)。每个元素的比较在 dst 中形成零扩展位 vector。"],["_mm256_mask_cvt_roundps_ph","将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: (_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常 (_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常 (_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常 (_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常 _MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm256_mask_cvtepi16_epi32","符号将包装后的 16 位整数从 a 扩展为包装后的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvtepi16_epi64","使用符号将包装的 16 位整数从 a 扩展为包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvtepi16_epi8","将带有 a 的包装的 16 位整数转换为带截断的 8 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvtepi16_storeu_epi8","将 a 中的包装的 16 位整数转换为带有截断的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。"],["_mm256_mask_cvtepi32_epi16","将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvtepi32_epi64","使用符号将包装的 32 位整数从 a 扩展为包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvtepi32_epi8","将带有 a 的包装的 32 位整数转换为带截断的包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvtepi32_pd","将 a 中的包装有符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm256_mask_cvtepi32_ps","将 a 中的包装有符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm256_mask_cvtepi32_storeu_epi16","将 a 中的包装的 32 位整数转换为带截断的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm256_mask_cvtepi32_storeu_epi8","将包装的 32 位整数在 a 中转换为带有截断的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。"],["_mm256_mask_cvtepi64_epi16","将 a 中的包装的 64 位整数转换为带截断的 16 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvtepi64_epi32","将 a 中的包装的 64 位整数转换为带截断的 32 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvtepi64_epi8","将 a 中的包装的 64 位整数转换为带有截断的包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvtepi64_storeu_epi16","将 a 中的包装的 64 位整数转换为带截断的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm256_mask_cvtepi64_storeu_epi32","将 a 中的包装的 64 位整数转换为带截断的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm256_mask_cvtepi64_storeu_epi8","将 a 中包装的 64 位整数转换为包装的 8 位整数并截断，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 的未对齐内存中。"],["_mm256_mask_cvtepi8_epi16","使用符号将包装的 8 位整数从 a 扩展为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvtepi8_epi32","符号将包装的 8 位整数从 a 扩展为包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvtepi8_epi64","将 a 的低 4 字节中的 8 位整数符号扩展为包装的 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm256_mask_cvtepu16_epi32","将 a 中的包装无符号 16 位整数零扩展为包装 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvtepu16_epi64","零扩展包装的无符号 16 位整数 a 的低 8 字节到包装的 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm256_mask_cvtepu32_epi64","将 a 中的包装无符号 32 位整数零扩展为包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvtepu32_pd","将 a 中的包装无符号 32 位整数转换为包装双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm256_mask_cvtepu8_epi16","将 a 中的包装无符号 8 位整数零扩展为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvtepu8_epi32","零扩展包装的无符号 8 位整数在 a 的低 8 字节到包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。"],["_mm256_mask_cvtepu8_epi64","零扩展包装的无符号 8 位整数在 a 的低 4 字节到包装的 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。"],["_mm256_mask_cvtne2ps_pbh","将两个 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 writemask k 将结果存储在单个 vector dst 中 (当相应的掩码位为没有设置)。"],["_mm256_mask_cvtneps_pbh","将包装在 a 中的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。"],["_mm256_mask_cvtpd_epi32","将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm256_mask_cvtpd_epu32","将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm256_mask_cvtpd_ps","将 a 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm256_mask_cvtph_ps","将 a 中的包装后的半精度 (16-bit) 浮点元素转换为包装后的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm256_mask_cvtps_epi32","将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm256_mask_cvtps_epu32","将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm256_mask_cvtps_ph","将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm256_mask_cvtsepi16_epi8","将 a 中的包装带符号的 16 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvtsepi16_storeu_epi8","将包装在 a 中的有符号 16 位整数转换为有符号饱和的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。"],["_mm256_mask_cvtsepi32_epi16","将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvtsepi32_epi8","将 a 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvtsepi32_storeu_epi16","将包装在 a 中的有符号 32 位整数转换为具有符号饱和的包装的 16 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。"],["_mm256_mask_cvtsepi32_storeu_epi8","将包装在 a 中的有符号 32 位整数转换为具有符号饱和的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。"],["_mm256_mask_cvtsepi64_epi16","将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvtsepi64_epi32","将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvtsepi64_epi8","将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvtsepi64_storeu_epi16","将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm256_mask_cvtsepi64_storeu_epi32","将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm256_mask_cvtsepi64_storeu_epi8","将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm256_mask_cvttpd_epi32","将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm256_mask_cvttpd_epu32","将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvttps_epi32","将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm256_mask_cvttps_epu32","将 a 中的包装的双精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvtusepi16_epi8","将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvtusepi16_storeu_epi8","将包装在 a 中的无符号 16 位整数转换为具有无符号饱和的包装的无符号 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm256_mask_cvtusepi32_epi16","将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvtusepi32_epi8","将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_cvtusepi32_storeu_epi16","将包装在 a 中的无符号 32 位整数转换为具有无符号饱和的包装的无符号 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm256_mask_cvtusepi32_storeu_epi8","将包装在 a 中的无符号 32 位整数转换为具有无符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm256_mask_cvtusepi64_epi16","将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_cvtusepi64_epi32","将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm256_mask_cvtusepi64_epi8","将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_cvtusepi64_storeu_epi16","将包装在 a 中的无符号 64 位整数转换为具有无符号饱和的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm256_mask_cvtusepi64_storeu_epi32","将包装的无符号 64 位整数在 a 中转换为具有无符号饱和的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm256_mask_cvtusepi64_storeu_epi8","将包装的无符号 64 位整数在 a 中转换为具有无符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 的未对齐内存中。"],["_mm256_mask_dbsad_epu8","计算 a 中的无符号 8 位整数与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs)，并使用写掩码 k 将 16 位结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。对于每个 64 位通道，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中通道的低 8 位四元组，而后两个 SAD 使用 a 中通道的较高 8 位四元组。根据 imm8 中的控件，从 128 位通道中选择 b 中的四元组，并且每个 64 位通道中的每个 SAD 使用 8 位偏移量的选定四元组。"],["_mm256_mask_div_pd","将 a 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_div_ps","将 a 中的包装的单精度 (32-bit) 浮点元素除以 b 中的包装的元素，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_dpbf16_ps","计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间的单精度 (32-bit) 浮点元素与 src 中的元素相加，并使用 writemask k 将结果存储在 dst 中 (当对应的元素从 src 复制时掩码位未设置)。"],["_mm256_mask_dpbusd_epi32","将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (未设置相应掩码位时从 src 复制元素)。"],["_mm256_mask_dpbusds_epi32","将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。使用符号饱和将这 4 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm256_mask_dpwssd_epi32","将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。"],["_mm256_mask_dpwssds_epi32","将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。"],["_mm256_mask_expand_epi16","从 a 加载连续的活动 16 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm256_mask_expand_epi32","从 a 加载连续的有效 32 位整数 (它们各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_expand_epi64","从 a 加载连续的有效 64 位整数 (它们各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_expand_epi8","从 a 加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm256_mask_expand_pd","从 a 加载连续的活动双精度 (64-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_expand_ps","从 a 中加载连续的活动单精度 (32-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm256_mask_extractf32x4_ps","从 a 提取 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并用 imm8 进行选择，并使用写掩码 k 将结果存储在 dst 中 (如果未设置相应的掩码位，则从 src 复制元素)。"],["_mm256_mask_extracti32x4_epi32","从 a 中提取 128 位 (由 4 个包装的 32 位整数组成)，用 IMM1 选中，用 writemask k 将结果存入 dst 中 (未设置相应掩码位时从 src 复制元素)。"],["_mm256_mask_fixupimm_pd","使用 c 中的包装 64 位整数修复 a 和 b 中的包装双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 a 复制元素)。imm8 用于设置所需的标志报告。"],["_mm256_mask_fixupimm_ps","使用 c 中的包装 32 位整数修复 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 a 复制元素)。imm8 用于设置所需的标志报告。"],["_mm256_mask_fmadd_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 a 复制元素)。"],["_mm256_mask_fmadd_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 a 复制元素)。"],["_mm256_mask_fmaddsub_pd","将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 a 中复制元素放)。"],["_mm256_mask_fmaddsub_ps","将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位则从 a 复制元素放)。"],["_mm256_mask_fmsub_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (如果未设置相应的掩码位，则从 a 复制元素)。"],["_mm256_mask_fmsub_ps","将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 a 复制元素)。"],["_mm256_mask_fmsubadd_pd","将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，并使用 writemask k 将结果存储在 dst 中 (当未使用相应的掩码位时，元素将从 a 复制放)。"],["_mm256_mask_fmsubadd_ps","将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 a 复制元素放)。"],["_mm256_mask_fnmadd_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。"],["_mm256_mask_fnmadd_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。"],["_mm256_mask_fnmsub_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。"],["_mm256_mask_fnmsub_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。"],["_mm256_mask_getexp_pd","将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并使用 writemask k 将结果存储在 dst 中 (当相应的 mask 时，元素从 src 复制位未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。"],["_mm256_mask_getexp_ps","将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，并使用 writemask k 将结果存储在 dst 中 (当相应的 mask 时，元素从 src 复制位未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。"],["_mm256_mask_getmant_pd","将 a 中的包装的双精度 (64-bit) 浮点元素的尾数标准化，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1"],["_mm256_mask_getmant_ps","标准化 a 中包装的单精度 (32-bit) 浮点元素的尾数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1"],["_mm256_mask_gf2p8affine_epi64_epi8","对 x 中的包装字节执行仿射变换。 也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。"],["_mm256_mask_gf2p8affineinv_epi64_epi8","对 x 中的反向包装的字节执行仿射变换。 也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。"],["_mm256_mask_gf2p8mul_epi8","在包装的字节上执行 GF(2^8) 乘法。 该字段以多项式表示，具有约数多项式 x^8 + x^4 + x^3 + x + 1。"],["_mm256_mask_i32gather_epi32","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。 如果设置了掩码，请从该位置从 `src` 加载值。"],["_mm256_mask_i32gather_epi64","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。 如果设置了掩码，请从该位置从 `src` 加载值。"],["_mm256_mask_i32gather_pd","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。 如果设置了掩码，请从该位置从 `src` 加载值。"],["_mm256_mask_i32gather_ps","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。 如果设置了掩码，请从该位置从 `src` 加载值。"],["_mm256_mask_i64gather_epi32","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。 如果设置了掩码，请从该位置从 `src` 加载值。"],["_mm256_mask_i64gather_epi64","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。 如果设置了掩码，请从该位置从 `src` 加载值。"],["_mm256_mask_i64gather_pd","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。 如果设置了掩码，请从该位置从 `src` 加载值。"],["_mm256_mask_i64gather_ps","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。 如果设置了掩码，请从该位置从 `src` 加载值。"],["_mm256_mask_insertf32x4","将 a 复制到 tmp，然后在 x00X 指定的位置将 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成) 插入 tmp。使用写掩码 k 将 tmp 存储到 dst (当未设置相应的掩码位时，将从 src 复制元素)。"],["_mm256_mask_inserti32x4","将 a 复制到 tmp，然后在 imm8 指定的位置，将 b 中的 128 位 (由 4 个包装的 32 位整数组成) 插入 tmp。使用写掩码 k 将 tmp 存储到 dst (当未设置相应的掩码位时，将从 src 复制元素)。"],["_mm256_mask_lzcnt_epi32","计算 a 中每个包装的 32 位整数中前导零位的数目，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_lzcnt_epi64","计算 a 中每个包装的 64 位整数中前导零位的数目，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_madd_epi16","在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。水平添加相邻的中间 32 位整数对，并使用 writemask k 将结果打包到 dst (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm256_mask_maddubs_epi16","将 a 中的包装无符号 8 位整数与 b 中的包装有符号 8 位整数相乘，生成中间有符号的 16 位整数。水平相加相邻的中间带符号的 16 位整数对，并使用写掩码 k 将饱和结果包装到 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_max_epi16","比较 a 和 b 中包装的带符号的 16 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_max_epi32","比较 a 和 b 中包装的带符号的 32 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_max_epi64","比较 a 和 b 中包装的带符号的 64 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_max_epi8","比较 a 和 b 中包装的带符号的 8 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_max_epu16","比较 a 和 b 中包装的无符号 16 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_max_epu32","比较 a 和 b 中包装的无符号 32 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_max_epu64","比较 a 和 b 中包装的无符号 64 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_max_epu8","比较 a 和 b 中包装的无符号 8 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_max_pd","比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_max_ps","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_min_epi16","比较 a 和 b 中包装的带符号 16 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_min_epi32","比较 a 和 b 中包装的带符号的 32 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_min_epi64","比较 a 和 b 中包装的带符号的 64 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_min_epi8","比较 a 和 b 中包装的带符号的 8 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_min_epu16","比较 a 和 b 中包装的无符号 16 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_min_epu32","比较 a 和 b 中包装的无符号 32 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_min_epu64","比较 a 和 b 中包装的无符号 64 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_min_epu8","比较 a 和 b 中包装的无符号 8 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_min_pd","比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_min_ps","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_mov_epi16","使用写掩码 k 将包装的 16 位整数从 a 移到 dst (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm256_mask_mov_epi32","使用写掩码 k 将包装的 32 位整数从 a 移动到 dst (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm256_mask_mov_epi64","使用写掩码 k 将包装的 64 位整数从 a 移动到 dst (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm256_mask_mov_epi8","使用写掩码 k 将包装的 8 位整数从 a 移到 dst (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm256_mask_mov_pd","使用写掩码 k 将包装的双精度 (64-bit) 浮点元素从 a 移动到 dst (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm256_mask_mov_ps","使用写掩码 k 将包装的单精度 (32-bit) 浮点元素从 a 移动到 dst (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm256_mask_movedup_pd","从 a 复制偶数索引的双精度 (64-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_movehdup_ps","从 a 复制奇数索引的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_moveldup_ps","从 a 复制偶数索引的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_mul_epi32","将 a 和 b 中每个包装的 64 位元素的低符号 32 位整数相乘，并使用写掩码 k 将有符号的 64 位结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_mul_epu32","将 a 和 b 中每个包装的 64 位元素的低无符号 32 位整数相乘，并使用写掩码 k 将无符号 64 位结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_mul_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_mul_ps","将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_mulhi_epi16","将 a 和 b 中包装的带符号的 16 位整数相乘，生成 32 位中间整数，并使用写掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_mulhi_epu16","将 a 和 b 中包装的无符号 16 位整数相乘，生成 32 位中间整数，并使用写掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_mulhrs_epi16","在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。将每个中间整数截断为 18 个最高有效位，通过加 1 舍入，并使用 writemask k 将位 [16:1] 存储到 dst (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm256_mask_mullo_epi16","将 a 和 b 中的包装的 16 位整数相乘，生成中间的 32 位整数，并使用写掩码 k 将中间整数的低 16 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_mullo_epi32","将 a 和 b 中的包装的 32 位整数相乘，生成中间 64 位整数，并使用写掩码 k 将中间整数的低 32 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_multishift_epi64_epi8","对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并使用 writemask k (元素当相应的屏蔽位未设置时，从 src 复制)。"],["_mm256_mask_or_epi32","计算 a 和 b 中包装的 32 位整数的按位或，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_or_epi64","计算 a 和 b 中包装的 64 位整数的按位或，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_packs_epi16","使用带符号的饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_packs_epi32","使用带符号的饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_packus_epi16","使用无符号饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_packus_epi32","使用无符号饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_permute_pd","使用 imm8 中的控件在 128 位通道内对双精度 (64-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_permute_ps","使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_permutevar_pd","使用 b 中的控件在 128 位通道内将 a 的双精度 (64-bit) 浮点元素进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm256_mask_permutevar_ps","使用 b 中的控件在 128 位通道内将 a 的单精度 (32-bit) 浮点元素打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm256_mask_permutex2var_epi16","使用相应的选择器和 idx 中的索引在通道中的 a 和 b 中对 16 位整数进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。"],["_mm256_mask_permutex2var_epi32","使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中对 32 位整数进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。"],["_mm256_mask_permutex2var_epi64","使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中随机排列 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。"],["_mm256_mask_permutex2var_epi8","使用相应的选择器和 idx 中的索引将 a 和 b 中的 8 位整数跨通道打乱，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。"],["_mm256_mask_permutex2var_pd","使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。"],["_mm256_mask_permutex2var_ps","使用对应的选择器和 idx 中的索引在 a 和 b 中的通道上对 a 和 b 中的单精度 (32-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。"],["_mm256_mask_permutex_epi64","使用 imm8 中的控件在 256 位通道内将 64 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_permutex_pd","使用 imm8 中的控件在 256 位通道内对双精度 (64-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_permutexvar_epi16","使用 idx 中的相应索引在跨通道中对 16 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_permutexvar_epi32","使用 idx 中的相应索引在跨通道中对 32 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_permutexvar_epi64","使用 idx 中的相应索引在跨通道中随机排列 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_permutexvar_epi8","使用 idx 中的相应索引在跨通道的 a 中打乱 8 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm256_mask_permutexvar_pd","使用 idx 中的相应索引对跨通道中的双精度 (64-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm256_mask_permutexvar_ps","使用 idx 中的相应索引对跨通道中的单精度 (32-bit) 浮点元素进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm256_mask_popcnt_epi16","对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm256_mask_popcnt_epi32","对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm256_mask_popcnt_epi64","对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。"],["_mm256_mask_popcnt_epi8","对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm256_mask_rcp14_pd","计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。该近似值的最大相对误差小于 2^-14。"],["_mm256_mask_rcp14_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。该近似值的最大相对误差小于 2^-14。"],["_mm256_mask_rol_epi32","将每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_rol_epi64","将每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_rolv_epi32","将 a 中每个包装的 32 位整数中的位向左旋转 b 对应元素 b 中指定的位数，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 src 复制元素放)。"],["_mm256_mask_rolv_epi64","将 a 中每个包装的 64 位整数中的位向左旋转 b 的对应元素中指定的位数，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 src 复制元素放)。"],["_mm256_mask_ror_epi32","将 X 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_ror_epi64","将 X 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_rorv_epi32","将 a 中每个包装的 32 位整数中的位向右旋转 b 的对应元素中指定的位数，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 src 复制元素放)。"],["_mm256_mask_rorv_epi64","将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 src 复制元素放)。"],["_mm256_mask_roundscale_pd","将 a 中的包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm256_mask_roundscale_ps","将 a 中的包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的小数位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm256_mask_rsqrt14_pd","计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。该近似值的最大相对误差小于 2^-14。"],["_mm256_mask_rsqrt14_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。该近似值的最大相对误差小于 2^-14。"],["_mm256_mask_scalef_pd","使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm256_mask_scalef_ps","使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm256_mask_set1_epi16","使用写掩码 k 向 dst 的所有元素广播 16 位整数 a (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm256_mask_set1_epi32","使用写掩码 k 将 32 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_set1_epi64","使用写掩码 k 将 64 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_set1_epi8","使用写掩码 k 将 8 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_shldi_epi16","在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并使用 writemask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm256_mask_shldi_epi32","将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并使用 writemask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm256_mask_shldi_epi64","在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并使用 writemask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm256_mask_shldv_epi16","在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。"],["_mm256_mask_shldv_epi32","将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。"],["_mm256_mask_shldv_epi64","在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 复制)。"],["_mm256_mask_shrdi_epi16","将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并使用 writemask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm256_mask_shrdi_epi32","连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并使用 writemask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm256_mask_shrdi_epi64","将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并使用 writemask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，元素从 src` 复制)。"],["_mm256_mask_shrdv_epi16","将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。"],["_mm256_mask_shrdv_epi32","连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。"],["_mm256_mask_shrdv_epi64","将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。"],["_mm256_mask_shuffle_epi32","使用 imm8 中的控件将 128 位通道中的 32 位整数随机排列，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_shuffle_epi8","使用 b 中相应的 8 位元素中的控件在 128 位通道内对 a 中的 8 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_shuffle_f32x4","将 imm8 从 a 和 b 中选择的 128 位 (由 4 个单精度 (32-bit) 浮点元素组成) 混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_shuffle_f64x2","将 imm8 从 a 和 b 中选择的 128 位 (由 2 个双精度 (64-bit) 浮点元素组成) 混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_shuffle_i32x4","将 imm8 从 a 和 b 中选择的 128 位 (由 4 个 32 位整数组成) 重排，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_shuffle_i64x2","将 imm8 从 a 和 b 中选择的 128 位 (由 2 个 64 位整数组成) 进行混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm256_mask_shuffle_pd","使用 imm8 中的控件对 128 位通道中的双精度 (64-bit) 浮点元素进行混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_shuffle_ps","使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_shufflehi_epi16","使用 imm8 中的控件在 a 的 128 位通道的高 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的高 64 位中，将 128 位通道的低 64 位从 a 复制到 dst，使用写掩码 k (当相应的掩码位不存在时，元素从 src 复制放)。"],["_mm256_mask_shufflelo_epi16","使用 imm8 中的控件在 a 的 128 位通道的低 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的低 64 位中，并使用写掩码 k 将 128 位通道的高 64 位从 a 复制到 dst (当未使用相应的掩码位时，元素从 src 复制) 放)。"],["_mm256_mask_sll_epi16","将包装的 16 位整数按计数左移，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_sll_epi32","将包装的 32 位整数左移计数，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_sll_epi64","将包装的 64 位整数左移计数，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_slli_epi16","将包装的 16 位整数左移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_slli_epi32","将包装的 32 位整数左移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_slli_epi64","将包装的 64 位整数向左移动 imm8，同时向零移动，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_sllv_epi16","将包装的 16 位整数按 count 中相应元素指定的数量向左移位，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_sllv_epi32","将填充的 32 位整数向左移动计数中相应元素指定的数量，同时将其移位为零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_sllv_epi64","将填充的 64 位整数向左移动 count 中相应元素指定的数量，同时将其移位为零，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm256_mask_sqrt_pd","计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_sqrt_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_sra_epi16","将包装的 16 位整数按计数右移，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_sra_epi32","在移动符号位的同时右移计数包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_sra_epi64","在移动符号位的同时右移计数包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_srai_epi16","将包装的 16 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_srai_epi32","将包装的 32 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_srai_epi64","将包装的 64 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_srav_epi16","将包装的 16 位整数右移 count 中相应元素指定的数量，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_srav_epi32","在将符号位移位的同时，将已包装的 32 位整数向右移动计数中相应元素指定的数量，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_srav_epi64","在移入符号位的同时，将包装的 64 位整数向右移动计数中相应元素指定的数量，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_srl_epi16","将包装的 16 位整数右移，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_srl_epi32","将包装的 32 位整数右移，同时移零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_srl_epi64","将包装的 64 位整数右移，同时移零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_srli_epi16","将包装的 16 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_srli_epi32","将包装的 32 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_srli_epi64","将包装的 64 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_srlv_epi16","将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_srlv_epi32","向右移动包装的 32 位整数整数 (由 count 中相应元素指定的数量)，同时向零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_srlv_epi64","向右移位包装的 64 位整数，其数量为计数中相应元素指定的数量，同时向零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_sub_epi16","从 a 中的包装的 16 位整数中减去 b 中的包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_sub_epi32","从 a 中的包装 32 位整数中减去 b 中的包装 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_sub_epi64","从 a 中的包装 64 位整数中减去 b 中的包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_sub_epi8","从 a 中的包装 8 位整数中减去 b 中的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_sub_pd","从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_sub_ps","将 b 中的包装后的单精度 (32-bit) 浮点元素减去 a 中的包装后的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_subs_epi16","使用饱和度将 b 中的包装 16 位整数减去 b 中的包装有符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_subs_epi8","使用饱和度将 b 中的包装 8 位整数减去 b 中的包装 8 位有符号整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_subs_epu16","使用 a 饱和度从 b 中的包装无符号 16 位整数减去 b 中的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_subs_epu8","使用 a 饱和度将 b 中的包装无符号 8 位整数减去 b 中的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm256_mask_ternarylogic_epi32","提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 32 位整数中的每一位，使用 src、a 和 b 中的相应位形成 imm8 的 3 位索引，并使用 writemask 将 imm8 中该位的值写入 dst 中的相应位 k 在 32 位粒度 (当相应的掩码位未设置时，从 src 复制 32 位元素)。"],["_mm256_mask_ternarylogic_epi64","提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 64 位整数中的每一位，src、a 和 b 中的相应位用于形成 imm8 的 3 位索引，并使用 writemask 将 imm8 中该位的值写入 dst 中的相应位 k 在 64 位粒度 (当相应的掩码位未设置时，从 src 复制 64 位元素)。"],["_mm256_mask_test_epi16_mask","计算 a 和 b 中包装的 16 位整数的按位与，生成中间的 16 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。"],["_mm256_mask_test_epi32_mask","计算 a 和 b 中包装的 32 位整数的按位与，生成中间的 32 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。"],["_mm256_mask_test_epi64_mask","计算 a 和 b 中包装的 64 位整数的按位与，生成中间 64 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。"],["_mm256_mask_test_epi8_mask","计算 a 和 b 中包装的 8 位整数的按位与，生成中间 8 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。"],["_mm256_mask_testn_epi16_mask","计算 a 和 b 中包装的 16 位整数的按位 NAND，生成中间的 16 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。"],["_mm256_mask_testn_epi32_mask","计算 a 和 b 中包装的 32 位整数的按位 NAND，生成中间的 32 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。"],["_mm256_mask_testn_epi64_mask","计算 a 和 b 中包装的 64 位整数的按位 NAND，生成中间 64 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。"],["_mm256_mask_testn_epi8_mask","计算 a 和 b 中包装的 8 位整数的按位 NAND，生成中间的 8 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。"],["_mm256_mask_unpackhi_epi16","从 a 和 b 中每个 128 位通道的高半部分拆包和交织 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm256_mask_unpackhi_epi32","从 a 和 b 中每个 128 位通道的高半部分解包和交织 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm256_mask_unpackhi_epi64","从 a 和 b 中每个 128 位通道的高半部分解包和交织 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_unpackhi_epi8","从 a 和 b 中每个 128 位通道的高半部分拆包和交织 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm256_mask_unpackhi_pd","从 a 和 b 中每个 128 位通道的高半部分解包和交织双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 src 复制元素)。"],["_mm256_mask_unpackhi_ps","从 a 和 b 中每个 128 位通道的高半部分解包和交织单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 src 复制元素)。"],["_mm256_mask_unpacklo_epi16","从 a 和 b 中每个 128 位通道的下半部分拆包和交织 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm256_mask_unpacklo_epi32","从 a 和 b 中每个 128 位通道的下半部分解包和交织 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm256_mask_unpacklo_epi64","从 a 和 b 中每个 128 位通道的下半部分解包和交织 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_unpacklo_epi8","从 a 和 b 中每个 128 位通道的下半部分拆包和交织 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm256_mask_unpacklo_pd","从 a 和 b 中每个 128 位通道的下半部分解包并交织双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 src 复制元素)。"],["_mm256_mask_unpacklo_ps","从 a 和 b 中每个 128 位通道的下半部分解包并交织单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 src 复制元素)。"],["_mm256_mask_xor_epi32","计算 a 和 b 中包装的 32 位整数的按位 XOR，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_mask_xor_epi64","计算 a 和 b 中包装的 64 位整数的按位 XOR，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm256_maskload_epi32","使用 `mask` 从 `mem_addr` 指向的内存中加载包装的 32 位整数 (当未在相应元素中设置最高位时，元素清零)。"],["_mm256_maskload_epi64","使用 `mask` 从 `mem_addr` 指向的内存中加载包装的 64 位整数 (当未在相应元素中设置最高位时，元素清零)。"],["_mm256_maskload_pd","使用 `mask` 将包装的双精度 (64-bit) 浮点元素从内存加载到结果中 (当未设置相应元素的高位时，元素清零)。"],["_mm256_maskload_ps","使用 `mask` 将包装的单精度 (32-bit) 浮点元素从内存加载到结果中 (当未设置相应元素的高位时，元素清零)。"],["_mm256_maskstore_epi32","使用 `mask` 将 `a` 中的包装后的 32 位整数存储到 `mem_addr` 指向的内存中 (当在相应元素中未设置最高位时，不存储元素)。"],["_mm256_maskstore_epi64","使用 `mask` 将 `a` 中的包装 64 位整数存储到 `mem_addr` 指向的内存中 (当未在相应元素中设置最高位时，不存储元素)。"],["_mm256_maskstore_pd","使用 `mask` 将包装的双精度 (64-bit) 浮点元素从 `a` 存储到内存中。"],["_mm256_maskstore_ps","使用 `mask` 将包装的单精度 (32-bit) 浮点元素从 `a` 存储到内存中。"],["_mm256_maskz_abs_epi16","计算 a 中包装的带符号的 16 位整数的绝对值，并使用零掩码 k (将未设置相应掩码位的元素清零) 将无符号结果存储在 dst 中。"],["_mm256_maskz_abs_epi32","计算 a 中包装的有符号 32 位整数的绝对值，并使用 zeromask k 将无符号结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_abs_epi64","计算 a 中包装的带符号的 64 位整数的绝对值，并使用零掩码 k (将未设置相应掩码位的元素清零) 将无符号结果存储在 dst 中。"],["_mm256_maskz_abs_epi8","计算 a 中包装的带符号的 8 位整数的绝对值，并使用零掩码 k 将无符号结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_add_epi16","将包装的 16 位整数添加到 a 和 b 中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_add_epi32","将包装的 32 位整数添加到 a 和 b 中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_add_epi64","在 a 和 b 中添加包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_add_epi8","在 a 和 b 中添加包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_add_pd","在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_add_ps","在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_adds_epi16","使用饱和度在 a 和 b 中添加包装的带符号的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_adds_epi8","使用饱和度在 a 和 b 中添加包装的带符号的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_adds_epu16","使用饱和度在 a 和 b 中添加包装的无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_adds_epu8","使用饱和度在 a 和 b 中添加包装的无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_alignr_epi32","将 a 和 b 连接成一个 64 字节的 immediate 结果，将结果右移 imm8 个 32 位元素，并使用 zeromask k 将低 32 字节 (8 个元素) 存储在 dst 中 (当相应的掩码位不存在时，元素被清零放)。"],["_mm256_maskz_alignr_epi64","将 a 和 b 连接成 64 字节的 immediate 结果，将结果右移 imm8 个 64 位元素，并使用 zeromask k 将低 32 字节 (4 个元素) 存储在 dst 中 (当相应的掩码位不存在时，元素被清零放)。"],["_mm256_maskz_alignr_epi8","将 a 和 b 中的 16 字节块对连接成一个 32 字节的临时结果，将结果右移 imm8 字节，并使用零掩码 k 将低 16 字节存储在 dst 中 (当未使用相应的掩码位时元素清零) 放)。"],["_mm256_maskz_and_epi32","计算 a 和 b 中包装的 32 位整数的按位与，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_and_epi64","计算 a 和 b 中包装的 64 位整数的按位与，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_andnot_epi32","计算 a 中包装的 32 位整数的按位 NOT，然后计算 b 中的 AND，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_andnot_epi64","计算 a 中包装的 64 位整数的按位 NOT，然后与 b 计算 AND，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_avg_epu16","将 a 和 b 中包装的无符号 16 位整数进行平均，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_avg_epu8","将 a 和 b 中包装的无符号 8 位整数进行平均，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_broadcast_f32x4","使用零掩码 k 将 4 个包装的单精度 (32-bit) 浮点元素从 a 广播到 dst 的所有元素 (未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_broadcast_i32x4","使用零掩码 k 将 4 的包装的 32 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm256_maskz_broadcastb_epi8","使用零掩码 k 将低包装的 8 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm256_maskz_broadcastd_epi32","使用零掩码 k 将低包装的 32 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm256_maskz_broadcastq_epi64","使用零掩码 k 将低包装的 64 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm256_maskz_broadcastsd_pd","使用零掩码 k 将低双精度 (64-bit) 浮点元素从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm256_maskz_broadcastss_ps","使用零掩码 k 将低单精度 (32-bit) 浮点元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_broadcastw_epi16","使用零掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm256_maskz_compress_epi16","将 a 中的活动 16 位整数 (它们各自的位设置在 zeromask k 中) 连续存储到 dst，并将其余元素设置为零。"],["_mm256_maskz_compress_epi32","将活动的 32 位整数连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的整数) 为 dst，并将其余元素设置为零。"],["_mm256_maskz_compress_epi64","将活动的 64 位整数连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的整数) 为 dst，并将其余元素设置为零。"],["_mm256_maskz_compress_epi8","将 a 中的活动 8 位整数 (它们各自的位设置在 zeromask k 中) 连续存储到 dst，并将其余元素设置为零。"],["_mm256_maskz_compress_pd","将活动的双精度 (64-bit) 浮点元素连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的那些元素) 为 dst，并将其余元素设置为零。"],["_mm256_maskz_compress_ps","将活动的单精度 (32-bit) 浮点元素连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的那些元素) 为 dst，并将其余元素设置为零。"],["_mm256_maskz_conflict_epi32","使用零掩码 k (在未设置相应的掩码位时将元素清零)，测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。"],["_mm256_maskz_conflict_epi64","使用零掩码 k (在未设置相应的掩码位时将元素清零)，测试 a 的每个 64 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。"],["_mm256_maskz_cvt_roundps_ph","将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: (_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常 (_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常 (_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常 (_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常 _MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm256_maskz_cvtepi16_epi32","符号将包装的 16 位整数从 a 扩展为包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm256_maskz_cvtepi16_epi64","使用符号将包装的 16 位整数从 a 扩展为包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_cvtepi16_epi8","将带有 a 的包装的 16 位整数转换为带截断的 8 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_cvtepi32_epi16","将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_cvtepi32_epi64","使用符号将包装的 32 位整数从 a 扩展为包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_cvtepi32_epi8","将带有 a 的包装的 32 位整数转换为带有截断的包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_cvtepi32_pd","将 a 中的包装有符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm256_maskz_cvtepi32_ps","将 a 中的包装有符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用零掩码 k (未设置相应的掩码位时将元素清零) 将结果存储在 dst 中。"],["_mm256_maskz_cvtepi64_epi16","将带有 a 的包装的 64 位整数转换为带截断的 16 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_cvtepi64_epi32","将 a 中的包装的 64 位整数转换为带截断的 32 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_cvtepi64_epi8","将带有 a 的包装的 64 位整数转换为带截断的 8 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_cvtepi8_epi16","使用符号将包装的 8 位整数从 a 扩展为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm256_maskz_cvtepi8_epi32","使用符号将包装的 8 位整数从 a 扩展为包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_cvtepi8_epi64","将 a 的低 4 字节中的 8 位整数符号扩展为包装的 64 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_cvtepu16_epi32","将 a 中的包装无符号 16 位整数零扩展为包装 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_cvtepu16_epi64","零扩展包装的无符号 16 位整数 a 的低 8 字节到包装的 64 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_cvtepu32_epi64","将 a 中的包装无符号 32 位整数零扩展为包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_cvtepu32_pd","将 a 中的包装无符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_cvtepu8_epi16","将 a 中的包装无符号 8 位整数零扩展为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_cvtepu8_epi32","零扩展包装的无符号 8 位整数 a 的低 8 字节到包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_cvtepu8_epi64","零扩展包装的无符号 8 位整数在 a 的低 4 字节到包装的 64 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_cvtne2ps_pbh","将两个 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在单个 vector dst 中 (当对应的掩码位不存在时，元素归零放)。"],["_mm256_maskz_cvtneps_pbh","将包装的单精度 (32-bit) 浮点元素在 a 中转换为包装的 BF16 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_cvtpd_epi32","将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。"],["_mm256_maskz_cvtpd_epu32","将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。"],["_mm256_maskz_cvtpd_ps","将 a 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。"],["_mm256_maskz_cvtph_ps","将 a 中的包装后的半精度 (16-bit) 浮点元素转换为包装后的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_cvtps_epi32","将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。"],["_mm256_maskz_cvtps_epu32","将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。"],["_mm256_maskz_cvtps_ph","将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm256_maskz_cvtsepi16_epi8","将 a 中的包装有符号 16 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_cvtsepi32_epi16","将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并将结果存储在 dst 中。"],["_mm256_maskz_cvtsepi32_epi8","将 a 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_cvtsepi64_epi16","将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm256_maskz_cvtsepi64_epi32","将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm256_maskz_cvtsepi64_epi8","将 a 中的包装有符号 64 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm256_maskz_cvttpd_epi32","将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。"],["_mm256_maskz_cvttpd_epu32","将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_cvttps_epi32","将带有 a 的包装的单精度 (32-bit) 浮点元素转换为带有截断的包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_cvttps_epu32","将 a 中的包装的双精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_cvtusepi16_epi8","将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm256_maskz_cvtusepi32_epi16","将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm256_maskz_cvtusepi32_epi8","将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm256_maskz_cvtusepi64_epi16","将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_cvtusepi64_epi32","将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_cvtusepi64_epi8","将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm256_maskz_dbsad_epu8","计算 a 中与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs) 的总和，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将 16 位结果存储在 dst 中。对于每个 64 位通道，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中通道的低 8 位四元组，而后两个 SAD 使用 a 中通道的较高 8 位四元组。根据 imm8 中的控件，从 128 位通道中选择 b 中的四元组，并且每个 64 位通道中的每个 SAD 使用 8 位偏移量的选定四元组。"],["_mm256_maskz_div_pd","将 a 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_div_ps","将 a 中的包装单精度 (32-bit) 浮点元素除以 b 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_dpbf16_ps","计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间单精度 (32-bit) 浮点元素与 src 中的元素进行累加，并将结果存储在 dst 中使用 zeromask k (当对应的掩码为位未设置)。"],["_mm256_maskz_dpbusd_epi32","将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果使用 zeromask k 存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_dpbusds_epi32","将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数用带符号饱和求和，并将包装的 32 位结果用 zeromask k 存储在 dst 中 (当对应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_dpwssd_epi32","将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中对应的 32 位整数相加，并使用 zeromask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_dpwssds_epi32","将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并使用 zeromask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_expand_epi16","从 a 加载连续的活动 16 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_expand_epi32","从 a 中加载连续的有效 32 位整数 (它们各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_expand_epi64","从 a 中加载连续的有效 64 位整数 (它们各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_expand_epi8","从 a 加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_expand_pd","从 a 中加载连续的活动双精度 (64-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_expand_ps","从 a 中加载连续的活动单精度 (32-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_extractf32x4_ps","从 a 提取 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并用 imm8 进行选择，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_extracti32x4_epi32","从 a 中提取 128 位 (由 4 个包装的 32 位整数组成)，用 IMM1 选择，结果用 zeromask k 存储在 dst 中 (当相应的掩码位未设置时，元素归零)。"],["_mm256_maskz_fixupimm_pd","使用 c 中的包装 64 位整数修复 a 和 b 中的包装双精度 (64-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。imm8 用于设置所需的标志报告。"],["_mm256_maskz_fixupimm_ps","使用 c 中的包装 32 位整数修复 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。imm8 用于设置所需的标志报告。"],["_mm256_maskz_fmadd_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_fmadd_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_fmaddsub_pd","将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或减去，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm256_maskz_fmaddsub_ps","将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm256_maskz_fmsub_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_fmsub_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_fmsubadd_pd","将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或减去，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm256_maskz_fmsubadd_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，或者将 C from/to 中的包装元素相减并相加，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm256_maskz_fnmadd_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_fnmadd_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_fnmsub_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_fnmsub_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_getexp_pd","将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并使用 zeromask k 将结果存储在 dst 中 (当相应的 mask 位为零时，元素被清零未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。"],["_mm256_maskz_getexp_ps","将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为代表整数指数的单精度 (32-bit) 浮点数，并使用 zeromask k 将结果存储在 dst 中 (当相应的 mask 位为零时，元素被清零未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。"],["_mm256_maskz_getmant_pd","将 a 中的包装的双精度 (64-bit) 浮点元素的尾数标准化，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1"],["_mm256_maskz_getmant_ps","将 a 中的包装的单精度 (32-bit) 浮点元素的尾数规格化，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1"],["_mm256_maskz_gf2p8affine_epi64_epi8","对 x 中的包装字节执行仿射变换。 也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。"],["_mm256_maskz_gf2p8affineinv_epi64_epi8","对 x 中的反向包装的字节执行仿射变换。 也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。"],["_mm256_maskz_gf2p8mul_epi8","在包装的字节上执行 GF(2^8) 乘法。 该字段以多项式表示，具有约数多项式 x^8 + x^4 + x^3 + x + 1。"],["_mm256_maskz_insertf32x4","将 a 复制到 tmp，然后在 x00X 指定的位置将 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成) 插入 tmp。使用 zeromask k 将 tmp 存储到 dst (当未设置相应的掩码位时，元素会被清零)。"],["_mm256_maskz_inserti32x4","将 a 复制到 tmp，然后在 imm8 指定的位置，将 b 中的 128 位 (由 4 个包装的 32 位整数组成) 插入 tmp。使用 zeromask k 将 tmp 存储到 dst (当未设置相应的掩码位时，元素会被清零)。"],["_mm256_maskz_lzcnt_epi32","计算 a 中每个包装的 32 位整数中前导零位的数目，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_lzcnt_epi64","计算 a 中每个包装的 64 位整数中前导零位的数目，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_madd_epi16","在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。水平添加相邻的中间 32 位整数对，并使用 zeromask k 将结果打包到 dst (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_maddubs_epi16","将 a 中的包装无符号 8 位整数与 b 中的包装有符号 8 位整数相乘，生成中间有符号的 16 位整数。水平添加相邻的中间有符号 16 位整数对，并使用 zeromask k 将饱和结果打包到 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_max_epi16","比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm256_maskz_max_epi32","比较 a 和 b 中包装的带符号的 32 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm256_maskz_max_epi64","比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_max_epi8","比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm256_maskz_max_epu16","比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm256_maskz_max_epu32","比较 a 和 b 中包装的无符号 32 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm256_maskz_max_epu64","比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm256_maskz_max_epu8","比较 a 和 b 中包装的无符号 8 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm256_maskz_max_pd","比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm256_maskz_max_ps","比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm256_maskz_min_epi16","比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm256_maskz_min_epi32","比较 a 和 b 中包装的带符号 32 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm256_maskz_min_epi64","比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm256_maskz_min_epi8","比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm256_maskz_min_epu16","比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm256_maskz_min_epu32","比较 a 和 b 中包装的无符号 32 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm256_maskz_min_epu64","比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm256_maskz_min_epu8","比较 a 和 b 中包装的无符号 8 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm256_maskz_min_pd","比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm256_maskz_min_ps","比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm256_maskz_mov_epi16","使用零掩码 k 将包装的 16 位整数从 a 移到 dst (当未设置相应的掩码位时，元素将清零)。"],["_mm256_maskz_mov_epi32","使用零掩码 k 将包装的 32 位整数从 a 移至 dst (未设置相应的掩码位时将元素清零)。"],["_mm256_maskz_mov_epi64","使用零掩码 k 将包装的 64 位整数从 a 移到 dst (未设置相应的掩码位时，元素将清零)。"],["_mm256_maskz_mov_epi8","使用零掩码 k 将包装的 8 位整数从 a 移到 dst (当未设置相应的掩码位时，元素将清零)。"],["_mm256_maskz_mov_pd","使用零掩码 k 将包装的双精度 (64-bit) 浮点元素从 a 移到 dst (未设置相应的掩码位时将元素清零)。"],["_mm256_maskz_mov_ps","使用零掩码 k 将包装的单精度 (32-bit) 浮点元素从 a 移到 dst (未设置相应的掩码位时将元素清零)。"],["_mm256_maskz_movedup_pd","从 a 复制偶数索引的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_movehdup_ps","从 a 复制奇数索引的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_moveldup_ps","从 a 复制偶数索引的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_mul_epi32","将 a 和 b 中每个包装的 64 位元素的低位有符号 32 位整数相乘，并使用零掩码 k 将有符号的 64 位结果存储在 dst 中 (未设置相应的掩码位时将元素清零)。"],["_mm256_maskz_mul_epu32","将 a 和 b 中每个包装的 64 位元素的低无符号 32 位整数相乘，并使用零掩码 k 将无符号 64 位结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_mul_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_mul_ps","将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_mulhi_epi16","将 a 和 b 中包装的带符号的 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_mulhi_epu16","将 a 和 b 中包装的无符号 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_mulhrs_epi16","在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。将每个中间整数截断为 18 个最高有效位，通过加 1 舍入，并使用 zeromask k 将位 [16:1] 存储到 dst (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_mullo_epi16","将 a 和 b 中的包装的 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的低 16 位存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_mullo_epi32","将 a 和 b 中的包装的 32 位整数相乘，生成中间 64 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将中间整数的低 32 位存储在 dst 中。"],["_mm256_maskz_multishift_epi64_epi8","对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并使用 zeromask k (元素当相应的屏蔽位未设置时被清零)。"],["_mm256_maskz_or_epi32","计算 a 和 b 中包装的 32 位整数的按位或，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_or_epi64","计算 a 和 b 中包装的 64 位整数的按位或，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_packs_epi16","使用带符号的饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm256_maskz_packs_epi32","使用带符号的饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm256_maskz_packus_epi16","使用无符号饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm256_maskz_packus_epi32","使用无符号饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_permute_pd","使用 imm8 中的控件在 128 位通道内对双精度 (64-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_permute_ps","使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_permutevar_pd","使用 b 中的控件在 128 位通道内将 a 中的双精度 (64-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_permutevar_ps","使用 b 中的控件在 128 位通道内将 a 的单精度 (32-bit) 浮点元素打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_permutex2var_epi16","使用相应的选择器和 idx 中的索引在通道中的 a 和 b 中对 16 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_permutex2var_epi32","使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中对 32 位整数进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_permutex2var_epi64","使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中对 64 位整数进行混洗，并使用 zeromask k (未设置相应的 mask 位时将元素清零) 将结果存储在 dst 中。"],["_mm256_maskz_permutex2var_epi8","使用 idx 中的相应选择器和索引将 a 和 b 中的 8 位整数跨通道打乱，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_permutex2var_pd","使用对应的选择器和 idx 中的索引在通道中的通道 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_permutex2var_ps","使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对单精度 (32-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_permutex_epi64","使用 imm8 中的控件在 256 位通道内将 64 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_permutex_pd","使用 imm8 中的控件在 256 位通道内将双精度 (64-bit) 浮点元素打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_permutexvar_epi16","使用 idx 中的相应索引在跨通道中对 16 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_permutexvar_epi32","使用 idx 中的相应索引在跨通道中对 32 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_permutexvar_epi64","使用 idx 中的相应索引在跨通道中对 64 位整数进行打乱，并使用零掩码 k (未设置相应的掩码位时将元素清零) 将结果存储在 dst 中。"],["_mm256_maskz_permutexvar_epi8","使用 idx 中的相应索引在跨通道的 a 中打乱 8 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_permutexvar_pd","使用 idx 中的相应索引在跨通道中对双精度 (64-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_permutexvar_ps","使用 idx 中的相应索引在跨通道中对单精度 (32-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_popcnt_epi16","对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm256_maskz_popcnt_epi32","对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm256_maskz_popcnt_epi64","对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。"],["_mm256_maskz_popcnt_epi8","对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm256_maskz_rcp14_pd","计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。该近似值的最大相对误差小于 2^-14。"],["_mm256_maskz_rcp14_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。该近似值的最大相对误差小于 2^-14。"],["_mm256_maskz_rol_epi32","将每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm256_maskz_rol_epi64","将每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm256_maskz_rolv_epi32","将 a 中每个包装的 32 位整数中的位向左旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm256_maskz_rolv_epi64","将 a 中每个包装的 64 位整数中的位向左旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm256_maskz_ror_epi32","将 X 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_ror_epi64","将 X 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm256_maskz_rorv_epi32","将 a 中每个包装的 32 位整数中的位向右旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm256_maskz_rorv_epi64","将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm256_maskz_roundscale_pd","将 x 中的包装双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm256_maskz_roundscale_ps","将 a 中的包装单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm256_maskz_rsqrt14_pd","计算 a 中的包装的双精度 (64-bit) 浮点元素的近似倒数平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。该近似值的最大相对误差小于 2^-14。"],["_mm256_maskz_rsqrt14_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。该近似值的最大相对误差小于 2^-14。"],["_mm256_maskz_scalef_pd","使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_scalef_ps","使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_set1_epi16","使用零掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm256_maskz_set1_epi32","使用零掩码 k 将 32 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm256_maskz_set1_epi64","使用零掩码 k 将 64 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm256_maskz_set1_epi8","使用零掩码 k 将 8 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm256_maskz_shldi_epi16","在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_shldi_epi32","将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_shldi_epi64","在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_shldv_epi16","在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_shldv_epi32","将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_shldv_epi64","在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_shrdi_epi16","将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_shrdi_epi32","连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_shrdi_epi64","将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_shrdv_epi16","将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_shrdv_epi32","连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_shrdv_epi64","将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_shuffle_epi32","使用 imm8 中的控件在 128 位通道中的 32 位整数中混洗 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_shuffle_epi8","根据 b 的相应 8 位元素中的打乱控制掩码对 a 中的包装 8 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_shuffle_f32x4","将 imm8 从 a 和 b 中选择的 128 位 (由 4 个单精度 (32-bit) 浮点元素组成) 混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_shuffle_f64x2","将 imm8 从 a 和 b 中选择的 128 位 (由 2 个双精度 (64-bit) 浮点元素组成) 混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_shuffle_i32x4","将 imm8 从 a 和 b 中选择的 128 位 (由 4 个 32 位整数组成) 混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_shuffle_i64x2","将 imm8 从 a 和 b 中选择的 128 位 (由 2 个 64 位整数组成) 混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_shuffle_pd","使用 imm8 中的控件对 128 位通道内的双精度 (64-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_shuffle_ps","使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_shufflehi_epi16","使用 imm8 中的控件在 a 的 128 位通道的高 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的高 64 位中，将 128 位通道的低 64 位从 a 复制到 dst，使用 zeromask k (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_shufflelo_epi16","使用 imm8 中的控件在 a 的 128 位通道的低 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的低 64 位中，并使用写掩码 k 将 128 位通道的高 64 位从 a 复制到 dst (当未使用相应的掩码位时，元素从 src 复制) 放)。"],["_mm256_maskz_sll_epi16","将包装的 16 位整数按计数左移，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_sll_epi32","将包装的 32 位整数左移计数，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_sll_epi64","将填充的 64 位整数左移计数，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_slli_epi16","将包装的 16 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_slli_epi32","将包装的 32 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_slli_epi64","将包装的 64 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_sllv_epi16","将包装的 16 位整数左移由 count 中的相应元素指定的数量，同时移入零，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_sllv_epi32","在将移位的 32 位整数左移零时，将其对应计数指定的数量左移，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_sllv_epi64","在将移位的 64 位整数左移零时，将其对应计数指定的数量左移，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_sqrt_pd","计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并使用零掩码 k (将结果置零，当未设置相应的掩码位时将元素清零) 将结果存储在 dst 中。"],["_mm256_maskz_sqrt_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_sra_epi16","将包装的 16 位整数按计数右移，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_sra_epi32","在移动符号位的同时右移计数包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_sra_epi64","在移动符号位的同时右移计数包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_srai_epi16","将包装的 16 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_srai_epi32","将包装的 32 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_srai_epi64","将包装的 64 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_srav_epi16","将包装的 16 位整数右移由 count 中的相应元素指定的数量，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_srav_epi32","在将符号位移位的同时，将已包装的 32 位整数向右移动计数中相应元素指定的数量，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_srav_epi64","在移入符号位的同时，将包装的 64 位整数右移由 count 中相应元素指定的数量，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_srl_epi16","将包装的 16 位整数右移，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_srl_epi32","将移位的 32 位整数右移，同时移零，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_srl_epi64","将包装的 64 位整数右移计数，同时移入零，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm256_maskz_srli_epi16","将包装的 16 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_srli_epi32","将包装的 32 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_srli_epi64","将包装的 64 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_srlv_epi16","将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_srlv_epi32","向右移动已包装的 32 位整数，偏移量为相应元素在计数中指定的数量，同时向零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_srlv_epi64","向右移位包装的 64 位整数，其数量为计数中相应元素指定的数量，同时移位为零，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_sub_epi16","从 a 中的包装的 16 位整数中减去 b 中的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_sub_epi32","从 a 中的包装 32 位整数中减去 b 中的包装 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_sub_epi64","从 a 中的包装 64 位整数中减去 b 中的包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_sub_epi8","从 a 中的包装 8 位整数中减去 b 中的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_sub_pd","从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_sub_ps","将 b 中的包装后的单精度 (32-bit) 浮点元素减去 a 中的包装后的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_subs_epi16","使用饱和度将 b 中的包装 16 位整数减去 b 中的包装有符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_subs_epi8","使用饱和度从包装的 8 位整数中减去 b 中的包装有符号的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_subs_epu16","使用 a 饱和度将 b 中的包装无符号 16 位整数减去 b 中的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_subs_epu8","使用 a 饱和度从 b 中的包装无符号 8 位整数减去 b 中的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_ternarylogic_epi32","提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 32 位整数中的每一位，来自 a、b 和 c 的相应位用于形成 imm8 的 3 位索引，并使用零掩码将 imm8 中该位的值写入 dst 中的相应位 k 在 32 位粒度 (当未设置相应的掩码位时，32 位元素被清零)。"],["_mm256_maskz_ternarylogic_epi64","提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 64 位整数中的每一位，来自 a、b 和 c 的相应位用于在 imm8 中形成 3 位索引，并使用零掩码将 imm8 中该位的值写入 dst 中的相应位 k 在 64 位粒度 (当未设置相应的掩码位时，64 位元素将被清零)。"],["_mm256_maskz_unpackhi_epi16","从 a 和 b 中每个 128 位通道的高半部分拆包和交织 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_unpackhi_epi32","从 a 和 b 中每个 128 位通道的高半部分解包和交织 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_unpackhi_epi64","从 a 和 b 中每个 128 位通道的高半部分解包和交织 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_unpackhi_epi8","从 a 和 b 中每个 128 位通道的高半部分拆包和交织 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_unpackhi_pd","从 a 和 b 中每个 128 位通道的高半部分解包和交织双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_unpackhi_ps","从 a 和 b 中每个 128 位通道的高半部分解包和交织单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_unpacklo_epi16","从 a 和 b 中每个 128 位通道的下半部分拆包和交织 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_unpacklo_epi32","从 a 和 b 中每个 128 位通道的下半部分解包和交织 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_unpacklo_epi64","从 a 和 b 中每个 128 位通道的下半部分解包和交织 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_unpacklo_epi8","从 a 和 b 中每个 128 位通道的下半部分拆包和交织 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm256_maskz_unpacklo_pd","从 a 和 b 中每个 128 位通道的下半部分解包和交织双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_unpacklo_ps","从 a 和 b 中每个 128 位通道的下半部分解包和交织单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm256_maskz_xor_epi32","计算 a 和 b 中包装的 32 位整数的按位 XOR，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_maskz_xor_epi64","计算 a 和 b 中包装的 64 位整数的按位 XOR，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm256_max_epi16","比较 `a` 和 `b` 中的包装的 16 位整数，并返回包装的最大值。"],["_mm256_max_epi32","比较 `a` 和 `b` 中的包装的 32 位整数，并返回包装的最大值。"],["_mm256_max_epi64","比较 a 和 b 中包装的带符号的 64 位整数，并将包装的最大值存储在 dst 中。"],["_mm256_max_epi8","比较 `a` 和 `b` 中的包装的 8 位整数，并返回包装的最大值。"],["_mm256_max_epu16","比较 `a` 和 `b` 中包装的无符号 16 位整数，并返回包装的最大值。"],["_mm256_max_epu32","比较 `a` 和 `b` 中的包装的无符号 32 位整数，并返回包装的最大值。"],["_mm256_max_epu64","比较 a 和 b 中包装的无符号 64 位整数，并将包装的最大值存储在 dst 中。"],["_mm256_max_epu8","比较 `a` 和 `b` 中包装的无符号 8 位整数，并返回包装的最大值。"],["_mm256_max_pd","比较 `a` 和 `b` 中的包装的双精度 (64-bit) 浮点元素，并返回包装的最大值"],["_mm256_max_ps","比较 `a` 和 `b` 中的包装的单精度 (32-bit) 浮点元素，并返回包装的最大值"],["_mm256_min_epi16","比较 `a` 和 `b` 中包装的 16 位整数，并返回包装的最小值。"],["_mm256_min_epi32","比较 `a` 和 `b` 中的包装的 32 位整数，并返回包装的最小值。"],["_mm256_min_epi64","比较 a 和 b 中包装的带符号的 64 位整数，并将包装的最小值存储在 dst 中。"],["_mm256_min_epi8","比较 `a` 和 `b` 中的包装的 8 位整数，并返回包装的最小值。"],["_mm256_min_epu16","比较 `a` 和 `b` 中包装的无符号 16 位整数，并返回包装的最小值。"],["_mm256_min_epu32","比较 `a` 和 `b` 中包装的无符号 32 位整数，并返回包装的最小值。"],["_mm256_min_epu64","比较 a 和 b 中包装的无符号 64 位整数，并将包装的最小值存储在 dst 中。"],["_mm256_min_epu8","比较 `a` 和 `b` 中包装的无符号 8 位整数，并返回包装的最小值。"],["_mm256_min_pd","比较 `a` 和 `b` 中的包装的双精度 (64-bit) 浮点元素，并返回包装的最小值"],["_mm256_min_ps","比较 `a` 和 `b` 中的包装的单精度 (32-bit) 浮点元素，并返回包装的最小值"],["_mm256_movedup_pd","从 `a` 复制偶数索引的双精度 (64-bit) 浮点元素，并返回结果。"],["_mm256_movehdup_ps","从 `a` 复制奇数索引的单精度 (32-bit) 浮点元素，并返回结果。"],["_mm256_moveldup_ps","从 `a` 复制偶数索引的单精度 (32-bit) 浮点元素，并返回结果。"],["_mm256_movemask_epi8","从 `a` 中每个 8 位元素的最高有效位创建掩码，并返回结果。"],["_mm256_movemask_pd","根据 `a` 中相应的包装的双精度 (64-bit) 浮点元素的最高有效位设置返回掩码的每一位。"],["_mm256_movemask_ps","基于 `a` 中相应的包装单精度 (32-bit) 浮点元素的最高有效位来设置返回掩码的每一位。"],["_mm256_movepi16_mask","根据 a 中相应的包装的 16 位整数的最高有效位设置掩码寄存器 k 的每一位。"],["_mm256_movepi8_mask","根据 a 中相应包装的 8 位整数的最高有效位设置掩码寄存器 k 的每个位。"],["_mm256_movm_epi16","根据 k 中相应位的值，将 dst 中每个包装的 16 位整数设置为全 1 或全 0。"],["_mm256_movm_epi8","根据 k 中相应位的值，将 dst 中每个包装的 8 位整数设置为全 1 或全 0。"],["_mm256_mpsadbw_epu8","计算无符号四元组的绝对差之和 (SADs) `a` 中的 8 位整数与 `b` 中的 8 位整数相比较，并将 16 位结果存储在 dst 中。 使用来自 `b` 的一个四元组和来自 `a` 的八个四元组，对每个 128 位通道执行八个 SAD。 从 `b` 中指定的偏移量开始，从 `b` 中选择一个四元组。 从 `a` 中选择的有序 8 位整数开始的 8 个四元组，起始于 `imm8` 中指定的偏移量。"],["_mm256_mul_epi32","将 `a` 和 `b` 中每个包装的 64 位元素的低位 32 位整数相乘"],["_mm256_mul_epu32","将 `a` 和 `b` 中每个包装的 64 位元素的低位无符号 32 位整数相乘"],["_mm256_mul_pd","将 `a` 和 `b` 中的包装的双精度 (64-bit) 浮点元素相乘。"],["_mm256_mul_ps","将 `a` 和 `b` 中的包装的单精度 (32-bit) 浮点元素相乘。"],["_mm256_mulhi_epi16","将 `a` 和 `b` 中的包装的 16 位整数相乘，产生 32 位中间整数，并返回中间整数的高 16 位。"],["_mm256_mulhi_epu16","将 `a` 和 `b` 中包装的无符号 16 位整数相乘，生成中间的 32 位整数，并返回中间整数的高 16 位。"],["_mm256_mulhrs_epi16","将 `a` 和 `b` 中的包装的 16 位整数相乘，生成中间带符号的 32 位整数。 将每个中间整数截断为 18 个最高有效位，再加 1 取整，然后返回 `[16:1]` 位。"],["_mm256_mullo_epi16","将 `a` 和 `b` 中的包装的 16 位整数相乘，产生 32 位中间整数，并返回中间整数的低 16 位"],["_mm256_mullo_epi32","将 `a` 和 `b` 中的包装的 32 位整数相乘，生成中间 64 位整数，并返回中间整数的低 32 位"],["_mm256_multishift_epi64_epi8","对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并将 8 个组装字节存储到 dst 的相应 64 位元素。"],["_mm256_or_epi32","计算 a 和 b 中包装的 32 位整数的按位或，并将结果存储在 dst 中。"],["_mm256_or_epi64","计算 a 和 b 中包装的 64 位整数的按位或，并将结果存储在 dst 中。"],["_mm256_or_pd","计算 `a` 和 `b` 中按位或包装的双精度 (64-bit) 浮点元素。"],["_mm256_or_ps","计算 `a` 和 `b` 中按位或包装的单精度 (32-bit) 浮点元素。"],["_mm256_or_si256","计算 `a` 和 `b` 中 256 位 (表示整数数据) 的按位或"],["_mm256_packs_epi16","使用带符号的饱和度将包装的 16 位整数从 `a` 和 `b` 转换为包装的 8 位整数"],["_mm256_packs_epi32","使用带符号的饱和度将包装的 32 位整数从 `a` 和 `b` 转换为包装的 16 位整数"],["_mm256_packus_epi16","使用无符号饱和度将包装的 16 位整数从 `a` 和 `b` 转换为包装的 8 位整数"],["_mm256_packus_epi32","使用无符号饱和度将包装的 32 位整数从 `a` 和 `b` 转换为包装的 16 位整数"],["_mm256_permute2f128_pd","混洗 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成)，由 `imm8` 从 `a` 和 `b` 中选择。"],["_mm256_permute2f128_ps","混洗 256 位 (由 8 个包装的单精度 (32-bit) 浮点元素组成)，由 `imm8` 从 `a` 和 `b` 中选择。"],["_mm256_permute2f128_si256","重排 `imm8` 从 `a` 和 `b` 选择的 128 位 (由整数数据组成)。"],["_mm256_permute2x128_si256","打乱由 `imm8` 从 `a` 和 `b` 选择的 128 位整数数据。"],["_mm256_permute4x64_epi64","使用控制掩码 `imm8` 从 `a` 置换 64 位整数。"],["_mm256_permute4x64_pd","使用 `imm8` 中的控件对 `a` 中的 64 位浮点元素进行打乱。"],["_mm256_permute_pd","使用 `imm8` 中的控件在 128 位通道内对 `a` 中的双精度 (64-bit) 浮点元素进行混洗。"],["_mm256_permute_ps","使用 `imm8` 中的控件在 128 位通道内对 `a` 中的单精度 (32-bit) 浮点元素进行混洗。"],["_mm256_permutevar8x32_epi32","根据 `b` 的内容，对 `a` 的 32 位整数进行包装的排列。"],["_mm256_permutevar8x32_ps","使用 `idx` 中相应的 32 位整数索引跨通道对 `a` 中的八个 32 位浮点元素进行打乱。"],["_mm256_permutevar_pd","使用 `b` 中的控件在 256 位通道内对 `a` 中的双精度 (64-bit) 浮点元素进行混洗。"],["_mm256_permutevar_ps","使用 `b` 中的控件在 128 位通道内对 `a` 中的单精度 (32-bit) 浮点元素进行混洗。"],["_mm256_permutex2var_epi16","使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中对 16 位整数进行打乱，并将结果存储在 dst 中。"],["_mm256_permutex2var_epi32","使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中随机排列 32 位整数，并将结果存储在 dst 中。"],["_mm256_permutex2var_epi64","使用 idx 中的相应选择器和索引在通道中的 a 和 b 中随机排列 64 位整数，并将结果存储在 dst 中。"],["_mm256_permutex2var_epi8","使用 idx 中的相应选择器和索引将 a 和 b 中的 8 位整数跨通道打乱，并将结果存储在 dst 中。"],["_mm256_permutex2var_pd","使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并将结果存储在 dst 中。"],["_mm256_permutex2var_ps","使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对单精度 (32-bit) 浮点元素进行混洗，并将结果存储在 dst 中。"],["_mm256_permutex_epi64","使用 imm8 中的控件在 256 位通道中的 a 内随机排列 64 位整数，并将结果存储在 dst 中。"],["_mm256_permutex_pd","使用 imm8 中的控件在 256 位通道内对双精度 (64-bit) 浮点元素进行打乱，并将结果存储在 dst 中。"],["_mm256_permutexvar_epi16","使用 idx 中的相应索引在跨通道中对 16 位整数进行打乱，并将结果存储在 dst 中。"],["_mm256_permutexvar_epi32","使用 idx 中的相应索引在跨通道中随机排列 32 位整数，并将结果存储在 dst 中。"],["_mm256_permutexvar_epi64","使用 idx 中的相应索引在跨通道中随机排列 64 位整数，并将结果存储在 dst 中。"],["_mm256_permutexvar_epi8","使用 idx 中的相应索引将 a 中的 8 位整数打乱到通道中，并将结果存储在 dst 中。"],["_mm256_permutexvar_pd","使用 idx 中的相应索引在跨通道中对双精度 (64-bit) 浮点元素进行混洗，并将结果存储在 dst 中。"],["_mm256_permutexvar_ps","使用 idx 中的相应索引对跨通道中的单精度 (32-bit) 浮点元素进行打乱。"],["_mm256_popcnt_epi16","对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm256_popcnt_epi32","对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm256_popcnt_epi64","对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。"],["_mm256_popcnt_epi8","对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm256_rcp14_pd","计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并将结果存储在 dst 中。该近似值的最大相对误差小于 2^-14。"],["_mm256_rcp14_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并将结果存储在 dst 中。该近似值的最大相对误差小于 2^-14。"],["_mm256_rcp_ps","计算 `a` 中包装的单精度 (32-bit) 浮点元素的近似倒数，并返回结果。 该近似值的最大相对误差小于 1.5*2^-12。"],["_mm256_rol_epi32","将 X 中每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，然后将结果存储在 dst 中。"],["_mm256_rol_epi64","将 X 中每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后将结果存储在 dst 中。"],["_mm256_rolv_epi32","将 a 中每个包装的 32 位整数中的位向左旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。"],["_mm256_rolv_epi64","将 a 中每个包装的 64 位整数中的位向左旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。"],["_mm256_ror_epi32","将 X 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并将结果存储在 dst 中。"],["_mm256_ror_epi64","将 X 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，然后将结果存储在 dst 中。"],["_mm256_rorv_epi32","将 a 中每个包装的 32 位整数中的位向右旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。"],["_mm256_rorv_epi64","将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。"],["_mm256_round_pd","根据 `ROUNDING` 标志对 `a` 中的双精度 (64-bit) 浮点包装的 (64-bit) 浮点元素进行舍入。 `ROUNDING` 的值可能如下:"],["_mm256_round_ps","根据标志 `ROUNDING` 对 `a` 中的单精度 (32-bit) 浮点包装元素进行舍入。 `ROUNDING` 的值可能如下:"],["_mm256_roundscale_pd","将 x 中的包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并将结果存储在 dst 中。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm256_roundscale_ps","将 a 中的包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的小数位数，然后将结果存储在 dst 中。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm256_rsqrt_ps","计算 `a` 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并返回结果。"],["_mm256_sad_epu8","计算 `a` 和 `b` 中包装的无符号 8 位整数的绝对差，然后将每个连续的 8 个差水平求和，产生四个无符号的 16 位整数，并将这些无符号的 16 位整数包装在 64 位返回值的低 16 位中"],["_mm256_scalef_pd","使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm256_scalef_ps","使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm256_set1_epi16","向返回的 vector 的所有所有元素广播 16 位整数 `a`。 此内联函数可能会生成 `vpbroadcastw`。"],["_mm256_set1_epi32","向返回的 vector 的所有元素广播 32 位整数 `a`。 此内联函数可能会生成 `vpbroadcastd`。"],["_mm256_set1_epi64x","向返回的 vector 的所有元素广播 64 位整数 `a`。 此内联函数可能会生成 `vpbroadcastq`。"],["_mm256_set1_epi8","向返回的 vector 的所有元素广播 8 位整数 `a`。 此内联函数可能会生成 `vpbroadcastb`。"],["_mm256_set1_pd","向返回的 vector 的所有元素广播双精度 (64-bit) 浮点值 `a`。"],["_mm256_set1_ps","向返回的 vector 的所有元素广播单精度 (32-bit) 浮点值 `a`。"],["_mm256_set_epi16","使用提供的值在返回的 vector 中设置包装的 16 位整数。"],["_mm256_set_epi32","使用提供的值在返回的 vector 中设置包装的 32 位整数。"],["_mm256_set_epi64x","使用提供的值在返回的 vector 中设置包装的 64 位整数。"],["_mm256_set_epi8","在返回的 vector 中设置包装的 8 位整数，并以相反的顺序提供所提供的值。"],["_mm256_set_m128","设置包装的 __m256 返回的 vector 与提供的值。"],["_mm256_set_m128d","设置包装的 __m256d 返回的 vector 具有提供的值。"],["_mm256_set_m128i","包装的 __m256i 集合使用提供的值返回 vector。"],["_mm256_set_pd","使用提供的值在返回的 vector 中设置包装的双精度 (64-bit) 浮点元素。"],["_mm256_set_ps","使用提供的值在返回的 vector 中设置包装的单精度 (32-bit) 浮点元素。"],["_mm256_setr_epi16","在返回的 vector 中设置包装的 16 位整数，其提供的值的顺序相反。"],["_mm256_setr_epi32","在返回的 vector 中设置包装的 32 位整数，并以相反的顺序提供所提供的值。"],["_mm256_setr_epi64x","在返回的 vector 中设置包装的 64 位整数，其提供的值的顺序相反。"],["_mm256_setr_epi8","在返回的 vector 中设置包装的 8 位整数，并以相反的顺序提供所提供的值。"],["_mm256_setr_m128","设置包装的 __m256 返回的 vector 与提供的值。"],["_mm256_setr_m128d","设置包装的 __m256d 返回的 vector 具有提供的值。"],["_mm256_setr_m128i","包装的 __m256i 集合使用提供的值返回 vector。"],["_mm256_setr_pd","在返回的 vector 中使用反向提供的值设置包装的双精度 (64-bit) 浮点元素。"],["_mm256_setr_ps","在返回的 vector 中使用反向提供的值设置包装的单精度 (32-bit) 浮点元素。"],["_mm256_setzero_pd","返回 __m256d 类型的 vector，所有元素均设置为零。"],["_mm256_setzero_ps","返回 __m256 类型的 vector，所有元素都设置为零。"],["_mm256_setzero_si256","返回类型为 __m256i 的 vector，所有元素均设置为零。"],["_mm256_shldi_epi16","在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并将高 16 位存储在 dst 中)。"],["_mm256_shldi_epi32","将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并将高 32 位存储在 dst 中。"],["_mm256_shldi_epi64","在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并将高 64 位存储在 dst 中)。"],["_mm256_shldv_epi16","在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的对应元素中指定的量，并将高 16 位存储在 dst 中。"],["_mm256_shldv_epi32","将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的对应元素中指定的量，并将高 32 位存储在 dst 中。"],["_mm256_shldv_epi64","在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的对应元素中指定的量，并将高 64 位存储在 dst 中。"],["_mm256_shrdi_epi16","将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并将低 16 位存储在 dst 中。"],["_mm256_shrdi_epi32","连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并将低 32 位存储在 dst 中。"],["_mm256_shrdi_epi64","将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并将低 64 位存储在 dst 中。"],["_mm256_shrdv_epi16","将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的对应元素中指定的量，并将低 16 位存储在 dst 中。"],["_mm256_shrdv_epi32","连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的对应元素中指定的量，并将低 32 位存储在 dst 中。"],["_mm256_shrdv_epi64","将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的对应元素中指定的量，并将低 64 位存储在 dst 中。"],["_mm256_shuffle_epi32","使用 `imm8` 中的控件，在 `a` 的 128 位通道中打乱 32 位整数。"],["_mm256_shuffle_epi8","根据 `b` 的内容，打乱 `a` 中的字节。"],["_mm256_shuffle_f32x4","imm8 从 a 和 b 中随机选择 128 位 (由 4 个单精度 (32-bit) 浮点元素组成)，并将结果存储在 dst 中。"],["_mm256_shuffle_f64x2","随机排列 imm8 从 a 和 b 中选择的 128 位 (由 2 个双精度 (64-bit) 浮点元素组成)，并将结果存储在 dst 中。"],["_mm256_shuffle_i32x4","随机排列 imm8 从 a 和 b 中选择的 128 位 (由 4 个 32 位整数组成)，并将结果存储在 dst 中。"],["_mm256_shuffle_i64x2","随机排列 imm8 从 a 和 b 中选择的 128 位 (由 2 个 64 位整数组成)，并将结果存储在 dst 中。"],["_mm256_shuffle_pd","使用 `imm8` 中的控件对 128 位通道中的双精度 (64-bit) 浮点元素进行混洗。"],["_mm256_shuffle_ps","将 `a` 中的单精度 (32-bit) 浮点元素改组为 使用 `imm8` 中的控件的 128 位通道。"],["_mm256_shufflehi_epi16","使用 `imm8` 中的控件，在 `a` 的 128 位通道的高 64 位中打乱 16 位整数。 `a` 的 128 位通道的低 64 位被复制到输出中。"],["_mm256_shufflelo_epi16","使用 `imm8` 中的控件在 `a` 的 128 位通道的低 64 位中打乱 16 位整数。 `a` 的 128 位通道的高 64 位被复制到输出中。"],["_mm256_sign_epi16","当相应的带符号时，将 `a` 中的 16 位整数包装为无效 `b` 中的 16 位整数为负，并返回结果。 当 `b` 中的相应元素为零时，结果归零。"],["_mm256_sign_epi32","当相应的带符号时，将 `a` 中的包装的 32 位整数取反 `b` 中的 32 位整数为负，并返回结果。 当 `b` 中的相应元素为零时，结果归零。"],["_mm256_sign_epi8","当相应的带符号时，将 `a` 中的包装的 8 位整数取反 `b` 中的 8 位整数为负，并返回结果。 当 `b` 中的相应元素为零时，结果归零。"],["_mm256_sll_epi16","将 `count` 左移的 `a` 中的包装的 16 位整数移位，同时移零，并返回结果"],["_mm256_sll_epi32","将 `count` 左移的 `a` 中的包装的 32 位整数移位，同时移零，并返回结果"],["_mm256_sll_epi64","将 `count` 左移的 `a` 中的包装的 64 位整数移位，同时移零，并返回结果"],["_mm256_slli_epi16","将 `a` 中包装的 16 位整数在 `IMM8` 左移同时移零，返回结果;"],["_mm256_slli_epi32","将 `a` 中的包装的 32 位整数在 `IMM8` 左移同时移零，返回结果;"],["_mm256_slli_epi64","将 `a` 中的包装的 64 位整数在 `IMM8` 左移同时移零，返回结果;"],["_mm256_slli_si256","将 `a` 中的 128 位通道向左移 `imm8` 字节，同时向零移位。"],["_mm256_sllv_epi16","将包装的 16 位整数按 count 中相应元素指定的数量向左移位，同时将零移位，并将结果存储在 dst 中。"],["_mm256_sllv_epi32","将 `a` 中的包装的 32 位整数左移 `count` 中相应元素所指定的数量，同时将零移位，并返回结果。"],["_mm256_sllv_epi64","将 `a` 中的包装的 64 位整数左移 `count` 中相应元素所指定的数量，同时将零移位，并返回结果。"],["_mm256_sqrt_pd","返回 `a` 中包装的双精度 (64-bit) 浮点元素的平方根。"],["_mm256_sqrt_ps","返回 `a` 中包装的单精度 (32-bit) 浮点元素的平方根。"],["_mm256_sra_epi16","将符号位移入时，将 `a` 中的包装的 16 位整数右移 `count`。"],["_mm256_sra_epi32","将符号位移位时，将 `a` 中的包装的 32 位整数右移 `count`。"],["_mm256_sra_epi64","在移动符号位的同时按计数右移包装的 64 位整数，并将结果存储在 dst 中。"],["_mm256_srai_epi16","将 `a` 中包装的 16 位整数右移 `IMM8`，同时移入符号位。"],["_mm256_srai_epi32","将 `a` 中包装的 32 位整数右移 `IMM8`，同时移入符号位。"],["_mm256_srai_epi64","将包装的 64 位整数右移 imm8，同时将符号位移位，并将结果存储在 dst 中。"],["_mm256_srav_epi16","将包装的 16 位整数右移 count 中相应元素指定的数量，同时移入符号位，然后将结果存储在 dst 中。"],["_mm256_srav_epi32","将 `a` 中的32位整数向右移动，移动量由 `count` 中的相应元素指定，同时移入符号位。"],["_mm256_srav_epi64","将移位的 64 位整数向右移动计数中相应元素指定的数量，同时移入符号位，并将结果存储在 dst 中。"],["_mm256_srl_epi16","将 `a` 中的包装的 16 位整数右移 `count`，同时将零移位。"],["_mm256_srl_epi32","将 `a` 中的包装的 32 位整数右移 `count`，同时将零移位。"],["_mm256_srl_epi64","将 `a` 中的包装的 64 位整数右移 `count`，同时将零移位。"],["_mm256_srli_epi16","将 `a` 中包装的 16 位整数右移 `IMM8`，同时将其移入零"],["_mm256_srli_epi32","将 `a` 中包装的 32 位整数右移 `IMM8`，同时将其移入零"],["_mm256_srli_epi64","将 `a` 中包装的 64 位整数右移 `IMM8`，同时将其移入零"],["_mm256_srli_si256","将 `a` 中的 128 位通道右移 `imm8` 字节，同时将其移位为零。"],["_mm256_srlv_epi16","将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并将结果存储在 dst 中。"],["_mm256_srlv_epi32","将 `a` 中的包装的 32 位整数右移 `count` 中相应元素所指定的数量，同时将零移位，"],["_mm256_srlv_epi64","将 `a` 中的包装的 64 位整数右移 `count` 中相应元素所指定的数量，同时将零移位，"],["_mm256_store_epi32","将 a 中的 256 位 (由 8 个包装的 32 位整数组成) 存储到内存中。mem_addr 必须在 32 字节边界上对齐，否则可能会生成一般保护异常。"],["_mm256_store_epi64","将 a 中的 256 位 (由 4 个包装的 64 位整数组成) 存储到内存中。mem_addr 必须在 32 字节边界上对齐，否则可能会生成一般保护异常。"],["_mm256_store_pd","将来自 `a` 的 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。"],["_mm256_store_ps","将来自 `a` 的 256 位 (由 8 个包装的单精度 (32-bit) 浮点元素组成) 存储到内存中。"],["_mm256_store_si256","将来自 `a` 的 256 位整数数据存储到内存中。 `mem_addr` 必须在 32 字节边界上对齐，否则可能会产生一般保护异常。"],["_mm256_storeu2_m128","将来自 `a` 的高和低 128 位半部分 (每个半部分由 4 个包装的单精度 (32-bit) 浮点元素组成) 存储到内存中两个不同的 128 位位置。"],["_mm256_storeu2_m128d","将来自 `a` 的高和低 128 位半部分 (每个半部分由 2 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中两个不同的 128 位位置。"],["_mm256_storeu2_m128i","将来自 `a` 的高 128 位和低 128 位 (分别由整数数据组成) 存储到内存中两个不同的 128 位位置。"],["_mm256_storeu_epi16","将 a 中的 256 位 (由 16 个包装的 16 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。"],["_mm256_storeu_epi32","将 a 中的 256 位 (由 8 个包装的 32 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。"],["_mm256_storeu_epi64","将 a 中的 256 位 (由 4 个包装的 64 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。"],["_mm256_storeu_epi8","将 a 中的 256 位 (由 32 个包装的 8 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。"],["_mm256_storeu_pd","将来自 `a` 的 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。"],["_mm256_storeu_ps","将来自 `a` 的 256 位 (由 8 个包装的单精度 (32-bit) 浮点元素组成) 存储到内存中。"],["_mm256_storeu_si256","将来自 `a` 的 256 位整数数据存储到内存中。 `mem_addr` 不需要在任何特定边界上对齐。"],["_mm256_stream_pd","将双精度值从 `[4 x double]` 的 256 位 vector 移动到 32 字节对齐的内存位置。 为了最大程度地减少缓存，数据被标记为非时间性的 (不太可能很快再次使用)。"],["_mm256_stream_ps","将单精度浮点值从 `[8 x float]` 的 256 位 vector 移到 32 字节对齐的内存位置。 为了最大程度地减少缓存，数据被标记为非时间性的 (不太可能很快再次使用)。"],["_mm256_stream_si256","将整数数据从 256 位整数 vector 移动到 32 字节对齐的内存位置。 为了最大程度地减少缓存，数据被标记为非时间性的 (不太可能很快再次使用)"],["_mm256_sub_epi16","从 `a` 中的包装的 16 位整数减去 `b` 中的包装的 16 位整数"],["_mm256_sub_epi32","从 `a` 中的包装的 32 位整数减去 `b` 中的包装的 32 位整数"],["_mm256_sub_epi64","从 `a` 中的包装的 64 位整数减去 `b` 中的包装的 64 位整数"],["_mm256_sub_epi8","从 `a` 中的包装的 8 位整数中减去 `b` 中的包装的 8 位整数"],["_mm256_sub_pd","从 `a` 中的包装的元素中减去 `b` 中的包装后的双精度 (64-bit) 浮点元素。"],["_mm256_sub_ps","从 `a` 中的包装元素中减去 `b` 中的包装的单精度 (32-bit) 浮点元素。"],["_mm256_subs_epi16","使用饱和度从 `a` 的包装的 16 位整数减去 `b` 的包装的 16 位整数。"],["_mm256_subs_epi8","使用饱和度从 `a` 的包装的 8 位整数减去 `b` 的包装的 8 位整数。"],["_mm256_subs_epu16","使用饱和度从 `a` 的包装的 16 位整数减去 `b` 的包装的无符号 16 位整数。"],["_mm256_subs_epu8","使用饱和度从 `a` 的包装的 8 位整数减去 `b` 的包装的无符号 8 位整数。"],["_mm256_ternarylogic_epi32","提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个包装的 32 位整数中的每个位，来自 a，b 和 c 的相应位用于形成到 imm8 的 3 位索引，并且将 imm8 中该位的值写入 dst 中的相应位。"],["_mm256_ternarylogic_epi64","提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 64 位整数中的每一位，a、b 和 c 中的相应位用于形成 imm8 中的 3 位索引，并将 imm8 中该位的值写入 dst 中的相应位。"],["_mm256_test_epi16_mask","计算 a 和 b 中包装的 16 位整数的按位与，生成中间的 16 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。"],["_mm256_test_epi32_mask","计算 a 和 b 中包装的 32 位整数的按位与，生成中间的 32 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。"],["_mm256_test_epi64_mask","计算 a 和 b 中包装的 64 位整数的按位与，生成中间 64 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。"],["_mm256_test_epi8_mask","计算 a 和 b 中包装的 8 位整数的按位与，生成中间 8 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。"],["_mm256_testc_pd","计算 `a` 和 `b` 中 256 位 (表示双精度 (64-bit) 浮点元素) 的按位与，生成中间 256 位值，如果中间值中每个 64 位元素的符号位都将 `ZF` 设置为 1 为零，否则将 `ZF` 设置为 0。 计算 `a` 的按位 NOT，然后与 `b` 进行与运算，得到一个中间值，如果中间值中每个 64 位元素的符号位为零，则将 `CF` 设置为 1，否则将 `CF` 设置为 0。 返回 `CF` 值。"],["_mm256_testc_ps","计算 `a` 和 `b` 中 256 位 (表示单精度 (32-bit) 浮点元素) 的按位与，生成中间 256 位值，如果中间值中每个 32 位元素的符号位都将 `ZF` 设置为 1 为零，否则将 `ZF` 设置为 0。 计算 `a` 的按位非，然后与 `b` 进行与运算，产生一个中间值，如果中间值中每个 32 位元素的符号位为零，则将 `CF` 设置为 1，否则将 `CF` 设置为 0。 返回 `CF` 值。"],["_mm256_testc_si256","计算 `a` 和 `b` 中 256 位 (表示整数数据) 的按位与，如果结果为零，则将 `ZF` 设置为 1，否则将 `ZF` 设置为 0。"],["_mm256_testn_epi16_mask","计算 a 和 b 中包装的 16 位整数的按位 NAND，生成中间的 16 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。"],["_mm256_testn_epi32_mask","计算 a 和 b 中包装的 32 位整数的按位 NAND，生成中间的 32 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。"],["_mm256_testn_epi64_mask","计算 a 和 b 中包装的 64 位整数的按位 NAND，生成中间的 64 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。"],["_mm256_testn_epi8_mask","计算 a 和 b 中包装的 8 位整数的按位 NAND，生成中间的 8 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。"],["_mm256_testnzc_pd","计算 `a` 和 `b` 中 256 位 (表示双精度 (64-bit) 浮点元素) 的按位与，生成中间 256 位值，如果中间值中每个 64 位元素的符号位都将 `ZF` 设置为 1 为零，否则将 `ZF` 设置为 0。 计算 `a` 的按位 NOT，然后与 `b` 进行与运算，得到一个中间值，如果中间值中每个 64 位元素的符号位为零，则将 `CF` 设置为 1，否则将 `CF` 设置为 0。 如果 `ZF` 和 `CF` 的值均为零，则返回 1，否则返回 0。"],["_mm256_testnzc_ps","计算 `a` 和 `b` 中 256 位 (表示单精度 (32-bit) 浮点元素) 的按位与，生成中间 256 位值，如果中间值中每个 32 位元素的符号位都将 `ZF` 设置为 1 为零，否则将 `ZF` 设置为 0。 计算 `a` 的按位非，然后与 `b` 进行与运算，产生一个中间值，如果中间值中每个 32 位元素的符号位为零，则将 `CF` 设置为 1，否则将 `CF` 设置为 0。 如果 `ZF` 和 `CF` 的值均为零，则返回 1，否则返回 0。"],["_mm256_testnzc_si256","计算 `a` 和 `b` 中 256 位 (表示整数数据) 的按位与，如果结果为零，则将 `ZF` 设置为 1，否则将 `ZF` 设置为 0。"],["_mm256_testz_pd","计算 `a` 和 `b` 中 256 位 (表示双精度 (64-bit) 浮点元素) 的按位与，生成中间 256 位值，如果中间值中每个 64 位元素的符号位都将 `ZF` 设置为 1 为零，否则将 `ZF` 设置为 0。 计算 `a` 的按位 NOT，然后与 `b` 进行与运算，得到一个中间值，如果中间值中每个 64 位元素的符号位为零，则将 `CF` 设置为 1，否则将 `CF` 设置为 0。 返回 `ZF` 值。"],["_mm256_testz_ps","计算 `a` 和 `b` 中 256 位 (表示单精度 (32-bit) 浮点元素) 的按位与，生成中间 256 位值，如果中间值中每个 32 位元素的符号位都将 `ZF` 设置为 1 为零，否则将 `ZF` 设置为 0。 计算 `a` 的按位非，然后与 `b` 进行与运算，产生一个中间值，如果中间值中每个 32 位元素的符号位为零，则将 `CF` 设置为 1，否则将 `CF` 设置为 0。 返回 `ZF` 值。"],["_mm256_testz_si256","计算 `a` 和 `b` 中 256 位 (表示整数数据) 的按位与，如果结果为零，则将 `ZF` 设置为 1，否则将 `ZF` 设置为 0。"],["_mm256_undefined_pd","返回带有未定义元素的 `__m256d` 类型的 vector。"],["_mm256_undefined_ps","返回带有未定义元素的 `__m256` 类型的 vector。"],["_mm256_undefined_si256","返回带有未定义元素的 __m256i 类型的 vector。"],["_mm256_unpackhi_epi16","从每个高位的一半拆包并交织 16 位整数 `a` 和 `b` 的 128 位通道"],["_mm256_unpackhi_epi32","从每个高位的一半拆包并交织 32 位整数 `a` 和 `b` 的 128 位通道"],["_mm256_unpackhi_epi64","从每个高位的一半拆包并交织 64 位整数 `a` 和 `b` 的 128 位通道"],["_mm256_unpackhi_epi8","从每个高位的一半拆包并交织 8 位整数 `a` 和 `b` 中的 128 位通道。"],["_mm256_unpackhi_pd","从 `a` 和 `b` 中每个 128 位通道的上半部分解包并交织双精度 (64-bit) 浮点元素。"],["_mm256_unpackhi_ps","从 `a` 和 `b` 中每个 128 位通道的高半部分解包并交织单精度 (32-bit) 浮点元素。"],["_mm256_unpacklo_epi16","从每个低位拆包并交织 16 位整数 `a` 和 `b` 的 128 位通道"],["_mm256_unpacklo_epi32","从每个低位拆包并交织 32 位整数 `a` 和 `b` 的 128 位通道"],["_mm256_unpacklo_epi64","从每个字节的下半部分拆包并交织 64 位整数 `a` 和 `b` 的 128 位通道"],["_mm256_unpacklo_epi8","从每个低位拆包并交织 8 位整数 `a` 和 `b` 的 128 位通道"],["_mm256_unpacklo_pd","从 `a` 和 `b` 中每个 128 位通道的下半部分解包并交织双精度 (64-bit) 浮点元素。"],["_mm256_unpacklo_ps","从 `a` 和 `b` 中每个 128 位通道的下半部分解包并交织单精度 (32-bit) 浮点元素。"],["_mm256_xor_epi32","计算 a 和 b 中包装的 32 位整数的按位 XOR，并将结果存储在 dst 中。"],["_mm256_xor_epi64","计算 a 和 b 中包装的 64 位整数的按位 XOR，并将结果存储在 dst 中。"],["_mm256_xor_pd","计算 `a` 和 `b` 中包装的双精度 (64-bit) 浮点元素的按位 XOR。"],["_mm256_xor_ps","计算 `a` 和 `b` 中包装的单精度 (32-bit) 浮点元素的按位 XOR。"],["_mm256_xor_si256","计算 `a` 和 `b` 中 256 位 (表示整数数据) 的按位 XOR"],["_mm256_zeroall","将所有 XMM 或 YMM 寄存器的内容清零。"],["_mm256_zeroupper","将所有 YMM 寄存器的高 128 位清零; 寄存器的低 128 位保持不变。"],["_mm256_zextpd128_pd256","从 a 创建一个 `[4 x double]` 的 256 位浮点 vector `[2 x double]` 的 128 位浮点 vector。低 128 位包含源 vector 的值。 高 128 位设置为零。"],["_mm256_zextps128_ps256","从 a 创建一个 `[8 x float]` 的 256 位浮点 vector `[4 x float]` 的 128 位浮点 vector。低 128 位包含源 vector 的值。 高 128 位设置为零。"],["_mm256_zextsi128_si256","从 128 位整数 vector 创建一个 256 位整数 vector。 低 128 位包含源 vector 的值。上层 128 位设置为零。"],["_mm512_abs_epi16","计算 a 中包装的带符号的 16 位整数的绝对值，并将无符号的结果存储在 dst 中。"],["_mm512_abs_epi32","计算 `a` 中包装的 32 位整数的绝对值。"],["_mm512_abs_epi64","计算 a 中包装的带符号的 64 位整数的绝对值，并将无符号的结果存储在 dst 中。"],["_mm512_abs_epi8","计算 a 中包装的带符号的 8 位整数的绝对值，并将无符号的结果存储在 dst 中。"],["_mm512_abs_pd","查找 v2 中每个包装的双精度 (64-bit) 浮点元素的绝对值，并将结果存储在 dst 中。"],["_mm512_abs_ps","查找 v2 中每个包装的单精度 (32-bit) 浮点元素的绝对值，并将结果存储在 dst 中。"],["_mm512_add_epi16","将包装的 16 位整数添加到 a 和 b 中，并将结果存储在 dst 中。"],["_mm512_add_epi32","在 a 和 b 中添加包装的 32 位整数，并将结果存储在 dst 中。"],["_mm512_add_epi64","在 a 和 b 中添加包装的 64 位整数，并将结果存储在 dst 中。"],["_mm512_add_epi8","将包装的 8 位整数添加到 a 和 b 中，并将结果存储在 dst 中。"],["_mm512_add_pd","在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_add_ps","在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_add_round_pd","在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_add_round_ps","在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_adds_epi16","使用饱和度在 a 和 b 中添加包装的带符号的 16 位整数，并将结果存储在 dst 中。"],["_mm512_adds_epi8","使用饱和度在 a 和 b 中添加包装的带符号的 8 位整数，并将结果存储在 dst 中。"],["_mm512_adds_epu16","使用饱和度在 a 和 b 中添加包装的无符号 16 位整数，并将结果存储在 dst 中。"],["_mm512_adds_epu8","使用饱和度在 a 和 b 中添加包装的无符号 8 位整数，并将结果存储在 dst 中。"],["_mm512_aesdec_epi128","使用 `round_key` 中的相应 128 位字 (key) 对 `a` 中的每个 128 位字 (state) 执行一轮 AES 解密流程。"],["_mm512_aesdeclast_epi128","使用 `round_key` 中的相应 128 位字 (key) 对 `a` 中的每个 128 位字 (state) 执行最后一轮 AES 解密流程。"],["_mm512_aesenc_epi128","使用 `round_key` 中的相应 128 位字 (key) 对 `a` 中的每个 128 位字 (state) 执行一轮 AES 加密流程。"],["_mm512_aesenclast_epi128","使用 `round_key` 中的相应 128 位字 (key) 对 `a` 中的每个 128 位字 (state) 执行最后一轮 AES 加密流程。"],["_mm512_alignr_epi32","将 a 和 b 连接成一个 128 字节的立即结果，将结果右移 imm8 32 位元素，并将低 64 字节 (16 个元素) 存储在 dst 中。"],["_mm512_alignr_epi64","将 a 和 b 连接成一个 128 字节的立即结果，将结果右移 imm8 64 位元素，并将低 64 字节 (8 个元素) 存储在 dst 中。"],["_mm512_alignr_epi8","将 a 和 b 中的 16 字节块对连接成 32 字节的临时结果，将结果右移 imm8 字节，并将低 16 字节存储在 dst 中。"],["_mm512_and_epi32","计算 a 和 b 中包装的 32 位整数的按位与，并将结果存储在 dst 中。"],["_mm512_and_epi64","计算 a 和 b 中 512 位 (由包装的 64 位整数组成) 的按位与，并将结果存储在 dst 中。"],["_mm512_and_si512","计算 a 和 b 中 512 位 (代表整数数据) 的按位与，并将结果存储在 dst 中。"],["_mm512_andnot_epi32","计算 a 中包装的 32 位整数的按位 NOT，然后与 b 计算 AND，并将结果存储在 dst 中。"],["_mm512_andnot_epi64","计算 a 中的 512 位 (由包装的 64 位整数组成) 的按位非，然后与 b 计算 AND，并将结果存储在 dst 中。"],["_mm512_andnot_si512","计算 a 中的 512 位 (代表整数数据) 的按位非，然后与 b 计算 AND，并将结果存储在 dst 中。"],["_mm512_avg_epu16","将 a 和 b 中的包装无符号 16 位整数进行平均，然后将结果存储在 dst 中。"],["_mm512_avg_epu8","将 a 和 b 中包装的无符号 8 位整数平均，然后将结果存储在 dst 中。"],["_mm512_bitshuffle_epi64_mask","将输入 `b` 视为包装的 64 位整数，并将 `c` 视为包装的 8 位整数。 然后将来自 `c` 的 8 个 8 位值作为索引分组到相应的 64 位整数的位中。 然后，选择这些位并将其包装到输出中。"],["_mm512_broadcast_f32x4","从 a 广播 4 个包装的单精度 (32-bit) 浮点元素到 dst 的所有元素。"],["_mm512_broadcast_f64x4","从 a 广播 4 个包装的双精度 (64-bit) 浮点元素到 dst 的所有元素。"],["_mm512_broadcast_i32x4","将 4 个包装的 32 位整数从 a 广播到 dst 的所有元素。"],["_mm512_broadcast_i64x4","将 4 个包装的 64 位整数从 a 广播到 dst 的所有元素。"],["_mm512_broadcastb_epi8","将低包装的 8 位整数从 a 广播到 dst 的所有元素。"],["_mm512_broadcastd_epi32","将低包装的 32 位整数从 a 广播到 dst 的所有元素。"],["_mm512_broadcastmb_epi64","将输入掩码 k 的低 8 位广播到 dst 的所有 64 位元素。"],["_mm512_broadcastmw_epi32","将输入掩码 k 的低 16 位广播到 dst 的所有 32 位元素。"],["_mm512_broadcastq_epi64","将低包装的 64 位整数从 a 广播到 dst 的所有元素。"],["_mm512_broadcastsd_pd","从 a 广播低双精度 (64-bit) 浮点元素到 dst 的所有元素。"],["_mm512_broadcastss_ps","将低单精度 (32-bit) 浮点元素从 A 广播到 dst 的所有元素。"],["_mm512_broadcastw_epi16","将低包装的 16 位整数从 a 广播到 dst 的所有元素。"],["_mm512_bslli_epi128","向左移动 128 位通道 imm8 字节，同时向零移动，并将结果存储在 dst 中。"],["_mm512_bsrli_epi128","向右移动 128 位通道 imm8 字节，同时向零移动，并将结果存储在 dst 中。"],["_mm512_castpd128_pd512","将类型 __m128d 的 vector 强制转换为 __m512d 类型; 结果的高 384 位未定义。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。"],["_mm512_castpd256_pd512","将类型 __m256d 的 vector 强制转换为 __m512d 类型; 结果的高 256 位未定义。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。"],["_mm512_castpd512_pd128","将类型为 __m512d 的 vector 强制转换为类型为 __m128d 的 vector。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。"],["_mm512_castpd512_pd256","将类型为 __m512d 的 vector 强制转换为类型为 __m256d 的 vector。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。"],["_mm512_castpd_ps","将类型为 __m512d 的 vector 强制转换为类型 __m512。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。"],["_mm512_castpd_si512","将类型为 __m512d 的 vector 强制转换为类型为 __m512i 的 vector。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。"],["_mm512_castps128_ps512","将类型 __m128 的 vector 转换为 __m512 类型; 结果的高 384 位未定义。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。"],["_mm512_castps256_ps512","将类型为 __m256 的 vector 强制转换为类型 __m512; 结果的高 256 位未定义。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。"],["_mm512_castps512_ps128","将类型为 __m512 的 vector 强制转换为类型为 __m128 的 vector。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。"],["_mm512_castps512_ps256","将类型为 __m512 的 vector 强制转换为类型 __m256。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。"],["_mm512_castps_pd","将类型为 __m512 的 vector 强制转换为类型为 __m512d 的 vector。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。"],["_mm512_castps_si512","将类型为 __m512 的 vector 强制转换为类型 __m512i。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。"],["_mm512_castsi128_si512","将类型为 __m128i 的 vector 强制转换为类型 __m512i; 结果的高 384 位未定义。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。"],["_mm512_castsi256_si512","将类型为 __m256i 的 vector 强制转换为类型 __m512i; 结果的高 256 位未定义。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。"],["_mm512_castsi512_pd","将类型为 __m512i 的 vector 强制转换为类型为 __m512d 的 vector。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。"],["_mm512_castsi512_ps","将类型为 __m512i 的 vector 强制转换为类型 __m512。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。"],["_mm512_castsi512_si128","将类型为 __m512i 的 vector 强制转换为类型为 __m128i 的 vector。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。"],["_mm512_castsi512_si256","将类型为 __m512i 的 vector 强制转换为类型为 __m256i 的 vector。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。"],["_mm512_clmulepi64_epi128","在 4 个 128 位通道中的每一个中，在有限域 GF(2^k) 上执行两个 64 位多项式的无进位乘法。"],["_mm512_cmp_epi16_mask","根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号 16 位整数，并将结果存储在掩码 vector k 中。"],["_mm512_cmp_epi32_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装有符号 32 位整数，并将结果存储在掩码 vector k 中。"],["_mm512_cmp_epi64_mask","根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 64 位整数，并将结果存储在掩码 vector k 中。"],["_mm512_cmp_epi8_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装带符号 8 位整数，并将结果存储在掩码 vector k 中。"],["_mm512_cmp_epu16_mask","根据 `IMM8` 指定的比较操作数比较 a 和 b 中包装的无符号 16 位整数，并将结果存储在掩码 vector k 中。"],["_mm512_cmp_epu32_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 32 位整数，并将结果存储在掩码 vector k 中。"],["_mm512_cmp_epu64_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 64 位整数，并将结果存储在掩码 vector k 中。"],["_mm512_cmp_epu8_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 8 位整数，并将结果存储在掩码 vector k 中。"],["_mm512_cmp_pd_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在掩码 vector k 中。"],["_mm512_cmp_ps_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并将结果存储在掩码 vector k 中。"],["_mm512_cmp_round_pd_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在掩码 vector k 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_cmp_round_ps_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并将结果存储在掩码 vector k 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_cmpeq_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm512_cmpeq_epi32_mask","比较 a 和 b 中包装的 32 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm512_cmpeq_epi64_mask","比较 a 和 b 中包装的 64 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm512_cmpeq_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm512_cmpeq_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm512_cmpeq_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm512_cmpeq_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm512_cmpeq_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm512_cmpeq_pd_mask","比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否相等，并将结果存储在掩码 vector k 中。"],["_mm512_cmpeq_ps_mask","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否相等，并将结果存储在掩码 vector k 中。"],["_mm512_cmpge_epi16_mask","比较 a 和 b 中包装的带符号 16 位整数是否大于等于，并将结果存储在掩码 vector k 中。"],["_mm512_cmpge_epi32_mask","比较 a 和 b 中包装的带符号 32 位整数是否大于等于，并将结果存储在掩码 vector k 中。"],["_mm512_cmpge_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数是否大于等于，并将结果存储在掩码 vector k 中。"],["_mm512_cmpge_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否大于等于，并将结果存储在掩码 vector k 中。"],["_mm512_cmpge_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否大于等于，并将结果存储在掩码 vector k 中。"],["_mm512_cmpge_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否大于等于，并将结果存储在掩码 vector k 中。"],["_mm512_cmpge_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否大于等于，并将结果存储在掩码 vector k 中。"],["_mm512_cmpge_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否大于等于，并将结果存储在掩码 vector k 中。"],["_mm512_cmpgt_epi16_mask","比较 a 和 b 中包装的带符号 16 位整数是否大于，并将结果存储在掩码 vector k 中。"],["_mm512_cmpgt_epi32_mask","比较 a 和 b 中包装的带符号的 32 位整数是否大于，并将结果存储在掩码 vector k 中。"],["_mm512_cmpgt_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数是否大于，并将结果存储在掩码 vector k 中。"],["_mm512_cmpgt_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否大于，并将结果存储在掩码 vector k 中。"],["_mm512_cmpgt_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否大于，并将结果存储在掩码 vector k 中。"],["_mm512_cmpgt_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否大于，并将结果存储在掩码 vector k 中。"],["_mm512_cmpgt_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否大于，并将结果存储在掩码 vector k 中。"],["_mm512_cmpgt_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否大于，并将结果存储在掩码 vector k 中。"],["_mm512_cmple_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数 (小于等于)，并将结果存储在掩码 vector k 中。"],["_mm512_cmple_epi32_mask","比较 a 和 b 中包装的带符号的 32 位整数 (小于等于)，并将结果存储在掩码 vector k 中。"],["_mm512_cmple_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数 (小于等于)，并将结果存储在掩码 vector k 中。"],["_mm512_cmple_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数 (小于等于)，并将结果存储在掩码 vector k 中。"],["_mm512_cmple_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否小于等于，并将结果存储在掩码 vector k 中。"],["_mm512_cmple_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否小于等于，并将结果存储在掩码 vector k 中。"],["_mm512_cmple_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否小于等于，并将结果存储在掩码 vector k 中。"],["_mm512_cmple_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数以得出小于或等于的结果，并将结果存储在掩码 vector k 中。"],["_mm512_cmple_pd_mask","比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否小于等于，并将结果存储在掩码 vector k 中。"],["_mm512_cmple_ps_mask","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否小于等于，并将结果存储在掩码 vector k 中。"],["_mm512_cmplt_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数 (小于)，并将结果存储在掩码 vector k 中。"],["_mm512_cmplt_epi32_mask","比较 a 和 b 中包装的带符号的 32 位整数 (小于)，并将结果存储在掩码 vector k 中。"],["_mm512_cmplt_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数小于零，并将结果存储在掩码 vector k 中。"],["_mm512_cmplt_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数小于零，并将结果存储在掩码 vector k 中。"],["_mm512_cmplt_epu16_mask","比较 a 和 b 中包装后的无符号 16 位整数 (小于)，并将结果存储在掩码 vector k 中。"],["_mm512_cmplt_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否小于，并将结果存储在掩码 vector k 中。"],["_mm512_cmplt_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否小于，并将结果存储在掩码 vector k 中。"],["_mm512_cmplt_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数以得到小于，并将结果存储在掩码 vector k 中。"],["_mm512_cmplt_pd_mask","比较 a 和 b 中包装后的双精度 (64-bit) 浮点元素的小于，并将结果存储在掩码 vector k 中。"],["_mm512_cmplt_ps_mask","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素的小于，并将结果存储在掩码 vector k 中。"],["_mm512_cmpneq_epi16_mask","比较 a 和 b 中包装的带符号 16 位整数是否不相等，并将结果存储在掩码 vector k 中。"],["_mm512_cmpneq_epi32_mask","比较 a 和 b 中包装的 32 位整数是否不相等，并将结果存储在掩码 vector k 中。"],["_mm512_cmpneq_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数是否不相等，并将结果存储在掩码 vector k 中。"],["_mm512_cmpneq_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否不相等，并将结果存储在掩码 vector k 中。"],["_mm512_cmpneq_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否不相等，并将结果存储在掩码 vector k 中。"],["_mm512_cmpneq_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否不相等，并将结果存储在掩码 vector k 中。"],["_mm512_cmpneq_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否不相等，并将结果存储在掩码 vector k 中。"],["_mm512_cmpneq_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm512_cmpneq_pd_mask","比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否相等，并将结果存储在掩码 vector k 中。"],["_mm512_cmpneq_ps_mask","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否不相等，并将结果存储在掩码 vector k 中。"],["_mm512_cmpnle_pd_mask","比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否等于或小于等于，并将结果存储在掩码 vector k 中。"],["_mm512_cmpnle_ps_mask","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否等于或小于等于，并将结果存储在掩码 vector k 中。"],["_mm512_cmpnlt_pd_mask","比较 a 和 b 中包装的双精度 (64-bit) 浮点元素不小于，并将结果存储在掩码 vector k 中。"],["_mm512_cmpnlt_ps_mask","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素不小于，并将结果存储在掩码 vector k 中。"],["_mm512_cmpord_pd_mask","比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，看是否都不是 NaN，并将结果存储在掩码 vector k 中。"],["_mm512_cmpord_ps_mask","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，看是否都不是 NaN，并将结果存储在掩码 vector k 中。"],["_mm512_cmpunord_pd_mask","比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，以查看其中一个是否为 NaN，并将结果存储在掩码 vector k 中。"],["_mm512_cmpunord_ps_mask","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，以查看是否为 NaN，并将结果存储在掩码 vector k 中。"],["_mm512_conflict_epi32","测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。"],["_mm512_conflict_epi64","测试 a 的每个 64 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。"],["_mm512_cvt_roundepi32_ps","将包装后的带符号的 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_cvt_roundepu32_ps","将 a 中的包装无符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_cvt_roundpd_epi32","将包装的双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并将结果存储在 dst 中。"],["_mm512_cvt_roundpd_epu32","将包装的双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并将结果存储在 dst 中。"],["_mm512_cvt_roundpd_ps","将包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_cvt_roundph_ps","将包装的半精度 (16-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_cvt_roundps_epi32","将包装的单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并将结果存储在 dst 中。"],["_mm512_cvt_roundps_epu32","将包装的单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并将结果存储在 dst 中。"],["_mm512_cvt_roundps_pd","将包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_cvt_roundps_ph","将包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并将结果存储在 dst 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_cvtepi16_epi32","符号将包装的 16 位整数从 a 扩展为包装的 32 位整数，并将结果存储在 dst 中。"],["_mm512_cvtepi16_epi64","使用符号将包装的 16 位整数从 a 扩展到包装的 64 位整数，并将结果存储在 dst 中。"],["_mm512_cvtepi16_epi8","将 a 中的包装的 16 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。"],["_mm512_cvtepi32_epi16","将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并将结果存储在 dst 中。"],["_mm512_cvtepi32_epi64","使用符号将包装的 32 位整数从 a 扩展到包装的 64 位整数，并将结果存储在 dst 中。"],["_mm512_cvtepi32_epi8","将带有 a 的包装的 32 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。"],["_mm512_cvtepi32_pd","将包装后的带符号的 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_cvtepi32_ps","将包装后的带符号的 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_cvtepi32lo_pd","将 v2 中包装的 32 位整数整数元素的下半部分转换为包装的双精度 (64-bit) 浮点元素，将元素进行逐元素转换，并将结果存储在 dst 中。"],["_mm512_cvtepi64_epi16","将带有 a 的包装的 64 位整数转换为带有截断的包装的 16 位整数，并将结果存储在 dst 中。"],["_mm512_cvtepi64_epi32","将带有 a 的包装的 64 位整数转换为带有截断的包装的 32 位整数，并将结果存储在 dst 中。"],["_mm512_cvtepi64_epi8","将带有 a 的包装的 64 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。"],["_mm512_cvtepi8_epi16","使用符号将包装的 8 位整数从 a 扩展到包装的 16 位整数，并将结果存储在 dst 中。"],["_mm512_cvtepi8_epi32","使用符号将包装的 8 位整数从 a 扩展到包装的 32 位整数，并将结果存储在 dst 中。"],["_mm512_cvtepi8_epi64","符号将 a 的低 8 个字节中的包装 8 位整数扩展为包装 64 位整数，并将结果存储在 dst 中。"],["_mm512_cvtepu16_epi32","将 a 中的包装无符号 16 位整数零扩展为包装 32 位整数，并将结果存储在 dst 中。"],["_mm512_cvtepu16_epi64","将 a 中的包装无符号 16 位整数零扩展为包装 64 位整数，并将结果存储在 dst 中。"],["_mm512_cvtepu32_epi64","将 a 中的包装无符号 32 位整数零扩展为包装 64 位整数，并将结果存储在 dst 中。"],["_mm512_cvtepu32_pd","将 A 中的包装的无符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_cvtepu32_ps","将 a 中的包装无符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_cvtepu32lo_pd","将 v2 中包装的 32 位无符号整数整数元素的下半部分转换为包装的双精度 (64-bit) 浮点元素，将每个元素进行逐元素转换，并将结果存储在 dst 中。"],["_mm512_cvtepu8_epi16","将 a 中的包装无符号 8 位整数零扩展为包装 16 位整数，并将结果存储在 dst 中。"],["_mm512_cvtepu8_epi32","将 a 中的包装无符号 8 位整数零扩展为包装 32 位整数，并将结果存储在 dst 中。"],["_mm512_cvtepu8_epi64","将低 8 字节 sof 中的包装无符号 8 位整数零扩展到包装 64 位整数，并将结果存储在 dst 中。"],["_mm512_cvtne2ps_pbh","将两个 512 位 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并将结果存入 a"],["_mm512_cvtneps_pbh","将包装在 a 中的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并将结果存储在 dst 中。 Intel’s documentation"],["_mm512_cvtpd_epi32","将包装的双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并将结果存储在 dst 中。"],["_mm512_cvtpd_epu32","将包装的双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并将结果存储在 dst 中。"],["_mm512_cvtpd_ps","将包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_cvtpd_pslo","将 v2 中的包装的双精度 (64-bit) 浮点元素执行逐元素转换为单精度 (32-bit) 浮点元素并将其存储在 dst 中。元素存储在结果 vector 的下半部分中，而其余的上半部分位置设置为 0。"],["_mm512_cvtph_ps","将包装的半精度 (16-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_cvtps_epi32","将包装的单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并将结果存储在 dst 中。"],["_mm512_cvtps_epu32","将包装的单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并将结果存储在 dst 中。"],["_mm512_cvtps_pd","将包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_cvtps_ph","将包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并将结果存储在 dst 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_cvtpslo_pd","对 v2 中包装的单精度 (32-bit) 浮点元素的下半部分到包装的双精度 (64-bit) 浮点元素的下半部分进行逐元素转换，并将结果存储在 dst 中。"],["_mm512_cvtsepi16_epi8","将 A 中的包装有符号 16 位整数转换为带符号饱和的包装 8 位整数，并将结果存储在 dst 中。"],["_mm512_cvtsepi32_epi16","将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并将结果存储在 dst 中。"],["_mm512_cvtsepi32_epi8","将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并将结果存储在 dst 中。"],["_mm512_cvtsepi64_epi16","将包装的带符号的 64 位整数转换为带符号饱和的包装的 16 位整数，并将结果存储在 dst 中。"],["_mm512_cvtsepi64_epi32","将包装的带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并将结果存储在 dst 中。"],["_mm512_cvtsepi64_epi8","将包装的带符号的 64 位整数转换为带符号饱和的包装的 8 位整数，并将结果存储在 dst 中。"],["_mm512_cvtsi512_si32","将 a 中的低 32 位整数复制到 dst。"],["_mm512_cvtt_roundpd_epi32","将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并将结果存储在 dst 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_cvtt_roundpd_epu32","将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并将结果存储在 dst 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_cvtt_roundps_epi32","将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数，并将结果存储在 dst 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_cvtt_roundps_epu32","将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并将结果存储在 dst 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_cvttpd_epi32","将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并将结果存储在 dst 中。"],["_mm512_cvttpd_epu32","将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并将结果存储在 dst 中。"],["_mm512_cvttps_epi32","将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数，并将结果存储在 dst 中。"],["_mm512_cvttps_epu32","将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并将结果存储在 dst 中。"],["_mm512_cvtusepi16_epi8","将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。"],["_mm512_cvtusepi32_epi16","将 A 中的包装无符号 32 位整数转换为具有无符号饱和度的包装无符号 16 位整数，并将结果存储在 dst 中。"],["_mm512_cvtusepi32_epi8","将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。"],["_mm512_cvtusepi64_epi16","将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并将结果存储在 dst 中。"],["_mm512_cvtusepi64_epi32","将 A 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并将结果存储在 dst 中。"],["_mm512_cvtusepi64_epi8","将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。"],["_mm512_dbsad_epu8","计算 a 中与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs)，并将 16 位结果存储在 dst 中。对于每个 64 位通道，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中通道的低 8 位四元组，而后两个 SAD 使用 a 中通道的较高 8 位四元组。根据 imm8 中的控件，从 128 位通道中选择 b 中的四元组，并且每个 64 位通道中的每个 SAD 使用 8 位偏移量的选定四元组。"],["_mm512_div_pd","将 b 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后将结果存储在 dst 中。"],["_mm512_div_ps","将 b 中的包装的单精度 (32-bit) 浮点元素除以 b 中的包装的元素，然后将结果存储在 dst 中。"],["_mm512_div_round_pd","将 b 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，并将结果存储在 dst 中。"],["_mm512_div_round_ps","将 b 中的包装的单精度 (32-bit) 浮点元素除以 b 中的包装的元素，然后将结果存储在 dst 中。"],["_mm512_dpbf16_ps","计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间单精度 (32-bit) 浮点元素与 src 中的元素累加，结果存储在 BF16 (16-bit) 浮点对的 dst.Compute 点积中 b、将中间的单精度 (32-bit) 浮点元素与 src 中的元素进行累加，并将结果存入 dst。"],["_mm512_dpbusd_epi32","将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果存入 dst。"],["_mm512_dpbusds_epi32","将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。使用有符号饱和将这 4 个结果与 src 中相应的 32 位整数相加，并将包装的 32 位结果存储在 dst 中。"],["_mm512_dpwssd_epi32","将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果存入 dst。"],["_mm512_dpwssds_epi32","将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并将包装的 32 位结果存储在 dst 中。"],["_mm512_extractf32x4_ps","从 a 提取 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并用 imm8 进行选择，并将结果存储在 dst 中。"],["_mm512_extractf64x4_pd","从 a 提取 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成)，并用 imm8 进行选择，并将结果存储在 dst 中。"],["_mm512_extracti32x4_epi32","从 a 中提取 128 位 (由 4 个包装的 32 位整数组成)，用 IMM2 选中，结果存入 dst。"],["_mm512_extracti64x4_epi64","从 a 中提取 256 位 (由 4 个包装的 64 位整数组成)，用 IMM1 选择，并将结果存储在 dst 中。"],["_mm512_fixupimm_pd","使用 c 中的包装的 64 位整数修复 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。imm8 用于设置所需的标志报告。"],["_mm512_fixupimm_ps","使用 c 中的包装 32 位整数修复 a 和 b 中包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。imm8 用于设置所需的标志报告。"],["_mm512_fixupimm_round_pd","使用 c 中的包装的 64 位整数修复 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。imm8 用于设置所需的标志报告。"],["_mm512_fixupimm_round_ps","使用 c 中的包装 32 位整数修复 a 和 b 中包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。imm8 用于设置所需的标志报告。"],["_mm512_fmadd_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并将结果存储在 dst 中。"],["_mm512_fmadd_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并将结果存储在 dst 中。"],["_mm512_fmadd_round_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并将结果存储在 dst 中。"],["_mm512_fmadd_round_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并将结果存储在 dst 中。"],["_mm512_fmaddsub_pd","在 a 和 b 中乘以包装的双精度 (64-bit) 浮点元素，或者在中间结果中乘以 c to/from 的包装的元素，然后将结果存储在 dst 中。"],["_mm512_fmaddsub_ps","将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，或者将 c to/from 中的包装的元素相加或相减，得到中间结果，并将结果存储在 dst 中。"],["_mm512_fmaddsub_round_pd","在 a 和 b 中乘以包装的双精度 (64-bit) 浮点元素，或者在中间结果中乘以 c to/from 的包装的元素，然后将结果存储在 dst 中。"],["_mm512_fmaddsub_round_ps","将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，或者将 c to/from 中的包装的元素相加或相减，得到中间结果，并将结果存储在 dst 中。"],["_mm512_fmsub_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并将结果存储在 dst 中。"],["_mm512_fmsub_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并将结果存储在 dst 中。"],["_mm512_fmsub_round_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并将结果存储在 dst 中。"],["_mm512_fmsub_round_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并将结果存储在 dst 中。"],["_mm512_fmsubadd_pd","将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 c from/to 中的包装后的元素相减并相加，然后将结果存储在 dst 中。"],["_mm512_fmsubadd_ps","将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，或者将 c from/to 中的包装的元素相减并相加，得到中间结果，并将结果存储在 dst 中。"],["_mm512_fmsubadd_round_pd","将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 c from/to 中的包装后的元素相减并相加，然后将结果存储在 dst 中。"],["_mm512_fmsubadd_round_ps","将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，或者将 c from/to 中的包装的元素相减并相加，得到中间结果，并将结果存储在 dst 中。"],["_mm512_fnmadd_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，然后将结果存储在 dst 中。"],["_mm512_fnmadd_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，然后将结果存储在 dst 中。"],["_mm512_fnmadd_round_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，然后将结果存储在 dst 中。"],["_mm512_fnmadd_round_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，然后将结果存储在 dst 中。"],["_mm512_fnmsub_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装的元素，并将结果存储在 dst 中。"],["_mm512_fnmsub_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，然后将结果存储在 dst 中。"],["_mm512_fnmsub_round_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装的元素，并将结果存储在 dst 中。"],["_mm512_fnmsub_round_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，然后将结果存储在 dst 中。"],["_mm512_getexp_pd","将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并将结果存储在 dst 中。本质上，此内联函数为每个元素计算 floor(log2(x))。"],["_mm512_getexp_ps","将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，并将结果存储在 dst 中。本质上，此内联函数为每个元素计算 floor(log2(x))。"],["_mm512_getexp_round_pd","将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并将结果存储在 dst 中。本质上，此内联函数为每个元素计算 floor(log2(x))。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_getexp_round_ps","将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，并将结果存储在 dst 中。本质上，此内联函数为每个元素计算 floor(log2(x))。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_getmant_pd","将 a 中的包装的双精度 (64-bit) 浮点元素的尾数规格化，并将结果存储在 dst 中。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1"],["_mm512_getmant_ps","将 a 中的包装的单精度 (32-bit) 浮点元素的尾数标准化，并将结果存储在 dst 中。 此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) The sign is determined by sc which can take the following values:"],["_mm512_getmant_round_pd","将 a 中的包装的双精度 (64-bit) 浮点元素的尾数规格化，并将结果存储在 dst 中。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_getmant_round_ps","将 a 中的包装的单精度 (32-bit) 浮点元素的尾数标准化，并将结果存储在 dst 中。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_gf2p8affine_epi64_epi8","对 x 中的包装字节执行仿射变换。 也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。"],["_mm512_gf2p8affineinv_epi64_epi8","对 x 中的反向包装的字节执行仿射变换。 也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。"],["_mm512_gf2p8mul_epi8","在包装的字节上执行 GF(2^8) 乘法。 该字段以多项式表示，具有约数多项式 x^8 + x^4 + x^3 + x + 1。"],["_mm512_i32gather_epi32","使用 32 位索引从内存中收集 32 位整数。从 base_addr 开始的地址加载 32 位元素，并由 vindex 中的每个 32 位元素偏移 (每个索引均按比例因子进行缩放)。收集的元素将合并到 dst 中。小数位数应为 1、2、4 或 8。"],["_mm512_i32gather_epi64","使用 32 位索引从内存中收集 64 位整数。从 base_addr 开始的地址加载 64 位元素，并由 vindex 中的每个 32 位元素偏移 (每个索引均按比例因子进行缩放)。收集的元素将合并到 dst 中。小数位数应为 1、2、4 或 8。"],["_mm512_i32gather_pd","使用 32 位索引从内存中收集双精度 (64-bit) 浮点元素。从 base_addr 开始的地址加载 64 位元素，并由 vindex 中的每个 32 位元素偏移 (每个索引均按比例因子进行缩放)。收集的元素将合并到 dst 中。小数位数应为 1、2、4 或 8。"],["_mm512_i32gather_ps","使用 32 位索引从内存中收集单精度 (32-bit) 浮点元素。从 base_addr 开始的地址加载 32 位元素，并由 vindex 中的每个 32 位元素偏移 (每个索引均按比例因子进行缩放)。收集的元素将合并到 dst 中。小数位数应为 1、2、4 或 8。"],["_mm512_i32scatter_epi32","使用 32 位索引将 32 位整数从 a 分散到内存中。32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 32 位元素偏移 (每个索引都按比例因子进行缩放)。小数位数应为 1、2、4 或 8。"],["_mm512_i32scatter_epi64","使用 32 位索引将 64 位整数从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 32 位元素偏移 (每个索引都按比例因子进行缩放)。小数位数应为 1、2、4 或 8。"],["_mm512_i32scatter_pd","使用 32 位索引将双精度 (64-bit) 浮点元素从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 32 位元素偏移 (每个索引都按比例因子进行缩放)。小数位数应为 1、2、4 或 8。"],["_mm512_i32scatter_ps","使用 32 位索引将单精度 (32-bit) 浮点元素从 a 分散到内存中。32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 32 位元素偏移 (每个索引都按比例因子进行缩放)。小数位数应为 1、2、4 或 8。"],["_mm512_i64gather_epi32","使用 64 位索引从内存中收集 32 位整数。从 base_addr 开始的地址加载 32 位元素，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)。收集的元素将合并到 dst 中。小数位数应为 1、2、4 或 8。"],["_mm512_i64gather_epi64","使用 64 位索引从内存中收集 64 位整数。从 base_addr 开始的地址加载 64 位元素，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)。收集的元素将合并到 dst 中。小数位数应为 1、2、4 或 8。"],["_mm512_i64gather_pd","使用 64 位索引从内存中收集双精度 (64-bit) 浮点元素。从 base_addr 开始的地址加载 64 位元素，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)。收集的元素将合并到 dst 中。小数位数应为 1、2、4 或 8。"],["_mm512_i64gather_ps","使用 64 位索引从内存中收集单精度 (32-bit) 浮点元素。从 base_addr 开始的地址加载 32 位元素，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)。收集的元素将合并到 dst 中。小数位数应为 1、2、4 或 8。"],["_mm512_i64scatter_epi32","使用 64 位索引将 32 位整数从 a 分散到内存中。32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)。小数位数应为 1、2、4 或 8。"],["_mm512_i64scatter_epi64","使用 64 位索引将 64 位整数从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)。小数位数应为 1、2、4 或 8。"],["_mm512_i64scatter_pd","使用 64 位索引将双精度 (64-bit) 浮点元素从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)。小数位数应为 1、2、4 或 8。"],["_mm512_i64scatter_ps","使用 64 位索引将单精度 (32-bit) 浮点元素从 a 分散到内存中。32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)，且受掩码 k 限制 (未设置相应的掩码位时不存储元素)。小数位数应为 1、2、4 或 8。"],["_mm512_insertf32x4","将 a 复制到 dst，然后在 x00X 指定的位置将 d 的 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成) 插入 dst。"],["_mm512_insertf64x4","将 a 复制到 dst，然后在 x00X 指定的位置将 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成) 插入 dst。"],["_mm512_inserti32x4","将 a 复制到 dst，然后在 x00X 指定的位置将 d 的 128 位 (由 4 个包装的 32 位整数组成) 插入 dst。"],["_mm512_inserti64x4","将 a 复制到 dst，然后在 imm8 指定的位置将 256 位 (由 4 个包装的 64 位整数组成) 插入 dst。"],["_mm512_int2mask","将整数掩码转换为位掩码，并将结果存储在 dst 中。"],["_mm512_kand","计算 16 位掩码 a 和 b 的按位与，并将结果存储在 k 中。"],["_mm512_kandn","计算 16 位掩码 a 的按位非，然后与 b 计算 AND，并将结果存储在 k 中。"],["_mm512_kmov","将 16 位掩码 a 复制到 k。"],["_mm512_knot","计算 16 位掩码 a 的按位非，并将结果存储在 k 中。"],["_mm512_kor","计算 16 位掩码 a 和 b 的按位或，并将结果存储在 k 中。"],["_mm512_kortestc","在 k1 和 k2 之间执行按位或运算，将结果存储在 dst 中。如果 dst 全为 1，则设置 CF 标志。"],["_mm512_kunpackb","从掩码 a 和 b 解包并交织 8 位，并将 16 位结果存储在 k 中。"],["_mm512_kxnor","计算 16 位掩码 a 和 b 的按位 XNOR，并将结果存储在 k 中。"],["_mm512_kxor","计算 16 位掩码 a 和 b 的按位 XOR，并将结果存储在 k 中。"],["_mm512_load_epi32","将 512 位 (由 16 个包装的 32 位整数组成) 从 dst 加载。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。"],["_mm512_load_epi64","将 512 位 (由 8 个包装的 64 位整数组成) 从 dst 加载。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。"],["_mm512_load_pd","将 512 位 (由 8 个包装的双精度 (64-bit) 浮点元素组成) 从 dst 加载。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。"],["_mm512_load_ps","将 512 位 (由 16 个包装的单精度 (32-bit) 浮点元素组成) 从 dst 加载。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。"],["_mm512_load_si512","将 512 位整数数据从内存加载到 dst 中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。"],["_mm512_loadu_epi16","将 512 位 (由 32 个包装的 16 位整数组成) 从 dst 加载。mem_addr 不需要在任何特定边界上对齐。"],["_mm512_loadu_epi32","将 512 位 (由 16 个包装的 32 位整数组成) 从 dst 加载。mem_addr 不需要在任何特定边界上对齐。"],["_mm512_loadu_epi64","将 512 位 (由 8 个包装的 64 位整数组成) 从 dst 加载。mem_addr 不需要在任何特定边界上对齐。"],["_mm512_loadu_epi8","将 512 位 (由 64 个包装的 8 位整数组成) 从 dst 加载。mem_addr 不需要在任何特定边界上对齐。"],["_mm512_loadu_pd","从内存中加载 512 位 (由 8 个包装的双精度 (64-bit) 浮点元素组成) 到结果中。"],["_mm512_loadu_ps","从内存中将 512 位 (由 16 个包装的单精度 (32-bit) 浮点元素组成) 加载到结果中。"],["_mm512_loadu_si512","将 512 位整数数据从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。"],["_mm512_lzcnt_epi32","计算 a 中每个包装的 32 位整数中前导零位的数目，并将结果存储在 dst 中。"],["_mm512_lzcnt_epi64","计算 a 中每个包装的 64 位整数中前导零位的数目，并将结果存储在 dst 中。"],["_mm512_madd52hi_epu64","将 `b` 和 `c` 的每个 64 位元素中的包装无符号 52 位整数相乘以形成 104 位中间结果。 将中间结果的高 52 位无符号整数与 `a` 中的相应无符号 64 位整数相加，并将结果存储在 `dst` 中。"],["_mm512_madd52lo_epu64","将 `b` 和 `c` 的每个 64 位元素中的包装无符号 52 位整数相乘以形成 104 位中间结果。 将中间结果的低 52 位无符号整数与 `a` 中的相应无符号 64 位整数相加，并将结果存储在 `dst` 中。"],["_mm512_madd_epi16","在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。将相邻的 32 位中间整数对水平相加，并将结果打包到 dst 中。"],["_mm512_maddubs_epi16","将 a 中的每个无符号 8 位整数与 b 中对应的有符号 8 位整数垂直相乘，生成中间有符号的 16 位整数。水平相加相邻的中间带符号的 16 位整数对，并将饱和结果包装到 dst 中。"],["_mm512_mask2_permutex2var_epi16","使用相应的选择器和 idx 中的索引在通道中的 a 和 b 中对 16 位整数进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 idx 复制元素)。"],["_mm512_mask2_permutex2var_epi32","使用相应的选择器和 idx 中的索引在通道中的 a 和 b 中对 32 位整数进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 idx 复制元素)。"],["_mm512_mask2_permutex2var_epi64","使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中随机排列 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 idx 复制元素)。"],["_mm512_mask2_permutex2var_epi8","使用相应的选择器和 idx 中的索引将 a 和 b 中的 8 位整数跨通道打乱，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。"],["_mm512_mask2_permutex2var_pd","使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 idx 复制元素)"],["_mm512_mask2_permutex2var_ps","使用 idx 中的对应选择器和索引在 a 和 b 中的通道中对 a 和 b 中的单精度 (32-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 idx 复制元素)。"],["_mm512_mask2int","将位掩码 k1 转换为整数值，并将结果存储在 dst 中。"],["_mm512_mask3_fmadd_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 c 复制元素)。"],["_mm512_mask3_fmadd_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。"],["_mm512_mask3_fmadd_round_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 c 复制元素)。"],["_mm512_mask3_fmadd_round_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。"],["_mm512_mask3_fmaddsub_pd","在 a 和 b 中分别乘以包装的单精度 (32-bit) 浮点元素，或者在 to/from 中将中间结果乘以包装的元素加减乘以 x，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 c 复制元素) 放)。"],["_mm512_mask3_fmaddsub_ps","在 a 和 b 中分别乘以包装的单精度 (32-bit) 浮点元素，或者在 to/from 中将中间结果乘以包装的元素加减乘以 x，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 c 复制元素) 放)。"],["_mm512_mask3_fmaddsub_round_pd","在 a 和 b 中分别乘以包装的单精度 (32-bit) 浮点元素，或者在 to/from 中将中间结果乘以包装的元素加减乘以 x，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 c 复制元素) 放)。"],["_mm512_mask3_fmaddsub_round_ps","在 a 和 b 中分别乘以包装的单精度 (32-bit) 浮点元素，或者在 to/from 中将中间结果乘以包装的元素加减乘以 x，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 c 复制元素) 放)。"],["_mm512_mask3_fmsub_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。"],["_mm512_mask3_fmsub_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。"],["_mm512_mask3_fmsub_round_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。"],["_mm512_mask3_fmsub_round_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。"],["_mm512_mask3_fmsubadd_pd","将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，并使用 writemask k 将结果存储在 dst 中 (当未使用相应的 mask 位时从 c 复制元素) 放)。"],["_mm512_mask3_fmsubadd_ps","在 a 和 b 中乘以包装的单精度 (32-bit) 浮点元素，或者在中间结果中减去并在 c from/to 中包装的元素相乘，然后使用 writemask k 将结果存储在 dst 中 (当未使用相应的 mask 位时从 c 复制元素) 放)。"],["_mm512_mask3_fmsubadd_round_pd","将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，并使用 writemask k 将结果存储在 dst 中 (当未使用相应的 mask 位时从 c 复制元素) 放)。"],["_mm512_mask3_fmsubadd_round_ps","在 a 和 b 中乘以包装的单精度 (32-bit) 浮点元素，或者在中间结果中减去并在 c from/to 中包装的元素相乘，然后使用 writemask k 将结果存储在 dst 中 (当未使用相应的 mask 位时从 c 复制元素) 放)。"],["_mm512_mask3_fnmadd_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 c 复制元素)。"],["_mm512_mask3_fnmadd_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 c 复制)。"],["_mm512_mask3_fnmadd_round_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 c 复制元素)。"],["_mm512_mask3_fnmadd_round_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 c 复制)。"],["_mm512_mask3_fnmsub_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 c 复制元素)。"],["_mm512_mask3_fnmsub_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 c 复制元素)。"],["_mm512_mask3_fnmsub_round_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 c 复制元素)。"],["_mm512_mask3_fnmsub_round_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 c 复制元素)。"],["_mm512_mask_abs_epi16","计算 a 中包装的带符号的 16 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_abs_epi32","计算 `a` 中包装的 32 位整数的绝对值，并使用写掩码 `k` 将无符号结果存储在 `dst` 中 (如果未设置相应的掩码位，则从 `src` 复制元素)。"],["_mm512_mask_abs_epi64","计算 a 中包装的带符号的 64 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_abs_epi8","计算 a 中包装的带符号的 8 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_abs_pd","查找 v2 中每个包装的双精度 (64-bit) 浮点元素的绝对值，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_abs_ps","查找 v2 中每个包装的单精度 (32-bit) 浮点元素的绝对值，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_add_epi16","在 a 和 b 中添加包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_add_epi32","在 a 和 b 中添加包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_add_epi64","在 a 和 b 中添加包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_add_epi8","在 a 和 b 中添加包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_add_pd","在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_add_ps","在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_add_round_pd","在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_add_round_ps","在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_adds_epi16","使用饱和度在 a 和 b 中添加包装的带符号的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_adds_epi8","使用饱和度在 a 和 b 中添加包装的带符号的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_adds_epu16","使用饱和度在 a 和 b 中添加包装的无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_adds_epu8","使用饱和度在 a 和 b 中添加包装的无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_alignr_epi32","将 a 和 b 连接成一个 128 字节的立即结果，将结果右移 imm8 32 位元素，并使用写掩码 k 将低 64 字节 (16 个元素) 存储在 dst 中 (当相应的掩码位为 1 时，元素从 src 复制) 没有设置)。"],["_mm512_mask_alignr_epi64","将 a 和 b 连接成一个 128 字节的立即结果，将结果右移 imm8 64 位元素，并使用写掩码 k 将低 64 字节 (8 个元素) 存储在 dst 中 (当相应的掩码位为 1 时，元素从 src 复制) 没有设置)。"],["_mm512_mask_alignr_epi8","将 a 和 b 中的 16 字节块对连接成 32 字节的临时结果，将结果右移 imm8 字节，并使用写掩码 k 将低 16 个字节存储在 dst 中 (当相应的掩码位为 1 时，元素从 src 复制没有设置)。"],["_mm512_mask_and_epi32","在包装的 a 和 b 的 32 位整数元素之间执行逐个元素的按位 AND，使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm512_mask_and_epi64","计算 a 和 b 中包装的 64 位整数的按位与，并使用写掩码 k 将结果存储在 dst 中 (如果未设置相应的掩码位，则从 src 复制元素)。"],["_mm512_mask_andnot_epi32","计算 a 中包装的 32 位整数的按位 NOT，然后与 b 计算 AND，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_andnot_epi64","计算 a 中包装的 64 位整数的按位 NOT，然后与 b 计算 AND，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_avg_epu16","将 a 和 b 中包装的无符号 16 位整数进行平均，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_avg_epu8","将 a 和 b 中包装的无符号 8 位整数平均，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_bitshuffle_epi64_mask","将输入 `b` 视为包装的 64 位整数，并将 `c` 视为包装的 8 位整数。 然后将来自 `c` 的 8 个 8 位值作为索引分组到相应的 64 位整数的位中。 然后，选择这些位并将其包装到输出中。"],["_mm512_mask_blend_epi16","使用控制掩码 k 混合来自 a 和 b 的包装的 16 位整数，并将结果存储在 dst 中。"],["_mm512_mask_blend_epi32","使用控制掩码 k 混合 a 和 b 中的包装 32 位整数，并将结果存储在 dst 中。"],["_mm512_mask_blend_epi64","使用控制掩码 k 混合 a 和 b 中的包装 64 位整数，并将结果存储在 dst 中。"],["_mm512_mask_blend_epi8","使用控制掩码 k 混合 a 和 b 中的包装 8 位整数，并将结果存储在 dst 中。"],["_mm512_mask_blend_pd","使用控制掩码 k 混合来自 a 和 b 的包装后的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_mask_blend_ps","使用控制掩码 k 混合来自 a 和 b 的包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_mask_broadcast_f32x4","使用写掩码 k 将 4 个包装的单精度 (32-bit) 浮点元素从 a 广播到 dst 的所有元素 (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm512_mask_broadcast_f64x4","使用写掩码 k 将 4 个包装的双精度 (64-bit) 浮点元素从 a 广播到 dst 的所有元素 (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm512_mask_broadcast_i32x4","使用写掩码 k 将 a 的 4 个包装的 32 位整数广播到 dst 的所有元素 (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm512_mask_broadcast_i64x4","使用写掩码 k 将 a 的 4 个包装的 64 位整数广播到 dst 的所有元素 (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm512_mask_broadcastb_epi8","使用写掩码 k 将 d 的低包装的 8 位整数广播到 dst 的所有元素 (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm512_mask_broadcastd_epi32","使用写掩码 k 将低包装的 32 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_broadcastq_epi64","使用写掩码 k 将低包装的 64 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_broadcastsd_pd","使用写掩码 k 将低双精度 (64-bit) 浮点型元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将从 src 复制元素)。"],["_mm512_mask_broadcastss_ps","使用写掩码 k 将低单精度 (32-bit) 浮点型元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将元素从 src 复制)。"],["_mm512_mask_broadcastw_epi16","使用写掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm512_mask_cmp_epi16_mask","根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmp_epi32_mask","根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 32 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_mask_cmp_epi64_mask","根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_mask_cmp_epi8_mask","根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmp_epu16_mask","根据 imm8 指定的比较操作数比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmp_epu32_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 32 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmp_epu64_mask","根据 imm8 指定的比较操作数比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmp_epu8_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 8 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_mask_cmp_pd_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_mask_cmp_ps_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_mask_cmp_round_pd_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_mask_cmp_round_ps_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_mask_cmpeq_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数是否相等，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpeq_epi32_mask","比较 a 和 b 中包装的 32 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_mask_cmpeq_epi64_mask","比较 a 和 b 中包装的 64 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpeq_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpeq_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpeq_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpeq_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpeq_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpeq_pd_mask","比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpeq_ps_mask","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpge_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpge_epi32_mask","比较 a 和 b 中包装的带符号的 32 位整数是否等于或大于等于，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpge_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpge_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpge_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否大于等于，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpge_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpge_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpge_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpgt_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpgt_epi32_mask","比较 a 和 b 中包装的带符号的 32 位整数是否大于，并将结果使用零掩码 k1 存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpgt_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpgt_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpgt_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpgt_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpgt_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpgt_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmple_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数 (小于或等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_mask_cmple_epi32_mask","比较 a 和 b 中包装的带符号的 32 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmple_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数 (小于等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_mask_cmple_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmple_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmple_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmple_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmple_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmple_pd_mask","比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmple_ps_mask","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmplt_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmplt_epi32_mask","比较 a 和 b 中包装的带符号的 32 位整数 (小于或等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_mask_cmplt_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmplt_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmplt_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数以得到小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmplt_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmplt_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmplt_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmplt_pd_mask","比较 a 和 b 中包装的双精度 (64-bit) 浮点元素的小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_mask_cmplt_ps_mask","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_mask_cmpneq_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpneq_epi32_mask","比较 a 和 b 中包装的 32 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpneq_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm512_mask_cmpneq_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_mask_cmpneq_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpneq_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpneq_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpneq_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpneq_pd_mask","比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_mask_cmpneq_ps_mask","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否相等，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_mask_cmpnle_pd_mask","比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否等于或小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpnle_ps_mask","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否等于或小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpnlt_pd_mask","比较 a 和 b 中包装的双精度 (64-bit) 浮点元素是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_mask_cmpnlt_ps_mask","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_mask_cmpord_pd_mask","比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，看是否都不是 NaN，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_mask_cmpord_ps_mask","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，看是否都不是 NaN，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_mask_cmpunord_pd_mask","比较 a 和 b 中包装的双精度 (64-bit) 浮点元素以查看是否为 NaN，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_mask_cmpunord_ps_mask","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，看是否为 NaN，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_mask_compress_epi16","将 a 中的活动 16 位整数 (它们各自的位设置在写掩码 k 中) 连续存储到 dst，并通过 src 中的其余元素。"],["_mm512_mask_compress_epi32","将活动的 32 位整数连续存储在 dst 中 (它们各自的位在写掩码 k 中设置的整数) 到 dst，并通过 src 中的其余元素。"],["_mm512_mask_compress_epi64","将活动的 64 位整数连续存储在 dst 中 (它们各自的位在写掩码 k 中设置的整数) 到 dst，并通过 src 中的其余元素。"],["_mm512_mask_compress_epi8","将 a 中的活动 8 位整数 (它们各自的位设置在写掩码 k 中) 连续存储到 dst，并通过 src 中的其余元素。"],["_mm512_mask_compress_pd","将活动的双精度 (64-bit) 浮点元素连续存储在 dst 中 (它们各自的位在写掩码 k 中设置) 到 dst，并通过 src 中的其余元素。"],["_mm512_mask_compress_ps","将活动的单精度 (32-bit) 浮点元素连续存储在 dst 中 (将其各自的位设置在写掩码 k 中的那些元素中) 存储到 dst，并通过 src 中的其余元素。"],["_mm512_mask_conflict_epi32","使用写掩码 k (在未设置相应的掩码位时从 src 复制元素)，测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。"],["_mm512_mask_conflict_epi64","使用写掩码 k 测试 a 的每个 64 位元素是否与所有其他元素相等 (更接近最低有效位) (当未设置相应的掩码位时，从 src 复制元素)。每个元素的比较在 dst 中形成零扩展位 vector。"],["_mm512_mask_cvt_roundepi32_ps","将 a 中的包装有符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_cvt_roundepu32_ps","将 a 中的包装无符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_cvt_roundpd_epi32","将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_cvt_roundpd_epu32","将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_cvt_roundpd_ps","将 a 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_cvt_roundph_ps","将 a 中的包装后的半精度 (16-bit) 浮点元素转换为包装后的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_mask_cvt_roundps_epi32","将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_cvt_roundps_epu32","将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_cvt_roundps_pd","将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_mask_cvt_roundps_ph","将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_mask_cvtepi16_epi32","符号将包装后的 16 位整数从 a 扩展为包装后的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtepi16_epi64","使用符号将包装的 16 位整数从 a 扩展为包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtepi16_epi8","将带有 a 的包装的 16 位整数转换为带截断的 8 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtepi16_storeu_epi8","将 a 中的包装的 16 位整数转换为带有截断的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。"],["_mm512_mask_cvtepi32_epi16","将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtepi32_epi64","使用符号将包装的 32 位整数从 a 扩展为包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtepi32_epi8","将带有 a 的包装的 32 位整数转换为带截断的包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtepi32_pd","将 a 中的包装有符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_cvtepi32_ps","将 a 中的包装有符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_cvtepi32_storeu_epi16","将 a 中的包装的 32 位整数转换为带截断的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm512_mask_cvtepi32_storeu_epi8","将包装的 32 位整数在 a 中转换为带有截断的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。"],["_mm512_mask_cvtepi32lo_pd","将 v2 中包装的 32 位整数整数元素的下半部分转换为包装的双精度 (64-bit) 浮点元素，进行逐元素转换，并使用 writemask k 将结果存储在 dst 中 (当相应的 mask 位为 src 时，会复制这些元素未设置)。"],["_mm512_mask_cvtepi64_epi16","将 a 中的包装的 64 位整数转换为带截断的 16 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtepi64_epi32","将 a 中的包装的 64 位整数转换为带截断的 32 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtepi64_epi8","将 a 中的包装的 64 位整数转换为带有截断的包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtepi64_storeu_epi16","将 a 中的包装的 64 位整数转换为带截断的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm512_mask_cvtepi64_storeu_epi32","将 a 中的包装的 64 位整数转换为带截断的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm512_mask_cvtepi64_storeu_epi8","将 a 中包装的 64 位整数转换为包装的 8 位整数并截断，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 的未对齐内存中。"],["_mm512_mask_cvtepi8_epi16","使用符号将包装的 8 位整数从 a 扩展为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtepi8_epi32","符号将包装的 8 位整数从 a 扩展为包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtepi8_epi64","符号将 a 的低 8 个字节中的包装 8 位整数扩展为包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtepu16_epi32","将 a 中的包装无符号 16 位整数零扩展为包装 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtepu16_epi64","将 a 中的包装无符号 16 位整数零扩展为包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtepu32_epi64","将 a 中的包装无符号 32 位整数零扩展为包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtepu32_pd","将 a 中的包装无符号 32 位整数转换为包装双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_cvtepu32_ps","将 a 中的包装无符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_cvtepu32lo_pd","将 v2 中 32 位无符号整数元素的下半部分转换为包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中，使用 writemask k (当相应的 mask 位为 src 时，复制这些元素) 未设置)。"],["_mm512_mask_cvtepu8_epi16","将 a 中的包装无符号 8 位整数零扩展为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtepu8_epi32","将 a 中的包装无符号 8 位整数零扩展为包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtepu8_epi64","将 a 的低 8 个字节中的包装无符号 8 位整数零扩展为包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtne2ps_pbh","将两个 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 writemask k 将结果存储在单个 vector dst 中 (当对应的掩码位为没有设置)。"],["_mm512_mask_cvtneps_pbh","将包装在 a 中的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。"],["_mm512_mask_cvtpd_epi32","将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_cvtpd_epu32","将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_cvtpd_ps","将 a 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_cvtpd_pslo","将 v2 中的包装的双精度 (64-bit) 浮点元素转换为单精度 (32-bit) 浮点元素，将其逐个元素转换，并使用 writemask k 将它们存储在 dst 中 (如果没有相应的 mask 位，则从 src 复制元素放)。元素存储在结果 vector 的下半部分中，而其余的上半部分位置设置为 0。"],["_mm512_mask_cvtph_ps","将 a 中的包装后的半精度 (16-bit) 浮点元素转换为包装后的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_cvtps_epi32","将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_cvtps_epu32","将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_cvtps_pd","将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_cvtps_ph","将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_mask_cvtpslo_pd","将 v2 中包装的单精度 (32-bit) 浮点元素的下半部分转换为包装的双精度 (64-bit) 浮点元素的下半部分进行逐元素转换，并使用写掩码 k 将结果存储在 dst 中 (当相应的屏蔽位未设置)。"],["_mm512_mask_cvtsepi16_epi8","将 a 中的包装带符号的 16 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtsepi16_storeu_epi8","将包装在 a 中的有符号 16 位整数转换为有符号饱和的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。"],["_mm512_mask_cvtsepi32_epi16","将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtsepi32_epi8","将 a 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtsepi32_storeu_epi16","将包装在 a 中的有符号 32 位整数转换为具有符号饱和的包装的 16 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。"],["_mm512_mask_cvtsepi32_storeu_epi8","将包装在 a 中的有符号 32 位整数转换为具有符号饱和的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。"],["_mm512_mask_cvtsepi64_epi16","将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtsepi64_epi32","将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtsepi64_epi8","将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtsepi64_storeu_epi16","将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm512_mask_cvtsepi64_storeu_epi32","将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm512_mask_cvtsepi64_storeu_epi8","将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm512_mask_cvtt_roundpd_epi32","将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_mask_cvtt_roundpd_epu32","将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_mask_cvtt_roundps_epi32","将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_mask_cvtt_roundps_epu32","将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_mask_cvttpd_epi32","将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_cvttpd_epu32","将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvttps_epi32","将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_cvttps_epu32","将 a 中的包装的双精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtusepi16_epi8","将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtusepi16_storeu_epi8","将包装在 a 中的无符号 16 位整数转换为具有无符号饱和的包装的无符号 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm512_mask_cvtusepi32_epi16","将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtusepi32_epi8","将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_cvtusepi32_storeu_epi16","将包装在 a 中的无符号 32 位整数转换为具有无符号饱和的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm512_mask_cvtusepi32_storeu_epi8","将包装在 a 中的无符号 32 位整数转换为具有无符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm512_mask_cvtusepi64_epi16","将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_cvtusepi64_epi32","将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_cvtusepi64_epi8","将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_cvtusepi64_storeu_epi16","将包装在 a 中的无符号 64 位整数转换为具有无符号饱和的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm512_mask_cvtusepi64_storeu_epi32","将包装的无符号 64 位整数在 a 中转换为具有无符号饱和的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm512_mask_cvtusepi64_storeu_epi8","将包装的无符号 64 位整数在 a 中转换为具有无符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 的未对齐内存中。"],["_mm512_mask_dbsad_epu8","计算 a 中的无符号 8 位整数与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs)，并使用写掩码 k 将 16 位结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。对于每个 64 位通道，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中通道的低 8 位四元组，而后两个 SAD 使用 a 中通道的较高 8 位四元组。根据 imm8 中的控件，从 128 位通道中选择 b 中的四元组，并且每个 64 位通道中的每个 SAD 使用 8 位偏移量的选定四元组。"],["_mm512_mask_div_pd","将 a 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_div_ps","将 a 中的包装的单精度 (32-bit) 浮点元素除以 b 中的包装的元素，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_div_round_pd","将 a 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_div_round_ps","将 a 中的包装的单精度 (32-bit) 浮点元素除以 b 中的包装的元素，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_dpbf16_ps","计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间的单精度 (32-bit) 浮点元素与 src 中的元素相加，并使用 writemask k 将结果存储在 dst 中 (当对应的元素从 src 复制时掩码位未设置)。"],["_mm512_mask_dpbusd_epi32","将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (未设置相应掩码位时从 src 复制元素)。"],["_mm512_mask_dpbusds_epi32","将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。使用符号饱和将这 4 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm512_mask_dpwssd_epi32","将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。"],["_mm512_mask_dpwssds_epi32","将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。"],["_mm512_mask_expand_epi16","从 a 加载连续的活动 16 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm512_mask_expand_epi32","从 a 加载连续的有效 32 位整数 (它们各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_expand_epi64","从 a 加载连续的有效 64 位整数 (它们各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_expand_epi8","从 a 加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm512_mask_expand_pd","从 a 加载连续的活动双精度 (64-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_expand_ps","从 a 中加载连续的活动单精度 (32-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm512_mask_extractf32x4_ps","从 a 提取 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并用 imm8 进行选择，并使用写掩码 k 将结果存储在 dst 中 (如果未设置相应的掩码位，则从 src 复制元素)。"],["_mm512_mask_extractf64x4_pd","从 a 提取 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成)，并用 imm8 进行选择，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_extracti32x4_epi32","从 a 中提取 128 位 (由 4 个包装的 32 位整数组成)，用 IMM2 选中，用 writemask k 将结果存入 dst 中 (未设置相应掩码位时从 src 复制元素)。"],["_mm512_mask_extracti64x4_epi64","从 a 中提取 256 位 (由 4 个包装的 64 位整数组成)，用 IMM1 选中，用 writemask k 将结果存入 dst (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm512_mask_fixupimm_pd","使用 c 中的包装 64 位整数修复 a 和 b 中的包装双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 a 复制元素)。imm8 用于设置所需的标志报告。"],["_mm512_mask_fixupimm_ps","使用 c 中的包装 32 位整数修复 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 a 复制元素)。imm8 用于设置所需的标志报告。"],["_mm512_mask_fixupimm_round_pd","使用 c 中的包装 64 位整数修复 a 和 b 中的包装双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 a 复制元素)。imm8 用于设置所需的标志报告。"],["_mm512_mask_fixupimm_round_ps","使用 c 中的包装 32 位整数修复 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 a 复制元素)。imm8 用于设置所需的标志报告。"],["_mm512_mask_fmadd_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 a 复制元素)。"],["_mm512_mask_fmadd_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 a 复制元素)。"],["_mm512_mask_fmadd_round_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 a 复制元素)。"],["_mm512_mask_fmadd_round_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 a 复制元素)。"],["_mm512_mask_fmaddsub_pd","将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 a 中复制元素放)。"],["_mm512_mask_fmaddsub_ps","将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位则从 a 复制元素放)。"],["_mm512_mask_fmaddsub_round_pd","将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 a 中复制元素放)。"],["_mm512_mask_fmaddsub_round_ps","将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位则从 a 复制元素放)。"],["_mm512_mask_fmsub_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (如果未设置相应的掩码位，则从 a 复制元素)。"],["_mm512_mask_fmsub_ps","将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 a 复制元素)。"],["_mm512_mask_fmsub_round_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (如果未设置相应的掩码位，则从 a 复制元素)。"],["_mm512_mask_fmsub_round_ps","将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 a 复制元素)。"],["_mm512_mask_fmsubadd_pd","将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，并使用 writemask k 将结果存储在 dst 中 (当未使用相应的掩码位时，元素将从 a 复制放)。"],["_mm512_mask_fmsubadd_ps","将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 a 复制元素放)。"],["_mm512_mask_fmsubadd_round_pd","将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，并使用 writemask k 将结果存储在 dst 中 (当未使用相应的掩码位时，元素将从 a 复制放)。"],["_mm512_mask_fmsubadd_round_ps","将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 a 复制元素放)。"],["_mm512_mask_fnmadd_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。"],["_mm512_mask_fnmadd_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。"],["_mm512_mask_fnmadd_round_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。"],["_mm512_mask_fnmadd_round_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。"],["_mm512_mask_fnmsub_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。"],["_mm512_mask_fnmsub_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。"],["_mm512_mask_fnmsub_round_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。"],["_mm512_mask_fnmsub_round_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。"],["_mm512_mask_getexp_pd","将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并使用 writemask k 将结果存储在 dst 中 (当相应的 mask 时，元素从 src 复制位未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。"],["_mm512_mask_getexp_ps","将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，并使用 writemask k 将结果存储在 dst 中 (当相应的 mask 时，元素从 src 复制位未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。"],["_mm512_mask_getexp_round_pd","将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并使用 writemask k 将结果存储在 dst 中 (当相应的 mask 时，元素从 src 复制位未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_mask_getexp_round_ps","将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，并使用 writemask k 将结果存储在 dst 中 (当相应的 mask 时，元素从 src 复制位未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_mask_getmant_pd","将 a 中的包装的双精度 (64-bit) 浮点元素的尾数标准化，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1"],["_mm512_mask_getmant_ps","标准化 a 中包装的单精度 (32-bit) 浮点元素的尾数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1"],["_mm512_mask_getmant_round_pd","将 a 中的包装的双精度 (64-bit) 浮点元素的尾数标准化，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_mask_getmant_round_ps","标准化 a 中包装的单精度 (32-bit) 浮点元素的尾数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_mask_gf2p8affine_epi64_epi8","对 x 中的包装字节执行仿射变换。 也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。"],["_mm512_mask_gf2p8affineinv_epi64_epi8","对 x 中的反向包装的字节执行仿射变换。 也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。"],["_mm512_mask_gf2p8mul_epi8","在包装的字节上执行 GF(2^8) 乘法。 该字段以多项式表示，具有约数多项式 x^8 + x^4 + x^3 + x + 1。"],["_mm512_mask_i32gather_epi32","使用 32 位索引从内存中收集 32 位整数。从 base_addr 开始的地址加载 32 位元素，并由 vindex 中的每个 32 位元素偏移 (每个索引均按比例因子进行缩放)。使用 writemask k 将收集到的元素合并到 dst (当相应的掩码位未设置时，从 src 复制元素)。小数位数应为 1、2、4 或 8。"],["_mm512_mask_i32gather_epi64","使用 32 位索引从内存中收集 64 位整数。从 base_addr 开始的地址加载 64 位元素，并由 vindex 中的每个 32 位元素偏移 (每个索引均按比例因子进行缩放)。使用 writemask k 将收集到的元素合并到 dst (当相应的掩码位未设置时，从 src 复制元素)。小数位数应为 1、2、4 或 8。"],["_mm512_mask_i32gather_pd","使用 32 位索引从内存中收集双精度 (64-bit) 浮点元素。从 base_addr 开始的地址加载 64 位元素，并由 vindex 中的每个 32 位元素偏移 (每个索引均按比例因子进行缩放)。使用 writemask k 将收集到的元素合并到 dst (当相应的掩码位未设置时，从 src 复制元素)。小数位数应为 1、2、4 或 8。"],["_mm512_mask_i32gather_ps","使用 32 位索引从内存中收集单精度 (32-bit) 浮点元素。从 base_addr 开始的地址加载 32 位元素，并由 vindex 中的每个 32 位元素偏移 (每个索引均按比例因子进行缩放)。使用 writemask k 将收集到的元素合并到 dst (当相应的掩码位未设置时，从 src 复制元素)。小数位数应为 1、2、4 或 8。"],["_mm512_mask_i32scatter_epi32","使用 32 位索引将 32 位整数从 a 分散到内存中。32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 32 位元素偏移 (每个索引按比例因子缩放) 受掩码 k (当相应掩码位未设置时不存储元素) . 小数位数应为 1、2、4 或 8。"],["_mm512_mask_i32scatter_epi64","使用 32 位索引将 64 位整数从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址中，并由 vindex 中的每个 32 位元素偏移 (每个索引按比例因子缩放) 受掩码 k (未设置相应掩码位时不存储元素) . 小数位数应为 1、2、4 或 8。"],["_mm512_mask_i32scatter_pd","使用 32 位索引将双精度 (64-bit) 浮点元素从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址中，并由 vindex 中的每个 32 位元素偏移 (每个索引按比例因子缩放) 受掩码 k (未设置相应掩码位时不存储元素) . 小数位数应为 1、2、4 或 8。"],["_mm512_mask_i32scatter_ps","使用 32 位索引将单精度 (32-bit) 浮点元素从 a 分散到内存中。32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 32 位元素偏移 (每个索引按比例因子缩放) 受掩码 k (当相应掩码位未设置时不存储元素) . 小数位数应为 1、2、4 或 8。"],["_mm512_mask_i64gather_epi32","使用 64 位索引从内存中收集 32 位整数。从 base_addr 开始的地址加载 32 位元素，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)。使用 writemask k 将收集到的元素合并到 dst (当相应的掩码位未设置时，从 src 复制元素)。小数位数应为 1、2、4 或 8。"],["_mm512_mask_i64gather_epi64","使用 64 位索引从内存中收集 64 位整数。从 base_addr 开始的地址加载 64 位元素，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)。使用 writemask k 将收集到的元素合并到 dst (当相应的掩码位未设置时，从 src 复制元素)。小数位数应为 1、2、4 或 8。"],["_mm512_mask_i64gather_pd","使用 64 位索引从内存中收集双精度 (64-bit) 浮点元素。从 base_addr 开始的地址加载 64 位元素，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)。使用 writemask k 将收集到的元素合并到 dst (当相应的掩码位未设置时，从 src 复制元素)。小数位数应为 1、2、4 或 8。"],["_mm512_mask_i64gather_ps","使用 64 位索引从内存中收集单精度 (32-bit) 浮点元素。从 base_addr 开始的地址加载 32 位元素，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)。使用 writemask k 将收集到的元素合并到 dst (当相应的掩码位未设置时，从 src 复制元素)。小数位数应为 1、2、4 或 8。"],["_mm512_mask_i64scatter_epi32","使用 64 位索引将 32 位整数从 a 分散到内存中。32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)，且受掩码 k 限制 (未设置相应的掩码位时不存储元素)。小数位数应为 1、2、4 或 8。"],["_mm512_mask_i64scatter_epi64","使用 64 位索引将 64 位整数从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 64 位元素偏移 (每个索引按比例因子缩放) 受掩码 k (当相应掩码位未设置时不存储元素) . 小数位数应为 1、2、4 或 8。"],["_mm512_mask_i64scatter_pd","使用 64 位索引将双精度 (64-bit) 浮点元素从 a 分散到内存中。64 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 64 位元素偏移 (每个索引按比例因子缩放) 受掩码 k (当相应掩码位未设置时不存储元素) . 小数位数应为 1、2、4 或 8。"],["_mm512_mask_i64scatter_ps","使用 64 位索引将单精度 (32-bit) 浮点元素从 a 分散到内存中。32 位元素存储在从 base_addr 开始的地址处，并由 vindex 中的每个 64 位元素偏移 (每个索引均按比例因子进行缩放)，且受掩码 k 限制 (未设置相应的掩码位时不存储元素)。小数位数应为 1、2、4 或 8。"],["_mm512_mask_insertf32x4","将 a 复制到 tmp，然后在 x00X 指定的位置将 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成) 插入 tmp。使用写掩码 k 将 tmp 存储到 dst (当未设置相应的掩码位时，将从 src 复制元素)。"],["_mm512_mask_insertf64x4","将 a 复制到 tmp，然后在 x00X 指定的位置将 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成) 插入 tmp。使用写掩码 k 将 tmp 存储到 dst (当未设置相应的掩码位时，将从 src 复制元素)。"],["_mm512_mask_inserti32x4","将 a 复制到 tmp，然后在 imm8 指定的位置，将 b 中的 128 位 (由 4 个包装的 32 位整数组成) 插入 tmp。使用写掩码 k 将 tmp 存储到 dst (当未设置相应的掩码位时，将从 src 复制元素)。"],["_mm512_mask_inserti64x4","将 a 复制到 tmp，然后在 imm8 指定的位置将 b 的 256 位 (由 4 个包装的 64 位整数组成) 插入 tmp。使用写掩码 k 将 tmp 存储到 dst (当未设置相应的掩码位时，将从 src 复制元素)。"],["_mm512_mask_lzcnt_epi32","计算 a 中每个包装的 32 位整数中前导零位的数目，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_lzcnt_epi64","计算 a 中每个包装的 64 位整数中前导零位的数目，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_madd_epi16","在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。水平添加相邻的中间 32 位整数对，并使用 writemask k 将结果打包到 dst (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm512_mask_maddubs_epi16","将 a 中的包装无符号 8 位整数与 b 中的包装有符号 8 位整数相乘，生成中间有符号的 16 位整数。水平相加相邻的中间带符号的 16 位整数对，并使用写掩码 k 将饱和结果包装到 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_max_epi16","比较 a 和 b 中包装的带符号的 16 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_max_epi32","比较 a 和 b 中包装的带符号的 32 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_max_epi64","比较 a 和 b 中包装的带符号的 64 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_max_epi8","比较 a 和 b 中包装的带符号的 8 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_max_epu16","比较 a 和 b 中包装的无符号 16 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_max_epu32","比较 a 和 b 中包装的无符号 32 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_max_epu64","比较 a 和 b 中包装的无符号 64 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_max_epu8","比较 a 和 b 中包装的无符号 8 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_max_pd","比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_max_ps","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_max_round_pd","比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_mask_max_round_ps","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_mask_min_epi16","比较 a 和 b 中包装的带符号 16 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_min_epi32","比较 a 和 b 中包装的带符号的 32 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_min_epi64","比较 a 和 b 中包装的带符号的 64 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_min_epi8","比较 a 和 b 中包装的带符号的 8 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_min_epu16","比较 a 和 b 中包装的无符号 16 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_min_epu32","比较 a 和 b 中包装的无符号 32 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_min_epu64","比较 a 和 b 中包装的无符号 64 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_min_epu8","比较 a 和 b 中包装的无符号 8 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_min_pd","比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_min_ps","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_min_round_pd","比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_mask_min_round_ps","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_mask_mov_epi16","使用写掩码 k 将包装的 16 位整数从 a 移到 dst (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm512_mask_mov_epi32","使用写掩码 k 将包装的 32 位整数从 a 移动到 dst (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm512_mask_mov_epi64","使用写掩码 k 将包装的 64 位整数从 a 移动到 dst (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm512_mask_mov_epi8","使用写掩码 k 将包装的 8 位整数从 a 移到 dst (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm512_mask_mov_pd","使用写掩码 k 将包装的双精度 (64-bit) 浮点元素从 a 移动到 dst (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm512_mask_mov_ps","使用写掩码 k 将包装的单精度 (32-bit) 浮点元素从 a 移动到 dst (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm512_mask_movedup_pd","从 a 复制偶数索引的双精度 (64-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_movehdup_ps","从 a 复制奇数索引的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_moveldup_ps","从 a 复制偶数索引的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_mul_epi32","将 a 和 b 中每个包装的 64 位元素的低符号 32 位整数相乘，并使用写掩码 k 将有符号的 64 位结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_mul_epu32","将 a 和 b 中每个包装的 64 位元素的低无符号 32 位整数相乘，并使用写掩码 k 将无符号 64 位结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_mul_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_mul_ps","将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_mul_round_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_mul_round_ps","将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_mulhi_epi16","将 a 和 b 中包装的带符号的 16 位整数相乘，生成 32 位中间整数，并使用写掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_mulhi_epu16","将 a 和 b 中包装的无符号 16 位整数相乘，生成 32 位中间整数，并使用写掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_mulhrs_epi16","在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。将每个中间整数截断为 18 个最高有效位，通过加 1 舍入，并使用 writemask k 将位 [16:1] 存储到 dst (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm512_mask_mullo_epi16","将 a 和 b 中的包装的 16 位整数相乘，生成中间的 32 位整数，并使用写掩码 k 将中间整数的低 16 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_mullo_epi32","将 a 和 b 中的包装的 32 位整数相乘，生成中间 64 位整数，并使用写掩码 k 将中间整数的低 32 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_mullox_epi64","将包装的 64 位整数 vectors a 和 b 中的元素相乘，使用写掩码 k 将结果的低 64 位存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm512_mask_multishift_epi64_epi8","对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并使用 writemask k (元素当相应的屏蔽位未设置时，从 src 复制)。"],["_mm512_mask_or_epi32","计算 a 和 b 中包装的 32 位整数的按位或，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_or_epi64","计算 a 和 b 中包装的 64 位整数的按位或，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_packs_epi16","使用带符号的饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_packs_epi32","使用带符号的饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_packus_epi16","使用无符号饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_packus_epi32","使用无符号饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_permute_pd","使用 imm8 中的控件在 128 位通道内对双精度 (64-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_permute_ps","使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_permutevar_epi32","使用 idx 中的相应索引在跨通道中对 32 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。请注意，与使用 permutevar 名称的过去内联函数不同，该内联函数在 128 位通道上进行了重排。此内联函数与 _mm512_mask_permutexvar_epi32 相同，建议您使用该内联函数名称。"],["_mm512_mask_permutevar_pd","使用 b 中的控件在 128 位通道内将 a 的双精度 (64-bit) 浮点元素进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_permutevar_ps","使用 b 中的控件在 128 位通道内将 a 的单精度 (32-bit) 浮点元素打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_permutex2var_epi16","使用相应的选择器和 idx 中的索引在通道中的 a 和 b 中对 16 位整数进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。"],["_mm512_mask_permutex2var_epi32","使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中对 32 位整数进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。"],["_mm512_mask_permutex2var_epi64","使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中随机排列 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。"],["_mm512_mask_permutex2var_epi8","使用相应的选择器和 idx 中的索引将 a 和 b 中的 8 位整数跨通道打乱，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。"],["_mm512_mask_permutex2var_pd","使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。"],["_mm512_mask_permutex2var_ps","使用对应的选择器和 idx 中的索引在 a 和 b 中的通道上对 a 和 b 中的单精度 (32-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。"],["_mm512_mask_permutex_epi64","使用 imm8 中的控件在 256 位通道内将 64 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_permutex_pd","使用 imm8 中的控件在 256 位通道内对双精度 (64-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_permutexvar_epi16","使用 idx 中的相应索引在跨通道中对 16 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_permutexvar_epi32","使用 idx 中的相应索引在跨通道中对 32 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_permutexvar_epi64","使用 idx 中的相应索引在跨通道中随机排列 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_permutexvar_epi8","使用 idx 中的相应索引在跨通道的 a 中打乱 8 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm512_mask_permutexvar_pd","使用 idx 中的相应索引对跨通道中的双精度 (64-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_permutexvar_ps","使用 idx 中的相应索引对跨通道中的单精度 (32-bit) 浮点元素进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_popcnt_epi16","对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm512_mask_popcnt_epi32","对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm512_mask_popcnt_epi64","对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。"],["_mm512_mask_popcnt_epi8","对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm512_mask_rcp14_pd","计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。该近似值的最大相对误差小于 2^-14。"],["_mm512_mask_rcp14_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。该近似值的最大相对误差小于 2^-14。"],["_mm512_mask_reduce_add_epi32","使用掩码 k 通过加法来减少 a 中包装的 32 位整数。返回 a 中所有活动元素的总和。"],["_mm512_mask_reduce_add_epi64","使用掩码 k 通过加法来减少 a 中包装的 64 位整数。返回 a 中所有活动元素的总和。"],["_mm512_mask_reduce_add_pd","通过使用掩膜 k 加法来减少包装的双精度 (64-bit) 浮点元素。返回 a 中所有活动元素的总和。"],["_mm512_mask_reduce_add_ps","通过使用掩码 k 加法来减少包装的单精度 (32-bit) 浮点元素。返回 a 中所有活动元素的总和。"],["_mm512_mask_reduce_and_epi32","使用掩码 k 按位与减少包装的 32 位整数。返回 a 中所有活动元素的按位与。"],["_mm512_mask_reduce_and_epi64","使用掩码 k 通过加法来减少 a 中包装的 64 位整数。返回 a 中所有活动元素的总和。"],["_mm512_mask_reduce_max_epi32","使用掩码 k 最多减少 a 中的包装有符号 32 位整数。返回 a 中所有活动元素的最大值。"],["_mm512_mask_reduce_max_epi64","使用掩码 k 最大减少包装的带符号的 64 位整数。返回 a 中所有活动元素的最大值。"],["_mm512_mask_reduce_max_epu32","使用掩码 k 最大减少包装的无符号 32 位整数。返回 a 中所有活动元素的最大值。"],["_mm512_mask_reduce_max_epu64","使用掩码 k 最大减少包装的无符号 64 位整数。返回 a 中所有活动元素的最大值。"],["_mm512_mask_reduce_max_pd","使用掩码 k 最多减少 a 中包装的双精度 (64-bit) 浮点元素。返回 a 中所有活动元素的最大值。"],["_mm512_mask_reduce_max_ps","最多使用掩码 k 减少包装后的单精度 (32-bit) 浮点元素。返回 a 中所有活动元素的最大值。"],["_mm512_mask_reduce_min_epi32","使用掩码 k 最多减少 a 中的包装有符号 32 位整数。返回 a 中所有活动元素的最小值。"],["_mm512_mask_reduce_min_epi64","使用掩码 k 最大减少包装的带符号的 64 位整数。返回 a 中所有活动元素的最小值。"],["_mm512_mask_reduce_min_epu32","使用掩码 k 最大减少包装的无符号 32 位整数。返回 a 中所有活动元素的最小值。"],["_mm512_mask_reduce_min_epu64","使用掩码 k 最大减少包装的带符号的 64 位整数。返回 a 中所有活动元素的最小值。"],["_mm512_mask_reduce_min_pd","使用掩码 k 最多减少 a 中包装的双精度 (64-bit) 浮点元素。返回 a 中所有活动元素的最小值。"],["_mm512_mask_reduce_min_ps","最多使用掩码 k 减少包装后的单精度 (32-bit) 浮点元素。返回 a 中所有活动元素的最小值。"],["_mm512_mask_reduce_mul_epi32","使用掩码 k 通过乘以减少 a 中包装的 32 位整数。返回 a 中所有活动元素的乘积。"],["_mm512_mask_reduce_mul_epi64","使用掩码 k 通过乘以减少 a 中包装的 64 位整数。返回 a 中所有活动元素的乘积。"],["_mm512_mask_reduce_mul_pd","使用掩码 k 通过乘以减少 a 中包装的双精度 (64-bit) 浮点元素。返回 a 中所有活动元素的乘积。"],["_mm512_mask_reduce_mul_ps","使用掩码 k 通过乘以减少 a 中包装的单精度 (32-bit) 浮点元素。返回 a 中所有活动元素的乘积。"],["_mm512_mask_reduce_or_epi32","使用掩码 k 按位或减少包装的 32 位整数。返回 a 中所有活动元素的按位或。"],["_mm512_mask_reduce_or_epi64","使用掩码 k 按位或减少包装的 64 位整数。返回 a 中所有活动元素的按位或。"],["_mm512_mask_rol_epi32","将每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_rol_epi64","将每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_rolv_epi32","将 a 中每个包装的 32 位整数中的位向左旋转 b 对应元素 b 中指定的位数，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 src 复制元素放)。"],["_mm512_mask_rolv_epi64","将 a 中每个包装的 64 位整数中的位向左旋转 b 的对应元素中指定的位数，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 src 复制元素放)。"],["_mm512_mask_ror_epi32","将 X 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_ror_epi64","将 X 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_rorv_epi32","将 a 中每个包装的 32 位整数中的位向右旋转 b 的对应元素中指定的位数，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 src 复制元素放)。"],["_mm512_mask_rorv_epi64","将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 src 复制元素放)。"],["_mm512_mask_roundscale_pd","将 a 中的包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm512_mask_roundscale_ps","将 a 中的包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的小数位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm512_mask_roundscale_round_pd","将 a 中的包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm512_mask_roundscale_round_ps","将 a 中的包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的小数位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm512_mask_rsqrt14_pd","计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。该近似值的最大相对误差小于 2^-14。"],["_mm512_mask_rsqrt14_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。该近似值的最大相对误差小于 2^-14。"],["_mm512_mask_scalef_pd","使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_scalef_ps","使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_scalef_round_pd","使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_scalef_round_ps","使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_set1_epi16","使用写掩码 k 向 dst 的所有元素广播 16 位整数 a (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm512_mask_set1_epi32","使用写掩码 k 将 32 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_set1_epi64","使用写掩码 k 将 64 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_set1_epi8","使用写掩码 k 将 8 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_shldi_epi16","在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并使用 writemask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm512_mask_shldi_epi32","将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并使用 writemask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm512_mask_shldi_epi64","在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并使用 writemask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm512_mask_shldv_epi16","在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。"],["_mm512_mask_shldv_epi32","将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。"],["_mm512_mask_shldv_epi64","在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 复制)。"],["_mm512_mask_shrdi_epi16","将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并使用 writemask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm512_mask_shrdi_epi32","连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并使用 writemask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm512_mask_shrdi_epi64","将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并使用 writemask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，元素从 src` 复制)。"],["_mm512_mask_shrdv_epi16","将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。"],["_mm512_mask_shrdv_epi32","连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。"],["_mm512_mask_shrdv_epi64","将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。"],["_mm512_mask_shuffle_epi32","使用 imm8 中的控件将 128 位通道中的 32 位整数随机排列，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_shuffle_epi8","使用 b 中相应的 8 位元素中的控件在 128 位通道内对 a 中的 8 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_shuffle_f32x4","将 imm8 从 a 和 b 中选择的 128 位 (由 4 个单精度 (32-bit) 浮点元素组成) 混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_shuffle_f64x2","将 imm8 从 a 和 b 中选择的 128 位 (由 2 个双精度 (64-bit) 浮点元素组成) 混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_shuffle_i32x4","将 imm8 从 a 和 b 中选择的 128 位 (由 4 个 32 位整数组成) 重排，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_shuffle_i64x2","将 imm8 从 a 和 b 中选择的 128 位 (由 2 个 64 位整数组成) 进行混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm512_mask_shuffle_pd","使用 imm8 中的控件对 128 位通道中的双精度 (64-bit) 浮点元素进行混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_shuffle_ps","使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_shufflehi_epi16","使用 imm8 中的控件在 a 的 128 位通道的高 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的高 64 位中，将 128 位通道的低 64 位从 a 复制到 dst，使用写掩码 k (当相应的掩码位不存在时，元素从 src 复制放)。"],["_mm512_mask_shufflelo_epi16","使用 imm8 中的控件在 a 的 128 位通道的低 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的低 64 位中，并使用写掩码 k 将 128 位通道的高 64 位从 a 复制到 dst (当未使用相应的掩码位时，元素从 src 复制) 放)。"],["_mm512_mask_sll_epi16","将包装的 16 位整数按计数左移，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_sll_epi32","将包装的 32 位整数左移计数，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_sll_epi64","将包装的 64 位整数左移计数，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_slli_epi16","将包装的 16 位整数左移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_slli_epi32","将包装的 32 位整数左移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_slli_epi64","将包装的 64 位整数向左移动 imm8，同时向零移动，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_sllv_epi16","将包装的 16 位整数按 count 中相应元素指定的数量向左移位，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_sllv_epi32","将填充的 32 位整数向左移动计数中相应元素指定的数量，同时将其移位为零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_sllv_epi64","将填充的 64 位整数向左移动 count 中相应元素指定的数量，同时将其移位为零，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm512_mask_sqrt_pd","计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_sqrt_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_sqrt_round_pd","计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_sqrt_round_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_sra_epi16","将包装的 16 位整数按计数右移，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_sra_epi32","在移动符号位的同时右移计数包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_sra_epi64","在移动符号位的同时右移计数包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_srai_epi16","将包装的 16 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_srai_epi32","将包装的 32 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_srai_epi64","将包装的 64 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_srav_epi16","将包装的 16 位整数右移 count 中相应元素指定的数量，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_srav_epi32","在将符号位移位的同时，将已包装的 32 位整数向右移动计数中相应元素指定的数量，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_srav_epi64","在移入符号位的同时，将包装的 64 位整数向右移动计数中相应元素指定的数量，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_srl_epi16","将包装的 16 位整数右移，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_srl_epi32","将包装的 32 位整数右移，同时移零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_srl_epi64","将包装的 64 位整数右移，同时移零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_srli_epi16","将包装的 16 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_srli_epi32","将包装的 32 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_srli_epi64","将包装的 64 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_srlv_epi16","将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_srlv_epi32","向右移动包装的 32 位整数整数 (由 count 中相应元素指定的数量)，同时向零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_srlv_epi64","向右移位包装的 64 位整数，其数量为计数中相应元素指定的数量，同时向零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_sub_epi16","从 a 中的包装的 16 位整数中减去 b 中的包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_sub_epi32","从 a 中的包装 32 位整数中减去 b 中的包装 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_sub_epi64","从 a 中的包装 64 位整数中减去 b 中的包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_sub_epi8","从 a 中的包装 8 位整数中减去 b 中的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_sub_pd","从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_sub_ps","将 b 中的包装后的单精度 (32-bit) 浮点元素减去 a 中的包装后的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_sub_round_pd","从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_sub_round_ps","将 b 中的包装后的单精度 (32-bit) 浮点元素减去 a 中的包装后的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_subs_epi16","使用饱和度将 b 中的包装 16 位整数减去 b 中的包装有符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_subs_epi8","使用饱和度将 b 中的包装 8 位整数减去 b 中的包装 8 位有符号整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_subs_epu16","使用 a 饱和度从 b 中的包装无符号 16 位整数减去 b 中的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_subs_epu8","使用 a 饱和度将 b 中的包装无符号 8 位整数减去 b 中的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm512_mask_ternarylogic_epi32","提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 32 位整数中的每一位，使用 src、a 和 b 中的相应位形成 imm8 的 3 位索引，并使用 writemask 将 imm8 中该位的值写入 dst 中的相应位 k 在 32 位粒度 (当相应的掩码位未设置时，从 src 复制 32 位元素)。"],["_mm512_mask_ternarylogic_epi64","提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 64 位整数中的每一位，src、a 和 b 中的相应位用于形成 imm8 的 3 位索引，并使用 writemask 将 imm8 中该位的值写入 dst 中的相应位 k 在 64 位粒度 (当相应的掩码位未设置时，从 src 复制 64 位元素)。"],["_mm512_mask_test_epi16_mask","计算 a 和 b 中包装的 16 位整数的按位与，生成中间的 16 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。"],["_mm512_mask_test_epi32_mask","计算 a 和 b 中包装的 32 位整数的按位与，生成中间的 32 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。"],["_mm512_mask_test_epi64_mask","计算 a 和 b 中包装的 64 位整数的按位与，生成中间 64 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。"],["_mm512_mask_test_epi8_mask","计算 a 和 b 中包装的 8 位整数的按位与，生成中间 8 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。"],["_mm512_mask_testn_epi16_mask","计算 a 和 b 中包装的 16 位整数的按位 NAND，生成中间的 16 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。"],["_mm512_mask_testn_epi32_mask","计算 a 和 b 中包装的 32 位整数的按位 NAND，生成中间的 32 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。"],["_mm512_mask_testn_epi64_mask","计算 a 和 b 中包装的 64 位整数的按位 NAND，生成中间 64 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。"],["_mm512_mask_testn_epi8_mask","计算 a 和 b 中包装的 8 位整数的按位 NAND，生成中间的 8 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。"],["_mm512_mask_unpackhi_epi16","从 a 和 b 中每个 128 位通道的高半部分拆包和交织 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm512_mask_unpackhi_epi32","从 a 和 b 中每个 128 位通道的高半部分解包和交织 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm512_mask_unpackhi_epi64","从 a 和 b 中每个 128 位通道的高半部分解包和交织 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_unpackhi_epi8","从 a 和 b 中每个 128 位通道的高半部分拆包和交织 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm512_mask_unpackhi_pd","从 a 和 b 中每个 128 位通道的高半部分解包和交织双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 src 复制元素)。"],["_mm512_mask_unpackhi_ps","从 a 和 b 中每个 128 位通道的高半部分解包和交织单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 src 复制元素)。"],["_mm512_mask_unpacklo_epi16","从 a 和 b 中每个 128 位通道的下半部分拆包和交织 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm512_mask_unpacklo_epi32","从 a 和 b 中每个 128 位通道的下半部分解包和交织 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm512_mask_unpacklo_epi64","从 a 和 b 中每个 128 位通道的下半部分解包和交织 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_unpacklo_epi8","从 a 和 b 中每个 128 位通道的下半部分拆包和交织 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm512_mask_unpacklo_pd","从 a 和 b 中每个 128 位通道的下半部分解包并交织双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 src 复制元素)。"],["_mm512_mask_unpacklo_ps","从 a 和 b 中每个 128 位通道的下半部分解包并交织单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 src 复制元素)。"],["_mm512_mask_xor_epi32","计算 a 和 b 中包装的 32 位整数的按位 XOR，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_mask_xor_epi64","计算 a 和 b 中包装的 64 位整数的按位 XOR，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm512_maskz_abs_epi16","计算 a 中包装的带符号的 16 位整数的绝对值，并使用零掩码 k (将未设置相应掩码位的元素清零) 将无符号结果存储在 dst 中。"],["_mm512_maskz_abs_epi32","计算 `a` 中包装的 32 位整数的绝对值，并使用零掩码 `k` 将无符号结果存储在 `dst` 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_abs_epi64","计算 a 中包装的带符号的 64 位整数的绝对值，并使用零掩码 k (将未设置相应掩码位的元素清零) 将无符号结果存储在 dst 中。"],["_mm512_maskz_abs_epi8","计算 a 中包装的带符号的 8 位整数的绝对值，并使用零掩码 k 将无符号结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_add_epi16","将包装的 16 位整数添加到 a 和 b 中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_add_epi32","将包装的 32 位整数添加到 a 和 b 中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_add_epi64","在 a 和 b 中添加包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_add_epi8","在 a 和 b 中添加包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_add_pd","在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_add_ps","在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_add_round_pd","在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_add_round_ps","在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_adds_epi16","使用饱和度在 a 和 b 中添加包装的带符号的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_adds_epi8","使用饱和度在 a 和 b 中添加包装的带符号的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_adds_epu16","使用饱和度在 a 和 b 中添加包装的无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_adds_epu8","使用饱和度在 a 和 b 中添加包装的无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_alignr_epi32","将 a 和 b 连接成一个 128 字节的立即结果，将结果右移 imm8 32 位元素，并使用零掩码 k 将低 64 字节 (16 个元素) 存储在 dst 中 (当未使用相应的掩码位时元素清零) 放)。"],["_mm512_maskz_alignr_epi64","将 a 和 b 连接成一个 128 字节的立即结果，将结果右移 imm8 64 位元素，并使用零掩码 k 将低 64 字节 (8 个元素) 存储在 dst 中 (当未使用相应的掩码位时元素清零) 放)。"],["_mm512_maskz_alignr_epi8","将 a 和 b 中的 16 字节块对连接成一个 32 字节的临时结果，将结果右移 imm8 字节，并使用零掩码 k 将低 16 字节存储在 dst 中 (当未使用相应的掩码位时元素清零) 放)。"],["_mm512_maskz_and_epi32","计算 a 和 b 中包装的 32 位整数的按位与，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_and_epi64","计算 a 和 b 中包装的 64 位整数的按位与，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_andnot_epi32","计算 a 中包装的 32 位整数的按位 NOT，然后计算 b 中的 AND，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_andnot_epi64","计算 a 中包装的 64 位整数的按位 NOT，然后与 b 计算 AND，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_avg_epu16","将 a 和 b 中包装的无符号 16 位整数进行平均，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_avg_epu8","将 a 和 b 中包装的无符号 8 位整数进行平均，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_broadcast_f32x4","使用零掩码 k 将 4 个包装的单精度 (32-bit) 浮点元素从 a 广播到 dst 的所有元素 (未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_broadcast_f64x4","使用零掩码 k 将 4 个包装的双精度 (64-bit) 浮点元素从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm512_maskz_broadcast_i32x4","使用零掩码 k 将 4 的包装的 32 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm512_maskz_broadcast_i64x4","使用零掩码 k 将 4 个包装的 64 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm512_maskz_broadcastb_epi8","使用零掩码 k 将低包装的 8 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm512_maskz_broadcastd_epi32","使用零掩码 k 将低包装的 32 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm512_maskz_broadcastq_epi64","使用零掩码 k 将低包装的 64 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm512_maskz_broadcastsd_pd","使用零掩码 k 将低双精度 (64-bit) 浮点元素从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm512_maskz_broadcastss_ps","使用零掩码 k 将低单精度 (32-bit) 浮点元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_broadcastw_epi16","使用零掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm512_maskz_compress_epi16","将 a 中的活动 16 位整数 (它们各自的位设置在 zeromask k 中) 连续存储到 dst，并将其余元素设置为零。"],["_mm512_maskz_compress_epi32","将活动的 32 位整数连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的整数) 为 dst，并将其余元素设置为零。"],["_mm512_maskz_compress_epi64","将活动的 64 位整数连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的整数) 为 dst，并将其余元素设置为零。"],["_mm512_maskz_compress_epi8","将 a 中的活动 8 位整数 (它们各自的位设置在 zeromask k 中) 连续存储到 dst，并将其余元素设置为零。"],["_mm512_maskz_compress_pd","将活动的双精度 (64-bit) 浮点元素连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的那些元素) 为 dst，并将其余元素设置为零。"],["_mm512_maskz_compress_ps","将活动的单精度 (32-bit) 浮点元素连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的那些元素) 为 dst，并将其余元素设置为零。"],["_mm512_maskz_conflict_epi32","使用零掩码 k (在未设置相应的掩码位时将元素清零)，测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。"],["_mm512_maskz_conflict_epi64","使用零掩码 k (在未设置相应的掩码位时将元素清零)，测试 a 的每个 64 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。"],["_mm512_maskz_cvt_roundepi32_ps","将 a 中的包装有符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用零掩码 k (未设置相应的掩码位时将元素清零) 将结果存储在 dst 中。"],["_mm512_maskz_cvt_roundepu32_ps","将 a 中的包装无符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_cvt_roundpd_epi32","将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。"],["_mm512_maskz_cvt_roundpd_epu32","将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。"],["_mm512_maskz_cvt_roundpd_ps","将 a 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。"],["_mm512_maskz_cvt_roundph_ps","将 a 中的包装后的半精度 (16-bit) 浮点元素转换为包装后的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_maskz_cvt_roundps_epi32","将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。"],["_mm512_maskz_cvt_roundps_epu32","将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。"],["_mm512_maskz_cvt_roundps_pd","将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_maskz_cvt_roundps_ph","将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_maskz_cvtepi16_epi32","符号将包装的 16 位整数从 a 扩展为包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm512_maskz_cvtepi16_epi64","使用符号将包装的 16 位整数从 a 扩展为包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_cvtepi16_epi8","将带有 a 的包装的 16 位整数转换为带截断的 8 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_cvtepi32_epi16","将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_cvtepi32_epi64","使用符号将包装的 32 位整数从 a 扩展为包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_cvtepi32_epi8","将带有 a 的包装的 32 位整数转换为带有截断的包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_cvtepi32_pd","将 a 中的包装有符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm512_maskz_cvtepi32_ps","将 a 中的包装有符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用零掩码 k (未设置相应的掩码位时将元素清零) 将结果存储在 dst 中。"],["_mm512_maskz_cvtepi64_epi16","将带有 a 的包装的 64 位整数转换为带截断的 16 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_cvtepi64_epi32","将 a 中的包装的 64 位整数转换为带截断的 32 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_cvtepi64_epi8","将带有 a 的包装的 64 位整数转换为带截断的 8 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_cvtepi8_epi16","使用符号将包装的 8 位整数从 a 扩展为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm512_maskz_cvtepi8_epi32","使用符号将包装的 8 位整数从 a 扩展为包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_cvtepi8_epi64","符号将 a 的低 8 个字节中的包装 8 位整数扩展为包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_cvtepu16_epi32","将 a 中的包装无符号 16 位整数零扩展为包装 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_cvtepu16_epi64","将 a 中的包装无符号 16 位整数零扩展为包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_cvtepu32_epi64","将 a 中的包装无符号 32 位整数零扩展为包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_cvtepu32_pd","将 a 中的包装无符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_cvtepu32_ps","将 a 中的包装无符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_cvtepu8_epi16","将 a 中的包装无符号 8 位整数零扩展为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_cvtepu8_epi32","将 a 中的包装无符号 8 位整数零扩展为包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_cvtepu8_epi64","将 a 的低 8 个字节中的包装无符号 8 位整数零扩展为包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_cvtne2ps_pbh","将两个 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在单个 vector dst 中 (当对应的掩码位不存在时，元素归零放)。"],["_mm512_maskz_cvtneps_pbh","将包装的单精度 (32-bit) 浮点元素在 a 中转换为包装的 BF16 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_cvtpd_epi32","将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。"],["_mm512_maskz_cvtpd_epu32","将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。"],["_mm512_maskz_cvtpd_ps","将 a 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。"],["_mm512_maskz_cvtph_ps","将 a 中的包装后的半精度 (16-bit) 浮点元素转换为包装后的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_cvtps_epi32","将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。"],["_mm512_maskz_cvtps_epu32","将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。"],["_mm512_maskz_cvtps_pd","将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_cvtps_ph","将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_maskz_cvtsepi16_epi8","将 a 中的包装有符号 16 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_cvtsepi32_epi16","将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并将结果存储在 dst 中。"],["_mm512_maskz_cvtsepi32_epi8","将 a 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_cvtsepi64_epi16","将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm512_maskz_cvtsepi64_epi32","将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm512_maskz_cvtsepi64_epi8","将 a 中的包装有符号 64 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm512_maskz_cvtt_roundpd_epi32","将带有 a 的包装的单精度 (32-bit) 浮点元素转换为带有截断的包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_maskz_cvtt_roundpd_epu32","将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_maskz_cvtt_roundps_epi32","将带有 a 的包装的单精度 (32-bit) 浮点元素转换为带有截断的包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_maskz_cvtt_roundps_epu32","将 a 中的包装单精度 (32-bit) 浮点元素转换为带有截断的包装无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_maskz_cvttpd_epi32","将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。"],["_mm512_maskz_cvttpd_epu32","将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_cvttps_epi32","将带有 a 的包装的单精度 (32-bit) 浮点元素转换为带有截断的包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_cvttps_epu32","将 a 中的包装的双精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_cvtusepi16_epi8","将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm512_maskz_cvtusepi32_epi16","将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm512_maskz_cvtusepi32_epi8","将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm512_maskz_cvtusepi64_epi16","将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_cvtusepi64_epi32","将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_cvtusepi64_epi8","将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm512_maskz_dbsad_epu8","计算 a 中与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs) 的总和，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将 16 位结果存储在 dst 中。对于每个 64 位通道，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中通道的低 8 位四元组，而后两个 SAD 使用 a 中通道的较高 8 位四元组。根据 imm8 中的控件，从 128 位通道中选择 b 中的四元组，并且每个 64 位通道中的每个 SAD 使用 8 位偏移量的选定四元组。"],["_mm512_maskz_div_pd","将 a 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_div_ps","将 a 中的包装单精度 (32-bit) 浮点元素除以 b 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_div_round_pd","将 a 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_div_round_ps","将 a 中的包装单精度 (32-bit) 浮点元素除以 b 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_dpbf16_ps","计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间单精度 (32-bit) 浮点元素与 src 中的元素进行累加，并将结果存储在 dst 中使用 zeromask k (当对应的掩码为位未设置)。"],["_mm512_maskz_dpbusd_epi32","将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果使用 zeromask k 存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_dpbusds_epi32","将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数用带符号饱和求和，并将包装的 32 位结果用 zeromask k 存储在 dst 中 (当对应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_dpwssd_epi32","将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中对应的 32 位整数相加，并使用 zeromask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_dpwssds_epi32","将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并使用 zeromask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_expand_epi16","从 a 加载连续的活动 16 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_expand_epi32","从 a 中加载连续的有效 32 位整数 (它们各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_expand_epi64","从 a 中加载连续的有效 64 位整数 (它们各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_expand_epi8","从 a 加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_expand_pd","从 a 中加载连续的活动双精度 (64-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_expand_ps","从 a 中加载连续的活动单精度 (32-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_extractf32x4_ps","从 a 提取 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成)，并用 imm8 进行选择，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_extractf64x4_pd","从 a 提取 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成)，并用 imm8 进行选择，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_extracti32x4_epi32","从 a 中提取 128 位 (由 4 个包装的 32 位整数组成)，用 IMM2 选择，结果用 zeromask k 存储在 dst 中 (当相应的掩码位未设置时，元素归零)。"],["_mm512_maskz_extracti64x4_epi64","从 a 中提取 256 位 (由 4 个包装的 64 位整数组成)，用 IMM1 选择，结果用 zeromask k 存储在 dst 中 (当相应的掩码位未设置时，元素归零)。"],["_mm512_maskz_fixupimm_pd","使用 c 中的包装 64 位整数修复 a 和 b 中的包装双精度 (64-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。imm8 用于设置所需的标志报告。"],["_mm512_maskz_fixupimm_ps","使用 c 中的包装 32 位整数修复 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。imm8 用于设置所需的标志报告。"],["_mm512_maskz_fixupimm_round_pd","使用 c 中的包装 64 位整数修复 a 和 b 中的包装双精度 (64-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。imm8 用于设置所需的标志报告。"],["_mm512_maskz_fixupimm_round_ps","使用 c 中的包装 32 位整数修复 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。imm8 用于设置所需的标志报告。"],["_mm512_maskz_fmadd_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_fmadd_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_fmadd_round_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_fmadd_round_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并将结果存储在使用零掩码 k 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_fmaddsub_pd","将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或减去，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm512_maskz_fmaddsub_ps","将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm512_maskz_fmaddsub_round_pd","将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或减去，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm512_maskz_fmaddsub_round_ps","将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm512_maskz_fmsub_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_fmsub_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_fmsub_round_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_fmsub_round_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_fmsubadd_pd","将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或减去，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm512_maskz_fmsubadd_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，或者将 C from/to 中的包装元素相减并相加，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm512_maskz_fmsubadd_round_pd","将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或减去，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm512_maskz_fmsubadd_round_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，或者将 C from/to 中的包装元素相减并相加，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm512_maskz_fnmadd_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_fnmadd_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_fnmadd_round_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_fnmadd_round_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_fnmsub_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_fnmsub_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_fnmsub_round_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_fnmsub_round_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_getexp_pd","将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并使用 zeromask k 将结果存储在 dst 中 (当相应的 mask 位为零时，元素被清零未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。"],["_mm512_maskz_getexp_ps","将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为代表整数指数的单精度 (32-bit) 浮点数，并使用 zeromask k 将结果存储在 dst 中 (当相应的 mask 位为零时，元素被清零未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。"],["_mm512_maskz_getexp_round_pd","将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并使用 zeromask k 将结果存储在 dst 中 (当相应的 mask 位为零时，元素被清零未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_maskz_getexp_round_ps","将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为代表整数指数的单精度 (32-bit) 浮点数，并使用 zeromask k 将结果存储在 dst 中 (当相应的 mask 位为零时，元素被清零未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_maskz_getmant_pd","将 a 中的包装的双精度 (64-bit) 浮点元素的尾数标准化，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1"],["_mm512_maskz_getmant_ps","将 a 中的包装的单精度 (32-bit) 浮点元素的尾数规格化，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1"],["_mm512_maskz_getmant_round_pd","将 a 中的包装的双精度 (64-bit) 浮点元素的尾数标准化，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_maskz_getmant_round_ps","将 a 中的包装的单精度 (32-bit) 浮点元素的尾数规格化，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_maskz_gf2p8affine_epi64_epi8","对 x 中的包装字节执行仿射变换。 也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。"],["_mm512_maskz_gf2p8affineinv_epi64_epi8","对 x 中的反向包装的字节执行仿射变换。 也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。"],["_mm512_maskz_gf2p8mul_epi8","在包装的字节上执行 GF(2^8) 乘法。 该字段以多项式表示，具有约数多项式 x^8 + x^4 + x^3 + x + 1。"],["_mm512_maskz_insertf32x4","将 a 复制到 tmp，然后在 x00X 指定的位置将 128 位 (由 4 个包装的单精度 (32-bit) 浮点元素组成) 插入 tmp。使用 zeromask k 将 tmp 存储到 dst (当未设置相应的掩码位时，元素会被清零)。"],["_mm512_maskz_insertf64x4","将 a 复制到 tmp，然后在 x00X 指定的位置将 256 位 (由 4 个包装的双精度 (64-bit) 浮点元素组成) 插入 tmp。使用 zeromask k 将 tmp 存储到 dst (当未设置相应的掩码位时，元素会被清零)。"],["_mm512_maskz_inserti32x4","将 a 复制到 tmp，然后在 imm8 指定的位置，将 b 中的 128 位 (由 4 个包装的 32 位整数组成) 插入 tmp。使用 zeromask k 将 tmp 存储到 dst (当未设置相应的掩码位时，元素会被清零)。"],["_mm512_maskz_inserti64x4","将 a 复制到 tmp，然后在 imm8 指定的位置将 b 的 256 位 (由 4 个包装的 64 位整数组成) 插入 tmp。使用 zeromask k 将 tmp 存储到 dst (当未设置相应的掩码位时，元素会被清零)。"],["_mm512_maskz_lzcnt_epi32","计算 a 中每个包装的 32 位整数中前导零位的数目，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_lzcnt_epi64","计算 a 中每个包装的 64 位整数中前导零位的数目，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_madd_epi16","在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。水平添加相邻的中间 32 位整数对，并使用 zeromask k 将结果打包到 dst (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_maddubs_epi16","将 a 中的包装无符号 8 位整数与 b 中的包装有符号 8 位整数相乘，生成中间有符号的 16 位整数。水平添加相邻的中间有符号 16 位整数对，并使用 zeromask k 将饱和结果打包到 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_max_epi16","比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm512_maskz_max_epi32","比较 a 和 b 中包装的带符号的 32 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm512_maskz_max_epi64","比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_max_epi8","比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm512_maskz_max_epu16","比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm512_maskz_max_epu32","比较 a 和 b 中包装的无符号 32 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm512_maskz_max_epu64","比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm512_maskz_max_epu8","比较 a 和 b 中包装的无符号 8 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm512_maskz_max_pd","比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm512_maskz_max_ps","比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm512_maskz_max_round_pd","比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_maskz_max_round_ps","比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_maskz_min_epi16","比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm512_maskz_min_epi32","比较 a 和 b 中包装的带符号 32 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm512_maskz_min_epi64","比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm512_maskz_min_epi8","比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm512_maskz_min_epu16","比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm512_maskz_min_epu32","比较 a 和 b 中包装的无符号 32 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm512_maskz_min_epu64","比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm512_maskz_min_epu8","比较 a 和 b 中包装的无符号 8 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm512_maskz_min_pd","比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm512_maskz_min_ps","比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm512_maskz_min_round_pd","比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_maskz_min_round_ps","比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_maskz_mov_epi16","使用零掩码 k 将包装的 16 位整数从 a 移到 dst (当未设置相应的掩码位时，元素将清零)。"],["_mm512_maskz_mov_epi32","使用零掩码 k 将包装的 32 位整数从 a 移至 dst (未设置相应的掩码位时将元素清零)。"],["_mm512_maskz_mov_epi64","使用零掩码 k 将包装的 64 位整数从 a 移到 dst (未设置相应的掩码位时，元素将清零)。"],["_mm512_maskz_mov_epi8","使用零掩码 k 将包装的 8 位整数从 a 移到 dst (当未设置相应的掩码位时，元素将清零)。"],["_mm512_maskz_mov_pd","使用零掩码 k 将包装的双精度 (64-bit) 浮点元素从 a 移到 dst (未设置相应的掩码位时将元素清零)。"],["_mm512_maskz_mov_ps","使用零掩码 k 将包装的单精度 (32-bit) 浮点元素从 a 移到 dst (未设置相应的掩码位时将元素清零)。"],["_mm512_maskz_movedup_pd","从 a 复制偶数索引的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_movehdup_ps","从 a 复制奇数索引的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_moveldup_ps","从 a 复制偶数索引的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_mul_epi32","将 a 和 b 中每个包装的 64 位元素的低位有符号 32 位整数相乘，并使用零掩码 k 将有符号的 64 位结果存储在 dst 中 (未设置相应的掩码位时将元素清零)。"],["_mm512_maskz_mul_epu32","将 a 和 b 中每个包装的 64 位元素的低无符号 32 位整数相乘，并使用零掩码 k 将无符号 64 位结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_mul_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_mul_ps","将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_mul_round_pd","将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_mul_round_ps","将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_mulhi_epi16","将 a 和 b 中包装的带符号的 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_mulhi_epu16","将 a 和 b 中包装的无符号 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_mulhrs_epi16","在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。将每个中间整数截断为 18 个最高有效位，通过加 1 舍入，并使用 zeromask k 将位 [16:1] 存储到 dst (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_mullo_epi16","将 a 和 b 中的包装的 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的低 16 位存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_mullo_epi32","将 a 和 b 中的包装的 32 位整数相乘，生成中间 64 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将中间整数的低 32 位存储在 dst 中。"],["_mm512_maskz_multishift_epi64_epi8","对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并使用 zeromask k (元素当相应的屏蔽位未设置时被清零)。"],["_mm512_maskz_or_epi32","计算 a 和 b 中包装的 32 位整数的按位或，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_or_epi64","计算 a 和 b 中包装的 64 位整数的按位或，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_packs_epi16","使用带符号的饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm512_maskz_packs_epi32","使用带符号的饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm512_maskz_packus_epi16","使用无符号饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm512_maskz_packus_epi32","使用无符号饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_permute_pd","使用 imm8 中的控件在 128 位通道内对双精度 (64-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_permute_ps","使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_permutevar_pd","使用 b 中的控件在 128 位通道内将 a 中的双精度 (64-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_permutevar_ps","使用 b 中的控件在 128 位通道内将 a 的单精度 (32-bit) 浮点元素打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_permutex2var_epi16","使用相应的选择器和 idx 中的索引在通道中的 a 和 b 中对 16 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_permutex2var_epi32","使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中对 32 位整数进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_permutex2var_epi64","使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中对 64 位整数进行混洗，并使用 zeromask k (未设置相应的 mask 位时将元素清零) 将结果存储在 dst 中。"],["_mm512_maskz_permutex2var_epi8","使用 idx 中的相应选择器和索引将 a 和 b 中的 8 位整数跨通道打乱，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_permutex2var_pd","使用对应的选择器和 idx 中的索引在通道中的通道 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_permutex2var_ps","使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对单精度 (32-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_permutex_epi64","使用 imm8 中的控件在 256 位通道内将 64 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_permutex_pd","使用 imm8 中的控件在 256 位通道内将双精度 (64-bit) 浮点元素打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_permutexvar_epi16","使用 idx 中的相应索引在跨通道中对 16 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_permutexvar_epi32","使用 idx 中的相应索引在跨通道中对 32 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_permutexvar_epi64","使用 idx 中的相应索引在跨通道中对 64 位整数进行打乱，并使用零掩码 k (未设置相应的掩码位时将元素清零) 将结果存储在 dst 中。"],["_mm512_maskz_permutexvar_epi8","使用 idx 中的相应索引在跨通道的 a 中打乱 8 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_permutexvar_pd","使用 idx 中的相应索引在跨通道中对双精度 (64-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_permutexvar_ps","使用 idx 中的相应索引在跨通道中对单精度 (32-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_popcnt_epi16","对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm512_maskz_popcnt_epi32","对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm512_maskz_popcnt_epi64","对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。"],["_mm512_maskz_popcnt_epi8","对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm512_maskz_rcp14_pd","计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。该近似值的最大相对误差小于 2^-14。"],["_mm512_maskz_rcp14_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。该近似值的最大相对误差小于 2^-14。"],["_mm512_maskz_rol_epi32","将每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm512_maskz_rol_epi64","将每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm512_maskz_rolv_epi32","将 a 中每个包装的 32 位整数中的位向左旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm512_maskz_rolv_epi64","将 a 中每个包装的 64 位整数中的位向左旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm512_maskz_ror_epi32","将 X 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_ror_epi64","将 X 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm512_maskz_rorv_epi32","将 a 中每个包装的 32 位整数中的位向右旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm512_maskz_rorv_epi64","将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm512_maskz_roundscale_pd","将 x 中的包装双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm512_maskz_roundscale_ps","将 a 中的包装单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm512_maskz_roundscale_round_pd","将 x 中的包装双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm512_maskz_roundscale_round_ps","将 a 中的包装单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm512_maskz_rsqrt14_pd","计算 a 中的包装的双精度 (64-bit) 浮点元素的近似倒数平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。该近似值的最大相对误差小于 2^-14。"],["_mm512_maskz_rsqrt14_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。该近似值的最大相对误差小于 2^-14。"],["_mm512_maskz_scalef_pd","使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_scalef_ps","使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_scalef_round_pd","使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_scalef_round_ps","使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_set1_epi16","使用零掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm512_maskz_set1_epi32","使用零掩码 k 将 32 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm512_maskz_set1_epi64","使用零掩码 k 将 64 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm512_maskz_set1_epi8","使用零掩码 k 将 8 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm512_maskz_shldi_epi16","在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_shldi_epi32","将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_shldi_epi64","在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_shldv_epi16","在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_shldv_epi32","将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_shldv_epi64","在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_shrdi_epi16","将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_shrdi_epi32","连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_shrdi_epi64","将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_shrdv_epi16","将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_shrdv_epi32","连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_shrdv_epi64","将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_shuffle_epi32","使用 imm8 中的控件在 128 位通道中的 32 位整数中混洗 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_shuffle_epi8","根据 b 的相应 8 位元素中的打乱控制掩码对 a 中的包装 8 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_shuffle_f32x4","将 imm8 从 a 和 b 中选择的 128 位 (由 4 个单精度 (32-bit) 浮点元素组成) 混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_shuffle_f64x2","将 imm8 从 a 和 b 中选择的 128 位 (由 2 个双精度 (64-bit) 浮点元素组成) 混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_shuffle_i32x4","将 imm8 从 a 和 b 中选择的 128 位 (由 4 个 32 位整数组成) 混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_shuffle_i64x2","将 imm8 从 a 和 b 中选择的 128 位 (由 2 个 64 位整数组成) 混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_shuffle_pd","使用 imm8 中的控件对 128 位通道内的双精度 (64-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_shuffle_ps","使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_shufflehi_epi16","使用 imm8 中的控件在 a 的 128 位通道的高 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的高 64 位中，将 128 位通道的低 64 位从 a 复制到 dst，使用 zeromask k (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_shufflelo_epi16","使用 imm8 中的控件在 a 的 128 位通道的低 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的低 64 位中，128 位通道的高 64 位从 a 复制到 dst，使用 zeromask k (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_sll_epi16","将包装的 16 位整数按计数左移，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_sll_epi32","将包装的 32 位整数左移计数，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_sll_epi64","将填充的 64 位整数左移计数，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_slli_epi16","将包装的 16 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_slli_epi32","将包装的 32 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_slli_epi64","将包装的 64 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_sllv_epi16","将包装的 16 位整数左移由 count 中的相应元素指定的数量，同时移入零，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_sllv_epi32","在将移位的 32 位整数左移零时，将其对应计数指定的数量左移，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_sllv_epi64","在将移位的 64 位整数左移零时，将其对应计数指定的数量左移，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_sqrt_pd","计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并使用零掩码 k (将结果置零，当未设置相应的掩码位时将元素清零) 将结果存储在 dst 中。"],["_mm512_maskz_sqrt_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_sqrt_round_pd","计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并使用零掩码 k (将结果置零，当未设置相应的掩码位时将元素清零) 将结果存储在 dst 中。"],["_mm512_maskz_sqrt_round_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_sra_epi16","将包装的 16 位整数按计数右移，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_sra_epi32","在移动符号位的同时右移计数包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_sra_epi64","在移动符号位的同时右移计数包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_srai_epi16","将包装的 16 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_srai_epi32","将包装的 32 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_srai_epi64","将包装的 64 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_srav_epi16","将包装的 16 位整数右移由 count 中的相应元素指定的数量，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_srav_epi32","在将符号位移位的同时，将已包装的 32 位整数向右移动计数中相应元素指定的数量，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_srav_epi64","在移入符号位的同时，将包装的 64 位整数右移由 count 中相应元素指定的数量，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_srl_epi16","将包装的 16 位整数右移，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_srl_epi32","将移位的 32 位整数右移，同时移零，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_srl_epi64","将包装的 64 位整数右移计数，同时移入零，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm512_maskz_srli_epi16","将包装的 16 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_srli_epi32","将包装的 32 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_srli_epi64","将包装的 64 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_srlv_epi16","将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_srlv_epi32","向右移动已包装的 32 位整数，偏移量为相应元素在计数中指定的数量，同时向零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_srlv_epi64","向右移位包装的 64 位整数，其数量为计数中相应元素指定的数量，同时移位为零，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_sub_epi16","从 a 中的包装的 16 位整数中减去 b 中的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_sub_epi32","从 a 中的包装 32 位整数中减去 b 中的包装 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_sub_epi64","从 a 中的包装 64 位整数中减去 b 中的包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_sub_epi8","从 a 中的包装 8 位整数中减去 b 中的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_sub_pd","从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_sub_ps","将 b 中的包装后的单精度 (32-bit) 浮点元素减去 a 中的包装后的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_sub_round_pd","从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_sub_round_ps","将 b 中的包装后的单精度 (32-bit) 浮点元素减去 a 中的包装后的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_subs_epi16","使用饱和度将 b 中的包装 16 位整数减去 b 中的包装有符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_subs_epi8","使用饱和度从包装的 8 位整数中减去 b 中的包装有符号的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_subs_epu16","使用 a 饱和度将 b 中的包装无符号 16 位整数减去 b 中的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_subs_epu8","使用 a 饱和度从 b 中的包装无符号 8 位整数减去 b 中的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_ternarylogic_epi32","提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 32 位整数中的每一位，来自 a、b 和 c 的相应位用于形成 imm8 的 3 位索引，并使用零掩码将 imm8 中该位的值写入 dst 中的相应位 k 在 32 位粒度 (当未设置相应的掩码位时，32 位元素被清零)。"],["_mm512_maskz_ternarylogic_epi64","提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 64 位整数中的每一位，来自 a、b 和 c 的相应位用于在 imm8 中形成 3 位索引，并使用零掩码将 imm8 中该位的值写入 dst 中的相应位 k 在 64 位粒度 (当未设置相应的掩码位时，64 位元素将被清零)。"],["_mm512_maskz_unpackhi_epi16","从 a 和 b 中每个 128 位通道的高半部分拆包和交织 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_unpackhi_epi32","从 a 和 b 中每个 128 位通道的高半部分解包和交织 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_unpackhi_epi64","从 a 和 b 中每个 128 位通道的高半部分解包和交织 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_unpackhi_epi8","从 a 和 b 中每个 128 位通道的高半部分拆包和交织 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_unpackhi_pd","从 a 和 b 中每个 128 位通道的高半部分解包和交织双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_unpackhi_ps","从 a 和 b 中每个 128 位通道的高半部分解包和交织单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_unpacklo_epi16","从 a 和 b 中每个 128 位通道的下半部分拆包和交织 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_unpacklo_epi32","从 a 和 b 中每个 128 位通道的下半部分解包和交织 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_unpacklo_epi64","从 a 和 b 中每个 128 位通道的下半部分解包和交织 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_unpacklo_epi8","从 a 和 b 中每个 128 位通道的下半部分拆包和交织 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm512_maskz_unpacklo_pd","从 a 和 b 中每个 128 位通道的下半部分解包和交织双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_unpacklo_ps","从 a 和 b 中每个 128 位通道的下半部分解包和交织单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm512_maskz_xor_epi32","计算 a 和 b 中包装的 32 位整数的按位 XOR，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_maskz_xor_epi64","计算 a 和 b 中包装的 64 位整数的按位 XOR，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm512_max_epi16","比较 a 和 b 中包装的带符号的 16 位整数，并将包装的最大值存储在 dst 中。"],["_mm512_max_epi32","比较 a 和 b 中包装的带符号 32 位整数，并将包装的最大值存储在 dst 中。"],["_mm512_max_epi64","比较 a 和 b 中包装的带符号的 64 位整数，并将包装的最大值存储在 dst 中。"],["_mm512_max_epi8","比较 a 和 b 中包装的带符号的 8 位整数，并将包装的最大值存储在 dst 中。"],["_mm512_max_epu16","比较 a 和 b 中包装的无符号 16 位整数，并将包装的最大值存储在 dst 中。"],["_mm512_max_epu32","比较 a 和 b 中包装的无符号 32 位整数，并将包装的最大值存储在 dst 中。"],["_mm512_max_epu64","比较 a 和 b 中包装的无符号 64 位整数，并将包装的最大值存储在 dst 中。"],["_mm512_max_epu8","比较 a 和 b 中包装的无符号 8 位整数，并将包装的最大值存储在 dst 中。"],["_mm512_max_pd","比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，并将包装的最大值存储在 dst 中。"],["_mm512_max_ps","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并将包装的最大值存储在 dst 中。"],["_mm512_max_round_pd","比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，并将包装的最大值存储在 dst 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_max_round_ps","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并将包装的最大值存储在 dst 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_min_epi16","比较 a 和 b 中包装的带符号的 16 位整数，并将包装的最小值存储在 dst 中。"],["_mm512_min_epi32","比较 a 和 b 中包装的带符号 32 位整数，并将包装的最小值存储在 dst 中。"],["_mm512_min_epi64","比较 a 和 b 中包装的带符号的 64 位整数，并将包装的最小值存储在 dst 中。"],["_mm512_min_epi8","比较 a 和 b 中包装的带符号的 8 位整数，并将包装的最小值存储在 dst 中。"],["_mm512_min_epu16","比较 a 和 b 中包装的无符号 16 位整数，并将包装的最小值存储在 dst 中。"],["_mm512_min_epu32","比较 a 和 b 中包装的无符号 32 位整数，并将包装的最小值存储在 dst 中。"],["_mm512_min_epu64","比较 a 和 b 中包装的无符号 64 位整数，并将包装的最小值存储在 dst 中。"],["_mm512_min_epu8","比较 a 和 b 中包装的无符号 8 位整数，并将包装的最小值存储在 dst 中。"],["_mm512_min_pd","比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，并将包装的最小值存储在 dst 中。 比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，并将包装的最小值存储在 dst 中。"],["_mm512_min_ps","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并将包装的最小值存储在 dst 中。"],["_mm512_min_round_pd","比较 a 和 b 中包装的双精度 (64-bit) 浮点元素，并将包装的最小值存储在 dst 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_min_round_ps","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并将包装的最小值存储在 dst 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm512_movedup_pd","从 a 复制偶数索引的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_movehdup_ps","从 a 复制奇数索引的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_moveldup_ps","从 a 复制偶数索引的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_movepi16_mask","根据 a 中相应的包装的 16 位整数的最高有效位设置掩码寄存器 k 的每一位。"],["_mm512_movepi8_mask","根据 a 中相应包装的 8 位整数的最高有效位设置掩码寄存器 k 的每个位。"],["_mm512_movm_epi16","根据 k 中相应位的值，将 dst 中每个包装的 16 位整数设置为全 1 或全 0。"],["_mm512_movm_epi8","根据 k 中相应位的值，将 dst 中每个包装的 8 位整数设置为全 1 或全 0。"],["_mm512_mul_epi32","将 a 和 b 中每个包装的 64 位元素的低符号 32 位整数相乘，并将带符号的 64 位结果存储在 dst 中。"],["_mm512_mul_epu32","将 a 和 b 中每个包装的 64 位元素的低无符号 32 位整数相乘，并将无符号 64 位结果存储在 dst 中。"],["_mm512_mul_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并将结果存储在 dst 中。"],["_mm512_mul_ps","将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并将结果存储在 dst 中。"],["_mm512_mul_round_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并将结果存储在 dst 中。"],["_mm512_mul_round_ps","将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并将结果存储在 dst 中。"],["_mm512_mulhi_epi16","将包装的带符号的 16 位整数与 a 和 b 相乘，生成中间的 32 位整数，并将中间整数的高 16 位存储在 dst 中。"],["_mm512_mulhi_epu16","将包装的无符号 16 位整数与 a 和 b 相乘，生成中间的 32 位整数，并将中间整数的高 16 位存储在 dst 中。"],["_mm512_mulhrs_epi16","在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。将每个中间整数截断为 18 个最高有效位，加 1 舍入，然后将 [16: 1] 位存储到 dst。"],["_mm512_mullo_epi16","将 a 和 b 中的包装的 16 位整数相乘，生成中间的 32 位整数，并将中间整数的低 16 位存储在 dst 中。"],["_mm512_mullo_epi32","将 a 和 b 中的包装的 32 位整数相乘，生成中间 64 位整数，并将中间整数的低 32 位存储在 dst 中。"],["_mm512_mullox_epi64","将包装的 64 位整数 vectors a 和 b 中的元素相乘，将结果的低 64 位存储在 dst 中。"],["_mm512_multishift_epi64_epi8","对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并将 8 个组装字节存储到 dst 的相应 64 位元素。"],["_mm512_or_epi32","计算 a 和 b 中包装的 32 位整数的按位或，并将结果存储在 dst 中。"],["_mm512_or_epi64","计算 a 和 b 中包装的 64 位整数的按位或，并将结果存储在 dst 中。"],["_mm512_or_si512","计算 a 和 b 中 512 位 (代表整数数据) 的按位或，并将结果存储在 dst 中。"],["_mm512_packs_epi16","使用带符号的饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并将结果存储在 dst 中。"],["_mm512_packs_epi32","使用带符号的饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并将结果存储在 dst 中。"],["_mm512_packus_epi16","使用无符号饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并将结果存储在 dst 中。"],["_mm512_packus_epi32","使用无符号饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并将结果存储在 dst 中。"],["_mm512_permute_pd","使用 imm8 中的控件在 128 位通道内对双精度 (64-bit) 浮点元素进行打乱，并将结果存储在 dst 中。"],["_mm512_permute_ps","使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并将结果存储在 dst 中。"],["_mm512_permutevar_epi32","使用 idx 中的相应索引在跨通道中随机排列 32 位整数，并将结果存储在 dst 中。请注意，与使用 permutevar 名称的过去内联函数不同，该内联函数在 128 位通道上进行了重排。此内部函数与 _mm512_permutexvar_epi32 相同，建议您使用该内部函数名称。"],["_mm512_permutevar_pd","使用 b 中的控件在 128 位通道内将 a 双精度 (64-bit) 浮点元素进行打乱，并将结果存储在 dst 中。"],["_mm512_permutevar_ps","使用 b 中的控件在 128 位通道内将 a 单精度 (32-bit) 浮点元素进行打乱，并将结果存储在 dst 中。"],["_mm512_permutex2var_epi16","使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中对 16 位整数进行打乱，并将结果存储在 dst 中。"],["_mm512_permutex2var_epi32","使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中随机排列 32 位整数，并将结果存储在 dst 中。"],["_mm512_permutex2var_epi64","使用 idx 中的相应选择器和索引在通道中的 a 和 b 中随机排列 64 位整数，并将结果存储在 dst 中。"],["_mm512_permutex2var_epi8","使用 idx 中的相应选择器和索引将 a 和 b 中的 8 位整数跨通道打乱，并将结果存储在 dst 中。"],["_mm512_permutex2var_pd","使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并将结果存储在 dst 中。"],["_mm512_permutex2var_ps","使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对单精度 (32-bit) 浮点元素进行混洗，并将结果存储在 dst 中。"],["_mm512_permutex_epi64","使用 imm8 中的控件在 256 位通道中的 a 内随机排列 64 位整数，并将结果存储在 dst 中。"],["_mm512_permutex_pd","使用 imm8 中的控件在 256 位通道内对双精度 (64-bit) 浮点元素进行打乱，并将结果存储在 dst 中。"],["_mm512_permutexvar_epi16","使用 idx 中的相应索引在跨通道中对 16 位整数进行打乱，并将结果存储在 dst 中。"],["_mm512_permutexvar_epi32","使用 idx 中的相应索引在跨通道中随机排列 32 位整数，并将结果存储在 dst 中。"],["_mm512_permutexvar_epi64","使用 idx 中的相应索引在跨通道中随机排列 64 位整数，并将结果存储在 dst 中。"],["_mm512_permutexvar_epi8","使用 idx 中的相应索引将 a 中的 8 位整数打乱到通道中，并将结果存储在 dst 中。"],["_mm512_permutexvar_pd","使用 idx 中的相应索引在跨通道中对双精度 (64-bit) 浮点元素进行混洗，并将结果存储在 dst 中。"],["_mm512_permutexvar_ps","使用 idx 中的相应索引对跨通道中的单精度 (32-bit) 浮点元素进行打乱。"],["_mm512_popcnt_epi16","对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm512_popcnt_epi32","对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm512_popcnt_epi64","对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。"],["_mm512_popcnt_epi8","对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm512_rcp14_pd","计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并将结果存储在 dst 中。该近似值的最大相对误差小于 2^-14。"],["_mm512_rcp14_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并将结果存储在 dst 中。该近似值的最大相对误差小于 2^-14。"],["_mm512_reduce_add_epi32","通过加法减少包装的 32 位整数。返回 a 中所有元素的总和。"],["_mm512_reduce_add_epi64","通过加法减少包装的 64 位整数。返回 a 中所有元素的总和。"],["_mm512_reduce_add_pd","另外，还减少了包装的双精度 (64-bit) 浮点元素。返回 a 中所有元素的总和。"],["_mm512_reduce_add_ps","此外，还减少了包装的单精度 (32-bit) 浮点元素。返回 a 中所有元素的总和。"],["_mm512_reduce_and_epi32","通过按位 AND 减少包装的 32 位整数。返回 a 中所有元素的按位与。"],["_mm512_reduce_and_epi64","通过按位 AND 减少包装的 64 位整数。返回 a 中所有元素的按位与。"],["_mm512_reduce_max_epi32","最多减少包装的带符号 32 位整数。返回 a 中所有元素的最大值。"],["_mm512_reduce_max_epi64","最大减少包装的带符号的 64 位整数。返回 a 中所有元素的最大值。"],["_mm512_reduce_max_epu32","最多减少包装的无符号 32 位整数。返回 a 中所有元素的最大值。"],["_mm512_reduce_max_epu64","最多减少包装的无符号 64 位整数。返回 a 中所有元素的最大值。"],["_mm512_reduce_max_pd","最大减少包装的双精度 (64-bit) 浮点元素。返回 a 中所有元素的最大值。"],["_mm512_reduce_max_ps","最大减少包装的单精度 (32-bit) 浮点元素。返回 a 中所有元素的最大值。"],["_mm512_reduce_min_epi32","将包装的有符号的 32 位整数减少到最小值。返回 a 中所有元素的最小值。"],["_mm512_reduce_min_epi64","将一个包装的有符号 64 位整数减少到最小值。返回 a 中所有元素的最小值。"],["_mm512_reduce_min_epu32","将一个包装的无符号 32 位整数减少到最小值。返回 a 中所有元素的最小值。"],["_mm512_reduce_min_epu64","将一个包装的无符号 64 位整数减少到最小。返回 a 中所有元素的最小值。"],["_mm512_reduce_min_pd","将一个包装的双精度（64位）浮点元素减少到最小。返回 a 中所有元素的最小值。"],["_mm512_reduce_min_ps","将一个包装的单精度（32位）浮点元素减少到最小。返回 a 中所有元素的最小值。"],["_mm512_reduce_mul_epi32","通过乘法减少包装的 32 位整数。返回 a 中所有元素的乘积。"],["_mm512_reduce_mul_epi64","通过乘法减少包装的 64 位整数。返回 a 中所有元素的乘积。"],["_mm512_reduce_mul_pd","通过乘法减少包装的双精度 (64-bit) 浮点元素。返回 a 中所有元素的乘积。"],["_mm512_reduce_mul_ps","通过乘法减少包装的单精度 (32-bit) 浮点元素。返回 a 中所有元素的乘积。"],["_mm512_reduce_or_epi32","通过按位 OR 减少包装的 32 位整数。返回 a 中所有元素的按位或。"],["_mm512_reduce_or_epi64","通过按位 OR 减少包装的 64 位整数。返回 a 中所有元素的按位或。"],["_mm512_rol_epi32","将 X 中每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，然后将结果存储在 dst 中。"],["_mm512_rol_epi64","将 X 中每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后将结果存储在 dst 中。"],["_mm512_rolv_epi32","将 a 中每个包装的 32 位整数中的位向左旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。"],["_mm512_rolv_epi64","将 a 中每个包装的 64 位整数中的位向左旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。"],["_mm512_ror_epi32","将 X 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并将结果存储在 dst 中。"],["_mm512_ror_epi64","将 X 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，然后将结果存储在 dst 中。"],["_mm512_rorv_epi32","将 a 中每个包装的 32 位整数中的位向右旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。"],["_mm512_rorv_epi64","将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。"],["_mm512_roundscale_pd","将 x 中的包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并将结果存储在 dst 中。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm512_roundscale_ps","将 a 中的包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的小数位数，然后将结果存储在 dst 中。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm512_roundscale_round_pd","将 x 中的包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并将结果存储在 dst 中。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm512_roundscale_round_ps","将 a 中的包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的小数位数，然后将结果存储在 dst 中。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm512_rsqrt14_pd","计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数平方根，并将结果存储在 dst 中。该近似值的最大相对误差小于 2^-14。"],["_mm512_rsqrt14_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并将结果存储在 dst 中。该近似值的最大相对误差小于 2^-14。"],["_mm512_sad_epu8","计算 a 和 b 中包装的无符号 8 位整数的绝对差，然后将每个连续的 8 个差水平地求和以生成八个无符号的 16 位整数，并将这些无符号的 16 位整数包装在 64 位元素的低 16 位中在 dst。"],["_mm512_scalef_pd","使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_scalef_ps","使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_scalef_round_pd","使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_scalef_round_ps","使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_set1_epi16","将低包装的 16 位整数从 a 广播到 dst 的所有所有元素。"],["_mm512_set1_epi32","向 `dst` 的所有元素广播 32 位整数 `a`。"],["_mm512_set1_epi64","向 `dst` 的所有元素广播 64 位整数 `a`。"],["_mm512_set1_epi8","向 dst 的所有元素广播 8 位整数 a。"],["_mm512_set1_pd","向 `dst` 的所有元素广播 64 位浮点数 `a`。"],["_mm512_set1_ps","向 `dst` 的所有元素广播 32 位浮点数 `a`。"],["_mm512_set4_epi32","使用重复的 4 个元素序列在 dst 中设置包装的 32 位整数。"],["_mm512_set4_epi64","使用重复的 4 个元素序列在 dst 中设置包装的 64 位整数。"],["_mm512_set4_pd","使用重复的 4 个元素序列在 dst 中设置包装的双精度 (64-bit) 浮点元素。"],["_mm512_set4_ps","使用重复的 4 个元素序列在 dst 中设置包装的单精度 (32-bit) 浮点元素。"],["_mm512_set_epi16","使用提供的值在 dst 中设置包装的 16 位整数。"],["_mm512_set_epi32","使用提供的值在 `dst` 中设置包装的 32 位整数。"],["_mm512_set_epi64","使用提供的值在 dst 中设置包装的 64 位整数。"],["_mm512_set_epi8","使用提供的值在 dst 中设置包装的 8 位整数。"],["_mm512_set_pd","使用提供的值在 dst 中设置包装的双精度 (64-bit) 浮点元素。"],["_mm512_set_ps","使用提供的值在 `dst` 中设置包装的 32 位整数。"],["_mm512_setr4_epi32","在 dst 中设置包装的 32 位整数，并以相反的顺序重复 4 个元素序列。"],["_mm512_setr4_epi64","在 dst 中设置包装的 64 位整数，并以相反的顺序重复 4 个元素序列。"],["_mm512_setr4_pd","在 dst 中设置包装的双精度 (64-bit) 浮点元素，并以相反的顺序重复 4 个元素序列。"],["_mm512_setr4_ps","在 dst 中设置包装的单精度 (32-bit) 浮点元素，并以相反的顺序重复 4 个元素。"],["_mm512_setr_epi32","在 `dst` 中设置包装的 32 位整数，并以相反的顺序提供所提供的值。"],["_mm512_setr_epi64","在 dst 中设置包装的 64 位整数，并以相反的顺序提供所提供的值。"],["_mm512_setr_pd","在 dst 中设置包装的双精度 (64-bit) 浮点元素，并以相反的顺序提供所提供的值。"],["_mm512_setr_ps","在 `dst` 中设置包装的 32 位整数，并以相反的顺序提供所提供的值。"],["_mm512_setzero","返回 __m512 类型的 vector，所有元素均设置为零。"],["_mm512_setzero_epi32","返回类型为 __m512i 的 vector，所有元素均设置为零。"],["_mm512_setzero_pd","返回 `__m512d` 类型的 vector，所有元素均设置为零。"],["_mm512_setzero_ps","返回 `__m512d` 类型的 vector，所有元素均设置为零。"],["_mm512_setzero_si512","返回 `__m512i` 类型的 vector，所有元素均设置为零。"],["_mm512_shldi_epi16","在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并将高 16 位存储在 dst 中)。"],["_mm512_shldi_epi32","将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并将高 32 位存储在 dst 中。"],["_mm512_shldi_epi64","在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并将高 64 位存储在 dst 中)。"],["_mm512_shldv_epi16","在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的对应元素中指定的量，并将高 16 位存储在 dst 中。"],["_mm512_shldv_epi32","将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的对应元素中指定的量，并将高 32 位存储在 dst 中。"],["_mm512_shldv_epi64","在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的对应元素中指定的量，并将高 64 位存储在 dst 中。"],["_mm512_shrdi_epi16","将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并将低 16 位存储在 dst 中。"],["_mm512_shrdi_epi32","连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并将低 32 位存储在 dst 中。"],["_mm512_shrdi_epi64","将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并将低 64 位存储在 dst 中。"],["_mm512_shrdv_epi16","将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的对应元素中指定的量，并将低 16 位存储在 dst 中。"],["_mm512_shrdv_epi32","连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的对应元素中指定的量，并将低 32 位存储在 dst 中。"],["_mm512_shrdv_epi64","将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的对应元素中指定的量，并将低 64 位存储在 dst 中。"],["_mm512_shuffle_epi32","使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并将结果存储在 dst 中。"],["_mm512_shuffle_epi8","根据 b 的对应 8 位元素中的打乱控制掩码，将 a 中的包装 8 位整数进行打乱，并将结果存储在 dst 中。"],["_mm512_shuffle_f32x4","imm8 从 a 和 b 中随机选择 128 位 (由 4 个单精度 (32-bit) 浮点元素组成)，并将结果存储在 dst 中。"],["_mm512_shuffle_f64x2","随机排列 imm8 从 a 和 b 中选择的 128 位 (由 2 个双精度 (64-bit) 浮点元素组成)，并将结果存储在 dst 中。"],["_mm512_shuffle_i32x4","随机排列 imm8 从 a 和 b 中选择的 128 位 (由 4 个 32 位整数组成)，并将结果存储在 dst 中。"],["_mm512_shuffle_i64x2","随机排列 imm8 从 a 和 b 中选择的 128 位 (由 2 个 64 位整数组成)，并将结果存储在 dst 中。"],["_mm512_shuffle_pd","使用 imm8 中的控件对 128 位通道中的双精度 (64-bit) 浮点元素进行混洗，并将结果存储在 dst 中。"],["_mm512_shuffle_ps","使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并将结果存储在 dst 中。"],["_mm512_shufflehi_epi16","使用 imm8 中的控件在 a 的 128 位通道的高 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的高 64 位中，并从 a 到 dst 复制 128 位的通道的低 64 位。"],["_mm512_shufflelo_epi16","使用 imm8 中的控件在 a 的 128 位通道的低 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的低 64 位中，并从 a 到 dst 复制 128 位的通道的高 64 位。"],["_mm512_sll_epi16","将包装的 16 位整数按计数左移，同时将零移位，并将结果存储在 dst 中。"],["_mm512_sll_epi32","将包装的 32 位整数左移计数，同时将零移位，并将结果存储在 dst 中。"],["_mm512_sll_epi64","将填充的 64 位整数左移计数，同时将零移位，并将结果存储在 dst 中。"],["_mm512_slli_epi16","将包装的 16 位整数左移 imm8，同时将零移位，并将结果存储在 dst 中。"],["_mm512_slli_epi32","将包装的 32 位整数左移 imm8，同时将零移位，并将结果存储在 dst 中。"],["_mm512_slli_epi64","将包装的 64 位整数左移 imm8，同时将零移位，并将结果存储在 dst 中。"],["_mm512_sllv_epi16","将包装的 16 位整数按 count 中相应元素指定的数量向左移位，同时将零移位，并将结果存储在 dst 中。"],["_mm512_sllv_epi32","将填充的 32 位整数向左移动 count 中相应元素指定的数量，同时向零移动，并将结果存储在 dst 中。"],["_mm512_sllv_epi64","将填充的 64 位整数向左移动由 count 中相应元素指定的数量，同时向零移动，并将结果存储在 dst 中。"],["_mm512_sqrt_pd","计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并将结果存储在 dst 中。"],["_mm512_sqrt_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并将结果存储在 dst 中。"],["_mm512_sqrt_round_pd","计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并将结果存储在 dst 中。"],["_mm512_sqrt_round_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并将结果存储在 dst 中。"],["_mm512_sra_epi16","将包装的 16 位整数按计数右移，同时将符号位移位，并将结果存储在 dst 中。"],["_mm512_sra_epi32","在移入符号位的同时按计数右移包装的 32 位整数，并将结果存储在 dst 中。"],["_mm512_sra_epi64","在移动符号位的同时按计数右移包装的 64 位整数，并将结果存储在 dst 中。"],["_mm512_srai_epi16","将包装的 16 位整数右移 imm8，同时将符号位移位，并将结果存储在 dst 中。"],["_mm512_srai_epi32","将包装的 32 位整数右移 imm8，同时将符号位移位，并将结果存储在 dst 中。"],["_mm512_srai_epi64","将包装的 64 位整数右移 imm8，同时将符号位移位，并将结果存储在 dst 中。"],["_mm512_srav_epi16","将包装的 16 位整数右移 count 中相应元素指定的数量，同时移入符号位，然后将结果存储在 dst 中。"],["_mm512_srav_epi32","在将符号位移位的同时，将已包装的 32 位整数右移由 count 中相应元素指定的数量，然后将结果存储在 dst 中。"],["_mm512_srav_epi64","将移位的 64 位整数向右移动计数中相应元素指定的数量，同时移入符号位，并将结果存储在 dst 中。"],["_mm512_srl_epi16","将包装的 16 位整数按计数右移，同时将零移位，并将结果存储在 dst 中。"],["_mm512_srl_epi32","将计数包装的 32 位整数右移，同时将零移位，并将结果存储在 dst 中。"],["_mm512_srl_epi64","按计数右移包装的 64 位整数，同时将零移位，并将结果存储在 dst 中。"],["_mm512_srli_epi16","将包装的 16 位整数右移 imm8，同时将零移位，并将结果存储在 dst 中。"],["_mm512_srli_epi32","将包装的 32 位整数右移 imm8，同时将零移位，并将结果存储在 dst 中。"],["_mm512_srli_epi64","将包装的 64 位整数右移 imm8，同时将零移位，并将结果存储在 dst 中。"],["_mm512_srlv_epi16","将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并将结果存储在 dst 中。"],["_mm512_srlv_epi32","向右移动已包装的 32 位整数，偏移量为计数中相应元素指定的数量，同时向零移动，并将结果存储在 dst 中。"],["_mm512_srlv_epi64","向右移位包装的 64 位整数 (由 count 中相应元素指定的数量)，同时向零移位，并将结果存储在 dst 中。"],["_mm512_store_epi32","将 a 中的 512 位 (由 16 个包装的 32 位整数组成) 存储到内存中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。"],["_mm512_store_epi64","将 a 中的 512 位 (由 8 个包装的 64 位整数组成) 存储到内存中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。"],["_mm512_store_pd","将 a 中的 512 位 (由 8 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。"],["_mm512_store_ps","将 a 中的 512 位整数数据存储到内存中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。"],["_mm512_store_si512","将 a 中的 512 位整数数据存储到内存中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。"],["_mm512_storeu_epi16","将 a 中的 512 位 (由 32 个包装的 16 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。"],["_mm512_storeu_epi32","将 a 中的 512 位 (由 16 个包装的 32 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。"],["_mm512_storeu_epi64","将 a 中的 512 位 (由 8 个包装的 64 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。"],["_mm512_storeu_epi8","将 a 中的 512 位 (由 64 个包装的 8 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。"],["_mm512_storeu_pd","将来自 `a` 的 512 位 (由 8 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。"],["_mm512_storeu_ps","将来自 `a` 的 512 位 (由 16 个包装的单精度 (32-bit) 浮点元素组成) 存储到内存中。"],["_mm512_storeu_si512","将 a 中的 512 位整数数据存储到内存中。mem_addr 不需要在任何特定边界上对齐。"],["_mm512_stream_pd","使用非临时内存提示将 512 位 (由 8 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。"],["_mm512_stream_ps","使用非临时内存提示将 512 位 (由 16 个包装的单精度 (32-bit) 浮点元素组成) 存储到内存中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。"],["_mm512_stream_si512","使用非临时内存提示将 512 位整数数据从 a 存储到内存中。mem_addr 必须在 64 字节边界上对齐，否则可能会生成常规保护异常。"],["_mm512_sub_epi16","从 a 中的包装的 16 位整数中减去 b 中的包装的 16 位整数，并将结果存储在 dst 中。"],["_mm512_sub_epi32","从 a 中的包装 32 位整数中减去 b 中的包装 32 位整数，并将结果存储在 dst 中。"],["_mm512_sub_epi64","从 a 中的包装 64 位整数中减去 b 中的包装 64 位整数，并将结果存储在 dst 中。"],["_mm512_sub_epi8","从 a 中的包装 8 位整数中减去 b 中的包装 8 位整数，并将结果存储在 dst 中。"],["_mm512_sub_pd","从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_sub_ps","从 a 中的包装的单精度 (32-bit) 浮点元素中减去 b 中的包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_sub_round_pd","从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_sub_round_ps","从 a 中的包装的单精度 (32-bit) 浮点元素中减去 b 中的包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_subs_epi16","使用饱和度从 a 中的包装的 16 位整数减去 b 中的包装的有符号 16 位整数，并将结果存储在 dst 中。"],["_mm512_subs_epi8","使用饱和度从包装的 8 位整数中减去 b 中的包装有符号 8 位整数，并将结果存储在 dst 中。"],["_mm512_subs_epu16","使用饱和度将 b 中的包装无符号 16 位整数减去 b 中的包装无符号 16 位整数，并将结果存储在 dst 中。"],["_mm512_subs_epu8","使用 a 饱和度将 b 中的包装无符号 8 位整数减去 b 中的包装无符号 8 位整数，并将结果存储在 dst 中。"],["_mm512_ternarylogic_epi32","提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个包装的 32 位整数中的每个位，来自 a，b 和 c 的相应位用于形成到 imm8 的 3 位索引，并且将 imm8 中该位的值写入 dst 中的相应位。"],["_mm512_ternarylogic_epi64","提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 64 位整数中的每一位，a、b 和 c 中的相应位用于形成 imm8 中的 3 位索引，并将 imm8 中该位的值写入 dst 中的相应位。"],["_mm512_test_epi16_mask","计算 a 和 b 中包装的 16 位整数的按位与，生成中间的 16 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。"],["_mm512_test_epi32_mask","计算 a 和 b 中包装的 32 位整数的按位与，生成中间的 32 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。"],["_mm512_test_epi64_mask","计算 a 和 b 中包装的 64 位整数的按位与，生成中间 64 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。"],["_mm512_test_epi8_mask","计算 a 和 b 中包装的 8 位整数的按位与，生成中间 8 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。"],["_mm512_testn_epi16_mask","计算 a 和 b 中包装的 16 位整数的按位 NAND，生成中间的 16 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。"],["_mm512_testn_epi32_mask","计算 a 和 b 中包装的 32 位整数的按位 NAND，生成中间的 32 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。"],["_mm512_testn_epi64_mask","计算 a 和 b 中包装的 64 位整数的按位 NAND，生成中间的 64 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。"],["_mm512_testn_epi8_mask","计算 a 和 b 中包装的 8 位整数的按位 NAND，生成中间的 8 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。"],["_mm512_undefined","返回类型为 __m512 的 vector，其中包含未定义的元素。"],["_mm512_undefined_epi32","返回类型为 __m512i 的 vector，其中包含未定义的元素。"],["_mm512_undefined_pd","返回带有未定义元素的 `__m512d` 类型的 vector。"],["_mm512_undefined_ps","返回带有未定义元素的 `__m512` 类型的 vector。"],["_mm512_unpackhi_epi16","从 a 和 b 中每个 128 位通道的高半部分拆包和交织 16 位整数，并将结果存储在 dst 中。"],["_mm512_unpackhi_epi32","从 a 和 b 中每个 128 位通道的高半部分解包和交织 32 位整数，并将结果存储在 dst 中。"],["_mm512_unpackhi_epi64","从 a 和 b 中每个 128 位通道的高半部分解包和交织 64 位整数，并将结果存储在 dst 中。"],["_mm512_unpackhi_epi8","从 a 和 b 中每个 128 位通道的高半部分拆包和交织 8 位整数，并将结果存储在 dst 中。"],["_mm512_unpackhi_pd","从 a 和 b 中每个 128 位通道的高半部分解包并交织双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_unpackhi_ps","从 a 和 b 中每个 128 位通道的高半部分解包和交织单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_unpacklo_epi16","从 a 和 b 中每个 128 位通道的下半部分拆包并交织 16 位整数，并将结果存储在 dst 中。"],["_mm512_unpacklo_epi32","从 a 和 b 中每个 128 位通道的下半部分解包和交织 32 位整数，并将结果存储在 dst 中。"],["_mm512_unpacklo_epi64","从 a 和 b 中每个 128 位通道的下半部分解包并交织 64 位整数，并将结果存储在 dst 中。"],["_mm512_unpacklo_epi8","从 a 和 b 中每个 128 位通道的下半部分拆包并交织 8 位整数，并将结果存储在 dst 中。"],["_mm512_unpacklo_pd","从 a 和 b 中每个 128 位通道的下半部分解解包并交织双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_unpacklo_ps","从 a 和 b 中每个 128 位通道的下半部分解压包并交织单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm512_xor_epi32","计算 a 和 b 中包装的 32 位整数的按位 XOR，并将结果存储在 dst 中。"],["_mm512_xor_epi64","计算 a 和 b 中包装的 64 位整数的按位 XOR，并将结果存储在 dst 中。"],["_mm512_xor_si512","计算 a 和 b 中 512 位 (代表整数数据) 的按位 XOR，并将结果存储在 dst 中。"],["_mm512_zextpd128_pd512","将类型 __m128d 的 vector 强制转换为 __m512d 类型; 结果的高 384 位被清零。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。"],["_mm512_zextpd256_pd512","将类型 __m256d 的 vector 强制转换为 __m512d 类型; 结果的高 256 位被清零。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。"],["_mm512_zextps128_ps512","将类型 __m128 的 vector 转换为 __m512 类型; 结果的高 384 位被清零。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。"],["_mm512_zextps256_ps512","将类型为 __m256 的 vector 强制转换为类型 __m512; 结果的高 256 位被清零。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。"],["_mm512_zextsi128_si512","将类型为 __m128i 的 vector 强制转换为类型 __m512i; 结果的高 384 位被清零。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。"],["_mm512_zextsi256_si512","将类型为 __m256i 的 vector 强制转换为类型 __m512i; 结果的高 256 位被清零。此内联函数仅用于编译，不会生成任何指令，因此延迟为零。"],["_mm_abs_epi16","计算 `a` 中每个包装的 16 位有符号整数的绝对值，并返回 16 位无符号整数"],["_mm_abs_epi32","计算 `a` 中每个包装的 32 位有符号整数的绝对值，并返回 32 位无符号整数"],["_mm_abs_epi8","计算 `a` 中包装的 8 位带符号整数的绝对值，并返回无符号结果。"],["_mm_add_epi16","在 `a` 和 `b` 中添加包装的 16 位整数。"],["_mm_add_epi32","在 `a` 和 `b` 中添加包装的 32 位整数。"],["_mm_add_epi64","在 `a` 和 `b` 中添加包装的 64 位整数。"],["_mm_add_epi8","在 `a` 和 `b` 中添加包装的 8 位整数。"],["_mm_add_pd","在 `a` 和 `b` 中添加包装的双精度 (64-bit) 浮点元素。"],["_mm_add_ps","添加 __m128 vectors。"],["_mm_add_round_sd","在 a 和 b 中添加较低的双精度 (64-bit) 浮点元素，将结果存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。"],["_mm_add_round_ss","在 a 和 b 中添加较低的单精度 (32-bit) 浮点元素，将结果存储在 dst 的较低元素中，并将较高的 3 个包装的元素从 a 复制到 dst 的较高元素。"],["_mm_add_sd","返回一个新的 vector，其中 `a` 的低位元素替换为 `a` 和 `b` 的低位元素之和。"],["_mm_add_ss","添加 `a` 和 `b` 的第一个组件，其他组件从 `a` 复制。"],["_mm_adds_epi16","使用饱和度在 `a` 和 `b` 中添加包装的 16 位整数。"],["_mm_adds_epi8","使用饱和度在 `a` 和 `b` 中添加包装的 8 位整数。"],["_mm_adds_epu16","使用饱和度在 `a` 和 `b` 中添加包装的无符号 16 位整数。"],["_mm_adds_epu8","使用饱和度在 `a` 和 `b` 中添加包装的无符号 8 位整数。"],["_mm_addsub_pd","或者，在 `a` 中的包装的双精度 (64-bit) 浮点元素中加减 `b` 中的 to/from 包装的元素。"],["_mm_addsub_ps","或者，在 `a` 中的包装的单精度 (32-bit) 浮点元素上加减 `b` 中的包装的元素 to/from。"],["_mm_aesdec_si128","对 `a` 中的数据 (state) 执行一轮 AES 解密流程。"],["_mm_aesdeclast_si128","对 `a` 中的数据 (state) 执行 AES 解密流的最后一轮。"],["_mm_aesenc_si128","对 `a` 中的数据 (state) 执行一轮 AES 加密流程。"],["_mm_aesenclast_si128","对 `a` 中的数据 (state) 执行最后一轮 AES 加密流程。"],["_mm_aesimc_si128","在 `a` 上执行 `InvMixColumns` 转换。"],["_mm_aeskeygenassist_si128","协助扩展 AES 密钥。"],["_mm_alignr_epi32","将 a 和 b 连接成一个 32 字节的 immediate 结果，将结果右移 imm8 个 32 位元素，并将低 16 字节 (4 个元素) 存储在 dst 中。"],["_mm_alignr_epi64","将 a 和 b 连接成一个 32 字节的 immediate 结果，将结果右移 imm8 个 64 位元素，并将低 16 字节 (2 个元素) 存储在 dst 中。"],["_mm_alignr_epi8","将 `a` 和 `b` 中的 16 字节块连接成一个 32 字节的临时结果，将结果右移 `n` 字节，然后返回低 16 字节。"],["_mm_and_pd","计算 `a` 和 `b` 中包装的双精度 (64-bit) 浮点元素的按位与。"],["_mm_and_ps","包装的单精度 (32-bit) 浮点元素的按位与。"],["_mm_and_si128","计算 `a` 和 `b` 中 128 位 (表示整数数据) 的按位与。"],["_mm_andnot_pd","计算 `a` 的按位 NOT，然后计算 `b` 的 AND。"],["_mm_andnot_ps","包装的单精度 (32-bit) 浮点元素的按位与非运算。"],["_mm_andnot_si128","计算 `a` 中 128 位 (代表整数数据) 的按位非，然后计算 `b` 的与。"],["_mm_avg_epu16","`a` 和 `b` 中的包装无符号 16 位整数的平均值。"],["_mm_avg_epu8","`a` 和 `b` 中的包装无符号 8 位整数的平均值。"],["_mm_bitshuffle_epi64_mask","将输入 `b` 视为包装的 64 位整数，并将 `c` 视为包装的 8 位整数。 然后将来自 `c` 的 8 个 8 位值作为索引分组到相应的 64 位整数的位中。 然后，选择这些位并将其包装到输出中。"],["_mm_blend_epi16","使用掩码 `IMM8` 混合来自 `a` 和 `b` 的 16 位整数包装。"],["_mm_blend_epi32","使用控制掩码 `IMM4` 混合来自 `a` 和 `b` 的包装的 32 位整数。"],["_mm_blend_pd","使用控制掩码 `IMM2` 从 `a` 和 `b` 混合包装的双精度 (64-bit) 浮点元素"],["_mm_blend_ps","使用掩码 `IMM4` 从 `a` 和 `b` 混合包装的单精度 (32-bit) 浮点元素"],["_mm_blendv_epi8","使用 `mask` 混合 `a` 和 `b` 中的包装 8 位整数"],["_mm_blendv_pd","使用 `mask` 混合来自 `a` 和 `b` 的包装的双精度 (64-bit) 浮点元素"],["_mm_blendv_ps","使用 `mask` 混合来自 `a` 和 `b` 的包装的单精度 (32-bit) 浮点元素"],["_mm_broadcast_ss","从内存向返回的 vector 的所有元素广播单精度 (32-bit) 浮点元素。"],["_mm_broadcastb_epi8","将 `a` 的低位包装 8 位整数广播到 128 位返回值的所有元素。"],["_mm_broadcastd_epi32","将 `a` 的低位包装 32 位整数广播到 128 位返回值的所有元素。"],["_mm_broadcastmb_epi64","将输入掩码 k 的低 8 位广播到 dst 的所有 64 位元素。"],["_mm_broadcastmw_epi32","将输入掩码 k 的低 16 位广播到 dst 的所有 32 位元素。"],["_mm_broadcastq_epi64","将 `a` 的低位包装 64 位整数广播到 128 位返回值的所有元素。"],["_mm_broadcastsd_pd","将低双精度 (64-bit) 浮点元素从 `a` 广播到 128 位返回值的所有元素。"],["_mm_broadcastss_ps","将低单精度 (32-bit) 浮点元素从 `a` 广播到 128 位返回值的所有元素。"],["_mm_broadcastw_epi16","将低包装的 16 位整数从 a 广播到 128 位返回值的所有元素"],["_mm_bslli_si128","将 `a` 左移 `IMM8` 个字节，同时移入零。"],["_mm_bsrli_si128","将 `a` 右移 `IMM8` 个字节，同时移入零。"],["_mm_castpd_ps","将 `[2 x double]` 的 128 位浮点 vector 转换为 `[4 x float]` 的 128 位浮点 vector。"],["_mm_castpd_si128","将 `[2 x double]` 的 128 位浮点 vector 转换为 128 位整数 vector。"],["_mm_castps_pd","将 `[4 x float]` 的 128 位浮点 vector 转换为 `[2 x double]` 的 128 位浮点 vector。"],["_mm_castps_si128","将 `[4 x float]` 的 128 位浮点 vector 转换为 128 位整数 vector。"],["_mm_castsi128_pd","将 128 位整数 vector 转换为 `[2 x double]` 的 128 位浮点 vector。"],["_mm_castsi128_ps","将 128 位整数 vector 转换为 `[4 x float]` 的 128 位浮点 vector。"],["_mm_ceil_pd","将 `a` 中的包装的双精度 (64-bit) 浮点元素四舍五入为整数，并将结果存储为包装的双精度浮点元素。"],["_mm_ceil_ps","将 `a` 中的包装的单精度 (32-bit) 浮点元素四舍五入为整数，并将结果存储为包装的单精度浮点元素。"],["_mm_ceil_sd","将 `b` 中的下部双精度 (64-bit) 浮点元素四舍五入为整数，将结果作为双精度浮点元素存储在本征结果的下部元素中，并将上部元素从 `a` 复制到上部内在结果的元素。"],["_mm_ceil_ss","将 `b` 中的下部单精度 (32-bit) 浮点元素四舍五入为整数，将结果作为单精度浮点元素存储在内部结果的下部元素中，并将高 3 个包装的元素从 `a` 复制到内在结果的上层要素。"],["_mm_clflush","使高速缓存层次结构中所有级别的包含 `p` 的高速缓存行失效并刷新。"],["_mm_clmulepi64_si128","在有限域 GF(2^k) 上执行两个 64 位多项式的无进位乘法。"],["_mm_cmp_epi16_mask","根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号 16 位整数，并将结果存储在掩码 vector k 中。"],["_mm_cmp_epi32_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装有符号 32 位整数，并将结果存储在掩码 vector k 中。"],["_mm_cmp_epi64_mask","根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 64 位整数，并将结果存储在掩码 vector k 中。"],["_mm_cmp_epi8_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装带符号 8 位整数，并将结果存储在掩码 vector k 中。"],["_mm_cmp_epu16_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 16 位整数，并将结果存储在掩码 vector k 中。"],["_mm_cmp_epu32_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 32 位整数，并将结果存储在掩码 vector k 中。"],["_mm_cmp_epu64_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 64 位整数，并将结果存储在掩码 vector k 中。"],["_mm_cmp_epu8_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 8 位整数，并将结果存储在掩码 vector k 中。"],["_mm_cmp_pd","根据 `IMM5` 指定的比较操作数比较 `a` 和 `b` 中包装的双精度 (64-bit) 浮点元素。"],["_mm_cmp_pd_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在掩码 vector k 中。"],["_mm_cmp_ps","根据 `IMM5` 指定的比较操作数比较 `a` 和 `b` 中包装的单精度 (32-bit) 浮点元素。"],["_mm_cmp_ps_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并将结果存储在掩码 vector k 中。"],["_mm_cmp_round_sd_mask","根据 imm8 指定的比较操作数比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，并将结果存储在掩码 vector k 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_cmp_round_ss_mask","根据 imm8 指定的比较操作数比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，并将结果存储在掩码 vector k 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_cmp_sd","根据 `IMM5` 指定的比较操作数，比较 `a` 和 `b` 中的低位双精度浮点元素 (64-bit)，将结果存入返回的 vector 的低位元素，并将 `a` 的高位元素复制到返回的 vector 的高位元素。"],["_mm_cmp_sd_mask","根据 imm8 指定的比较操作数比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，并将结果存储在掩码 vector k 中。"],["_mm_cmp_ss","根据 `IMM5` 指定的比较操作数比较 `a` 和 `b` 中的低位单精度 (32-bit) 浮点元素，将结果存储在返回的 vector 的低位元素中，并将高 3 个包装的元素从 `a` 复制到返回 vector。"],["_mm_cmp_ss_mask","根据 imm8 指定的比较操作数比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，并将结果存储在掩码 vector k 中。"],["_mm_cmpeq_epi16","比较 `a` 和 `b` 中的包装的 16 位整数是否相等。"],["_mm_cmpeq_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm_cmpeq_epi32","比较 `a` 和 `b` 中的包装 32 位整数是否相等。"],["_mm_cmpeq_epi32_mask","比较 a 和 b 中包装的 32 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm_cmpeq_epi64","比较 `a` 和 `b` 中的包装 64 位整数是否相等"],["_mm_cmpeq_epi64_mask","比较 a 和 b 中包装的 64 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm_cmpeq_epi8","比较 `a` 和 `b` 中的包装 8 位整数是否相等。"],["_mm_cmpeq_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm_cmpeq_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm_cmpeq_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm_cmpeq_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm_cmpeq_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm_cmpeq_pd","比较 `a` 和 `b` 中的相应元素是否相等。"],["_mm_cmpeq_ps","将 `a` 中的四个浮点数中的每个与 `b` 中的对应元素进行比较。 如果输入元素相等，则输出 vector 中的结果将为 `0xffffffff`，否则为 `0`。"],["_mm_cmpeq_sd","返回一个新的 vector，其中 `a` 的低位元素被 `a` 和 `b` 的低位元素的相等比较取代。"],["_mm_cmpeq_ss","比较两个输入中的最低 `f32` 是否相等。 如果两个输入相等，结果的最低 32 位将为 `0xffffffff`，否则为 `0`。 结果的高 96 位是 `a` 的高 96 位。"],["_mm_cmpestra","使用 `IMM8` 中的控件将 `a` 和 `b` 中的包装字符串与长度 `la` 和 `lb` 进行比较，如果 `b` 不包含空字符且结果掩码为零，则返回 `1`，否则返回 `0`。"],["_mm_cmpestrc","使用 `IMM8` 中的控件将 `a` 和 `b` 中的包装字符串与长度 `la` 和 `lb` 进行比较，如果结果掩码非零则返回 `1`，否则返回 `0`。"],["_mm_cmpestri","使用 `IMM8` 中的控件将包装的字符串 `a` 和 `b` 与长度 `la` 和 `lb` 进行比较，并返回生成的索引。 与 `_mm_cmpistri` 相似，但 `_mm_cmpistri` 隐式确定 `a` 和 `b` 的长度。"],["_mm_cmpestrm","使用 `IMM8` 中的控件将 `a` 和 `b` 中包装的字符串与长度 `la` 和 `lb` 进行比较，并返回生成的掩码。"],["_mm_cmpestro","使用 `IMM8` 中的控件将 `a` 和 `b` 中的包装字符串与长度 `la` 和 `lb` 进行比较，并返回结果位掩码的位 `0`。"],["_mm_cmpestrs","使用 `IMM8` 中的控件将 `a` 和 `b` 中的包装字符串与长度 `la` 和 `lb` 进行比较，如果 a 中的任何字符为空，则返回 `1`，否则返回 `0`。"],["_mm_cmpestrz","使用 `IMM8` 中的控件将 `a` 和 `b` 中的包装字符串与长度 `la` 和 `lb` 进行比较，如果 `b` 中的任何字符为空，则返回 `1`，否则返回 `0`。"],["_mm_cmpge_epi16_mask","比较 a 和 b 中包装的带符号 16 位整数是否大于等于，并将结果存储在掩码 vector k 中。"],["_mm_cmpge_epi32_mask","比较 a 和 b 中包装的带符号 32 位整数是否大于等于，并将结果存储在掩码 vector k 中。"],["_mm_cmpge_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数是否大于等于，并将结果存储在掩码 vector k 中。"],["_mm_cmpge_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否大于等于，并将结果存储在掩码 vector k 中。"],["_mm_cmpge_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否大于等于，并将结果存储在掩码 vector k 中。"],["_mm_cmpge_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否大于等于，并将结果存储在掩码 vector k 中。"],["_mm_cmpge_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否大于等于，并将结果存储在掩码 vector k 中。"],["_mm_cmpge_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否大于等于，并将结果存储在掩码 vector k 中。"],["_mm_cmpge_pd","比较 `a` 和 `b` 中的对应元素是否大于等于。"],["_mm_cmpge_ps","将 `a` 中的四个浮点数中的每个与 `b` 中的对应元素进行比较。 如果 `a` 中的输入元素大于或等于 `b` 中的相应元素，则输出 vector 中的结果将为 `0xffffffff`，否则为 `0`。"],["_mm_cmpge_sd","返回一个新的 vector，其中 `a` 的低位元素被 `a` 和 `b` 的低位元素大于或等于的比较所取代。"],["_mm_cmpge_ss","比较两个输入的最低 `f32` 大于或等于。 如果 `a.extract(0)` 大于或等于 `b.extract(0)`，则结果的最低 32 位将为 `0xffffffff`，否则为 `0`。"],["_mm_cmpgt_epi16","比较 `a` 和 `b` 中的包装的 16 位整数是否大于。"],["_mm_cmpgt_epi16_mask","比较 a 和 b 中包装的带符号 16 位整数是否大于，并将结果存储在掩码 vector k 中。"],["_mm_cmpgt_epi32","比较 `a` 和 `b` 中的包装的 32 位整数是否大于。"],["_mm_cmpgt_epi32_mask","比较 a 和 b 中包装的带符号的 32 位整数是否大于，并将结果存储在掩码 vector k 中。"],["_mm_cmpgt_epi64","比较 `a` 和 `b` 中的包装的 64 位整数是否大于，返回结果。"],["_mm_cmpgt_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数是否大于，并将结果存储在掩码 vector k 中。"],["_mm_cmpgt_epi8","比较 `a` 和 `b` 中的包装的 8 位整数是否大于。"],["_mm_cmpgt_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否大于，并将结果存储在掩码 vector k 中。"],["_mm_cmpgt_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否大于，并将结果存储在掩码 vector k 中。"],["_mm_cmpgt_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否大于，并将结果存储在掩码 vector k 中。"],["_mm_cmpgt_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否大于，并将结果存储在掩码 vector k 中。"],["_mm_cmpgt_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否大于，并将结果存储在掩码 vector k 中。"],["_mm_cmpgt_pd","比较 `a` 和 `b` 中的对应元素是否大于。"],["_mm_cmpgt_ps","将 `a` 中的四个浮点数中的每个与 `b` 中的对应元素进行比较。 如果 `a` 中的输入元素大于 `b` 中的相应元素，则输出 vector 中的结果将为 `0xffffffff`，否则为 `0`。"],["_mm_cmpgt_sd","返回一个新的 vector，其中 `a` 的低位元素被 `a` 和 `b` 的低位元素大于的比较所代替。"],["_mm_cmpgt_ss","比较两个输入的最低 `f32` 大于。 如果 `a.extract(0)` 大于 `b.extract(0)`，则结果的最低 32 位将为 `0xffffffff`，否则为 `0`。"],["_mm_cmpistra","使用 `IMM8` 中的控件比较 `a` 和 `b` 中隐含长度的包装字符串，如果 `b` 不包含空字符且结果掩码为零，则返回 `1`，否则返回 `0`。"],["_mm_cmpistrc","使用 `IMM8` 中的控件将包装的字符串与 `a` 和 `b` 中的隐式长度进行比较，如果结果掩码不为零，则返回 `1`，否则返回 `0`。"],["_mm_cmpistri","使用 `IMM8` 中的控件比较 `a` 和 `b` 中隐含长度的包装字符串，并返回生成的索引。 与 [`_mm_cmpestri`] 相似，不同之处在于 [`_mm_cmpestri`] 需要明确指定 `a` 和 `b` 的长度。"],["_mm_cmpistrm","使用 `IMM8` 中的控件比较 `a` 和 `b` 中隐含长度的包装的字符串，并返回生成的掩码。"],["_mm_cmpistro","使用 `IMM8` 中的控件比较 `a` 和 `b` 中隐含长度的包装字符串，并返回结果位掩码的位 `0`。"],["_mm_cmpistrs","使用 `IMM8` 中的控件比较 `a` 和 `b` 中隐含长度的包装字符串，如果 `a` 中的任何字符为空，则返回 `1`，否则返回 `0`。"],["_mm_cmpistrz","使用 `IMM8` 中的控件比较 `a` 和 `b` 中隐含长度的包装字符串，如果 `b` 中的任何字符为空，则返回 `1`。"],["_mm_cmple_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数 (小于等于)，并将结果存储在掩码 vector k 中。"],["_mm_cmple_epi32_mask","比较 a 和 b 中包装的带符号的 32 位整数 (小于等于)，并将结果存储在掩码 vector k 中。"],["_mm_cmple_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数 (小于等于)，并将结果存储在掩码 vector k 中。"],["_mm_cmple_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数 (小于等于)，并将结果存储在掩码 vector k 中。"],["_mm_cmple_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否小于等于，并将结果存储在掩码 vector k 中。"],["_mm_cmple_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否小于等于，并将结果存储在掩码 vector k 中。"],["_mm_cmple_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否小于等于，并将结果存储在掩码 vector k 中。"],["_mm_cmple_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数以得出小于或等于的结果，并将结果存储在掩码 vector k 中。"],["_mm_cmple_pd","比较 `a` 和 `b` 中的对应元素是否小于等于"],["_mm_cmple_ps","将 `a` 中的四个浮点数中的每个与 `b` 中的对应元素进行比较。 如果 `a` 中的输入元素小于或等于 `b` 中的相应元素，则输出 vector 中的结果将为 `0xffffffff`，否则为 `0`。"],["_mm_cmple_sd","返回一个新的 vector，其中 `a` 的低位元素被 `a` 和 `b` 的低位元素小于或等于的比较所取代。"],["_mm_cmple_ss","比较两个输入中的最低 `f32` 小于或等于。最低的 如果 `a.extract(0)` 小于或等于 `b.extract(0)`，则结果的 32 位将为 `0xffffffff`，否则为 `0`。 结果的高 96 位是 `a` 的高 96 位。"],["_mm_cmplt_epi16","比较 `a` 和 `b` 中的包装的 16 位整数小于。"],["_mm_cmplt_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数 (小于)，并将结果存储在掩码 vector k 中。"],["_mm_cmplt_epi32","比较 `a` 和 `b` 中的包装的 32 位整数是否小于。"],["_mm_cmplt_epi32_mask","比较 a 和 b 中包装的带符号的 32 位整数 (小于)，并将结果存储在掩码 vector k 中。"],["_mm_cmplt_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数小于零，并将结果存储在掩码 vector k 中。"],["_mm_cmplt_epi8","比较 `a` 和 `b` 中小于 8 的包装的 8 位整数。"],["_mm_cmplt_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数小于零，并将结果存储在掩码 vector k 中。"],["_mm_cmplt_epu16_mask","比较 a 和 b 中包装后的无符号 16 位整数 (小于)，并将结果存储在掩码 vector k 中。"],["_mm_cmplt_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否小于，并将结果存储在掩码 vector k 中。"],["_mm_cmplt_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否小于，并将结果存储在掩码 vector k 中。"],["_mm_cmplt_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数以得到小于，并将结果存储在掩码 vector k 中。"],["_mm_cmplt_pd","比较 `a` 和 `b` 中的对应元素小于。"],["_mm_cmplt_ps","将 `a` 中的四个浮点数中的每个与 `b` 中的对应元素进行比较。 如果 `a` 中的输入元素小于 `b` 中的相应元素，则输出 vector 中的结果将为 `0xffffffff`，否则为 `0`。"],["_mm_cmplt_sd","返回一个新的 vector，其中 `a` 的低位元素被 `a` 和 `b` 的低位元素的小于比较所代替。"],["_mm_cmplt_ss","比较两个输入的最低 `f32` 小于。 如果 `a.extract(0)` 小于 `b.extract(0)`，则结果的最低 32 位将为 `0xffffffff`，否则为 `0`。"],["_mm_cmpneq_epi16_mask","比较 a 和 b 中包装的带符号 16 位整数是否不相等，并将结果存储在掩码 vector k 中。"],["_mm_cmpneq_epi32_mask","比较 a 和 b 中包装的 32 位整数是否不相等，并将结果存储在掩码 vector k 中。"],["_mm_cmpneq_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数是否不相等，并将结果存储在掩码 vector k 中。"],["_mm_cmpneq_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否不相等，并将结果存储在掩码 vector k 中。"],["_mm_cmpneq_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否不相等，并将结果存储在掩码 vector k 中。"],["_mm_cmpneq_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否不相等，并将结果存储在掩码 vector k 中。"],["_mm_cmpneq_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否不相等，并将结果存储在掩码 vector k 中。"],["_mm_cmpneq_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否相等，并将结果存储在掩码 vector k 中。"],["_mm_cmpneq_pd","比较 `a` 和 `b` 中的对应元素是否相等。"],["_mm_cmpneq_ps","将 `a` 中的四个浮点数中的每个与 `b` 中的对应元素进行比较。 如果输入元素不相等，则输出 vector 中的结果将为 `0xffffffff`，否则为 `0`。"],["_mm_cmpneq_sd","返回一个新的 vector，其中 `a` 的低位元素被 `a` 和 `b` 的低位元素的不相等比较代替。"],["_mm_cmpneq_ss","比较两个输入中最低的 `f32` 是否不相等。 如果 `a.extract(0)` 不等于 `b.extract(0)`，则结果的最低 32 位将为 `0xffffffff`，否则为 `0`。"],["_mm_cmpnge_pd","比较 `a` 和 `b` 中的对应元素是否大于等于。"],["_mm_cmpnge_ps","将 `a` 中的四个浮点数中的每个与 `b` 中的对应元素进行比较。 如果 `a` 中的输入元素不大于或等于 `b` 中的相应元素，则输出 vector 中的结果将为 `0xffffffff`，否则为 `0`。"],["_mm_cmpnge_sd","返回一个新的 vector，其中 `a` 的低位元素被 `a` 和 `b` 的低位元素的不大于等于相等的比较所取代。"],["_mm_cmpnge_ss","比较两个输入中的最低 `f32`，以得出不大于等于。 如果 `a.extract(0)` 不大于或等于 `b.extract(0)`，则结果的最低 32 位将为 `0xffffffff`，否则为 `0`。"],["_mm_cmpngt_pd","比较 `a` 和 `b` 中的对应元素是否大于。"],["_mm_cmpngt_ps","将 `a` 中的四个浮点数中的每个与 `b` 中的对应元素进行比较。 如果 `a` 中的输入元素不大于 `b` 中的相应元素，则输出 vector 中的结果将为 `0xffffffff`，否则为 `0`。"],["_mm_cmpngt_sd","返回一个新的 vector，其中 `a` 的低位元素被 `a` 和 `b` 的低位元素的不大于比较所代替。"],["_mm_cmpngt_ss","比较两个输入的最低 `f32`，以得出不大于。 如果 `a.extract(0)` 不大于 `b.extract(0)`，则结果的最低 32 位将为 `0xffffffff`，否则为 `0`。"],["_mm_cmpnle_pd","比较 `a` 和 `b` 中的对应元素是否等于或大于等于。"],["_mm_cmpnle_ps","将 `a` 中的四个浮点数中的每个与 `b` 中的对应元素进行比较。 如果 `a` 中的输入元素不小于或等于 `b` 中的相应元素，则输出 vector 中的结果将为 `0xffffffff`，否则为 `0`。"],["_mm_cmpnle_sd","返回一个新的 vector，其中 `a` 的低位元素被 `a` 和 `b` 的低位元素相等或不小于的比较所取代。"],["_mm_cmpnle_ss","比较两个输入的最低 `f32` 等于或小于等于。 如果 `a.extract(0)` 不小于 `b.extract(0)`，则结果的最低 32 位将为 `0xffffffff`，否则为 `0`。"],["_mm_cmpnlt_pd","比较 `a` 和 `b` 中的对应元素不少于。"],["_mm_cmpnlt_ps","将 `a` 中的四个浮点数中的每个与 `b` 中的对应元素进行比较。 如果 `a` 中的输入元素不小于 `b` 中的相应元素，则输出 vector 中的结果将为 `0xffffffff`，否则为 `0`。"],["_mm_cmpnlt_sd","返回一个新的 vector，其中 `a` 的低位元素被 `a` 和 `b` 的低位元素相当的比较所取代。"],["_mm_cmpnlt_ss","比较两个输入中的最低 `f32` 不少于。 如果 `a.extract(0)` 不小于 `b.extract(0)`，则结果的最低 32 位将为 `0xffffffff`，否则为 `0`。"],["_mm_cmpord_pd","比较 `a` 和 `b` 中的相应元素以查看 `NaN` 是否都不是。"],["_mm_cmpord_ps","将 `a` 中的四个浮点数中的每个与 `b` 中的对应元素进行比较。 返回具有两个可能的位模式之一的四个浮点数。 如果 `a` 和 `b` 中的输入元素是有序的 (即，它们都不是 NaN)，则输出 vector 中的元素将为 `0xffffffff`，否则为 0。"],["_mm_cmpord_sd","返回一个新的 vector，其中 `a` 的低位元素被 `a` 和 `b` 的低位元素都与 `NaN` 进行比较的结果所代替。 如果两者都不等于 `NaN`，则使用 `0xFFFFFFFFFFFFFFFF`，否则使用 `0`。"],["_mm_cmpord_ss","检查两个输入中最低的 `f32` 是否已订购。 如果 `a.extract(0)` 或 `b.extract(0)` 都不是 NaN，则结果的最低 32 位将为 `0xffffffff`，否则为 `0`。"],["_mm_cmpunord_pd","比较 `a` 和 `b` 中的相应元素，以查看是否为 `NaN`。"],["_mm_cmpunord_ps","将 `a` 中的四个浮点数中的每个与 `b` 中的对应元素进行比较。 返回具有两个可能的位模式之一的四个浮点数。 如果 `a` 和 `b` 中的输入元素无序 (即，至少其中一个是 NaN)，则输出 vector 中的元素将为 `0xffffffff`，否则为 0。"],["_mm_cmpunord_sd","返回一个新的 vector，其中 `a` 的低位元素被 `a` 和 `b` 的低位元素都与 `NaN` 进行比较的结果所代替。 如果其中一个等于 `NaN`，则使用 `0xFFFFFFFFFFFFFFFF`，否则使用 `0`。"],["_mm_cmpunord_ss","检查两个输入中最低的 `f32` 是否无序。 如果 `a.extract(0)` 或 `b.extract(0)` 中的任何一个为 NaN，则结果的最低 32 位将为 `0xffffffff`，否则为 `0`。"],["_mm_comi_round_sd","根据 imm8 指定的比较操作数比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，并返回布尔结果 (0 或 1)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_comi_round_ss","根据 imm8 指定的比较操作数比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，并返回布尔结果 (0 或 1)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_comieq_sd","比较 `a` 和 `b` 的下部元素是否相等。"],["_mm_comieq_ss","比较 `a` 和 `b` 的低位的两个 32 位浮点数。 如果相等则返回 `1`，否则返回 `0`。"],["_mm_comige_sd","比较 `a` 和 `b` 的下限元素是否大于等于。"],["_mm_comige_ss","比较 `a` 和 `b` 的低位的两个 32 位浮点数。 如果 `a` 中的值大于或等于 `b` 中的值，则返回 `1`，否则返回 `0`。"],["_mm_comigt_sd","比较 `a` 和 `b` 的下限元素是否大于。"],["_mm_comigt_ss","比较 `a` 和 `b` 的低位的两个 32 位浮点数。 如果 `a` 中的值大于 `b` 中的值，则返回 `1`，否则返回 `0`。"],["_mm_comile_sd","比较 `a` 和 `b` 的下限元素是否等于或小于等于。"],["_mm_comile_ss","比较 `a` 和 `b` 的低位的两个 32 位浮点数。 如果 `a` 中的值小于或等于 `b` 中的值，则返回 `1`，否则返回 `0`。"],["_mm_comilt_sd","比较 `a` 和 `b` 的下限元素小于。"],["_mm_comilt_ss","比较 `a` 和 `b` 的低位的两个 32 位浮点数。 如果 `a` 中的值小于 `b` 中的值，则返回 `1`，否则返回 `0`。"],["_mm_comineq_sd","比较 `a` 和 `b` 的下部元素是否相等。"],["_mm_comineq_ss","比较 `a` 和 `b` 的低位的两个 32 位浮点数。 如果它们不相等，则返回 `1`，否则返回 `0`。"],["_mm_conflict_epi32","测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。"],["_mm_conflict_epi64","测试 a 的每个 64 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。"],["_mm_crc32_u16","从 `crc` 中的初始值开始，返回无符号 16 位整数 `v` 的累积 CRC32 值。"],["_mm_crc32_u32","从 `crc` 中的初始值开始，返回无符号 32 位整数 `v` 的累积 CRC32 值。"],["_mm_crc32_u8","从 `crc` 中的初始值开始，返回无符号 8 位整数 `v` 的累积 CRC32 值。"],["_mm_cvt_roundi32_ss","将带符号的 32 位整数 b 转换为单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 dst 的高位元素。"],["_mm_cvt_roundsd_i32","将 a 中的较低单精度 (32-bit) 浮点元素转换为 32 位整数，并将结果存储在 dst 中。 根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一: (_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常 (_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常 (_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常 (_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常 _MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_cvt_roundsd_si32","将 a 中的较低双精度 (64-bit) 浮点元素转换为 32 位整数，并将结果存储在 dst 中。 根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一: (_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常 (_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常 (_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常 (_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常 _MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_cvt_roundsd_ss","将 b 中的下部双精度 (64-bit) 浮点元素转换为单精度 (32-bit) 浮点元素，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到 dst 的上部元素。 根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一: (_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常 (_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常 (_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常 (_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常 _MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_cvt_roundsd_u32","将 a 中的较低双精度 (64-bit) 浮点元素转换为 32 位无符号整数，并将结果存储在 dst 中。 根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一: (_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常 (_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常 (_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常 (_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常 _MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_cvt_roundsi32_ss","将带符号的 32 位整数 b 转换为单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 dst 的高位元素。"],["_mm_cvt_roundss_i32","将 a 中的较低单精度 (32-bit) 浮点元素转换为 32 位整数，并将结果存储在 dst 中。 根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一: (_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常 (_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常 (_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常 (_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常 _MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_cvt_roundss_sd","将 b 中的下部单精度 (32-bit) 浮点元素转换为双精度 (64-bit) 浮点元素，将结果存储在 dst 的下部元素中，然后将上部的元素从 a 复制到 dst 的上部元素。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_cvt_roundss_si32","将 a 中的较低单精度 (32-bit) 浮点元素转换为 32 位整数，并将结果存储在 dst 中。 根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一: (_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常 (_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常 (_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常 (_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常 _MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_cvt_roundss_u32","将 a 中的较低单精度 (32-bit) 浮点元素转换为 32 位无符号整数，并将结果存储在 dst 中。 根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一: (_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常 (_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常 (_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常 (_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常 _MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_cvt_roundu32_ss","将无符号的 32 位整数 b 转换为单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 dst 的高位元素。 根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一: (_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常 (_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常 (_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常 (_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常 _MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_cvt_si2ss","`_mm_cvtsi32_ss` 的别名。"],["_mm_cvt_ss2si","`_mm_cvtss_si32` 的别名。"],["_mm_cvtepi16_epi32","符号将 `a` 中的包装的 16 位整数扩展为包装的 32 位整数"],["_mm_cvtepi16_epi64","符号将 `a` 中的包装 16 位整数扩展为包装 64 位整数"],["_mm_cvtepi16_epi8","将 a 中的包装的 16 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。"],["_mm_cvtepi32_epi16","将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并将结果存储在 dst 中。"],["_mm_cvtepi32_epi64","符号将 `a` 中的包装 32 位整数扩展为包装 64 位整数"],["_mm_cvtepi32_epi8","将带有 a 的包装的 32 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。"],["_mm_cvtepi32_pd","将 `a` 中的低位两个包装的 32 位整数转换为包装的双精度 (64-bit) 浮点元素。"],["_mm_cvtepi32_ps","将 `a` 中的包装的 32 位整数转换为包装的单精度 (32-bit) 浮点元素。"],["_mm_cvtepi64_epi16","将带有 a 的包装的 64 位整数转换为带有截断的包装的 16 位整数，并将结果存储在 dst 中。"],["_mm_cvtepi64_epi32","将带有 a 的包装的 64 位整数转换为带有截断的包装的 32 位整数，并将结果存储在 dst 中。"],["_mm_cvtepi64_epi8","将带有 a 的包装的 64 位整数转换为带有截断的包装的 8 位整数，并将结果存储在 dst 中。"],["_mm_cvtepi8_epi16","符号将 `a` 中的包装 8 位整数扩展为包装 16 位整数"],["_mm_cvtepi8_epi32","符号将 `a` 中的包装 8 位整数扩展为包装 32 位整数"],["_mm_cvtepi8_epi64","符号将 `a` 的低 8 字节中的包装的 8 位整数扩展为包装的 64 位整数"],["_mm_cvtepu16_epi32","零将 `a` 中的包装的无符号 16 位整数扩展为包装的 32 位整数"],["_mm_cvtepu16_epi64","零将 `a` 中的包装的无符号 16 位整数扩展为包装的 64 位整数"],["_mm_cvtepu32_epi64","零将 `a` 中的包装无符号 32 位整数扩展为包装 64 位整数"],["_mm_cvtepu32_pd","将 A 中的包装的无符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm_cvtepu8_epi16","零将 `a` 中的包装的无符号 8 位整数扩展为包装的 16 位整数"],["_mm_cvtepu8_epi32","零将 `a` 中的包装无符号 8 位整数扩展为包装 32 位整数"],["_mm_cvtepu8_epi64","零将 `a` 中的包装无符号 8 位整数扩展为包装 64 位整数"],["_mm_cvti32_sd","将带符号的 32 位整数 b 转换为双精度 (64-bit) 浮点元素，将结果存储在 dst 的下部元素中，然后将 a 的上部元素复制到 dst 的上部元素。"],["_mm_cvti32_ss","将带符号的 32 位整数 b 转换为单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 dst 的高位元素。"],["_mm_cvtne2ps_pbh","将两个 128 位 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并将结果存入 a"],["_mm_cvtpd_epi32","将 `a` 中的包装的双精度 (64-bit) 浮点元素转换为包装的 32 位整数。"],["_mm_cvtpd_epu32","将包装的双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并将结果存储在 dst 中。"],["_mm_cvtpd_ps","将 `a` 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素"],["_mm_cvtph_ps","将 128 位 vector `a` 的最低 64 位中的 4 x 16 位半精度浮点值转换为存储在 128 位宽的 vector 中的 4 x 32 位浮点值。"],["_mm_cvtps_epi32","将 `a` 中的包装的单精度 (32-bit) 浮点元素转换为包装的 32 位整数。"],["_mm_cvtps_epu32","将包装的单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并将结果存储在 dst 中。"],["_mm_cvtps_pd","将 `a` 中的包装的单精度 (32-bit) 浮点元素转换为包装的双精度 (64-bit) 浮点元素。"],["_mm_cvtps_ph","将 128 位 vector `a` 中的 4 x 32 位浮点值转换为 4 x 16 位半精度浮点值存储在 128 位 vector 的最低 64 位中。"],["_mm_cvtsd_f64","返回 `a` 的较低的双精度 (64-bit) 浮点元素。"],["_mm_cvtsd_i32","将 a 中的较低双精度 (64-bit) 浮点元素转换为 32 位整数，并将结果存储在 dst 中。"],["_mm_cvtsd_si32","将 a 中的较低双精度 (64-bit) 浮点元素转换为 32 位整数。"],["_mm_cvtsd_ss","将 `b` 中的下部双精度 (64-bit) 浮点元素转换为单精度 (32-bit) 浮点元素，将结果存储在返回值的下部元素中，并将上部元素从 `a` 复制到返回值的上部元素中。"],["_mm_cvtsd_u32","将 a 中的较低双精度 (64-bit) 浮点元素转换为 32 位无符号整数，并将结果存储在 dst 中。"],["_mm_cvtsepi16_epi8","将 A 中的包装有符号 16 位整数转换为带符号饱和的包装 8 位整数，并将结果存储在 dst 中。"],["_mm_cvtsepi32_epi16","将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并将结果存储在 dst 中。"],["_mm_cvtsepi32_epi8","将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并将结果存储在 dst 中。"],["_mm_cvtsepi64_epi16","将包装的带符号的 64 位整数转换为带符号饱和的包装的 16 位整数，并将结果存储在 dst 中。"],["_mm_cvtsepi64_epi32","将包装的带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并将结果存储在 dst 中。"],["_mm_cvtsepi64_epi8","将包装的带符号的 64 位整数转换为带符号饱和的包装的 8 位整数，并将结果存储在 dst 中。"],["_mm_cvtsi128_si32","返回 `a` 的最低元素。"],["_mm_cvtsi32_sd","将 `a` 的下位元素转换为 `f64` 后，返回其下位元素为 `b` 的 `a`。"],["_mm_cvtsi32_si128","返回 vector，其最低元素为 `a`，所有更高元素为 `0`。"],["_mm_cvtsi32_ss","将 32 位整数转换为 32 位浮点型。 结果 vector 是输入 vector `a`，其最低 32 位浮点数已由转换后的整数替换。"],["_mm_cvtss_f32","从输入 vector 中提取最低的 32 位浮点数。"],["_mm_cvtss_i32","将 a 中的较低单精度 (32-bit) 浮点元素转换为 32 位整数，并将结果存储在 dst 中。"],["_mm_cvtss_sd","将 `b` 中的下部单精度 (32-bit) 浮点元素转换为双精度 (64-bit) 浮点元素，将结果存储在返回值的下部元素中，然后将 `a` 的上部元素复制到返回值的上部元素中。"],["_mm_cvtss_si32","将输入 vector 中的最低 32 位浮点型转换为 32 位整数。"],["_mm_cvtss_u32","将 a 中的较低单精度 (32-bit) 浮点元素转换为 32 位无符号整数，并将结果存储在 dst 中。"],["_mm_cvtt_roundsd_i32","将 a 中的较低双精度 (64-bit) 浮点元素转换为带截断的 32 位整数，并将结果存储在 dst 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_cvtt_roundsd_si32","将 a 中的较低双精度 (64-bit) 浮点元素转换为带截断的 32 位整数，并将结果存储在 dst 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_cvtt_roundsd_u32","将 a 中的较低双精度 (64-bit) 浮点元素转换为带截断的无符号 32 位整数，并将结果存储在 dst 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_cvtt_roundss_i32","将 a 中的较低单精度 (32-bit) 浮点元素转换为带截断的 32 位整数，并将结果存储在 dst 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_cvtt_roundss_si32","将 a 中的较低单精度 (32-bit) 浮点元素转换为带截断的 32 位整数，并将结果存储在 dst 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_cvtt_roundss_u32","将 a 中的较低单精度 (32-bit) 浮点元素转换为带截断的无符号 32 位整数，并将结果存储在 dst 中。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_cvtt_ss2si","`_mm_cvttss_si32` 的别名。"],["_mm_cvttpd_epi32","将 `a` 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数。"],["_mm_cvttpd_epu32","将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并将结果存储在 dst 中。"],["_mm_cvttps_epi32","将 `a` 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数。"],["_mm_cvttps_epu32","将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并将结果存储在 dst 中。"],["_mm_cvttsd_i32","将 a 中的较低双精度 (64-bit) 浮点元素转换为带截断的 32 位整数，并将结果存储在 dst 中。"],["_mm_cvttsd_si32","将 `a` 中较低的双精度 (64-bit) 浮点元素转换为带截断的 32 位整数。"],["_mm_cvttsd_u32","将 a 中的较低双精度 (64-bit) 浮点元素转换为带截断的无符号 32 位整数，并将结果存储在 dst 中。"],["_mm_cvttss_i32","将 a 中的较低单精度 (32-bit) 浮点元素转换为带截断的 32 位整数，并将结果存储在 dst 中。"],["_mm_cvttss_si32","将输入 vector 中的最低 32 位浮点型转换为带有截断的 32 位整数。"],["_mm_cvttss_u32","将 a 中的较低单精度 (32-bit) 浮点元素转换为带截断的无符号 32 位整数，并将结果存储在 dst 中。"],["_mm_cvtu32_sd","将无符号的 32 位整数 b 转换为双精度 (64-bit) 浮点元素，将结果存储在 dst 的低位元素中，然后将 a 的高位元素复制到 dst 的高位元素。"],["_mm_cvtu32_ss","将无符号的 32 位整数 b 转换为单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 dst 的高位元素。"],["_mm_cvtusepi16_epi8","将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。"],["_mm_cvtusepi32_epi16","将 A 中的包装无符号 32 位整数转换为具有无符号饱和度的包装无符号 16 位整数，并将结果存储在 dst 中。"],["_mm_cvtusepi32_epi8","将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。"],["_mm_cvtusepi64_epi16","将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并将结果存储在 dst 中。"],["_mm_cvtusepi64_epi32","将 A 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并将结果存储在 dst 中。"],["_mm_cvtusepi64_epi8","将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并将结果存储在 dst 中。"],["_mm_dbsad_epu8","计算 a 中与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs)，并将 16 位结果存储在 dst 中。对于每个 64 位通道，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中通道的低 8 位四元组，而后两个 SAD 使用 a 中通道的较高 8 位四元组。根据 imm8 中的控件，从 128 位通道中选择 b 中的四元组，并且每个 64 位通道中的每个 SAD 使用 8 位偏移量的选定四元组。"],["_mm_div_pd","将 `a` 中的包装的双精度 (64-bit) 浮点元素除以 `b` 中的包装的元素。"],["_mm_div_ps","除 __m128 vectors。"],["_mm_div_round_sd","将 a 中的下部双精度 (64-bit) 浮点元素除以 b 中的下部双精度 (64-bit) 浮点元素，将结果存储在 dst 的下部元素中，并将上部的元素从 a 复制到 dst 的上部元素。"],["_mm_div_round_ss","将 a 中的下部单精度 (32-bit) 浮点元素除以 b 中的下部单精度 (32-bit) 浮点元素，将结果存储在 dst 的下部元素中，并将上部 3 个包装的元素从 a 复制到上部元素 dst。"],["_mm_div_sd","返回一个新的 vector，其中 `a` 的下限元素被 `a` 的下限元素除以 `b` 的下限元素所代替。"],["_mm_div_ss","将 `b` 的第一个组件除以 `a`，其他组件则从 `a` 复制。"],["_mm_dp_pd","返回两个 __m128d vectors 的点积。"],["_mm_dp_ps","返回两个 __m128 vectors 的点积。"],["_mm_dpbf16_ps","计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间单精度 (32-bit) 浮点元素与 src 中的元素相加，并将结果存储在 dst 中。"],["_mm_dpbusd_epi32","将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果存入 dst。"],["_mm_dpbusds_epi32","将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。使用有符号饱和将这 4 个结果与 src 中相应的 32 位整数相加，并将包装的 32 位结果存储在 dst 中。"],["_mm_dpwssd_epi32","将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果存入 dst。"],["_mm_dpwssds_epi32","将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并将包装的 32 位结果存储在 dst 中。"],["_mm_extract_epi16","返回 `a` 的 `imm8` 元素。"],["_mm_extract_epi32","从 `IMM8` 选择的 `a` 中提取 32 位整数"],["_mm_extract_epi8","从 `a` 中提取一个 8 位整数，用 `IMM8` 选择。 返回包含零扩展整数数据的 32 位整数。 See LLVM commit D20468."],["_mm_extract_ps","从 `a` 中提取单精度 (32-bit) 浮点元素，用 `IMM8` 选择"],["_mm_extract_si64","从 `x` 的低 64 位提取 `y` 指定的位范围。"],["_mm_fixupimm_pd","使用 c 中的包装的 64 位整数修复 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。imm8 用于设置所需的标志报告。"],["_mm_fixupimm_ps","使用 c 中的包装 32 位整数修复 a 和 b 中包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。imm8 用于设置所需的标志报告。"],["_mm_fixupimm_round_sd","使用 c 中的较低 64 位整数修复 a 和 b 中较低的双精度 (64-bit) 浮点元素，将结果存储在 dst 的较低元素中，并将较高的元素从 a 复制到 dst 的较高元素。imm8 用于设置所需的标志报告。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_fixupimm_round_ss","使用 c 中的低 32 位整数修复 a 和 b 中的低位单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 a 的高位元素 dst。imm8 用于设置所需的标志报告。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_fixupimm_sd","使用 c 中的较低 64 位整数修复 a 和 b 中较低的双精度 (64-bit) 浮点元素，将结果存储在 dst 的较低元素中，并将较高的元素从 a 复制到 dst 的较高元素。imm8 用于设置所需的标志报告。"],["_mm_fixupimm_ss","使用 c 中的低 32 位整数修复 a 和 b 中的低位单精度 (32-bit) 浮点元素，将结果存储在 dst 的低位元素中，并将高 3 个包装的元素从 a 复制到 a 的高位元素 dst。imm8 用于设置所需的标志报告。"],["_mm_floor_pd","将 `a` 中的包装的双精度 (64-bit) 浮点元素四舍五入为整数，并将结果存储为包装的双精度浮点元素。"],["_mm_floor_ps","将 `a` 中的包装的单精度 (32-bit) 浮点元素四舍五入为整数，并将结果存储为包装的单精度浮点元素。"],["_mm_floor_sd","将 `b` 中的下部双精度 (64-bit) 浮点元素四舍五入为整数值，将结果作为双精度浮点元素存储在内部结果的下部元素中，并将上部元素从 `a` 复制到上部内在结果的元素。"],["_mm_floor_ss","将 `b` 中的下部单精度 (32-bit) 浮点元素四舍五入为整数值，将结果作为单精度浮点元素存储在内部结果的下部元素中，然后将 `a` 的上部 3 个包装的元素复制到内在结果的上层要素。"],["_mm_fmadd_pd","将 `a` 和 `b` 中的包装的双精度 (64-bit) 浮点元素相乘，并将中间结果与 `c` 中的包装的元素相加。"],["_mm_fmadd_ps","将 `a` 和 `b` 中的包装单精度 (32-bit) 浮点元素相乘，并将中间结果添加到 `c` 中的包装元素中。"],["_mm_fmadd_round_sd","将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，并将中间结果与较低元素 in c. Store 的结果相加到 dst 的较低元素中，并将较高的元素从 a 复制到 dst 的较高元素。"],["_mm_fmadd_round_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，并将中间结果与较低元素 in c. Store 的结果相加到 dst 的较低元素中，然后将较高的 3 个包装的元素从 a 复制到 dst 的较高元素。"],["_mm_fmadd_sd","将 `a` 和 `b` 中的较低的双精度 (64-bit) 浮点元素相乘，并将中间结果与 `c` 中的较低的元素相加。"],["_mm_fmadd_ss","将 `a` 和 `b` 中较低的单精度 (32-bit) 浮点元素相乘，并将中间结果与 `c` 中的较低元素相加。"],["_mm_fmaddsub_pd","将 `a` 和 `b` 中的包装的双精度 (64-bit) 浮点元素相乘，或者在 `c` to/from 中将包装的元素相加或减去中间结果。"],["_mm_fmaddsub_ps","将 `a` 和 `b` 中包装的单精度 (32-bit) 浮点元素相乘，或者将 `c` 中包装的元素加/减到中间结果中。"],["_mm_fmsub_pd","将 `a` 和 `b` 中的包装的双精度 (64-bit) 浮点元素相乘，并从中间结果中减去 `c` 中的包装的双精度元素。"],["_mm_fmsub_ps","将 `a` 和 `b` 中的包装的单精度 (32-bit) 浮点元素相乘，并从中间结果中减去 `c` 中的包装元素。"],["_mm_fmsub_round_sd","将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。将结果存储在 dst 的下部元素中，然后将 a 的上部元素复制到 dst 的上部元素中。"],["_mm_fmsub_round_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。将结果存储在 dst 的下部元素中，并将上部 3 个包装的元素从 a 复制到 dst 的上部元素。"],["_mm_fmsub_sd","将 `a` 和 `b` 中的较低的双精度 (64-bit) 浮点元素相乘，并从中间结果中减去 `c` 中的较低的元素。 将结果存储在返回值的低位元素中，并将高位元素从 `a` 复制到结果的高位元素。"],["_mm_fmsub_ss","将 `a` 和 `b` 中的较低单精度 (32-bit) 浮点元素相乘，并从中间结果中减去 `c` 中的较低元素。 将结果存储在返回值的低位元素中，并将 3 个高位元素从 `a` 复制到结果的高位元素。"],["_mm_fmsubadd_pd","将 `a` 和 `b` 中的包装的双精度 (64-bit) 浮点元素相乘，也可以从中间结果中减去或加上 `c` 中的包装元素。"],["_mm_fmsubadd_ps","将 `a` 和 `b` 中的包装单精度 (32-bit) 浮点元素相乘，或者将 `c` 中的包装元素从中间结果中减去或加上。"],["_mm_fnmadd_pd","将 `a` 和 `b` 中的包装双精度 (64-bit) 浮点元素相乘，然后将取反的中间结果添加到 `c` 中的包装元素中。"],["_mm_fnmadd_ps","将 `a` 和 `b` 中的包装单精度 (32-bit) 浮点元素相乘，并将取反的中间结果添加到 `c` 中的包装元素中。"],["_mm_fnmadd_round_sd","将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后将求和的中间结果与较低元素 in c. Store 的结果相加到 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素中。"],["_mm_fnmadd_round_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后将取反的中间结果与较低元素 in c. Store 相加，将结果与 dst 的较低元素相乘，然后将较高的 3 个包装的元素从 a 复制到 dst。"],["_mm_fnmadd_sd","将 `a` 和 `b` 中较低的双精度 (64-bit) 浮点元素相乘，并将取反的中间结果添加到 `c` 中的较低元素。 将结果存储在返回值的低位元素中，并将高位元素从 `a` 复制到结果的高位元素。"],["_mm_fnmadd_ss","将 `a` 和 `b` 中较低的单精度 (32-bit) 浮点元素相乘，并将取反的中间结果与 `c` 中的较低元素相加。 将结果存储在返回值的低位元素中，并将 3 个高位元素从 `a` 复制到结果的高位元素。"],["_mm_fnmsub_pd","将 `a` 和 `b` 中的包装的双精度 (64-bit) 浮点元素相乘，并从取反的中间结果中减去 `c` 中的包装的元素。"],["_mm_fnmsub_ps","将 `a` 和 `b` 中的包装的单精度 (32-bit) 浮点元素相乘，并从取反的中间结果中减去 `c` 中的包装的元素。"],["_mm_fnmsub_round_sd","将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。将结果存储在 dst 的下部元素中，然后将 a 的上部元素复制到 dst 的上部元素中。"],["_mm_fnmsub_round_ss","将 a 和 b 中的下部单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的下部元素，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到上部 dst 的元素。"],["_mm_fnmsub_sd","将 `a` 和 `b` 中较低的双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 `c` 中的包装的元素。 将结果存储在返回值的低位元素中，并将高位元素从 `a` 复制到结果的高位元素。"],["_mm_fnmsub_ss","将 `a` 和 `b` 中较低的单精度 (32-bit) 浮点元素相乘，然后从取反的中间结果中减去 `c` 中的包装元素。 将结果存储在返回值的低位元素中，并将 3 个高位元素从 `a` 复制到结果的高位元素。"],["_mm_getcsr","获取 MXCSR 控制和状态寄存器的无符号 32 位值。"],["_mm_getexp_pd","将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并将结果存储在 dst 中。本质上，此内联函数为每个元素计算 floor(log2(x))。"],["_mm_getexp_ps","将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，并将结果存储在 dst 中。本质上，此内联函数为每个元素计算 floor(log2(x))。"],["_mm_getexp_round_sd","将 b 中较低的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，将结果存储在 dst 的低位元素中，并将高位元素从 a 复制到 dst 的上层元素。本质上，此内联函数计算下部元素的 floor(log2(x))。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_getexp_round_ss","将 b 中较低的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，将结果存储在 dst 的较低元素中，并从 a 中复制较高的 3 个包装的元素到 dst 的上层元素。本质上，此内联函数计算下部元素的 floor(log2(x))。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_getexp_sd","将 b 中较低的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，将结果存储在 dst 的低位元素中，并将高位元素从 a 复制到 dst 的上层元素。本质上，此内联函数计算下部元素的 floor(log2(x))。"],["_mm_getexp_ss","将 b 中较低的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，将结果存储在 dst 的较低元素中，并从 a 中复制较高的 3 个包装的元素到 dst 的上层元素。本质上，此内联函数计算下部元素的 floor(log2(x))。"],["_mm_getmant_pd","将 a 中的包装的双精度 (64-bit) 浮点元素的尾数规格化，并将结果存储在 dst 中。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1"],["_mm_getmant_ps","将 a 中的包装的单精度 (32-bit) 浮点元素的尾数标准化，并将结果存储在 dst 中。 此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) The sign is determined by sc which can take the following values:"],["_mm_getmant_round_sd","标准化 b 中较低的双精度 (64-bit) 浮点元素的尾数，将结果存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_getmant_round_ss","标准化 b 中较低单精度 (32-bit) 浮点元素的尾数，将结果存储在 dst 的较低元素中，并将高 3 个包装的元素从 a 复制到 dst 的较高元素。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_getmant_sd","标准化 b 中较低的双精度 (64-bit) 浮点元素的尾数，将结果存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_getmant_ss","标准化 b 中较低单精度 (32-bit) 浮点元素的尾数，将结果存储在 dst 的较低元素中，并将高 3 个包装的元素从 a 复制到 dst 的较高元素。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_gf2p8affine_epi64_epi8","对 x 中的包装字节执行仿射变换。 也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。"],["_mm_gf2p8affineinv_epi64_epi8","对 x 中的反向包装的字节执行仿射变换。 也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。"],["_mm_gf2p8mul_epi8","在包装的字节上执行 GF(2^8) 乘法。 该字段以多项式表示，具有约数多项式 x^8 + x^4 + x^3 + x + 1。"],["_mm_hadd_epi16","水平相加 2 个包装的包中包含的相邻值对 `[8 x i16]` 的 128 位 vectors。"],["_mm_hadd_epi32","水平相加 2 个包装的包中包含的相邻值对 `[4 x i32]` 的 128 位 vectors。"],["_mm_hadd_pd","在 `a` 和 `b` 中水平添加相邻对的双精度 (64-bit) 浮点元素，并包装结果。"],["_mm_hadd_ps","在 `a` 和 `b` 中水平添加相邻对的单精度 (32-bit) 浮点元素对，并包装结果。"],["_mm_hadds_epi16","水平相加 2 个包装的包中包含的相邻值对 `[8 x i16]` 的 128 位 vectors。大于 7FFFh 的正和饱和到 7FFFh。 小于 8000h 的负数和将饱和到 8000h。"],["_mm_hsub_epi16","水平减去 `[8 x i16]` 的 2 个包装的 128 位 vectors 中包含的相邻值对。"],["_mm_hsub_epi32","水平减去 `[4 x i32]` 的 2 个包装的 128 位 vectors 中包含的相邻值对。"],["_mm_hsub_pd","水平减去 `a` 和 `b` 中相邻的双精度 (64-bit) 浮点元素对，然后包装结果。"],["_mm_hsub_ps","在 `a` 和 `b` 中水平添加相邻对的单精度 (32-bit) 浮点元素对，并包装结果。"],["_mm_hsubs_epi16","水平减去 `[8 x i16]` 的 2 个包装的 128 位 vectors 中包含的相邻值对。 正差异大于 7FFFh 饱和到 7FFFh。小于 8000h 的负差会饱和到 8000h。"],["_mm_i32gather_epi32","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。"],["_mm_i32gather_epi64","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。"],["_mm_i32gather_pd","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。"],["_mm_i32gather_ps","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。"],["_mm_i64gather_epi32","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。"],["_mm_i64gather_epi64","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。"],["_mm_i64gather_pd","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。"],["_mm_i64gather_ps","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。"],["_mm_insert_epi16","返回一个新的 vector，其中 `a` 的 `imm8` 元素替换为 `i`。"],["_mm_insert_epi32","返回 `a` 的副本，其中 `i` 的 32 位整数插入到 `IMM8` 指定的位置。"],["_mm_insert_epi8","返回 `a` 的副本，其中 `i` 的 8 位整数插入到 `IMM8` 指定的位置。"],["_mm_insert_ps","在 `a` 中选择单个值存储在 `b` 中的某个位置，然后根据 `IMM8` 将元素归零。"],["_mm_insert_si64","将 `y` 的 `[length:0]` 位插入 `index` 处的 `x`。"],["_mm_lddqu_si128","从未对齐的内存中加载 128 位整数数据。 当数据越过缓存行边界时，此内联函数可能比 `_mm_loadu_si128` 更好。"],["_mm_lfence","对在此指令之前发布的所有内存加载指令执行序列化操作。"],["_mm_load1_pd","将内存中的双精度 (64-bit) 浮点元素加载到返回的 vector 的两个元素中。"],["_mm_load1_ps","通过将从 `p` 读取的值复制到所有元素中来构造 `__m128`。"],["_mm_load_epi32","将 128 位 (由 4 个包装的 32 位整数组成) 从内存加载到 dst 中。mem_addr 必须在 16 字节边界上对齐，否则可能会生成一般保护异常。"],["_mm_load_epi64","将 128 位 (由 2 个包装的 64 位整数组成) 从内存加载到 dst 中。mem_addr 必须在 16 字节边界上对齐，否则可能会生成一般保护异常。"],["_mm_load_pd","从内存中将 128 位 (由 2 个包装的双精度 (64-bit) 浮点元素组成) 加载到返回的 vector 中。"],["_mm_load_pd1","将内存中的双精度 (64-bit) 浮点元素加载到返回的 vector 的两个元素中。"],["_mm_load_ps","将 aligned 内存中的四个 `f32` 值加载到 `__m128` 中。 如果指针未与 128 位边界 (16 个字节) 对齐，则将触发一般保护错误 (致命程序崩溃)。"],["_mm_load_ps1","`_mm_load1_ps` 的别名"],["_mm_load_sd","将 64 位双精度值加载到 128 位整数 vector 并清除高位元素。"],["_mm_load_si128","从内存中将 128 位整数数据加载到新的 vector 中。"],["_mm_load_ss","使用从 `p` 读取的最低元素并将其他元素设置为零来构造 `__m128`。"],["_mm_loaddup_pd","将内存中的双精度 (64-bit) 浮点元素加载到返回 vector 的两个元素中。"],["_mm_loadh_pd","将双精度值加载到 `[2 x double]` 的 128 位 vector 的高阶位中。 低位从第一个操作数的低位复制而来。"],["_mm_loadl_epi64","将内存中的 64 位整数加载到返回的 vector 的第一个元素中。"],["_mm_loadl_pd","将双精度值加载到 `[2 x double]` 的 128 位 vector 的低位中。 高阶位是从第一个操作数的高阶位复制而来的。"],["_mm_loadr_pd","以相反的顺序将 2 个双精度 (64-bit) 浮点元素从内存加载到返回的 vector 中。 `mem_addr` 必须对齐 可能会生成 16 字节边界或一般保护异常。"],["_mm_loadr_ps","从对齐的内存中以相反的顺序将四个 `f32` 值加载到 `__m128` 中。"],["_mm_loadu_epi16","将 128 位 (由 8 个包装的 16 位整数组成) 从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。"],["_mm_loadu_epi32","将 128 位 (由 4 个包装的 32 位整数组成) 从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。"],["_mm_loadu_epi64","将 128 位 (由 2 个包装的 64 位整数组成) 从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。"],["_mm_loadu_epi8","将 128 位 (由 16 个包装的 8 位整数组成) 从内存加载到 dst 中。mem_addr 不需要在任何特定边界上对齐。"],["_mm_loadu_pd","从内存中将 128 位 (由 2 个包装的双精度 (64-bit) 浮点元素组成) 加载到返回的 vector 中。"],["_mm_loadu_ps","从内存中将四个 `f32` 值加载到 `__m128` 中。内存对齐没有任何限制。 对于对齐的内存 `_mm_load_ps` 可能更快。"],["_mm_loadu_si128","从内存中将 128 位整数数据加载到新的 vector 中。"],["_mm_loadu_si64","将未对齐的 64 位整数数据从内存加载到新的 vector 中。"],["_mm_lzcnt_epi32","计算 a 中每个包装的 32 位整数中前导零位的数目，并将结果存储在 dst 中。"],["_mm_lzcnt_epi64","计算 a 中每个包装的 64 位整数中前导零位的数目，并将结果存储在 dst 中。"],["_mm_madd52hi_epu64","将 `b` 和 `c` 的每个 64 位元素中的包装无符号 52 位整数相乘以形成 104 位中间结果。 将中间结果的高 52 位无符号整数与 `a` 中的相应无符号 64 位整数相加，并将结果存储在 `dst` 中。"],["_mm_madd52lo_epu64","将 `b` 和 `c` 的每个 64 位元素中的包装无符号 52 位整数相乘以形成 104 位中间结果。 将中间结果的低 52 位无符号整数与 `a` 中的相应无符号 64 位整数相加，并将结果存储在 `dst` 中。"],["_mm_madd_epi16","在 `a` 和 `b` 中相乘，然后水平相加带符号的 16 位整数。"],["_mm_maddubs_epi16","将第一个源操作数中包含的包装的 8 位无符号整数值与第二个源操作数中包含的包装的 8 位有符号整数值的对应对相乘，相加具有符号饱和度的连续乘积对，并将 16 位和写入到目标中的相应位。"],["_mm_mask2_permutex2var_epi16","使用相应的选择器和 idx 中的索引在通道中的 a 和 b 中对 16 位整数进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 idx 复制元素)。"],["_mm_mask2_permutex2var_epi32","使用相应的选择器和 idx 中的索引在通道中的 a 和 b 中对 32 位整数进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 idx 复制元素)。"],["_mm_mask2_permutex2var_epi64","使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中随机排列 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 idx 复制元素)。"],["_mm_mask2_permutex2var_epi8","使用相应的选择器和 idx 中的索引将 a 和 b 中的 8 位整数跨通道打乱，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。"],["_mm_mask2_permutex2var_pd","使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 idx 复制元素)"],["_mm_mask2_permutex2var_ps","使用 idx 中的对应选择器和索引在 a 和 b 中的通道中对 a 和 b 中的单精度 (32-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 idx 复制元素)。"],["_mm_mask3_fmadd_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 c 复制元素)。"],["_mm_mask3_fmadd_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。"],["_mm_mask3_fmadd_round_sd","将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，并将中间结果与较低的元素 in c. Store 的结果相加，使用 writemask k 在 dst 的较低元素中 (当未使用 mask bit 0 时从 c 复制该元素) 设置)，然后将 c 的上部元素复制到 dst 的上部元素。"],["_mm_mask3_fmadd_round_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，并将中间结果加到较低元素 in c. Store 中，并使用 writemask k 将结果存储到 dst 较低元素中 (当未使用 mask bit 0 时从 c 复制该元素) 设置)，然后将 c 的高 3 个包装的元素复制到 dst 的高元素。"],["_mm_mask3_fmadd_sd","将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，并将中间结果与较低的元素 in c. Store 的结果相加，使用 writemask k 在 dst 的较低元素中 (当未使用 mask bit 0 时从 c 复制该元素) 设置)，然后将 c 的上部元素复制到 dst 的上部元素。"],["_mm_mask3_fmadd_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，并将中间结果加到较低元素 in c. Store 中，并使用 writemask k 将结果存储到 dst 较低元素中 (当未使用 mask bit 0 时从 c 复制该元素) 设置)，然后将 c 的高 3 个包装的元素复制到 dst 的高元素。"],["_mm_mask3_fmaddsub_pd","在 a 和 b 中分别乘以包装的单精度 (32-bit) 浮点元素，或者在 to/from 中将中间结果乘以包装的元素加减乘以 x，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 c 复制元素) 放)。"],["_mm_mask3_fmaddsub_ps","在 a 和 b 中分别乘以包装的单精度 (32-bit) 浮点元素，或者在 to/from 中将中间结果乘以包装的元素加减乘以 x，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 c 复制元素) 放)。"],["_mm_mask3_fmsub_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。"],["_mm_mask3_fmsub_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 c 复制元素)。"],["_mm_mask3_fmsub_round_sd","将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用 writemask k 将结果存储在 dst 的下层元素中 (当掩码位 0 未设置时，从 c 复制元素)，并将 c 上的上层元素复制到 dst 的上层元素。"],["_mm_mask3_fmsub_round_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高 3 个包装的元素从 c 复制到 dst 的上部元素。"],["_mm_mask3_fmsub_sd","将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用 writemask k 将结果存储在 dst 的下层元素中 (当掩码位 0 未设置时，从 c 复制元素)，并将 c 上的上层元素复制到 dst 的上层元素。"],["_mm_mask3_fmsub_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高 3 个包装的元素从 c 复制到 dst 的上部元素。"],["_mm_mask3_fmsubadd_pd","将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，并使用 writemask k 将结果存储在 dst 中 (当未使用相应的 mask 位时从 c 复制元素) 放)。"],["_mm_mask3_fmsubadd_ps","在 a 和 b 中乘以包装的单精度 (32-bit) 浮点元素，或者在中间结果中减去并在 c from/to 中包装的元素相乘，然后使用 writemask k 将结果存储在 dst 中 (当未使用相应的 mask 位时从 c 复制元素) 放)。"],["_mm_mask3_fnmadd_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 c 复制元素)。"],["_mm_mask3_fnmadd_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 c 复制)。"],["_mm_mask3_fnmadd_round_sd","将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，然后使用写掩码 k 将求反的中间结果与较低的元素 in c. Store 的结果相加到 dst 的较低元素中 (当掩码位 0 为 0 时从 c 复制该元素) (未设置)，然后将 c 的上部元素复制到 dst 的上部元素。"],["_mm_mask3_fnmadd_round_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用写掩码 k 将取反的中间结果与较低元素 in c. Store 的结果相加到 dst 较低元素中 (当掩码位 0 为 0 时从 c 复制该元素) (未设置)，然后将 c 的高 3 个包装的元素复制到 dst 的高元素。"],["_mm_mask3_fnmadd_sd","将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，然后使用写掩码 k 将求反的中间结果与较低的元素 in c. Store 的结果相加到 dst 的较低元素中 (当掩码位 0 为 0 时从 c 复制该元素) (未设置)，然后将 c 的上部元素复制到 dst 的上部元素。"],["_mm_mask3_fnmadd_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用写掩码 k 将取反的中间结果与较低元素 in c. Store 的结果相加到 dst 较低元素中 (当掩码位 0 为 0 时从 c 复制该元素) (未设置)，然后将 c 的高 3 个包装的元素复制到 dst 的高元素。"],["_mm_mask3_fnmsub_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 c 复制元素)。"],["_mm_mask3_fnmsub_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 c 复制元素)。"],["_mm_mask3_fnmsub_round_sd","将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用 writemask k 将结果存储在 dst 的下层元素中 (当掩码位 0 未设置时，从 c 复制元素)，并将 c 上的上层元素复制到 dst 的上层元素。"],["_mm_mask3_fnmsub_round_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高 3 个包装的元素从 c 复制到 dst 的上部元素。"],["_mm_mask3_fnmsub_sd","将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用 writemask k 将结果存储在 dst 的下层元素中 (当掩码位 0 未设置时，从 c 复制元素)，并将 c 上的上层元素复制到 dst 的上层元素。"],["_mm_mask3_fnmsub_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高 3 个包装的元素从 c 复制到 dst 的上部元素。"],["_mm_mask_abs_epi16","计算 a 中包装的带符号的 16 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_abs_epi32","计算 a 中包装的有符号 32 位整数的绝对值，并使用 writemask k 将无符号结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm_mask_abs_epi8","计算 a 中包装的带符号的 8 位整数的绝对值，并使用写掩码 k 将无符号的结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)"],["_mm_mask_add_epi16","在 a 和 b 中添加包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_add_epi32","在 a 和 b 中添加包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_add_epi64","在 a 和 b 中添加包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_add_epi8","在 a 和 b 中添加包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_add_pd","在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_add_ps","在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_add_round_sd","在 a 和 b 中添加较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并从中复制较高的元素。a 到 dst 的高位元素。"],["_mm_mask_add_round_ss","在 a 和 b 中添加较低的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的较低元素中 (当未设置 mask bit 0 时，该元素是从 src 复制的)，并复制高位 3 从 a 到 dst 的高位元素。"],["_mm_mask_add_sd","在 a 和 b 中添加较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并从中复制较高的元素。a 到 dst 的高位元素。"],["_mm_mask_add_ss","在 a 和 b 中添加较低的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的较低元素中 (当未设置 mask bit 0 时，该元素是从 src 复制的)，并复制高位 3 从 a 到 dst 的高位元素。"],["_mm_mask_adds_epi16","使用饱和度在 a 和 b 中添加包装的带符号的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_adds_epi8","使用饱和度在 a 和 b 中添加包装的带符号的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_adds_epu16","使用饱和度在 a 和 b 中添加包装的无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_adds_epu8","使用饱和度在 a 和 b 中添加包装的无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_alignr_epi32","将 a 和 b 连接成一个 32 字节的 immediate 结果，将结果右移 imm8 个 32 位元素，并使用 writemask k 将低 16 字节 (4 个元素) 存储在 dst 中 (当对应的掩码位为没有设置)。"],["_mm_mask_alignr_epi64","将 a 和 b 连接成 32 字节的 immediate 结果，将结果右移 imm8 个 64 位元素，并使用 writemask k 将低 16 字节 (2 个元素) 存储在 dst 中 (当相应的掩码位为没有设置)。"],["_mm_mask_alignr_epi8","将 a 和 b 中的 16 字节块对连接成 32 字节的临时结果，将结果右移 imm8 字节，并使用写掩码 k 将低 16 个字节存储在 dst 中 (当相应的掩码位为 1 时，元素从 src 复制没有设置)。"],["_mm_mask_and_epi32","在包装的 a 和 b 的 32 位整数元素之间执行逐个元素的按位 AND，使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm_mask_and_epi64","计算 a 和 b 中包装的 64 位整数的按位与，并使用写掩码 k 将结果存储在 dst 中 (如果未设置相应的掩码位，则从 src 复制元素)。"],["_mm_mask_andnot_epi32","计算 a 中包装的 32 位整数的按位 NOT，然后与 b 计算 AND，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_andnot_epi64","计算 a 中包装的 64 位整数的按位 NOT，然后与 b 计算 AND，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_avg_epu16","将 a 和 b 中包装的无符号 16 位整数进行平均，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_avg_epu8","将 a 和 b 中包装的无符号 8 位整数平均，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_bitshuffle_epi64_mask","将输入 `b` 视为包装的 64 位整数，并将 `c` 视为包装的 8 位整数。 然后将来自 `c` 的 8 个 8 位值作为索引分组到相应的 64 位整数的位中。 然后，选择这些位并将其包装到输出中。"],["_mm_mask_blend_epi16","使用控制掩码 k 混合来自 a 和 b 的包装的 16 位整数，并将结果存储在 dst 中。"],["_mm_mask_blend_epi32","使用控制掩码 k 混合 a 和 b 中的包装 32 位整数，并将结果存储在 dst 中。"],["_mm_mask_blend_epi64","使用控制掩码 k 混合 a 和 b 中的包装 64 位整数，并将结果存储在 dst 中。"],["_mm_mask_blend_epi8","使用控制掩码 k 混合 a 和 b 中的包装 8 位整数，并将结果存储在 dst 中。"],["_mm_mask_blend_pd","使用控制掩码 k 混合来自 a 和 b 的包装后的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm_mask_blend_ps","使用控制掩码 k 混合来自 a 和 b 的包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm_mask_broadcastb_epi8","使用写掩码 k 将 d 的低包装的 8 位整数广播到 dst 的所有元素 (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm_mask_broadcastd_epi32","使用写掩码 k 将低包装的 32 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_broadcastq_epi64","使用写掩码 k 将低包装的 64 位整数从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_broadcastss_ps","使用写掩码 k 将低单精度 (32-bit) 浮点型元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，将元素从 src 复制)。"],["_mm_mask_broadcastw_epi16","使用写掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm_mask_cmp_epi16_mask","根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmp_epi32_mask","根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 32 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_mask_cmp_epi64_mask","根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_mask_cmp_epi8_mask","根据 imm8 指定的比较操作数比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmp_epu16_mask","根据 imm8 指定的比较操作数比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmp_epu32_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 32 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmp_epu64_mask","根据 imm8 指定的比较操作数比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmp_epu8_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装无符号 8 位整数，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_mask_cmp_pd_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_mask_cmp_ps_mask","根据 imm8 指定的比较操作数比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_mask_cmp_round_sd_mask","根据 imm8 指定的比较操作数比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置掩码位 0 时该元素清零)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_mask_cmp_round_ss_mask","根据 imm8 指定的比较操作数比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置掩码位 0 时该元素清零)。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_mask_cmp_sd_mask","根据 imm8 指定的比较操作数比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置掩码位 0 时该元素清零)。"],["_mm_mask_cmp_ss_mask","根据 imm8 指定的比较操作数比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置掩码位 0 时该元素清零)。"],["_mm_mask_cmpeq_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数是否相等，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpeq_epi32_mask","比较 a 和 b 中包装的 32 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_mask_cmpeq_epi64_mask","比较 a 和 b 中包装的 64 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpeq_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpeq_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpeq_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpeq_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpeq_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpge_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpge_epi32_mask","比较 a 和 b 中包装的带符号的 32 位整数是否等于或大于等于，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpge_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpge_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpge_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否大于等于，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpge_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpge_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpge_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否大于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpgt_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpgt_epi32_mask","比较 a 和 b 中包装的带符号的 32 位整数是否大于，并将结果使用零掩码 k1 存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpgt_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpgt_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpgt_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpgt_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpgt_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpgt_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否大于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmple_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数 (小于或等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_mask_cmple_epi32_mask","比较 a 和 b 中包装的带符号的 32 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmple_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数 (小于等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_mask_cmple_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmple_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmple_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmple_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmple_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmplt_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmplt_epi32_mask","比较 a 和 b 中包装的带符号的 32 位整数 (小于或等于)，然后使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_mask_cmplt_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmplt_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数小于零，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmplt_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数以得到小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmplt_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否小于等于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmplt_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmplt_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否小于，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpneq_epi16_mask","比较 a 和 b 中包装的带符号的 16 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpneq_epi32_mask","比较 a 和 b 中包装的 32 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpneq_epi64_mask","比较 a 和 b 中包装的带符号的 64 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm_mask_cmpneq_epi8_mask","比较 a 和 b 中包装的带符号的 8 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_mask_cmpneq_epu16_mask","比较 a 和 b 中包装的无符号 16 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpneq_epu32_mask","比较 a 和 b 中包装的无符号 32 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpneq_epu64_mask","比较 a 和 b 中包装的无符号 64 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_cmpneq_epu8_mask","比较 a 和 b 中包装的无符号 8 位整数是否不相等，并使用零掩码 k1 将结果存储在掩码 vector k 中 (当未设置相应的掩码位时元素清零)。"],["_mm_mask_compress_epi16","将 a 中的活动 16 位整数 (它们各自的位设置在写掩码 k 中) 连续存储到 dst，并通过 src 中的其余元素。"],["_mm_mask_compress_epi32","将活动的 32 位整数连续存储在 dst 中 (它们各自的位在写掩码 k 中设置的整数) 到 dst，并通过 src 中的其余元素。"],["_mm_mask_compress_epi64","将活动的 64 位整数连续存储在 dst 中 (它们各自的位在写掩码 k 中设置的整数) 到 dst，并通过 src 中的其余元素。"],["_mm_mask_compress_epi8","将 a 中的活动 8 位整数 (它们各自的位设置在写掩码 k 中) 连续存储到 dst，并通过 src 中的其余元素。"],["_mm_mask_compress_pd","将活动的双精度 (64-bit) 浮点元素连续存储在 dst 中 (它们各自的位在写掩码 k 中设置) 到 dst，并通过 src 中的其余元素。"],["_mm_mask_compress_ps","将活动的单精度 (32-bit) 浮点元素连续存储在 dst 中 (将其各自的位设置在写掩码 k 中的那些元素中) 存储到 dst，并通过 src 中的其余元素。"],["_mm_mask_conflict_epi32","使用写掩码 k (在未设置相应的掩码位时从 src 复制元素)，测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。"],["_mm_mask_conflict_epi64","使用写掩码 k 测试 a 的每个 64 位元素是否与所有其他元素相等 (更接近最低有效位) (当未设置相应的掩码位时，从 src 复制元素)。每个元素的比较在 dst 中形成零扩展位 vector。"],["_mm_mask_cvt_roundps_ph","将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: (_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常 (_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常 (_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常 (_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常 _MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_mask_cvt_roundsd_ss","将 b 中的下部双精度 (64-bit) 浮点元素转换为单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。 根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一: (_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常 (_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常 (_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常 (_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常 _MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_mask_cvt_roundss_sd","将 b 中的下部单精度 (32-bit) 浮点元素转换为双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，然后将上层元素从 a 复制到 dst 的上层元素。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_mask_cvtepi16_epi32","符号将包装后的 16 位整数从 a 扩展为包装后的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvtepi16_epi64","使用符号将包装的 16 位整数从 a 扩展为包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvtepi16_epi8","将带有 a 的包装的 16 位整数转换为带截断的 8 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvtepi16_storeu_epi8","将 a 中的包装的 16 位整数转换为带有截断的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。"],["_mm_mask_cvtepi32_epi16","将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvtepi32_epi64","使用符号将包装的 32 位整数从 a 扩展为包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvtepi32_epi8","将带有 a 的包装的 32 位整数转换为带截断的包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvtepi32_pd","将 a 中的包装有符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm_mask_cvtepi32_ps","将 a 中的包装有符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm_mask_cvtepi32_storeu_epi16","将 a 中的包装的 32 位整数转换为带截断的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm_mask_cvtepi32_storeu_epi8","将包装的 32 位整数在 a 中转换为带有截断的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。"],["_mm_mask_cvtepi64_epi16","将 a 中的包装的 64 位整数转换为带截断的 16 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvtepi64_epi32","将 a 中的包装的 64 位整数转换为带截断的 32 位包装的整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvtepi64_epi8","将 a 中的包装的 64 位整数转换为带有截断的包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvtepi64_storeu_epi16","将 a 中的包装的 64 位整数转换为带截断的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm_mask_cvtepi64_storeu_epi32","将 a 中的包装的 64 位整数转换为带截断的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm_mask_cvtepi64_storeu_epi8","将 a 中包装的 64 位整数转换为包装的 8 位整数并截断，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 的未对齐内存中。"],["_mm_mask_cvtepi8_epi16","使用符号将包装的 8 位整数从 a 扩展为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvtepi8_epi32","符号将包装的 8 位整数从 a 扩展为包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvtepi8_epi64","将 a 的低 2 字节中的 8 位整数符号扩展为包装的 64 位整数，并使用 writemask k 将结果存入 dst 中 (未设置相应掩码位时从 src 复制元素)。"],["_mm_mask_cvtepu16_epi32","将 a 中的包装无符号 16 位整数零扩展为包装 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvtepu16_epi64","零扩展包装的无符号 16 位整数 a 的低 4 字节到包装的 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。"],["_mm_mask_cvtepu32_epi64","将 a 中的包装无符号 32 位整数零扩展为包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvtepu32_pd","将 a 中的包装无符号 32 位整数转换为包装双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm_mask_cvtepu8_epi16","将 a 中的包装无符号 8 位整数零扩展为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvtepu8_epi32","零扩展包装的无符号 8 位整数在 a 的低 4 字节到包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。"],["_mm_mask_cvtepu8_epi64","零扩展包装的无符号 8 位整数在 a 的低 2 字节到包装的 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。"],["_mm_mask_cvtne2ps_pbh","将两个 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 writemask k 将结果存储在单个 vector dst 中 (当对应的掩码位为没有设置)。"],["_mm_mask_cvtpd_epi32","将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm_mask_cvtpd_epu32","将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm_mask_cvtpd_ps","将 a 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm_mask_cvtph_ps","将 a 中的包装后的半精度 (16-bit) 浮点元素转换为包装后的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm_mask_cvtps_epi32","将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm_mask_cvtps_epu32","将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm_mask_cvtps_ph","将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_mask_cvtsd_ss","将 b 中的下部双精度 (64-bit) 浮点元素转换为单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。"],["_mm_mask_cvtsepi16_epi8","将 a 中的包装带符号的 16 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvtsepi16_storeu_epi8","将包装在 a 中的有符号 16 位整数转换为有符号饱和的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。"],["_mm_mask_cvtsepi32_epi16","将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvtsepi32_epi8","将 a 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvtsepi32_storeu_epi16","将包装在 a 中的有符号 32 位整数转换为具有符号饱和的包装的 16 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。"],["_mm_mask_cvtsepi32_storeu_epi8","将包装在 a 中的有符号 32 位整数转换为具有符号饱和的包装的 8 位整数，并将活动结果 (那些在 writemask k 中设置了相应位的结果) 存储到 base_addr 处的未对齐内存中。"],["_mm_mask_cvtsepi64_epi16","将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvtsepi64_epi32","将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvtsepi64_epi8","将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvtsepi64_storeu_epi16","将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm_mask_cvtsepi64_storeu_epi32","将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm_mask_cvtsepi64_storeu_epi8","将包装在 a 中的有符号 64 位整数转换为具有符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm_mask_cvtss_sd","将 b 中的下部单精度 (32-bit) 浮点元素转换为双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，然后将上层元素从 a 复制到 dst 的上层元素。"],["_mm_mask_cvttpd_epi32","将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm_mask_cvttpd_epu32","将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvttps_epi32","将 a 中的包装的单精度 (32-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm_mask_cvttps_epu32","将 a 中的包装的双精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvtusepi16_epi8","将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvtusepi16_storeu_epi8","将包装在 a 中的无符号 16 位整数转换为具有无符号饱和的包装的无符号 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm_mask_cvtusepi32_epi16","将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvtusepi32_epi8","将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm_mask_cvtusepi32_storeu_epi16","将包装在 a 中的无符号 32 位整数转换为具有无符号饱和的包装的无符号 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm_mask_cvtusepi32_storeu_epi8","将包装在 a 中的无符号 32 位整数转换为具有无符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm_mask_cvtusepi64_epi16","将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm_mask_cvtusepi64_epi32","将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm_mask_cvtusepi64_epi8","将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_cvtusepi64_storeu_epi16","将包装在 a 中的无符号 64 位整数转换为具有无符号饱和的包装的 16 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm_mask_cvtusepi64_storeu_epi32","将包装的无符号 64 位整数在 a 中转换为具有无符号饱和的包装的 32 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 处的未对齐内存中。"],["_mm_mask_cvtusepi64_storeu_epi8","将包装的无符号 64 位整数在 a 中转换为具有无符号饱和的包装的 8 位整数，并将活动结果 (在 writemask k 中设置了相应位的那些) 存储到 base_addr 的未对齐内存中。"],["_mm_mask_dbsad_epu8","计算 a 中的无符号 8 位整数与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs)，并使用写掩码 k 将 16 位结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。对于每个 64 位通道，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中通道的低 8 位四元组，而后两个 SAD 使用 a 中通道的较高 8 位四元组。根据 imm8 中的控件，从 128 位通道中选择 b 中的四元组，并且每个 64 位通道中的每个 SAD 使用 8 位偏移量的选定四元组。"],["_mm_mask_div_pd","将 a 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_div_ps","将 a 中的包装的单精度 (32-bit) 浮点元素除以 b 中的包装的元素，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_div_round_sd","将 a 中的较低双精度 (64-bit) 浮点元素除以 b 中的较低双精度 (64-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 时从 src 复制该元素 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。"],["_mm_mask_div_round_ss","将 a 中的下部单精度 (32-bit) 浮点元素除以 b 中的下部单精度 (32-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的下部元素中 (当掩码位 0 时，该元素从 src 复制 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。"],["_mm_mask_div_sd","将 a 中的较低双精度 (64-bit) 浮点元素除以 b 中的较低双精度 (64-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 时从 src 复制该元素 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。"],["_mm_mask_div_ss","将 a 中的下部单精度 (32-bit) 浮点元素除以 b 中的下部单精度 (32-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的下部元素中 (当掩码位 0 时，该元素从 src 复制 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。"],["_mm_mask_dpbf16_ps","计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间的单精度 (32-bit) 浮点元素与 src 中的元素相加，并使用 writemask k 将结果存储在 dst 中 (当对应的元素从 src 复制时掩码位未设置)。"],["_mm_mask_dpbusd_epi32","将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (未设置相应掩码位时从 src 复制元素)。"],["_mm_mask_dpbusds_epi32","将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。使用符号饱和将这 4 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm_mask_dpwssd_epi32","将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。"],["_mm_mask_dpwssds_epi32","将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并使用 writemask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。"],["_mm_mask_expand_epi16","从 a 加载连续的活动 16 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm_mask_expand_epi32","从 a 加载连续的有效 32 位整数 (它们各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm_mask_expand_epi64","从 a 加载连续的有效 64 位整数 (它们各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm_mask_expand_epi8","从 a 加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm_mask_expand_pd","从 a 加载连续的活动双精度 (64-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm_mask_expand_ps","从 a 中加载连续的活动单精度 (32-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm_mask_fixupimm_pd","使用 c 中的包装 64 位整数修复 a 和 b 中的包装双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (未设置相应的 mask 位时从 a 复制元素)。imm8 用于设置所需的标志报告。"],["_mm_mask_fixupimm_ps","使用 c 中的包装 32 位整数修复 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，从 a 复制元素)。imm8 用于设置所需的标志报告。"],["_mm_mask_fixupimm_round_sd","使用 c 中的较低 64 位整数修复 a 和 b 中的较低双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的较低元素中 (当 mask bit 0 为 0 时从 a 复制该元素 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。imm8 用于设置所需的标志报告。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_mask_fixupimm_round_ss","使用 c 中的较低 32 位整数修复 a 和 b 中的较低单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的较低元素中 (当 mask bit 0 为 0 时从 a 复制该元素 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。imm8 用于设置所需的标志报告。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_mask_fixupimm_sd","使用 c 中的较低 64 位整数修复 a 和 b 中的较低双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的较低元素中 (当 mask bit 0 为 0 时从 a 复制该元素 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。imm8 用于设置所需的标志报告。"],["_mm_mask_fixupimm_ss","使用 c 中的较低 32 位整数修复 a 和 b 中的较低单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的较低元素中 (当 mask bit 0 为 0 时从 a 复制该元素 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。imm8 用于设置所需的标志报告。"],["_mm_mask_fmadd_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 a 复制元素)。"],["_mm_mask_fmadd_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 a 复制元素)。"],["_mm_mask_fmadd_round_sd","将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，并使用 writemask k 将中间结果添加到 dst 较低元素中的较低元素 in c. Store 的结果 (当未使用掩码位 0 时从 a 复制该元素) set)，然后将上层元素从 a 复制到 dst 的上层元素。"],["_mm_mask_fmadd_round_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，并将中间结果加到较低元素 in c. Store 中，并使用 writemask k 将结果添加到 dst 较低元素中 (当未使用 mask bit 0 时从 a 复制该元素设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。"],["_mm_mask_fmadd_sd","将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，并使用 writemask k 将中间结果添加到 dst 较低元素中的较低元素 in c. Store 的结果 (当未使用掩码位 0 时从 a 复制该元素) set)，然后将上层元素从 a 复制到 dst 的上层元素。"],["_mm_mask_fmadd_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，并将中间结果加到较低元素 in c. Store 中，并使用 writemask k 将结果添加到 dst 较低元素中 (当未使用 mask bit 0 时从 a 复制该元素设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。"],["_mm_mask_fmaddsub_pd","将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 a 中复制元素放)。"],["_mm_mask_fmaddsub_ps","将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位则从 a 复制元素放)。"],["_mm_mask_fmsub_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (如果未设置相应的掩码位，则从 a 复制元素)。"],["_mm_mask_fmsub_ps","将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 a 复制元素)。"],["_mm_mask_fmsub_round_sd","将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 a 复制该元素)，然后将 a 的上部元素复制到 dst 的上部元素。"],["_mm_mask_fmsub_round_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的低位元素中 (当未设置掩码位 0 时从 a 复制该元素)，并将高 3 个压缩元素从 a 复制到 dst 的高位元素。"],["_mm_mask_fmsub_sd","将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 a 复制该元素)，然后将 a 的上部元素复制到 dst 的上部元素。"],["_mm_mask_fmsub_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。将结果存储在 dst 的下部元素中，并将上部 3 个包装的元素从 a 复制到 dst 的上部元素。"],["_mm_mask_fmsubadd_pd","将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，并使用 writemask k 将结果存储在 dst 中 (当未使用相应的掩码位时，元素将从 a 复制放)。"],["_mm_mask_fmsubadd_ps","将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将中间结果中的包装后的元素 from/to 减去并相加，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 a 复制元素放)。"],["_mm_mask_fnmadd_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。"],["_mm_mask_fnmadd_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。"],["_mm_mask_fnmadd_round_sd","将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，然后使用写掩码 k 将求反的中间结果与较低的元素 in c. Store 的结果相加到 dst 的较低元素中 (当掩码位 0 为 0 时从 a 复制 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。"],["_mm_mask_fnmadd_round_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用写掩码 k 将求反的中间结果与较低元素 in c. Store 的结果相加到 dst 较低元素中 (当掩码位 0 为 0 时，该元素是从 a 复制的 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。"],["_mm_mask_fnmadd_sd","将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，然后使用写掩码 k 将求反的中间结果与较低的元素 in c. Store 的结果相加到 dst 的较低元素中 (当掩码位 0 为 0 时从 a 复制 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。"],["_mm_mask_fnmadd_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用写掩码 k 将求反的中间结果与较低元素 in c. Store 的结果相加到 dst 较低元素中 (当掩码位 0 为 0 时，该元素是从 a 复制的 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。"],["_mm_mask_fnmsub_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。"],["_mm_mask_fnmsub_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 a 复制元素)。"],["_mm_mask_fnmsub_round_sd","将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的低位元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高位元素从 a 复制到 dst 的高位元素。"],["_mm_mask_fnmsub_round_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高 3 个包装的元素从 a 复制到 dst 的上部元素。"],["_mm_mask_fnmsub_sd","将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的低位元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高位元素从 a 复制到 dst 的高位元素。"],["_mm_mask_fnmsub_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时从 c 复制该元素)，并将高 3 个包装的元素从 a 复制到 dst 的上部元素。"],["_mm_mask_getexp_pd","将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并使用 writemask k 将结果存储在 dst 中 (当相应的 mask 时，元素从 src 复制位未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。"],["_mm_mask_getexp_ps","将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，并使用 writemask k 将结果存储在 dst 中 (当相应的 mask 时，元素从 src 复制位未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。"],["_mm_mask_getexp_round_sd","将 b 中较低的双精度 (64-bit) 浮点元素的指数转换为表示整数指数的双精度 (64-bit) 浮点数，使用写掩码 k 将结果存储在 dst 的较低元素中 (该元素从 src 复制 (当未设置屏蔽位 0 时)，然后将 a 的高位元素复制到 dst 的高位元素。本质上，此内联函数计算下部元素的 floor(log2(x))。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_mask_getexp_round_ss","将 b 中较低的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，使用写掩码 k 将结果存储在 dst 的较低元素中 (该元素从 src 复制 (当未设置掩码位 0 时)，并将高 3 个包装的元素从 a 复制到 dst 的高元素。本质上，此内联函数计算下部元素的 floor(log2(x))。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_mask_getexp_sd","将 b 中较低的双精度 (64-bit) 浮点元素的指数转换为表示整数指数的双精度 (64-bit) 浮点数，使用写掩码 k 将结果存储在 dst 的较低元素中 (该元素从 src 复制 (当未设置屏蔽位 0 时)，然后将 a 的高位元素复制到 dst 的高位元素。本质上，此内联函数计算下部元素的 floor(log2(x))。"],["_mm_mask_getexp_ss","将 b 中较低的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，使用写掩码 k 将结果存储在 dst 的较低元素中 (该元素从 src 复制 (当未设置掩码位 0 时)，并将高 3 个包装的元素从 a 复制到 dst 的高元素。本质上，此内联函数计算下部元素的 floor(log2(x))。"],["_mm_mask_getmant_pd","将 a 中的包装的双精度 (64-bit) 浮点元素的尾数标准化，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1"],["_mm_mask_getmant_ps","标准化 a 中包装的单精度 (32-bit) 浮点元素的尾数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1"],["_mm_mask_getmant_round_sd","标准化 b 中下部双精度 (64-bit) 浮点元素的尾数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部元素从 a 到 dst 的高位元素。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_mask_getmant_round_ss","标准化 b 中较低单精度 (32-bit) 浮点元素的尾数，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制高 3 从 a 到 dst 的上层元素的包装的元素。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_mask_getmant_sd","标准化 b 中下部双精度 (64-bit) 浮点元素的尾数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部元素从 a 到 dst 的高位元素。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_mask_getmant_ss","标准化 b 中较低单精度 (32-bit) 浮点元素的尾数，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制高 3 从 a 到 dst 的上层元素的包装的元素。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_mask_gf2p8affine_epi64_epi8","对 x 中的包装字节执行仿射变换。 也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。"],["_mm_mask_gf2p8affineinv_epi64_epi8","对 x 中的反向包装的字节执行仿射变换。 也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。"],["_mm_mask_gf2p8mul_epi8","在包装的字节上执行 GF(2^8) 乘法。 该字段以多项式表示，具有约数多项式 x^8 + x^4 + x^3 + x + 1。"],["_mm_mask_i32gather_epi32","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。 如果设置了掩码，请从该位置从 `src` 加载值。"],["_mm_mask_i32gather_epi64","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。 如果设置了掩码，请从该位置从 `src` 加载值。"],["_mm_mask_i32gather_pd","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。 如果设置了掩码，请从该位置从 `src` 加载值。"],["_mm_mask_i32gather_ps","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。 如果设置了掩码，请从该位置从 `src` 加载值。"],["_mm_mask_i64gather_epi32","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。 如果设置了掩码，请从该位置从 `src` 加载值。"],["_mm_mask_i64gather_epi64","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。 如果设置了掩码，请从该位置从 `src` 加载值。"],["_mm_mask_i64gather_pd","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。 如果设置了掩码，请从该位置从 `src` 加载值。"],["_mm_mask_i64gather_ps","从 `slice` 返回由 `offsets * scale` 确定的偏移量的值，其中 `scale` 应该为 1、2、4 或 8。 如果设置了掩码，请从该位置从 `src` 加载值。"],["_mm_mask_lzcnt_epi32","计算 a 中每个包装的 32 位整数中前导零位的数目，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_lzcnt_epi64","计算 a 中每个包装的 64 位整数中前导零位的数目，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_madd_epi16","在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。水平添加相邻的中间 32 位整数对，并使用 writemask k 将结果打包到 dst (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm_mask_maddubs_epi16","将 a 中的包装无符号 8 位整数与 b 中的包装有符号 8 位整数相乘，生成中间有符号的 16 位整数。水平相加相邻的中间带符号的 16 位整数对，并使用写掩码 k 将饱和结果包装到 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_max_epi16","比较 a 和 b 中包装的带符号的 16 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_max_epi32","比较 a 和 b 中包装的带符号的 32 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_max_epi64","比较 a 和 b 中包装的带符号的 64 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_max_epi8","比较 a 和 b 中包装的带符号的 8 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_max_epu16","比较 a 和 b 中包装的无符号 16 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_max_epu32","比较 a 和 b 中包装的无符号 32 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_max_epu64","比较 a 和 b 中包装的无符号 64 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_max_epu8","比较 a 和 b 中包装的无符号 8 位整数，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_max_pd","比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_max_ps","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_max_round_sd","比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将最大值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的元素从 a 到 dst 的高位元素。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_mask_max_round_ss","比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用写掩码 k 将最大值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的 3 从 a 到 dst 的上层元素的包装的元素。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_mask_max_sd","比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将最大值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的元素从 a 到 dst 的高位元素。"],["_mm_mask_max_ss","比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用写掩码 k 将最大值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的 3 从 a 到 dst 的上层元素的包装的元素。"],["_mm_mask_min_epi16","比较 a 和 b 中包装的带符号 16 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_min_epi32","比较 a 和 b 中包装的带符号的 32 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_min_epi8","比较 a 和 b 中包装的带符号的 8 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_min_epu16","比较 a 和 b 中包装的无符号 16 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_min_epu32","比较 a 和 b 中包装的无符号 32 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_min_epu64","比较 a 和 b 中包装的无符号 64 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_min_epu8","比较 a 和 b 中包装的无符号 8 位整数，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_min_pd","比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_min_ps","比较 a 和 b 中包装的单精度 (32-bit) 浮点元素，并使用写掩码 k 将包装的最小值存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_min_round_sd","比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将最小值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，然后复制较高的元素从 a 到 dst 的高位元素。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_mask_min_round_ss","比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用写掩码 k 将最小值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的 3 从 a 到 dst 的上层元素的包装的元素。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_mask_min_sd","比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将最小值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，然后复制较高的元素从 a 到 dst 的高位元素。"],["_mm_mask_min_ss","比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用写掩码 k 将最小值存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的 3 从 a 到 dst 的上层元素的包装的元素。"],["_mm_mask_mov_epi16","使用写掩码 k 将包装的 16 位整数从 a 移到 dst (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm_mask_mov_epi32","使用写掩码 k 将包装的 32 位整数从 a 移动到 dst (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm_mask_mov_epi64","使用写掩码 k 将包装的 64 位整数从 a 移动到 dst (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm_mask_mov_epi8","使用写掩码 k 将包装的 8 位整数从 a 移到 dst (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm_mask_mov_pd","使用写掩码 k 将包装的双精度 (64-bit) 浮点元素从 a 移动到 dst (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm_mask_mov_ps","使用写掩码 k 将包装的单精度 (32-bit) 浮点元素从 a 移动到 dst (未设置相应的掩码位时，将从 src 复制元素)。"],["_mm_mask_move_sd","使用写掩码 k 将低位双精度 (64-bit) 浮点元素从 b 移到 dst 的低位元素 (当未设置掩码位 0 时从 src 复制该元素)，并将高位元素从 a 复制到 a 的高位元素 dst。"],["_mm_mask_move_ss","使用写掩码 k 将低位单精度 (32-bit) 浮点元素从 b 移到 dst 的低位元素 (当未设置掩码位 0 时从 src 复制该元素)，并将高 3 个包装的元素从 a 复制到高位 dst 的元素。"],["_mm_mask_movedup_pd","从 a 复制偶数索引的双精度 (64-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm_mask_movehdup_ps","从 a 复制奇数索引的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm_mask_moveldup_ps","从 a 复制偶数索引的单精度 (32-bit) 浮点元素，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm_mask_mul_epi32","将 a 和 b 中每个包装的 64 位元素的低符号 32 位整数相乘，并使用写掩码 k 将有符号的 64 位结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm_mask_mul_epu32","将 a 和 b 中每个包装的 64 位元素的低无符号 32 位整数相乘，并使用写掩码 k 将无符号 64 位结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm_mask_mul_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_mul_ps","将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_mul_round_sd","将 a 和 b 中的下部双精度 (64-bit) 浮点元素相乘，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并从中复制上部元素。a 到 dst 的高位元素。"],["_mm_mask_mul_round_ss","将 a 和 b 中的下部单精度 (32-bit) 浮点元素相乘，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制包装后的高 3 位元素从 a 到 dst 的高位元素。"],["_mm_mask_mul_sd","将 a 和 b 中的下部双精度 (64-bit) 浮点元素相乘，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并从中复制上部元素。a 到 dst 的高位元素。"],["_mm_mask_mul_ss","将 a 和 b 中的下部单精度 (32-bit) 浮点元素相乘，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制包装后的高 3 位元素从 a 到 dst 的高位元素。"],["_mm_mask_mulhi_epi16","将 a 和 b 中包装的带符号的 16 位整数相乘，生成 32 位中间整数，并使用写掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm_mask_mulhi_epu16","将 a 和 b 中包装的无符号 16 位整数相乘，生成 32 位中间整数，并使用写掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm_mask_mulhrs_epi16","在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。将每个中间整数截断为 18 个最高有效位，通过加 1 舍入，并使用 writemask k 将位 [16:1] 存储到 dst (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm_mask_mullo_epi16","将 a 和 b 中的包装的 16 位整数相乘，生成中间的 32 位整数，并使用写掩码 k 将中间整数的低 16 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm_mask_mullo_epi32","将 a 和 b 中的包装的 32 位整数相乘，生成中间 64 位整数，并使用写掩码 k 将中间整数的低 32 位存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm_mask_multishift_epi64_epi8","对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并使用 writemask k (元素当相应的屏蔽位未设置时，从 src 复制)。"],["_mm_mask_or_epi32","计算 a 和 b 中包装的 32 位整数的按位或，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_or_epi64","计算 a 和 b 中包装的 64 位整数的按位或，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_packs_epi16","使用带符号的饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_packs_epi32","使用带符号的饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm_mask_packus_epi16","使用无符号饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_packus_epi32","使用无符号饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm_mask_permute_pd","使用 imm8 中的控件在 128 位通道内对双精度 (64-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm_mask_permute_ps","使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm_mask_permutevar_pd","使用 b 中的控件在 128 位通道内将 a 的双精度 (64-bit) 浮点元素进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm_mask_permutevar_ps","使用 b 中的控件在 128 位通道内将 a 的单精度 (32-bit) 浮点元素打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm_mask_permutex2var_epi16","使用相应的选择器和 idx 中的索引在通道中的 a 和 b 中对 16 位整数进行打乱，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。"],["_mm_mask_permutex2var_epi32","使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中对 32 位整数进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。"],["_mm_mask_permutex2var_epi64","使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中随机排列 64 位整数，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。"],["_mm_mask_permutex2var_epi8","使用相应的选择器和 idx 中的索引将 a 和 b 中的 8 位整数跨通道打乱，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。"],["_mm_mask_permutex2var_pd","使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。"],["_mm_mask_permutex2var_ps","使用对应的选择器和 idx 中的索引在 a 和 b 中的通道上对 a 和 b 中的单精度 (32-bit) 浮点元素进行混洗，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 a 复制)。"],["_mm_mask_permutexvar_epi16","使用 idx 中的相应索引在跨通道中对 16 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_permutexvar_epi8","使用 idx 中的相应索引在跨通道的 a 中打乱 8 位整数，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm_mask_popcnt_epi16","对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm_mask_popcnt_epi32","对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm_mask_popcnt_epi64","对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。"],["_mm_mask_popcnt_epi8","对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm_mask_rcp14_pd","计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。该近似值的最大相对误差小于 2^-14。"],["_mm_mask_rcp14_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。该近似值的最大相对误差小于 2^-14。"],["_mm_mask_rcp14_sd","计算 b 中较低的双精度 (64-bit) 浮点元素的近似倒数，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，并复制较高的 x 元素从 a 到 dst 的高位元素。该近似值的最大相对误差小于 2^-14。"],["_mm_mask_rcp14_ss","计算 b 中下部单精度 (32-bit) 浮点元素的近似倒数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部从 a 到 dst 的上层元素的 3 个包装的元素。该近似值的最大相对误差小于 2^-14。"],["_mm_mask_rol_epi32","将每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_rol_epi64","将每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_rolv_epi32","将 a 中每个包装的 32 位整数中的位向左旋转 b 对应元素 b 中指定的位数，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 src 复制元素放)。"],["_mm_mask_rolv_epi64","将 a 中每个包装的 64 位整数中的位向左旋转 b 的对应元素中指定的位数，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 src 复制元素放)。"],["_mm_mask_ror_epi32","将 X 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_ror_epi64","将 X 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_rorv_epi32","将 a 中每个包装的 32 位整数中的位向右旋转 b 的对应元素中指定的位数，然后使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 src 复制元素放)。"],["_mm_mask_rorv_epi64","将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，并使用 writemask k 将结果存储在 dst 中 (如果没有使用相应的 mask 位，则从 src 复制元素放)。"],["_mm_mask_roundscale_pd","将 a 中的包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_mask_roundscale_ps","将 a 中的包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的小数位数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_mask_roundscale_round_sd","将 b 中的下部双精度 (64-bit) 浮点元素四舍五入为 imm8 指定的分数位数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时，该元素从 src 复制)，然后将上层元素从 a 复制到 dst 的上层元素。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_mask_roundscale_round_ss","将 b 中的下部单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时，该元素从 src 复制)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_mask_roundscale_sd","将 b 中的下部双精度 (64-bit) 浮点元素四舍五入为 imm8 指定的分数位数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时，该元素从 src 复制)，然后将上层元素从 a 复制到 dst 的上层元素。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_mask_roundscale_ss","将 b 中的下部单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，使用写掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时，该元素从 src 复制)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_mask_rsqrt14_pd","计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。该近似值的最大相对误差小于 2^-14。"],["_mm_mask_rsqrt14_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。该近似值的最大相对误差小于 2^-14。"],["_mm_mask_rsqrt14_sd","计算 b 中较低的双精度 (64-bit) 浮点元素的近似平方根，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，然后复制从 a 到 dst 的上元素的上元素。该近似值的最大相对误差小于 2^-14。"],["_mm_mask_rsqrt14_ss","计算 b 中较低单精度 (32-bit) 浮点元素的近似倒数平方根，使用写掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时从 src 复制该元素)，然后复制从 a 到 dst 的高位元素的前 3 个包装的元素。该近似值的最大相对误差小于 2^-14。"],["_mm_mask_scalef_pd","使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm_mask_scalef_ps","使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm_mask_scalef_round_sd","使用 b 中的值缩放 a 中的包装双精度 (64-bit) 浮点元素，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部元素从 a 到 dst 的高位元素。"],["_mm_mask_scalef_round_ss","使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的下部元素 (未设置 mask bit 0 时从 src 复制该元素)，并复制上部从 a 到 dst 的上层元素的 3 个包装的元素。"],["_mm_mask_scalef_sd","使用 b 中的值缩放 a 中的包装双精度 (64-bit) 浮点元素，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部元素从 a 到 dst 的高位元素。"],["_mm_mask_scalef_ss","使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 的下部元素 (未设置 mask bit 0 时从 src 复制该元素)，并复制上部从 a 到 dst 的上层元素的 3 个包装的元素。"],["_mm_mask_set1_epi16","使用写掩码 k 向 dst 的所有元素广播 16 位整数 a (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm_mask_set1_epi32","使用写掩码 k 将 32 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时从 src 复制元素)。"],["_mm_mask_set1_epi64","使用写掩码 k 将 64 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时从 src 复制元素)。"],["_mm_mask_set1_epi8","使用写掩码 k 将 8 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时从 src 复制元素)。"],["_mm_mask_shldi_epi16","在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并使用 writemask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm_mask_shldi_epi32","将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并使用 writemask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm_mask_shldi_epi64","在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并使用 writemask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm_mask_shldv_epi16","在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。"],["_mm_mask_shldv_epi32","将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。"],["_mm_mask_shldv_epi64","在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的相应元素中指定的数量，并使用 writemask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 复制)。"],["_mm_mask_shrdi_epi16","将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并使用 writemask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm_mask_shrdi_epi32","连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并使用 writemask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，从 src 复制元素)。"],["_mm_mask_shrdi_epi64","将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并使用 writemask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，元素从 src` 复制)。"],["_mm_mask_shrdv_epi16","将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。"],["_mm_mask_shrdv_epi32","连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，元素从 a 中复制)。"],["_mm_mask_shrdv_epi64","将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的相应元素中指定的数量，并使用 writemask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，从 a 复制元素)。"],["_mm_mask_shuffle_epi32","使用 imm8 中的控件将 128 位通道中的 32 位整数随机排列，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_shuffle_epi8","使用 b 中相应的 8 位元素中的控件在 128 位通道内对 a 中的 8 位整数进行打乱，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_shuffle_pd","使用 imm8 中的控件对 128 位通道中的双精度 (64-bit) 浮点元素进行混洗，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_shuffle_ps","使用 imm8 中的控件 shuffle a 中的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素从 src 复制)。"],["_mm_mask_shufflehi_epi16","使用 imm8 中的控件在 a 的 128 位通道的高 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的高 64 位中，将 128 位通道的低 64 位从 a 复制到 dst，使用写掩码 k (当相应的掩码位不存在时，元素从 src 复制放)。"],["_mm_mask_shufflelo_epi16","使用 imm8 中的控件在 a 的 128 位通道的低 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的低 64 位中，并使用写掩码 k 将 128 位通道的高 64 位从 a 复制到 dst (当未使用相应的掩码位时，元素从 src 复制) 放)。"],["_mm_mask_sll_epi16","将包装的 16 位整数按计数左移，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_sll_epi32","将包装的 32 位整数左移计数，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_sll_epi64","将包装的 64 位整数左移计数，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_slli_epi16","将包装的 16 位整数左移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_slli_epi32","将包装的 32 位整数左移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_slli_epi64","将包装的 64 位整数向左移动 imm8，同时向零移动，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_sllv_epi16","将包装的 16 位整数按 count 中相应元素指定的数量向左移位，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_sllv_epi32","将填充的 32 位整数向左移动计数中相应元素指定的数量，同时将其移位为零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_sllv_epi64","将填充的 64 位整数向左移动 count 中相应元素指定的数量，同时将其移位为零，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素将从 src 复制)。"],["_mm_mask_sqrt_pd","计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_sqrt_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_sqrt_round_sd","计算 b 中下部双精度 (64-bit) 浮点元素的平方根，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部元素从 a 到 dst 的高位元素。"],["_mm_mask_sqrt_round_ss","计算 b 中下部单精度 (32-bit) 浮点元素的平方根，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部从 a 到 dst 的上层元素的 3 个包装的元素。"],["_mm_mask_sqrt_sd","计算 b 中下部双精度 (64-bit) 浮点元素的平方根，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部元素从 a 到 dst 的高位元素。"],["_mm_mask_sqrt_ss","计算 b 中下部单精度 (32-bit) 浮点元素的平方根，使用 writemask k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时从 src 复制该元素)，并复制上部从 a 到 dst 的上层元素的 3 个包装的元素。"],["_mm_mask_sra_epi16","将包装的 16 位整数按计数右移，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_sra_epi32","在移动符号位的同时右移计数包装的 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_sra_epi64","在移动符号位的同时右移计数包装的 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_srai_epi16","将包装的 16 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_srai_epi32","将包装的 32 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_srai_epi64","将包装的 64 位整数右移 imm8，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_srav_epi16","将包装的 16 位整数右移 count 中相应元素指定的数量，同时将符号位移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_srav_epi32","在将符号位移位的同时，将已包装的 32 位整数向右移动计数中相应元素指定的数量，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_srav_epi64","在移入符号位的同时，将包装的 64 位整数向右移动计数中相应元素指定的数量，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_srl_epi16","将包装的 16 位整数右移，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_srl_epi32","将包装的 32 位整数右移，同时移零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_srl_epi64","将包装的 64 位整数右移，同时移零，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_srli_epi16","将包装的 16 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_srli_epi32","将包装的 32 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_srli_epi64","将包装的 64 位整数右移 imm8，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_srlv_epi16","将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_srlv_epi32","向右移动包装的 32 位整数整数 (由 count 中相应元素指定的数量)，同时向零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_srlv_epi64","向右移位包装的 64 位整数，其数量为计数中相应元素指定的数量，同时向零移位，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_sub_epi16","从 a 中的包装的 16 位整数中减去 b 中的包装的 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_sub_epi32","从 a 中的包装 32 位整数中减去 b 中的包装 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_sub_epi64","从 a 中的包装 64 位整数中减去 b 中的包装 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_sub_epi8","从 a 中的包装 8 位整数中减去 b 中的包装 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_sub_pd","从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_sub_ps","将 b 中的包装后的单精度 (32-bit) 浮点元素减去 a 中的包装后的单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_sub_round_sd","从 a 中的较低双精度 (64-bit) 浮点元素中减去 b 中较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 时，该元素是从 src 复制的 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。"],["_mm_mask_sub_round_ss","从 a 中的较低单精度 (32-bit) 浮点元素减去 b 中的较低单精度 (32-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 时从 src 复制该元素 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。"],["_mm_mask_sub_sd","从 a 中的较低双精度 (64-bit) 浮点元素中减去 b 中较低的双精度 (64-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 时，该元素是从 src 复制的 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。"],["_mm_mask_sub_ss","从 a 中的较低单精度 (32-bit) 浮点元素减去 b 中的较低单精度 (32-bit) 浮点元素，使用写掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 时从 src 复制该元素 (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。"],["_mm_mask_subs_epi16","使用饱和度将 b 中的包装 16 位整数减去 b 中的包装有符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm_mask_subs_epi8","使用饱和度将 b 中的包装 8 位整数减去 b 中的包装 8 位有符号整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_subs_epu16","使用 a 饱和度从 b 中的包装无符号 16 位整数减去 b 中的包装无符号 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm_mask_subs_epu8","使用 a 饱和度将 b 中的包装无符号 8 位整数减去 b 中的包装无符号 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时从 src 复制元素)。"],["_mm_mask_ternarylogic_epi32","提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 32 位整数中的每一位，使用 src、a 和 b 中的相应位形成 imm8 的 3 位索引，并使用 writemask 将 imm8 中该位的值写入 dst 中的相应位 k 在 32 位粒度 (当相应的掩码位未设置时，从 src 复制 32 位元素)。"],["_mm_mask_ternarylogic_epi64","提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 64 位整数中的每一位，src、a 和 b 中的相应位用于形成 imm8 的 3 位索引，并使用 writemask 将 imm8 中该位的值写入 dst 中的相应位 k 在 64 位粒度 (当相应的掩码位未设置时，从 src 复制 64 位元素)。"],["_mm_mask_test_epi16_mask","计算 a 和 b 中包装的 16 位整数的按位与，生成中间的 16 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。"],["_mm_mask_test_epi32_mask","计算 a 和 b 中包装的 32 位整数的按位与，生成中间的 32 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。"],["_mm_mask_test_epi64_mask","计算 a 和 b 中包装的 64 位整数的按位与，生成中间 64 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。"],["_mm_mask_test_epi8_mask","计算 a 和 b 中包装的 8 位整数的按位与，生成中间 8 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。"],["_mm_mask_testn_epi16_mask","计算 a 和 b 中包装的 16 位整数的按位 NAND，生成中间的 16 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。"],["_mm_mask_testn_epi32_mask","计算 a 和 b 中包装的 32 位整数的按位 NAND，生成中间的 32 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (服从写掩码 k)。"],["_mm_mask_testn_epi64_mask","计算 a 和 b 中包装的 64 位整数的按位 NAND，生成中间 64 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。"],["_mm_mask_testn_epi8_mask","计算 a 和 b 中包装的 8 位整数的按位 NAND，生成中间的 8 位值，如果中间值为零，则在结果掩码 k 中设置相应的位 (以写掩码 k 为准)。"],["_mm_mask_unpackhi_epi16","从 a 和 b 中每个 128 位通道的高半部分拆包和交织 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm_mask_unpackhi_epi32","从 a 和 b 中每个 128 位通道的高半部分解包和交织 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm_mask_unpackhi_epi64","从 a 和 b 中每个 128 位通道的高半部分解包和交织 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_unpackhi_epi8","从 a 和 b 中每个 128 位通道的高半部分拆包和交织 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm_mask_unpackhi_pd","从 a 和 b 中每个 128 位通道的高半部分解包和交织双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 src 复制元素)。"],["_mm_mask_unpackhi_ps","从 a 和 b 中每个 128 位通道的高半部分解包和交织单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 src 复制元素)。"],["_mm_mask_unpacklo_epi16","从 a 和 b 中每个 128 位通道的下半部分拆包和交织 16 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm_mask_unpacklo_epi32","从 a 和 b 中每个 128 位通道的下半部分解包和交织 32 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm_mask_unpacklo_epi64","从 a 和 b 中每个 128 位通道的下半部分解包和交织 64 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_unpacklo_epi8","从 a 和 b 中每个 128 位通道的下半部分拆包和交织 8 位整数，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，从 src 复制元素)。"],["_mm_mask_unpacklo_pd","从 a 和 b 中每个 128 位通道的下半部分解包并交织双精度 (64-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 src 复制元素)。"],["_mm_mask_unpacklo_ps","从 a 和 b 中每个 128 位通道的下半部分解包并交织单精度 (32-bit) 浮点元素，并使用 writemask k 将结果存储在 dst 中 (当未设置相应的 mask 位时从 src 复制元素)。"],["_mm_mask_xor_epi32","计算 a 和 b 中包装的 32 位整数的按位 XOR，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_mask_xor_epi64","计算 a 和 b 中包装的 64 位整数的按位 XOR，并使用写掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将从 src 复制)。"],["_mm_maskload_epi32","使用 `mask` 从 `mem_addr` 指向的内存中加载包装的 32 位整数 (当未在相应元素中设置最高位时，元素清零)。"],["_mm_maskload_epi64","使用 `mask` 从 `mem_addr` 指向的内存中加载包装的 64 位整数 (当未在相应元素中设置最高位时，元素清零)。"],["_mm_maskload_pd","使用 `mask` 将包装的双精度 (64-bit) 浮点元素从内存加载到结果中 (当未设置相应元素的高位时，元素清零)。"],["_mm_maskload_ps","使用 `mask` 将包装的单精度 (32-bit) 浮点元素从内存加载到结果中 (当未设置相应元素的高位时，元素清零)。"],["_mm_maskmoveu_si128","使用 `mask` 有条件地将 `a` 中的 8 位整数元素存储到内存中。"],["_mm_maskstore_epi32","使用 `mask` 将 `a` 中的包装后的 32 位整数存储到 `mem_addr` 指向的内存中 (当在相应元素中未设置最高位时，不存储元素)。"],["_mm_maskstore_epi64","使用 `mask` 将 `a` 中的包装 64 位整数存储到 `mem_addr` 指向的内存中 (当未在相应元素中设置最高位时，不存储元素)。"],["_mm_maskstore_pd","使用 `mask` 将包装的双精度 (64-bit) 浮点元素从 `a` 存储到内存中。"],["_mm_maskstore_ps","使用 `mask` 将包装的单精度 (32-bit) 浮点元素从 `a` 存储到内存中。"],["_mm_maskz_abs_epi16","计算 a 中包装的带符号的 16 位整数的绝对值，并使用零掩码 k (将未设置相应掩码位的元素清零) 将无符号结果存储在 dst 中。"],["_mm_maskz_abs_epi32","计算 a 中包装的有符号 32 位整数的绝对值，并使用 zeromask k 将无符号结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_abs_epi8","计算 a 中包装的带符号的 8 位整数的绝对值，并使用零掩码 k 将无符号结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_add_epi16","将包装的 16 位整数添加到 a 和 b 中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_add_epi32","将包装的 32 位整数添加到 a 和 b 中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_add_epi64","在 a 和 b 中添加包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_add_epi8","在 a 和 b 中添加包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_add_pd","在 a 和 b 中添加包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_add_ps","在 a 和 b 中添加包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_add_round_sd","在 a 和 b 中添加较低的双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素清零)，然后从 a 中复制较高的元素到 dst 的上层元素。"],["_mm_maskz_add_round_ss","在 a 和 b 中添加较低的单精度 (32-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素归零)，并复制较高的 3 个包装的元素从 a 到 dst 的上层元素。"],["_mm_maskz_add_sd","在 a 和 b 中添加较低的双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素清零)，然后从 a 中复制较高的元素到 dst 的上层元素。"],["_mm_maskz_add_ss","在 a 和 b 中添加较低的单精度 (32-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素归零)，并复制较高的 3 个包装的元素从 a 到 dst 的上层元素。"],["_mm_maskz_adds_epi16","使用饱和度在 a 和 b 中添加包装的带符号的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_adds_epi8","使用饱和度在 a 和 b 中添加包装的带符号的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_adds_epu16","使用饱和度在 a 和 b 中添加包装的无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_adds_epu8","使用饱和度在 a 和 b 中添加包装的无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_alignr_epi32","将 a 和 b 连接成 32 字节的 immediate 结果，将结果右移 imm8 个 32 位元素，并使用 zeromask k 将低 16 字节 (4 个元素) 存储在 dst 中 (当相应的掩码位不存在时，元素被清零放)。"],["_mm_maskz_alignr_epi64","将 a 和 b 连接成 32 字节的 immediate 结果，将结果右移 imm8 个 64 位元素，并使用 zeromask k 将低 16 字节 (2 个元素) 存储在 dst 中 (当相应的掩码位不存在时，元素被清零放)。"],["_mm_maskz_alignr_epi8","将 a 和 b 中的 16 字节块对连接成一个 32 字节的临时结果，将结果右移 imm8 字节，并使用零掩码 k 将低 16 字节存储在 dst 中 (当未使用相应的掩码位时元素清零) 放)。"],["_mm_maskz_and_epi32","计算 a 和 b 中包装的 32 位整数的按位与，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_and_epi64","计算 a 和 b 中包装的 64 位整数的按位与，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_andnot_epi32","计算 a 中包装的 32 位整数的按位 NOT，然后计算 b 中的 AND，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_andnot_epi64","计算 a 中包装的 64 位整数的按位 NOT，然后与 b 计算 AND，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_avg_epu16","将 a 和 b 中包装的无符号 16 位整数进行平均，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_avg_epu8","将 a 和 b 中包装的无符号 8 位整数进行平均，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_broadcastb_epi8","使用零掩码 k 将低包装的 8 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm_maskz_broadcastd_epi32","使用零掩码 k 将低包装的 32 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm_maskz_broadcastq_epi64","使用零掩码 k 将低包装的 64 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm_maskz_broadcastss_ps","使用零掩码 k 将低单精度 (32-bit) 浮点元素从 a 广播到 dst 的所有元素 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_broadcastw_epi16","使用零掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm_maskz_compress_epi16","将 a 中的活动 16 位整数 (它们各自的位设置在 zeromask k 中) 连续存储到 dst，并将其余元素设置为零。"],["_mm_maskz_compress_epi32","将活动的 32 位整数连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的整数) 为 dst，并将其余元素设置为零。"],["_mm_maskz_compress_epi64","将活动的 64 位整数连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的整数) 为 dst，并将其余元素设置为零。"],["_mm_maskz_compress_epi8","将 a 中的活动 8 位整数 (它们各自的位设置在 zeromask k 中) 连续存储到 dst，并将其余元素设置为零。"],["_mm_maskz_compress_pd","将活动的双精度 (64-bit) 浮点元素连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的那些元素) 为 dst，并将其余元素设置为零。"],["_mm_maskz_compress_ps","将活动的单精度 (32-bit) 浮点元素连续存储在 dst 中 (它们各自的位设置在零掩码 k 中的那些元素) 为 dst，并将其余元素设置为零。"],["_mm_maskz_conflict_epi32","使用零掩码 k (在未设置相应的掩码位时将元素清零)，测试 a 的每个 32 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。"],["_mm_maskz_conflict_epi64","使用零掩码 k (在未设置相应的掩码位时将元素清零)，测试 a 的每个 64 位元素是否与所有其他元素在最接近最低有效位的相等性相等。每个元素的比较在 dst 中形成零扩展位 vector。"],["_mm_maskz_cvt_roundps_ph","将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: (_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常 (_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常 (_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常 (_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常 _MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_maskz_cvt_roundsd_ss","将 b 中的下部双精度 (64-bit) 浮点元素转换为单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。 根据 rounding[3: 0] 参数进行舍入，该参数可以是以下之一: (_MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC) // 舍入到最接近的值，并抑制异常 (_MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)     // 向下取整并抑制异常 (_MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)     // 向上取整并抑制异常 (_MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)        // 截断并抑制异常 _MM_FROUND_CUR_DIRECTION // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_maskz_cvt_roundss_sd","将 b 中的下部单精度 (32-bit) 浮点元素转换为双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后将上层元素从 a 复制到 dst 的上层元素。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_maskz_cvtepi16_epi32","符号将包装的 16 位整数从 a 扩展为包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm_maskz_cvtepi16_epi64","使用符号将包装的 16 位整数从 a 扩展为包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_cvtepi16_epi8","将带有 a 的包装的 16 位整数转换为带截断的 8 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_cvtepi32_epi16","将带有 a 的包装的 32 位整数转换为带截断的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_cvtepi32_epi64","使用符号将包装的 32 位整数从 a 扩展为包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_cvtepi32_epi8","将带有 a 的包装的 32 位整数转换为带有截断的包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_cvtepi32_pd","将 a 中的包装有符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm_maskz_cvtepi32_ps","将 a 中的包装有符号 32 位整数转换为包装的单精度 (32-bit) 浮点元素，并使用零掩码 k (未设置相应的掩码位时将元素清零) 将结果存储在 dst 中。"],["_mm_maskz_cvtepi64_epi16","将带有 a 的包装的 64 位整数转换为带截断的 16 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_cvtepi64_epi32","将 a 中的包装的 64 位整数转换为带截断的 32 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_cvtepi64_epi8","将带有 a 的包装的 64 位整数转换为带截断的 8 位包装的整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_cvtepi8_epi16","使用符号将包装的 8 位整数从 a 扩展为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm_maskz_cvtepi8_epi32","使用符号将包装的 8 位整数从 a 扩展为包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_cvtepi8_epi64","将 a 的低 2 字节中的 8 位整数符号扩展为包装的 64 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_cvtepu16_epi32","将 a 中的包装无符号 16 位整数零扩展为包装 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_cvtepu16_epi64","零扩展包装的无符号 16 位整数在 a 的低 4 字节到包装的 64 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_cvtepu32_epi64","将 a 中的包装无符号 32 位整数零扩展为包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_cvtepu32_pd","将 a 中的包装无符号 32 位整数转换为包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_cvtepu8_epi16","将 a 中的包装无符号 8 位整数零扩展为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_cvtepu8_epi32","零扩展包装的无符号 8 位整数 a 的后 4 个字节到包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_cvtepu8_epi64","零扩展包装的无符号 8 位整数在 a 的低 2 字节到包装的 64 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_cvtne2ps_pbh","将两个 vectors a 和 b 中的包装的单精度 (32-bit) 浮点元素转换为包装的 BF16 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在单个 vector dst 中 (当对应的掩码位不存在时，元素归零放)。"],["_mm_maskz_cvtpd_epi32","将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。"],["_mm_maskz_cvtpd_epu32","将 a 中的包装双精度 (64-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。"],["_mm_maskz_cvtpd_ps","将 a 中的包装的双精度 (64-bit) 浮点元素转换为包装的单精度 (32-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。"],["_mm_maskz_cvtph_ps","将 a 中的包装后的半精度 (16-bit) 浮点元素转换为包装后的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_cvtps_epi32","将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。"],["_mm_maskz_cvtps_epu32","将 a 中的包装单精度 (32-bit) 浮点元素转换为包装的无符号 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。"],["_mm_maskz_cvtps_ph","将 a 中的包装的单精度 (32-bit) 浮点元素转换为包装的半精度 (16-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_maskz_cvtsd_ss","将 b 中的下部双精度 (64-bit) 浮点元素转换为单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。"],["_mm_maskz_cvtsepi16_epi8","将 a 中的包装有符号 16 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_cvtsepi32_epi16","将 A 中的包装有符号 32 位整数转换为带符号饱和的包装 16 位整数，并将结果存储在 dst 中。"],["_mm_maskz_cvtsepi32_epi8","将 a 中的包装有符号 32 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_cvtsepi64_epi16","将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm_maskz_cvtsepi64_epi32","将 a 中的包装带符号的 64 位整数转换为带符号饱和的包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm_maskz_cvtsepi64_epi8","将 a 中的包装有符号 64 位整数转换为带符号饱和的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm_maskz_cvtss_sd","将 b 中的下部单精度 (32-bit) 浮点元素转换为双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后将上层元素从 a 复制到 dst 的上层元素。"],["_mm_maskz_cvttpd_epi32","将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的 32 位整数，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。"],["_mm_maskz_cvttpd_epu32","将 a 中的包装的双精度 (64-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_cvttps_epi32","将带有 a 的包装的单精度 (32-bit) 浮点元素转换为带有截断的包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_cvttps_epu32","将 a 中的包装的双精度 (32-bit) 浮点元素转换为带截断的包装的无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_cvtusepi16_epi8","将 a 中的包装无符号 16 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm_maskz_cvtusepi32_epi16","将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm_maskz_cvtusepi32_epi8","将 a 中的包装无符号 32 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm_maskz_cvtusepi64_epi16","将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_cvtusepi64_epi32","将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_cvtusepi64_epi8","将 a 中的包装无符号 64 位整数转换为具有无符号饱和的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm_maskz_dbsad_epu8","计算 a 中与 b 中的无符号 8 位整数的四元组的绝对差之和 (SADs) 的总和，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将 16 位结果存储在 dst 中。对于每个 64 位通道，在四个 8 位四元组上执行四个 SAD。前两个 SAD 使用 a 中通道的低 8 位四元组，而后两个 SAD 使用 a 中通道的较高 8 位四元组。根据 imm8 中的控件，从 128 位通道中选择 b 中的四元组，并且每个 64 位通道中的每个 SAD 使用 8 位偏移量的选定四元组。"],["_mm_maskz_div_pd","将 a 中的包装的双精度 (64-bit) 浮点元素除以 b 中的包装的元素，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_div_ps","将 a 中的包装单精度 (32-bit) 浮点元素除以 b 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_div_round_sd","将 a 中的较低双精度 (64-bit) 浮点元素除以 b 中的较低双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 为 0 时，该元素归零 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。"],["_mm_maskz_div_round_ss","将 a 中的下部单精度 (32-bit) 浮点元素除以 b 中的下部单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当掩码位 0 为 0 时，该元素清零) (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。"],["_mm_maskz_div_sd","将 a 中的较低双精度 (64-bit) 浮点元素除以 b 中的较低双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 为 0 时，该元素归零 (未设置)，然后将上层元素从 a 复制到 dst 的上层元素。"],["_mm_maskz_div_ss","将 a 中的下部单精度 (32-bit) 浮点元素除以 b 中的下部单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当掩码位 0 为 0 时，该元素清零) (未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。"],["_mm_maskz_dpbf16_ps","计算 a 和 b 中 BF16 (16-bit) 浮点对的点积，将中间单精度 (32-bit) 浮点元素与 src 中的元素进行累加，并将结果存储在 dst 中使用 zeromask k (当对应的掩码为位未设置)。"],["_mm_maskz_dpbusd_epi32","将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数相加，并将包装的 32 位结果使用 zeromask k 存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_dpbusds_epi32","将 a 中的 4 对相邻的无符号 8 位整数组与 b 中的相应有符号 8 位整数相乘，产生 4 个中间有符号 16 位结果。将这 4 个结果与 src 中对应的 32 位整数用带符号饱和求和，并将包装的 32 位结果用 zeromask k 存储在 dst 中 (当对应的掩码位未设置时，元素被清零)。"],["_mm_maskz_dpwssd_epi32","将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。将这 2 个结果与 src 中对应的 32 位整数相加，并使用 zeromask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_dpwssds_epi32","将 a 中的 2 对相邻的有符号 16 位整数组与 b 中的相应 16 位整数相乘，产生 2 个中间有符号 32 位结果。使用符号饱和将这 2 个结果与 src 中相应的 32 位整数相加，并使用 zeromask k 将包装的 32 位结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_expand_epi16","从 a 加载连续的活动 16 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_expand_epi32","从 a 中加载连续的有效 32 位整数 (它们各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_expand_epi64","从 a 中加载连续的有效 64 位整数 (它们各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_expand_epi8","从 a 加载连续的活动 8 位整数 (那些在掩码 k 中设置了相应位的整数)，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_expand_pd","从 a 中加载连续的活动双精度 (64-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_expand_ps","从 a 中加载连续的活动单精度 (32-bit) 浮点元素 (其各自的位在掩码 k 中设置)，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_fixupimm_pd","使用 c 中的包装 64 位整数修复 a 和 b 中的包装双精度 (64-bit) 浮点元素，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的 mask 位时，元素清零)。imm8 用于设置所需的标志报告。"],["_mm_maskz_fixupimm_ps","使用 c 中的包装 32 位整数修复 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。imm8 用于设置所需的标志报告。"],["_mm_maskz_fixupimm_round_sd","使用 c 中的较低 64 位整数修复 a 和 b 中的较低双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 的较低元素中 (当不使用掩码位 0 时该元素清零) set)，然后将上层元素从 a 复制到 dst 的上层元素。imm8 用于设置所需的标志报告。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_maskz_fixupimm_round_ss","使用 c 中的较低 32 位整数固定 a 和 b 中的较低单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 的较低元素中 (当未使用掩码 bit 0 时该元素被清零) 设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。imm8 用于设置所需的标志报告。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_maskz_fixupimm_sd","使用 c 中的较低 64 位整数修复 a 和 b 中的较低双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 的较低元素中 (当不使用掩码位 0 时该元素清零) set)，然后将上层元素从 a 复制到 dst 的上层元素。imm8 用于设置所需的标志报告。"],["_mm_maskz_fixupimm_ss","使用 c 中的较低 32 位整数固定 a 和 b 中的较低单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 的较低元素中 (当未使用掩码 bit 0 时该元素被清零) 设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。imm8 用于设置所需的标志报告。"],["_mm_maskz_fmadd_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_fmadd_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_fmadd_round_sd","将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后使用零掩码 k 将中间结果与较低元素 in c. Store 的结果加到 dst 较低元素中 (当未设置掩码位 0 时该元素归零) )，然后将上层元素从 a 复制到 dst 的上层元素。"],["_mm_maskz_fmadd_round_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用零掩码 k 将中间结果与较低元素 in c. Store 的中间结果相加到 dst 较低元素中 (未设置掩码位 0 时该元素归零) )，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。"],["_mm_maskz_fmadd_sd","将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后使用零掩码 k 将中间结果与较低元素 in c. Store 的结果加到 dst 较低元素中 (当未设置掩码位 0 时该元素归零) )，然后将上层元素从 a 复制到 dst 的上层元素。"],["_mm_maskz_fmadd_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用零掩码 k 将中间结果与较低元素 in c. Store 的中间结果相加到 dst 较低元素中 (未设置掩码位 0 时该元素归零) )，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。"],["_mm_maskz_fmaddsub_pd","将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或减去，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm_maskz_fmaddsub_ps","将 a 和 b 中的包装后的单精度 (32-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或相减，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm_maskz_fmsub_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，从中间结果中减去 c 中的包装的元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_fmsub_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_fmsub_round_sd","将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用 zeromask k 将结果存储在 dst 的下元素中 (当掩码位 0 未设置时元素被清零)，并将上元素从 a 复制到 dst 的上元素。"],["_mm_maskz_fmsub_round_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用 zeromask k 将结果存储在 dst 的下元素中 (当未设置掩码位 0 时，元素被清零)，并将上 3 个打包元素从 a 复制到 dst 的上元素。"],["_mm_maskz_fmsub_sd","将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用 zeromask k 将结果存储在 dst 的下元素中 (当掩码位 0 未设置时元素被清零)，并将上元素从 a 复制到 dst 的上元素。"],["_mm_maskz_fmsub_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从中间结果中减去 c 中的较低元素。使用 zeromask k 将结果存储在 dst 的下元素中 (当未设置掩码位 0 时，元素被清零)，并将上 3 个打包元素从 a 复制到 dst 的上元素。"],["_mm_maskz_fmsubadd_pd","将 a 和 b 中的包装后的双精度 (64-bit) 浮点元素相乘，或者将 C to/from 中的包装后的元素相加或减去，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm_maskz_fmsubadd_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，或者将 C from/to 中的包装元素相减并相加，得到中间结果，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm_maskz_fnmadd_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_fnmadd_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，将取反的中间结果添加到 c 中的包装元素中，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_fnmadd_round_sd","将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，然后使用零掩码 k 将求反的中间结果与较低的元素 in c. Store 的结果加到 dst 的较低元素中 (当未使用掩码位 0 时该元素清零) set)，然后将上层元素从 a 复制到 dst 的上层元素。"],["_mm_maskz_fnmadd_round_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用零掩码 k 将求反的中间结果与较低元素 in c. Store 的结果相加到 dst 的较低元素中 (当未使用掩码位 0 时该元素清零) 设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。"],["_mm_maskz_fnmadd_sd","将 a 和 b 中的较低的双精度 (64-bit) 浮点元素相乘，然后使用零掩码 k 将求反的中间结果与较低的元素 in c. Store 的结果加到 dst 的较低元素中 (当未使用掩码位 0 时该元素清零) set)，然后将上层元素从 a 复制到 dst 的上层元素。"],["_mm_maskz_fnmadd_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后使用零掩码 k 将求反的中间结果与较低元素 in c. Store 的结果相加到 dst 的较低元素中 (当未使用掩码位 0 时该元素清零) 设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。"],["_mm_maskz_fnmsub_pd","将 a 和 b 中的包装双精度 (64-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_fnmsub_ps","将 a 和 b 中的包装单精度 (32-bit) 浮点元素相乘，从取反的中间结果中减去 c 中的包装元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_fnmsub_round_sd","将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用 zeromask k 将结果存储在 dst 中 (当未设置掩码位 0 时元素被清零)，并将上元素从 a 复制到 dst 的上元素。"],["_mm_maskz_fnmsub_round_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用 zeromask k 将结果存储在 dst 的下元素中 (当未设置掩码位 0 时，元素被清零)，并将上 3 个打包元素从 a 复制到 dst 的上元素。"],["_mm_maskz_fnmsub_sd","将 a 和 b 中的较低双精度 (64-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用 zeromask k 将结果存储在 dst 中 (当未设置掩码位 0 时元素被清零)，并将上元素从 a 复制到 dst 的上元素。"],["_mm_maskz_fnmsub_ss","将 a 和 b 中的较低单精度 (32-bit) 浮点元素相乘，然后从取反的中间结果中减去 c 中的较低元素。使用 zeromask k 将结果存储在 dst 的下元素中 (当未设置掩码位 0 时，元素被清零)，并将上 3 个打包元素从 a 复制到 dst 的上元素。"],["_mm_maskz_getexp_pd","将 a 中每个包装的双精度 (64-bit) 浮点元素的指数转换为代表整数指数的双精度 (64-bit) 浮点数，并使用 zeromask k 将结果存储在 dst 中 (当相应的 mask 位为零时，元素被清零未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。"],["_mm_maskz_getexp_ps","将 a 中每个包装的单精度 (32-bit) 浮点元素的指数转换为代表整数指数的单精度 (32-bit) 浮点数，并使用 zeromask k 将结果存储在 dst 中 (当相应的 mask 位为零时，元素被清零未设置)。本质上，此内联函数为每个元素计算 floor(log2(x))。"],["_mm_maskz_getexp_round_sd","将 b 中较低的双精度 (64-bit) 浮点元素的指数转换为表示整数指数的双精度 (64-bit) 浮点数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 未设置)，然后将较高的元素从 a 复制到 dst 的较高的元素。本质上，此内联函数计算下部元素的 floor(log2(x))。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_maskz_getexp_round_ss","将 b 中较低的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 未设置)，并将高 3 个包装的元素从 a 复制到 dst 的高元素。本质上，此内联函数计算下部元素的 floor(log2(x))。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_maskz_getexp_sd","将 b 中较低的双精度 (64-bit) 浮点元素的指数转换为表示整数指数的双精度 (64-bit) 浮点数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 未设置)，然后将较高的元素从 a 复制到 dst 的较高的元素。本质上，此内联函数计算下部元素的 floor(log2(x))。"],["_mm_maskz_getexp_ss","将 b 中较低的单精度 (32-bit) 浮点元素的指数转换为表示整数指数的单精度 (32-bit) 浮点数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码位 0 未设置)，并将高 3 个包装的元素从 a 复制到 dst 的高元素。本质上，此内联函数计算下部元素的 floor(log2(x))。"],["_mm_maskz_getmant_pd","将 a 中的包装的双精度 (64-bit) 浮点元素的尾数标准化，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1"],["_mm_maskz_getmant_ps","将 a 中的包装的单精度 (32-bit) 浮点元素的尾数规格化，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1"],["_mm_maskz_getmant_round_sd","标准化 b 中较低的双精度 (64-bit) 浮点元素的尾数，使用零掩码 k 将结果存储在 dst 的较低元素中 (未设置掩码位 0 时该元素归零)，然后从中复制较高元素。a 到 dst 的高位元素。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_maskz_getmant_round_ss","标准化 b 中较低单精度 (32-bit) 浮点元素的尾数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素清零)，然后复制高位 3 从 a 到 dst 的高位元素。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_maskz_getmant_sd","标准化 b 中较低的双精度 (64-bit) 浮点元素的尾数，使用零掩码 k 将结果存储在 dst 的较低元素中 (未设置掩码位 0 时该元素归零)，然后从中复制较高元素。a 到 dst 的高位元素。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_maskz_getmant_ss","标准化 b 中较低单精度 (32-bit) 浮点元素的尾数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素清零)，然后复制高位 3 从 a 到 dst 的高位元素。此内联函数本质上计算 ± (2 ^ k) * | x.significand |，其中 k 取决于由 interv 定义的间隔范围，而符号取决于 sc 和源符号。 尾数被标准化为由 interv 指定的间隔，该间隔可以采用以下值: _MM_MANT_NORM_1_2     // interval [1, 2) _MM_MANT_NORM_p5_2    // interval [0.5, 2) _MM_MANT_NORM_p5_1    // interval [0.5, 1) _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5) 该符号由 sc 确定，可以采用以下值: _MM_MANT_SIGN_src     // sign = sign(src) _MM_MANT_SIGN_zero    // sign = 0 _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_maskz_gf2p8affine_epi64_epi8","对 x 中的包装字节执行仿射变换。 也就是说，对于每个包装的字节，在 Galois 字段 2^8 上计算 a * x + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。"],["_mm_maskz_gf2p8affineinv_epi64_epi8","对 x 中的反向包装的字节执行仿射变换。 也就是说，对于每个包装的字节，在 Galois 字段 2 ^ 8 上计算 a * inv (x) + b，其中 a 是 8x8 位矩阵，b 是恒定 8 位 immediate 数。"],["_mm_maskz_gf2p8mul_epi8","在包装的字节上执行 GF(2^8) 乘法。 该字段以多项式表示，具有约数多项式 x^8 + x^4 + x^3 + x + 1。"],["_mm_maskz_lzcnt_epi32","计算 a 中每个包装的 32 位整数中前导零位的数目，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_lzcnt_epi64","计算 a 中每个包装的 64 位整数中前导零位的数目，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_madd_epi16","在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。水平添加相邻的中间 32 位整数对，并使用 zeromask k 将结果打包到 dst (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_maddubs_epi16","将 a 中的包装无符号 8 位整数与 b 中的包装有符号 8 位整数相乘，生成中间有符号的 16 位整数。水平添加相邻的中间有符号 16 位整数对，并使用 zeromask k 将饱和结果打包到 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_max_epi16","比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm_maskz_max_epi32","比较 a 和 b 中包装的带符号的 32 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm_maskz_max_epi64","比较 a 和 b 中包装的带符号的 64 位整数，并使用零掩码 k 将包装的最大值存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_max_epi8","比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm_maskz_max_epu16","比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm_maskz_max_epu32","比较 a 和 b 中包装的无符号 32 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm_maskz_max_epu64","比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm_maskz_max_epu8","比较 a 和 b 中包装的无符号 8 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm_maskz_max_pd","比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm_maskz_max_ps","比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最大值存储在 dst 中。"],["_mm_maskz_max_round_sd","比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用零掩码 k 将最大值存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后从中复制较高元素。a 到 dst 的高位元素。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_maskz_max_round_ss","比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用零掩码 k 将最大值存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后复制包装后的高 3 位从 a 到 dst 的高位元素。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_maskz_max_sd","比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用零掩码 k 将最大值存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后从中复制较高元素。a 到 dst 的高位元素。"],["_mm_maskz_max_ss","比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用零掩码 k 将最大值存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后复制包装后的高 3 位从 a 到 dst 的高位元素。"],["_mm_maskz_min_epi16","比较 a 和 b 中包装的带符号 16 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm_maskz_min_epi32","比较 a 和 b 中包装的带符号 32 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm_maskz_min_epi8","比较 a 和 b 中包装的带符号的 8 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm_maskz_min_epu16","比较 a 和 b 中包装的无符号 16 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm_maskz_min_epu32","比较 a 和 b 中包装的无符号 32 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm_maskz_min_epu64","比较 a 和 b 中包装的无符号 64 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm_maskz_min_epu8","比较 a 和 b 中包装的无符号 8 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm_maskz_min_pd","比较 a 和 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm_maskz_min_ps","比较 a 和 b 中的包装单精度 (32-bit) 浮点元素，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将包装的最小值存储在 dst 中。"],["_mm_maskz_min_round_sd","比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用零掩码 k 将最小值存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素清零)，然后从中复制较高元素。a 到 dst 的高位元素。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_maskz_min_round_ss","比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用零掩码 k 将最小值存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后复制包装后的高 3 位从 a 到 dst 的高位元素。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_maskz_min_sd","比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，使用零掩码 k 将最小值存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素清零)，然后从中复制较高元素。a 到 dst 的高位元素。"],["_mm_maskz_min_ss","比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，使用零掩码 k 将最小值存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后复制包装后的高 3 位从 a 到 dst 的高位元素。"],["_mm_maskz_mov_epi16","使用零掩码 k 将包装的 16 位整数从 a 移到 dst (当未设置相应的掩码位时，元素将清零)。"],["_mm_maskz_mov_epi32","使用零掩码 k 将包装的 32 位整数从 a 移至 dst (未设置相应的掩码位时将元素清零)。"],["_mm_maskz_mov_epi64","使用零掩码 k 将包装的 64 位整数从 a 移到 dst (未设置相应的掩码位时，元素将清零)。"],["_mm_maskz_mov_epi8","使用零掩码 k 将包装的 8 位整数从 a 移到 dst (当未设置相应的掩码位时，元素将清零)。"],["_mm_maskz_mov_pd","使用零掩码 k 将包装的双精度 (64-bit) 浮点元素从 a 移到 dst (未设置相应的掩码位时将元素清零)。"],["_mm_maskz_mov_ps","使用零掩码 k 将包装的单精度 (32-bit) 浮点元素从 a 移到 dst (未设置相应的掩码位时将元素清零)。"],["_mm_maskz_move_sd","使用零掩码 k 将较低的双精度 (64-bit) 浮点元素从 b 移动到 dst 的较低元素 (未设置掩码位 0 时将该元素清零)，然后将较高的元素从 a 复制到 dst 的较高元素。"],["_mm_maskz_move_ss","使用零掩码 k 将较低的单精度 (32-bit) 浮点元素从 b 移动到 dst 的较低元素 (未设置掩码位 0 时将该元素清零)，然后将较高的 3 个包装的元素从 a 复制到较高的元素 dst。"],["_mm_maskz_movedup_pd","从 a 复制偶数索引的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_movehdup_ps","从 a 复制奇数索引的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_moveldup_ps","从 a 复制偶数索引的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_mul_epi32","将 a 和 b 中每个包装的 64 位元素的低位有符号 32 位整数相乘，并使用零掩码 k 将有符号的 64 位结果存储在 dst 中 (未设置相应的掩码位时将元素清零)。"],["_mm_maskz_mul_epu32","将 a 和 b 中每个包装的 64 位元素的低无符号 32 位整数相乘，并使用零掩码 k 将无符号 64 位结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_mul_pd","将 a 和 b 中的包装的双精度 (64-bit) 浮点元素相乘，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_mul_ps","将 a 和 b 中的包装的单精度 (32-bit) 浮点元素相乘，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_mul_round_sd","将 a 和 b 中的低位双精度 (64-bit) 浮点元素相乘，使用零掩码 k 将结果存储在 dst 的低位元素中 (当未设置掩码位 0 时该元素归零)，然后从 a 中复制高位元素到 dst 的上层元素。"],["_mm_maskz_mul_round_ss","将 a 和 b 中的下部单精度 (32-bit) 浮点元素相乘，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，并复制上部 3 个包装的元素从 a 到 dst 的上层元素。"],["_mm_maskz_mul_sd","将 a 和 b 中的低位双精度 (64-bit) 浮点元素相乘，使用零掩码 k 将结果存储在 dst 的低位元素中 (当未设置掩码位 0 时该元素归零)，然后从 a 中复制高位元素到 dst 的上层元素。"],["_mm_maskz_mul_ss","将 a 和 b 中的下部单精度 (32-bit) 浮点元素相乘，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，并复制上部 3 个包装的元素从 a 到 dst 的上层元素。"],["_mm_maskz_mulhi_epi16","将 a 和 b 中包装的带符号的 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_mulhi_epu16","将 a 和 b 中包装的无符号 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的高 16 位存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_mulhrs_epi16","在 a 和 b 中乘以包装的带符号的 16 位整数，产生中间的带符号的 32 位整数。将每个中间整数截断为 18 个最高有效位，通过加 1 舍入，并使用 zeromask k 将位 [16:1] 存储到 dst (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_mullo_epi16","将 a 和 b 中的包装的 16 位整数相乘，生成中间的 32 位整数，并使用零掩码 k 将中间整数的低 16 位存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_mullo_epi32","将 a 和 b 中的包装的 32 位整数相乘，生成中间 64 位整数，并使用零掩码 k (在未设置相应的掩码位时将元素清零) 将中间整数的低 32 位存储在 dst 中。"],["_mm_maskz_multishift_epi64_epi8","对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并使用 zeromask k (元素当相应的屏蔽位未设置时被清零)。"],["_mm_maskz_or_epi32","计算 a 和 b 中包装的 32 位整数的按位或，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_or_epi64","计算 a 和 b 中包装的 64 位整数的按位或，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_packs_epi16","使用带符号的饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm_maskz_packs_epi32","使用带符号的饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm_maskz_packus_epi16","使用无符号饱和度将包装的带符号的 16 位整数从 a 和 b 转换为包装的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm_maskz_packus_epi32","使用无符号饱和度将包装的带符号的 32 位整数从 a 和 b 转换为包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_permute_pd","使用 imm8 中的控件在 128 位通道内对双精度 (64-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_permute_ps","使用 imm8 中的控件在 128 位通道内对单精度 (32-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_permutevar_pd","使用 b 中的控件在 128 位通道内将 a 中的双精度 (64-bit) 浮点元素进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_permutevar_ps","使用 b 中的控件在 128 位通道内将 a 的单精度 (32-bit) 浮点元素打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_permutex2var_epi16","使用相应的选择器和 idx 中的索引在通道中的 a 和 b 中对 16 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_permutex2var_epi32","使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中对 32 位整数进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_permutex2var_epi64","使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中对 64 位整数进行混洗，并使用 zeromask k (未设置相应的 mask 位时将元素清零) 将结果存储在 dst 中。"],["_mm_maskz_permutex2var_epi8","使用 idx 中的相应选择器和索引将 a 和 b 中的 8 位整数跨通道打乱，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_permutex2var_pd","使用对应的选择器和 idx 中的索引在通道中的通道 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_permutex2var_ps","使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对单精度 (32-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_permutexvar_epi16","使用 idx 中的相应索引在跨通道中对 16 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_permutexvar_epi8","使用 idx 中的相应索引在跨通道的 a 中打乱 8 位整数，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_popcnt_epi16","对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm_maskz_popcnt_epi32","对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm_maskz_popcnt_epi64","对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。"],["_mm_maskz_popcnt_epi8","对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm_maskz_rcp14_pd","计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。该近似值的最大相对误差小于 2^-14。"],["_mm_maskz_rcp14_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。该近似值的最大相对误差小于 2^-14。"],["_mm_maskz_rcp14_sd","计算 b 中较低的双精度 (64-bit) 浮点元素的近似倒数，使用零掩码 k 将结果存储在 dst 的较低元素中 (未设置掩码位 0 时该元素归零)，然后复制较高元素从 a 到 dst 的高位元素。该近似值的最大相对误差小于 2^-14。"],["_mm_maskz_rcp14_ss","计算 b 中较低的单精度 (32-bit) 浮点元素的近似倒数，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素归零)，并复制较高的 3 从 a 到 dst 的上层元素的包装的元素。该近似值的最大相对误差小于 2^-14。"],["_mm_maskz_rol_epi32","将每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm_maskz_rol_epi64","将每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm_maskz_rolv_epi32","将 a 中每个包装的 32 位整数中的位向左旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm_maskz_rolv_epi64","将 a 中每个包装的 64 位整数中的位向左旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm_maskz_ror_epi32","将 X 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_ror_epi64","将 X 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将清零)。"],["_mm_maskz_rorv_epi32","将 a 中每个包装的 32 位整数中的位向右旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm_maskz_rorv_epi64","将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零) )。"],["_mm_maskz_roundscale_pd","将 x 中的包装双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_maskz_roundscale_ps","将 a 中的包装单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_maskz_roundscale_round_sd","将 b 中的下部双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时该元素清零)，并将上一个元素从 a 复制到 dst 的上一个元素。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_maskz_roundscale_round_ss","将 b 中的下部单精度 (32-bit) 浮点元素四舍五入为 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时该元素清零)，并将上面的 3 个包装的元素从 a 复制到 dst 的上面的元素。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_maskz_roundscale_sd","将 b 中的下部双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时该元素清零)，并将上一个元素从 a 复制到 dst 的上一个元素。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_maskz_roundscale_ss","将 b 中的下部单精度 (32-bit) 浮点元素四舍五入为 imm8 指定的分数位数，并使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置掩码位 0 时该元素清零)，并将上面的 3 个包装的元素从 a 复制到 dst 的上面的元素。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_maskz_rsqrt14_pd","计算 a 中的包装的双精度 (64-bit) 浮点元素的近似倒数平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。该近似值的最大相对误差小于 2^-14。"],["_mm_maskz_rsqrt14_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。该近似值的最大相对误差小于 2^-14。"],["_mm_maskz_rsqrt14_sd","计算 b 中较低的双精度 (64-bit) 浮点元素的近似倒数平方根，使用零掩码 k 将结果存储在 dst 的较低元素中 (未设置掩码位 0 时该元素归零)，然后复制从 a 到 dst 的上元素的上元素。该近似值的最大相对误差小于 2^-14。"],["_mm_maskz_rsqrt14_ss","计算 b 中较低单精度 (32-bit) 浮点元素的近似倒数平方根，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置掩码位 0 时该元素归零)，然后复制从 a 到 dst 的上层元素的上 3 个包装的元素。该近似值的最大相对误差小于 2^-14。"],["_mm_maskz_scalef_pd","使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_scalef_ps","使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_scalef_round_sd","使用 b 中的值缩放 a 中的包装双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后复制上部元素从 a 到 dst 的高位元素。"],["_mm_maskz_scalef_round_ss","使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，并复制上部 3 从 a 到 dst 的上层元素的包装的元素。"],["_mm_maskz_scalef_sd","使用 b 中的值缩放 a 中的包装双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后复制上部元素从 a 到 dst 的高位元素。"],["_mm_maskz_scalef_ss","使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，并复制上部 3 从 a 到 dst 的上层元素的包装的元素。"],["_mm_maskz_set1_epi16","使用零掩码 k 将低包装的 16 位整数从 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm_maskz_set1_epi32","使用零掩码 k 将 32 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm_maskz_set1_epi64","使用零掩码 k 将 64 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm_maskz_set1_epi8","使用零掩码 k 将 8 位整数 a 广播到 dst 的所有元素 (未设置相应的掩码位时将元素清零)。"],["_mm_maskz_shldi_epi16","在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_shldi_epi32","将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_shldi_epi64","在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并使用 zeromask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_shldv_epi16","在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_shldv_epi32","将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_shldv_epi64","在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的相应元素中指定的数量，并使用 zeromask k 将高 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_shrdi_epi16","将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_shrdi_epi32","连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_shrdi_epi64","将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并使用 zeromask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_shrdv_epi16","将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 16 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_shrdv_epi32","连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 32 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_shrdv_epi64","将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的相应元素中指定的数量，并使用 zeromask k 将低 64 位存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_shuffle_epi32","使用 imm8 中的控件在 128 位通道中的 32 位整数中混洗 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_shuffle_epi8","根据 b 的相应 8 位元素中的打乱控制掩码对 a 中的包装 8 位整数进行打乱，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_shuffle_pd","使用 imm8 中的控件对 128 位通道内的双精度 (64-bit) 浮点元素进行混洗，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_shuffle_ps","使用 imm8 中的控件对 a 中的单精度 (32-bit) 浮点元素进行打乱，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素会被清零)。"],["_mm_maskz_shufflehi_epi16","使用 imm8 中的控件在 a 的 128 位通道的高 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的高 64 位中，将 128 位通道的低 64 位从 a 复制到 dst，使用 zeromask k (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_shufflelo_epi16","使用 imm8 中的控件在 a 的 128 位通道的低 64 位中对 16 位整数进行打乱。将结果存储在 dst 的 128 位通道的低 64 位中，并使用写掩码 k 将 128 位通道的高 64 位从 a 复制到 dst (当未使用相应的掩码位时，元素从 src 复制) 放)。"],["_mm_maskz_sll_epi16","将包装的 16 位整数按计数左移，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_sll_epi32","将包装的 32 位整数左移计数，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_sll_epi64","将填充的 64 位整数左移计数，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_slli_epi16","将包装的 16 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_slli_epi32","将包装的 32 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_slli_epi64","将包装的 64 位整数左移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_sllv_epi16","将包装的 16 位整数左移由 count 中的相应元素指定的数量，同时移入零，并使用 zeromask k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_sllv_epi32","在将移位的 32 位整数左移零时，将其对应计数指定的数量左移，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_sllv_epi64","在将移位的 64 位整数左移零时，将其对应计数指定的数量左移，然后使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_sqrt_pd","计算 a 中包装的双精度 (64-bit) 浮点元素的平方根，并使用零掩码 k (将结果置零，当未设置相应的掩码位时将元素清零) 将结果存储在 dst 中。"],["_mm_maskz_sqrt_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的平方根，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_sqrt_round_sd","计算 b 中下部双精度 (64-bit) 浮点元素的平方根，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后复制上部元素从 a 到 dst 的高位元素。"],["_mm_maskz_sqrt_round_ss","计算 b 中较低的单精度 (32-bit) 浮点元素的平方根，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后复制高 3 从 a 到 dst 的上层元素的包装的元素。"],["_mm_maskz_sqrt_sd","计算 b 中下部双精度 (64-bit) 浮点元素的平方根，使用零掩码 k 将结果存储在 dst 的下部元素中 (当未设置 mask bit 0 时该元素清零)，然后复制上部元素从 a 到 dst 的高位元素。"],["_mm_maskz_sqrt_ss","计算 b 中较低的单精度 (32-bit) 浮点元素的平方根，使用零掩码 k 将结果存储在 dst 的较低元素中 (当未设置 mask bit 0 时该元素清零)，然后复制高 3 从 a 到 dst 的上层元素的包装的元素。"],["_mm_maskz_sra_epi16","将包装的 16 位整数按计数右移，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_sra_epi32","在移动符号位的同时右移计数包装的 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_sra_epi64","在移动符号位的同时右移计数包装的 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_srai_epi16","将包装的 16 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_srai_epi32","将包装的 32 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_srai_epi64","将包装的 64 位整数右移 imm8，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_srav_epi16","将包装的 16 位整数右移由 count 中的相应元素指定的数量，同时将符号位移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_srav_epi32","在将符号位移位的同时，将已包装的 32 位整数向右移动计数中相应元素指定的数量，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_srav_epi64","在移入符号位的同时，将包装的 64 位整数右移由 count 中相应元素指定的数量，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_srl_epi16","将包装的 16 位整数右移，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_srl_epi32","将移位的 32 位整数右移，同时移零，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_srl_epi64","将包装的 64 位整数右移计数，同时移入零，并使用 zeromask k 将结果存储在 dst 中 (当相应的掩码位未设置时，元素被清零)。"],["_mm_maskz_srli_epi16","将包装的 16 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_srli_epi32","将包装的 32 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_srli_epi64","将包装的 64 位整数右移 imm8，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_srlv_epi16","将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_srlv_epi32","向右移动已包装的 32 位整数，偏移量为相应元素在计数中指定的数量，同时向零移位，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_srlv_epi64","向右移位包装的 64 位整数，其数量为计数中相应元素指定的数量，同时移位为零，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_sub_epi16","从 a 中的包装的 16 位整数中减去 b 中的包装的 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_sub_epi32","从 a 中的包装 32 位整数中减去 b 中的包装 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_sub_epi64","从 a 中的包装 64 位整数中减去 b 中的包装 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_sub_epi8","从 a 中的包装 8 位整数中减去 b 中的包装 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_sub_pd","从 a 中的包装的双精度 (64-bit) 浮点元素中减去 b 中的包装的双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_sub_ps","将 b 中的包装后的单精度 (32-bit) 浮点元素减去 a 中的包装后的单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_sub_round_sd","从 a 中的较低双精度 (64-bit) 浮点元素中减去 b 中的较低双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码 bit 0 为 0 时，该元素将被清零。(未设置)，然后将上层元素从 a 复制到 dst 的上层元素。"],["_mm_maskz_sub_round_ss","从 a 中的较低单精度 (32-bit) 浮点元素中减去 b 中的较低单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码 bit 0 为 0 时，该元素将被清零。(未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。"],["_mm_maskz_sub_sd","从 a 中的较低双精度 (64-bit) 浮点元素中减去 b 中的较低双精度 (64-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码 bit 0 为 0 时，该元素将被清零。(未设置)，然后将上层元素从 a 复制到 dst 的上层元素。"],["_mm_maskz_sub_ss","从 a 中的较低单精度 (32-bit) 浮点元素中减去 b 中的较低单精度 (32-bit) 浮点元素，使用零掩码 k 将结果存储在 dst 的较低元素中 (当掩码 bit 0 为 0 时，该元素将被清零。(未设置)，然后将前 3 个包装的元素从 a 复制到 dst 的高元素。"],["_mm_maskz_subs_epi16","使用饱和度将 b 中的包装 16 位整数减去 b 中的包装有符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_subs_epi8","使用饱和度从包装的 8 位整数中减去 b 中的包装有符号的 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_subs_epu16","使用 a 饱和度将 b 中的包装无符号 16 位整数减去 b 中的包装无符号 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_subs_epu8","使用 a 饱和度从 b 中的包装无符号 8 位整数减去 b 中的包装无符号 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_ternarylogic_epi32","提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 32 位整数中的每一位，来自 a、b 和 c 的相应位用于形成 imm8 的 3 位索引，并使用零掩码将 imm8 中该位的值写入 dst 中的相应位 k 在 32 位粒度 (当未设置相应的掩码位时，32 位元素被清零)。"],["_mm_maskz_ternarylogic_epi64","提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 64 位整数中的每一位，来自 a、b 和 c 的相应位用于在 imm8 中形成 3 位索引，并使用零掩码将 imm8 中该位的值写入 dst 中的相应位 k 在 64 位粒度 (当未设置相应的掩码位时，64 位元素将被清零)。"],["_mm_maskz_unpackhi_epi16","从 a 和 b 中每个 128 位通道的高半部分拆包和交织 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_unpackhi_epi32","从 a 和 b 中每个 128 位通道的高半部分解包和交织 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_unpackhi_epi64","从 a 和 b 中每个 128 位通道的高半部分解包和交织 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_unpackhi_epi8","从 a 和 b 中每个 128 位通道的高半部分拆包和交织 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_unpackhi_pd","从 a 和 b 中每个 128 位通道的高半部分解包和交织双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_unpackhi_ps","从 a 和 b 中每个 128 位通道的高半部分解包和交织单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_unpacklo_epi16","从 a 和 b 中每个 128 位通道的下半部分拆包和交织 16 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_unpacklo_epi32","从 a 和 b 中每个 128 位通道的下半部分解包和交织 32 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_unpacklo_epi64","从 a 和 b 中每个 128 位通道的下半部分解包和交织 64 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_unpacklo_epi8","从 a 和 b 中每个 128 位通道的下半部分拆包和交织 8 位整数，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时元素清零)。"],["_mm_maskz_unpacklo_pd","从 a 和 b 中每个 128 位通道的下半部分解包和交织双精度 (64-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_unpacklo_ps","从 a 和 b 中每个 128 位通道的下半部分解包和交织单精度 (32-bit) 浮点元素，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素清零)。"],["_mm_maskz_xor_epi32","计算 a 和 b 中包装的 32 位整数的按位 XOR，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_maskz_xor_epi64","计算 a 和 b 中包装的 64 位整数的按位 XOR，并使用零掩码 k 将结果存储在 dst 中 (当未设置相应的掩码位时，元素将被清零)。"],["_mm_max_epi16","比较 `a` 和 `b` 中的包装的 16 位整数，并返回包装的最大值。"],["_mm_max_epi32","比较 `a` 和 `b` 中的包装的 32 位整数，并返回包装的最大值。"],["_mm_max_epi64","比较 a 和 b 中包装的带符号的 64 位整数，并将包装的最大值存储在 dst 中。"],["_mm_max_epi8","比较 `a` 和 `b` 中的包装的 8 位整数，并以 dst 返回包装的最大值。"],["_mm_max_epu16","比较 `a` 和 `b` 中包装的无符号 16 位整数，并返回包装的最大值。"],["_mm_max_epu32","比较 `a` 和 `b` 中的包装无符号 32 位整数，并返回包装最大值。"],["_mm_max_epu64","比较 a 和 b 中包装的无符号 64 位整数，并将包装的最大值存储在 dst 中。"],["_mm_max_epu8","比较 `a` 和 `b` 中包装的无符号 8 位整数，并返回包装的最大值。"],["_mm_max_pd","返回一个新的 vector，它具有 `a` 和 `b` 中相应元素的最大值。"],["_mm_max_ps","比较 `a` 和 `b` 中包装的单精度 (32-bit) 浮点元素，并返回相应的最大值。"],["_mm_max_round_sd","比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，将最大值存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_max_round_ss","比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，将最大值存储在 dst 的较低元素中，并将较高的 3 个包装的元素从 a 复制到 dst 的较高元素。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_max_sd","返回一个新的 vector，其中 `a` 的低位元素被 `a` 和 `b` 的低位元素最大值取代。"],["_mm_max_ss","比较 `a` 和 `b` 的第一个单精度 (32-bit) 浮点元素，并在返回值的第一个元素中返回最大值，从 `a` 复制其他元素。"],["_mm_mfence","对在此指令之前发布的所有从内存加载和存储到内存指令执行序列化操作。"],["_mm_min_epi16","比较 `a` 和 `b` 中包装的 16 位整数，并返回包装的最小值。"],["_mm_min_epi32","比较 `a` 和 `b` 中的包装的 32 位整数，并返回包装的最小值。"],["_mm_min_epi8","比较 `a` 和 `b` 中的包装的 8 位整数，并以 dst 返回包装的最小值。"],["_mm_min_epu16","比较 `a` 和 `b` 中的包装的无符号 16 位整数，并返回包装的最小值。"],["_mm_min_epu32","比较 `a` 和 `b` 中的包装的无符号 32 位整数，并返回包装的最小值。"],["_mm_min_epu64","比较 a 和 b 中包装的无符号 64 位整数，并将包装的最小值存储在 dst 中。"],["_mm_min_epu8","比较 `a` 和 `b` 中包装的无符号 8 位整数，并返回包装的最小值。"],["_mm_min_pd","返回一个新的 vector，它具有 `a` 和 `b` 中相应元素的最小值。"],["_mm_min_ps","比较 `a` 和 `b` 中包装的单精度 (32-bit) 浮点元素，并返回相应的最小值。"],["_mm_min_round_sd","比较 a 和 b 中较低的双精度 (64-bit) 浮点元素，将最小值存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_min_round_ss","比较 a 和 b 中较低的单精度 (32-bit) 浮点元素，将最小值存储在 dst 的较低元素中，并将较高的 3 个包装的元素从 a 复制到 dst 的较高元素。 可以通过在 sae 参数中传递 _MM_FROUND_NO_EXC 来抑制异常。"],["_mm_min_sd","返回一个新的 vector，其中 `a` 的低位元素被 `a` 和 `b` 的低位元素的最小值替换。"],["_mm_min_ss","比较 `a` 和 `b` 的第一个单精度 (32-bit) 浮点元素，并在返回值的第一个元素中返回最小值，从 `a` 复制其他元素。"],["_mm_minpos_epu16","在 128 位 __m128i vector 中查找最小的无符号 16 位元素，并返回一个 vector，其中在第一个位置包含其值，在第二个位置包含其索引; 所有其他元素都设置为零。"],["_mm_move_epi64","返回 vector，其中从 `a` 提取低位元素，其高位元素为零。"],["_mm_move_sd","构造 `[2 x double]` 的 128 位浮点 vector。下层 将 64 位设置为第二个参数的低 64 位。上层 将 64 位设置为第一个参数的高 64 位。"],["_mm_move_ss","返回 `__m128`，其中第一个组件来自 `b`，其余组件来自 `a`。"],["_mm_movedup_pd","从 `a` 复制低双精度 (64-bit) 浮点元素。"],["_mm_movehdup_ps","`a` 中重复的奇数索引单精度 (32-bit) 浮点元素。"],["_mm_movehl_ps","合并 `a` 和 `b` 的上半部分。`b` 的上半部分占据结果的下半部分。"],["_mm_moveldup_ps","`a` 中重复的偶数索引单精度 (32-bit) 浮点元素。"],["_mm_movelh_ps","合并 `a` 和 `b` 的下半部分。`b` 的下半部分占据结果的上半部分。"],["_mm_movemask_epi8","返回 `a` 中每个元素的最高有效位的掩码。"],["_mm_movemask_pd","返回 `a` 中每个元素的最高有效位的掩码。"],["_mm_movemask_ps","返回 `a` 中每个元素的最高有效位的掩码。"],["_mm_movepi16_mask","根据 a 中相应的包装的 16 位整数的最高有效位设置掩码寄存器 k 的每一位。"],["_mm_movepi8_mask","根据 a 中相应包装的 8 位整数的最高有效位设置掩码寄存器 k 的每个位。"],["_mm_movm_epi16","根据 k 中相应位的值，将 dst 中每个包装的 16 位整数设置为全 1 或全 0。"],["_mm_movm_epi8","根据 k 中相应位的值，将 dst 中每个包装的 8 位整数设置为全 1 或全 0。"],["_mm_mpsadbw_epu8","减去 8 位无符号整数值，然后将差的绝对值计算为目标中的相应位。"],["_mm_mul_epi32","将 `a` 和 `b` 中每个包装的 64 位元素的低 32 位整数相乘，并返回带符号的 64 位结果。"],["_mm_mul_epu32","将 `a` 和 `b` 中每个包装的 64 位元素中的低 32 位无符号整数相乘。"],["_mm_mul_pd","将 `a` 和 `b` 中的包装的双精度 (64-bit) 浮点元素相乘。"],["_mm_mul_ps","乘以 __m128 vectors。"],["_mm_mul_round_sd","将 a 和 b 中的下部双精度 (64-bit) 浮点元素相乘，将结果存储在 dst 的下部元素中，然后将 a 的上部元素复制到 dst 的上部元素。"],["_mm_mul_round_ss","将 a 和 b 中的下部单精度 (32-bit) 浮点元素相乘，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到 dst 的上部元素。"],["_mm_mul_sd","返回一个新的 vector，其中 `a` 的低位元素被 `a` 和 `b` 的低位元素相乘。"],["_mm_mul_ss","将 `a` 和 `b` 的第一个组件相乘，然后从 `a` 复制其他组件。"],["_mm_mulhi_epi16","将 `a` 和 `b` 中的包装的 16 位整数相乘。"],["_mm_mulhi_epu16","将 `a` 和 `b` 中包装的无符号 16 位整数相乘。"],["_mm_mulhrs_epi16","将包装的 16 位带符号整数值相乘，通过右移将 32 位乘积截断为 18 个最高有效位，通过加 1 舍入舍入后的值，并将 `[16:1]` 位写入目标位置。"],["_mm_mullo_epi16","将 `a` 和 `b` 中的包装的 16 位整数相乘。"],["_mm_mullo_epi32","将 `a` 和 `b` 中包装的 32 位整数相乘，产生中间值 64 位整数，并返回最低的 32 位 (无论它们是什么)，都将重新解释为有符号整数。 虽然 `pmulld __m128i::splat(2), __m128i::splat(2)` 返回明显的 `__m128i::splat(4)`，但由于包装算术，`pmulld __m128i::splat(i32::MAX), __m128i::splat(2)` 将返回负数。"],["_mm_multishift_epi64_epi8","对于 b 中的每个 64 位元素，使用 a 的相应 64 位元素内的字节粒度移位控制选择 8 个未对齐的字节，并将 8 个组装字节存储到 dst 的相应 64 位元素。"],["_mm_or_epi32","计算 a 和 b 中包装的 32 位整数的按位或，并将结果存储在 dst 中。"],["_mm_or_epi64","计算 a 和 b 中包装的 64 位整数的按位或，并将结果存储在 dst 中。"],["_mm_or_pd","计算 `a` 和 `b` 的按位或。"],["_mm_or_ps","包装的单精度 (32-bit) 浮点元素的按位或。"],["_mm_or_si128","计算 `a` 和 `b` 中 128 位 (表示整数数据) 的按位或。"],["_mm_packs_epi16","使用带符号的饱和度将包装的 16 位整数从 `a` 和 `b` 转换为包装的 8 位整数。"],["_mm_packs_epi32","使用带符号的饱和度将包装的 32 位整数从 `a` 和 `b` 转换为包装的 16 位整数。"],["_mm_packus_epi16","使用无符号饱和度将 `a` 和 `b` 的包装的 16 位整数转换为包装的 8 位整数。"],["_mm_packus_epi32","使用无符号饱和度将包装的 32 位整数从 `a` 和 `b` 转换为包装的 16 位整数"],["_mm_pause","向处理器提示代码序列是自旋等待循环。"],["_mm_permute_pd","使用 `imm8` 中的控件对 `a` 中的双精度 (64-bit) 浮点元素进行混洗。"],["_mm_permute_ps","使用 `imm8` 中的控件对 `a` 中的单精度 (32-bit) 浮点元素进行混洗。"],["_mm_permutevar_pd","使用 `b` 中的控件对 `a` 中的双精度 (64-bit) 浮点元素进行混洗。"],["_mm_permutevar_ps","使用 `b` 中的控件对 `a` 中的单精度 (32-bit) 浮点元素进行混洗。"],["_mm_permutex2var_epi16","使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中对 16 位整数进行打乱，并将结果存储在 dst 中。"],["_mm_permutex2var_epi32","使用对应的选择器和 idx 中的索引在通道中的 a 和 b 中随机排列 32 位整数，并将结果存储在 dst 中。"],["_mm_permutex2var_epi64","使用 idx 中的相应选择器和索引在通道中的 a 和 b 中随机排列 64 位整数，并将结果存储在 dst 中。"],["_mm_permutex2var_epi8","使用 idx 中的相应选择器和索引将 a 和 b 中的 8 位整数跨通道打乱，并将结果存储在 dst 中。"],["_mm_permutex2var_pd","使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对双精度 (64-bit) 浮点元素进行混洗，并将结果存储在 dst 中。"],["_mm_permutex2var_ps","使用 idx 中的相应选择器和索引在通道中的 a 和 b 中对单精度 (32-bit) 浮点元素进行混洗，并将结果存储在 dst 中。"],["_mm_permutexvar_epi16","使用 idx 中的相应索引在跨通道中对 16 位整数进行打乱，并将结果存储在 dst 中。"],["_mm_permutexvar_epi8","使用 idx 中的相应索引将 a 中的 8 位整数打乱到通道中，并将结果存储在 dst 中。"],["_mm_popcnt_epi16","对于每个包装的 16 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm_popcnt_epi32","对于每个包装的 32 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm_popcnt_epi64","对于每个包装的 64 位整数 maps，该值均等于逻辑 1 位的数量。"],["_mm_popcnt_epi8","对于每个包装的 8 位整数 maps，该值等于逻辑 1 位的数量。"],["_mm_prefetch","使用给定的 `STRATEGY` 获取包含地址 `p` 的缓存行。"],["_mm_rcp14_pd","计算 a 中包装的双精度 (64-bit) 浮点元素的近似倒数，并将结果存储在 dst 中。该近似值的最大相对误差小于 2^-14。"],["_mm_rcp14_ps","计算 a 中包装的单精度 (32-bit) 浮点元素的近似倒数，并将结果存储在 dst 中。该近似值的最大相对误差小于 2^-14。"],["_mm_rcp14_sd","计算 b 中较低的双精度 (64-bit) 浮点元素的近似倒数，将结果存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。该近似值的最大相对误差小于 2^-14。"],["_mm_rcp14_ss","计算 b 中较低的单精度 (32-bit) 浮点元素的近似倒数，将结果存储在 dst 的较低元素中，并将高 3 个包装的元素从 a 复制到 dst 的较高元素。该近似值的最大相对误差小于 2^-14。"],["_mm_rcp_ps","返回 `a` 中包装的单精度 (32-bit) 浮点元素的近似倒数。"],["_mm_rcp_ss","返回 `a` 中第一个单精度 (32-bit) 浮点元素的近似倒数，其他元素不变。"],["_mm_rol_epi32","将 X 中每个包装的 32 位整数中的位向左旋转 imm8 中指定的位数，然后将结果存储在 dst 中。"],["_mm_rol_epi64","将 X 中每个包装的 64 位整数中的位向左旋转 imm8 中指定的位数，然后将结果存储在 dst 中。"],["_mm_rolv_epi32","将 a 中每个包装的 32 位整数中的位向左旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。"],["_mm_rolv_epi64","将 a 中每个包装的 64 位整数中的位向左旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。"],["_mm_ror_epi32","将 X 中每个包装的 32 位整数中的位向右旋转 imm8 中指定的位数，并将结果存储在 dst 中。"],["_mm_ror_epi64","将 X 中每个包装的 64 位整数中的位向右旋转 imm8 中指定的位数，然后将结果存储在 dst 中。"],["_mm_rorv_epi32","将 a 中每个包装的 32 位整数中的位向右旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。"],["_mm_rorv_epi64","将 a 中每个包装的 64 位整数中的位向右旋转 b 的相应元素中指定的位数，然后将结果存储在 dst 中。"],["_mm_round_pd","使用 `ROUNDING` 参数将 `a` 中的包装的双精度 (64-bit) 浮点元素舍入，并将结果存储为包装的双精度浮点元素。"],["_mm_round_ps","使用 `ROUNDING` 参数将 `a` 中的包装的单精度 (32-bit) 浮点元素舍入，并将结果存储为包装的单精度浮点元素。"],["_mm_round_sd","使用 `ROUNDING` 参数将 `b` 中的低位双精度浮点元素 (64-bit) 舍入，将结果作为双精度浮点元素存储在内部结果的低位元素中，并将高位元素从 `a` 复制到高位元素的内在结果。"],["_mm_round_ss","使用 `ROUNDING` 参数将 `b` 中的低位单精度 (32-bit) 浮点元素四舍五入，将结果作为单精度浮点元素存储在内部结果的低位元素中，并将高 3 个包装的元素从 `a` 复制到内在结果的上层元素。"],["_mm_roundscale_pd","将 x 中的包装的双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，并将结果存储在 dst 中。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_roundscale_ps","将 a 中的包装的单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的小数位数，然后将结果存储在 dst 中。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_roundscale_round_sd","将 b 中的下部双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，将结果存储在 dst 的下部元素中，并将上部的元素从 a 复制到 dst 的上部元素。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_roundscale_round_ss","将 b 中的下部单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到 dst 的上部元素。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_roundscale_sd","将 b 中的下部双精度 (64-bit) 浮点元素四舍五入到 imm8 指定的分数位数，将结果存储在 dst 的下部元素中，并将上部的元素从 a 复制到 dst 的上部元素。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_roundscale_ss","将 b 中的下部单精度 (32-bit) 浮点元素四舍五入到 imm8 指定的分数位数，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到 dst 的上部元素。 根据 imm8[2: 0] 参数进行舍入，该参数可以是以下之一: _MM_FROUND_TO_NEAREST_INT // 舍入到最接近的值 _MM_FROUND_TO_NEG_INF     // 向下取整 _MM_FROUND_TO_POS_INF     // 向上舍入 _MM_FROUND_TO_ZERO        // 截断 _MM_FROUND_CUR_DIRECTION  // 使用 MXCSR.RC; 请参见 _MM_SET_ROUNDING_MODE"],["_mm_rsqrt14_sd","计算 b 中较低的双精度 (64-bit) 浮点元素的近似倒数平方根，将结果存储在 dst 的较低元素中，并将较高的元素从 a 复制到 dst 的较高元素。该近似值的最大相对误差小于 2^-14。"],["_mm_rsqrt14_ss","计算 b 中较低单精度 (32-bit) 浮点元素的近似倒数平方根，将结果存储在 dst 的较低元素中，并将高 3 个包装的元素从 a 复制到 dst 的较高元素。该近似值的最大相对误差小于 2^-14。"],["_mm_rsqrt_ps","返回 `a` 中包装的单精度 (32-bit) 浮点元素的近似倒数平方根。"],["_mm_rsqrt_ss","返回 `a` 中第一个单精度 (32-bit) 浮点元素的近似倒数平方根，其他元素不变。"],["_mm_sad_epu8","包装无符号 8 位整数的绝对差之和。"],["_mm_scalef_pd","使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm_scalef_ps","使用 b 中的值缩放 a 中包装的单精度 (32-bit) 浮点元素，并将结果存储在 dst 中。"],["_mm_scalef_round_sd","使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，将结果存储在 dst 的下部元素中，然后将 a 的上部元素复制到 dst 的上部元素。"],["_mm_scalef_round_ss","使用 b 中的值缩放 a 中的包装的单精度 (32-bit) 浮点元素，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到 dst 的上部元素。"],["_mm_scalef_sd","使用 b 中的值缩放 a 中包装的双精度 (64-bit) 浮点元素，将结果存储在 dst 的下部元素中，然后将 a 的上部元素复制到 dst 的上部元素。"],["_mm_scalef_ss","使用 b 中的值缩放 a 中的包装的单精度 (32-bit) 浮点元素，将结果存储在 dst 的下部元素中，并将上部的 3 个包装的元素从 a 复制到 dst 的上部元素。"],["_mm_set1_epi16","向所有元素广播 16 位整数 `a`。"],["_mm_set1_epi32","向所有元素广播 32 位整数 `a`。"],["_mm_set1_epi64x","向所有元素广播 64 位整数 `a`。"],["_mm_set1_epi8","向所有元素广播 8 位整数 `a`。"],["_mm_set1_pd","向返回值的所有元素广播双精度 (64-bit) 浮点值 a。"],["_mm_set1_ps","创建一个 `__m128`，并将所有元素设置为 `a`。"],["_mm_set_epi16","使用提供的值设置包装的 16 位整数。"],["_mm_set_epi32","使用提供的值设置包装的 32 位整数。"],["_mm_set_epi64x","使用提供的值 (从最高到最低) 设置包装的 64 位整数。"],["_mm_set_epi8","使用提供的值设置包装的 8 位整数。"],["_mm_set_pd","使用提供的值在返回值中设置包装的双精度 (64-bit) 浮点元素。"],["_mm_set_pd1","向返回值的所有元素广播双精度 (64-bit) 浮点值 a。"],["_mm_set_ps","从最高到最低的四个浮点值构造 `__m128`。"],["_mm_set_ps1","`_mm_set1_ps` 的别名"],["_mm_set_sd","将双精度 (64-bit) 浮点元素 `a` 复制到包装的 64 位返回值的低位元素。"],["_mm_set_ss","创建一个 `__m128`，将最低元素设置为 `a`，将剩余部分设置为零。"],["_mm_setcsr","用 32 位无符号整数值设置 MXCSR 寄存器。"],["_mm_setr_epi16","以相反的顺序设置提供的值的包装 16 位整数。"],["_mm_setr_epi32","以相反的顺序设置提供的值的包装 32 位整数。"],["_mm_setr_epi8","以相反的顺序设置提供的值的包装 8 位整数。"],["_mm_setr_pd","在返回值中设置包装的双精度 (64-bit) 浮点元素，并以相反的顺序提供提供的值。"],["_mm_setr_ps","从四个最低到最高的浮点值构造 `__m128`。"],["_mm_setzero_pd","返回全零的包装的双精度 (64-bit) 浮点元素。"],["_mm_setzero_ps","创建一个 `__m128`，并将所有元素初始化为零。"],["_mm_setzero_si128","返回所有元素均设置为零的 vector。"],["_mm_sfence","对在此指令之前发出的所有存储到内存指令执行序列化操作。"],["_mm_sha1msg1_epu32","使用来自 `a` 和 `b` 的先前消息值，对接下来的四个 SHA1 消息值 (无符号的 32 位整数) 执行中间计算，并返回结果。"],["_mm_sha1msg2_epu32","使用 `a` 中的中间结果和 `b` 中的先前消息值，对接下来的四个 SHA1 消息值 (无符号的 32 位整数) 执行最终计算，并返回结果。"],["_mm_sha1nexte_epu32","经过四轮运算后，从当前 SHA1 状态变量 `a` 计算 SHA1 状态变量 E，将该值添加到 `b` 中的计划值 (无符号 32 位整数)，然后返回结果。"],["_mm_sha1rnds4_epu32","使用来自 `a` 的初始 SHA1 状态 (A,B,C,D) 以及接下来的 4 个回合消息值 (一些无符号的 32 位整数) 和来自 `b` 的状态变量 E 的一些预先计算的总和，执行四轮 SHA1 操作，并返回更新的 SHA1 状态 (A,B,C,D)。 `FUNC` 包含逻辑函数和舍入常量。"],["_mm_sha256msg1_epu32","使用来自 `a` 和 `b` 的先前消息值，对接下来的四个 SHA256 消息值 (无符号的 32 位整数) 执行中间计算，并返回结果。"],["_mm_sha256msg2_epu32","使用以前的 `a` 和 `b` 的消息值，对接下来的四个 SHA256 消息值 (无符号的 32 位整数) 执行最终计算，并返回结果。"],["_mm_sha256rnds2_epu32","使用来自 `a` 的初始 SHA256 状态 (C,D,G,H)，来自 `b` 的初始 SHA256 状态 (A,B,E,F) 以及接下来的 2 个回合消息值 (无符号的 32 位整数) 和来自 `k` 的相应回合常量的预先计算的总和，执行 2 轮 SHA256 操作。，并将更新的 SHA256 状态 (A,B,E,F) 存储在 dst 中。"],["_mm_shldi_epi16","在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 imm8 位，并将高 16 位存储在 dst 中)。"],["_mm_shldi_epi32","将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 imm8 位，并将高 32 位存储在 dst 中。"],["_mm_shldi_epi64","在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 imm8 位，并将高 64 位存储在 dst 中)。"],["_mm_shldv_epi16","在 a 和 b 中连接包装的 16 位整数，产生一个中间 32 位结果。将结果左移 c 的对应元素中指定的量，并将高 16 位存储在 dst 中。"],["_mm_shldv_epi32","将 a 和 b 中的 32 位整数连接包装产生中间 64 位结果。将结果左移 c 的对应元素中指定的量，并将高 32 位存储在 dst 中。"],["_mm_shldv_epi64","在 a 和 b 中连接包装的 64 位整数，产生一个中间的 128 位结果。将结果左移 c 的对应元素中指定的量，并将高 64 位存储在 dst 中。"],["_mm_shrdi_epi16","将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 imm8 位，并将低 16 位存储在 dst 中。"],["_mm_shrdi_epi32","连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 imm8 位，并将低 32 位存储在 dst 中。"],["_mm_shrdi_epi64","将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 imm8 位，并将低 64 位存储在 dst 中。"],["_mm_shrdv_epi16","将 b 和 a 中的包装的 16 位整数连接起来，产生一个中间 32 位结果。将结果右移 c 的对应元素中指定的量，并将低 16 位存储在 dst 中。"],["_mm_shrdv_epi32","连接包装在 b 和 a 中的 32 位整数，产生中间 64 位结果。将结果右移 c 的对应元素中指定的量，并将低 32 位存储在 dst 中。"],["_mm_shrdv_epi64","将 b 和 a 中的包装的 64 位整数连接起来，产生一个中间的 128 位结果。将结果右移 c 的对应元素中指定的量，并将低 64 位存储在 dst 中。"],["_mm_shuffle_epi32","使用 `IMM8` 中的控件在 `a` 中打乱 32 位整数。"],["_mm_shuffle_epi8","根据 `b` 的内容，打乱 `a` 中的字节。"],["_mm_shuffle_pd","从两个创建一个 `[2 x double]` 的 128 位浮点 vector `[2 x double]` 的 128 位 vector 参数，使用立即值参数作为说明符。"],["_mm_shuffle_ps","使用 `MASK` 在 `a` 和 `b` 中打乱包装的单精度 (32-bit) 浮点元素。"],["_mm_shufflehi_epi16","使用 `IMM8` 中的控件在 `a` 的高 64 位中打乱 16 位整数。"],["_mm_shufflelo_epi16","使用 `IMM8` 中的控件在 `a` 的低 64 位中打乱 16 位整数。"],["_mm_sign_epi16","当 `b` 中相应的带符号 16 位整数为负时，将 `a` 中的 16 位整数包装为无效，并返回结果。"],["_mm_sign_epi32","当 `b` 中相应的带符号 32 位整数为负时，对 `a` 中的包装 32 位整数求反，并返回结果。"],["_mm_sign_epi8","当 `b` 中相应的带符号 8 位整数为负时，对 `a` 中的 8 位包装整数取反，并返回结果。"],["_mm_sll_epi16","将 `count` 左移的 `a` 中的包装的 16 位整数移位，同时将零移位。"],["_mm_sll_epi32","将 `count` 左移的 `a` 中的包装的 32 位整数移位，同时将零移位。"],["_mm_sll_epi64","将 `count` 左移的 `a` 中的包装的 64 位整数移位，同时将零移位。"],["_mm_slli_epi16","将 `a` 中包装的 16 位整数左移 `IMM8`，同时将其移入零。"],["_mm_slli_epi32","将 `a` 中包装的 32 位整数左移 `IMM8`，同时将其移入零。"],["_mm_slli_epi64","将 `a` 中包装的 64 位整数左移 `IMM8`，同时将其移入零。"],["_mm_slli_si128","将 `a` 左移 `IMM8` 个字节，同时移入零。"],["_mm_sllv_epi16","将包装的 16 位整数按 count 中相应元素指定的数量向左移位，同时将零移位，并将结果存储在 dst 中。"],["_mm_sllv_epi32","将 `a` 中的包装的 32 位整数左移 `count` 中相应元素所指定的数量，同时将零移位，并返回结果。"],["_mm_sllv_epi64","将 `a` 中的包装的 64 位整数左移 `count` 中相应元素所指定的数量，同时将零移位，并返回结果。"],["_mm_sqrt_pd","返回一个新的 vector，它具有 `a` 中每个值的平方根。"],["_mm_sqrt_ps","返回 `a` 中包装的单精度 (32-bit) 浮点元素的平方根。"],["_mm_sqrt_round_sd","计算 b 中较低的双精度 (64-bit) 浮点元素的平方根，将结果存储在 dst 的较低元素中，然后将较高的元素从 a 复制到 dst 的较高元素。"],["_mm_sqrt_round_ss","计算 b 中较低的单精度 (32-bit) 浮点元素的平方根，将结果存储在 dst 的较低元素中，并将高 3 个包装的元素从 a 复制到 dst 的较高元素。"],["_mm_sqrt_sd","返回一个新的 vector，其中 `a` 的低端元素替换为下部元素 `b` 的平方根。"],["_mm_sqrt_ss","返回 `a` 中第一个单精度 (32-bit) 浮点元素的平方根，其他元素保持不变。"],["_mm_sra_epi16","将符号位移入时，将 `a` 中的包装的 16 位整数右移 `count`。"],["_mm_sra_epi32","将符号位移位时，将 `a` 中的包装的 32 位整数右移 `count`。"],["_mm_sra_epi64","在移动符号位的同时按计数右移包装的 64 位整数，并将结果存储在 dst 中。"],["_mm_srai_epi16","将 `a` 中包装的 16 位整数右移 `IMM8`，同时移入符号位。"],["_mm_srai_epi32","将 `a` 中包装的 32 位整数右移 `IMM8`，同时移入符号位。"],["_mm_srai_epi64","将包装的 64 位整数右移 imm8，同时将符号位移位，并将结果存储在 dst 中。"],["_mm_srav_epi16","将包装的 16 位整数右移 count 中相应元素指定的数量，同时移入符号位，然后将结果存储在 dst 中。"],["_mm_srav_epi32","将 `a` 中的32位整数向右移动，移动量由 `count` 中的相应元素指定，同时移入符号位。"],["_mm_srav_epi64","将移位的 64 位整数向右移动计数中相应元素指定的数量，同时移入符号位，并将结果存储在 dst 中。"],["_mm_srl_epi16","将 `a` 中的包装的 16 位整数右移 `count`，同时将零移位。"],["_mm_srl_epi32","将 `a` 中的包装的 32 位整数右移 `count`，同时将零移位。"],["_mm_srl_epi64","将 `a` 中的包装的 64 位整数右移 `count`，同时将零移位。"],["_mm_srli_epi16","将 `a` 中包装的 16 位整数右移 `IMM8`，同时将其移入零。"],["_mm_srli_epi32","将 `a` 中包装的 32 位整数右移 `IMM8`，同时将其移入零。"],["_mm_srli_epi64","将 `a` 中包装的 64 位整数右移 `IMM8`，同时将其移入零。"],["_mm_srli_si128","将 `a` 右移 `IMM8` 个字节，同时移入零。"],["_mm_srlv_epi16","将包装的 16 位整数向右移位 (由 count 中相应元素指定的数量)，同时将零移位，并将结果存储在 dst 中。"],["_mm_srlv_epi32","将 `a` 中的包装的 32 位整数右移 `count` 中相应元素所指定的数量，同时将零移位，"],["_mm_srlv_epi64","将 `a` 中的包装的 64 位整数右移 `count` 中相应元素所指定的数量，同时将零移位，"],["_mm_store1_pd","将来自 `a` 的较低的双精度 (64-bit) 浮点元素存储到内存中的 2 个连续元素中。 `mem_addr` 必须对齐 可能会生成 16 字节边界或一般保护异常。"],["_mm_store1_ps","将 `a` 的最低 32 位浮点数重复存储四次到 aligned 存储器中。"],["_mm_store_epi32","将 a 中的 128 位 (由 4 个包装的 32 位整数组成) 存储到内存中。mem_addr 必须在 16 字节边界上对齐，否则可能会生成一般保护异常。"],["_mm_store_epi64","将 a 中的 128 位 (由 2 个包装的 64 位整数组成) 存储到内存中。mem_addr 必须在 16 字节边界上对齐，否则可能会生成一般保护异常。"],["_mm_store_pd","将来自 `a` 的 128 位 (由 2 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。 `mem_addr` 必须在 16 字节边界上对齐，否则可能会产生一般保护异常。"],["_mm_store_pd1","将来自 `a` 的较低的双精度 (64-bit) 浮点元素存储到内存中的 2 个连续元素中。 `mem_addr` 必须对齐 可能会生成 16 字节边界或一般保护异常。"],["_mm_store_ps","将四个 32 位浮点数存储到 aligned 存储器中。"],["_mm_store_ps1","`_mm_store1_ps` 的别名"],["_mm_store_sd","将 `[2 x double]` 的 128 位 vector 的低 64 位存储到内存位置。"],["_mm_store_si128","将来自 `a` 的 128 位整数数据存储到内存中。"],["_mm_store_ss","将 `a` 的最低 32 位浮点数存储到内存中。"],["_mm_storeh_pd","将 `[2 x double]` 的 128 位 vector 的高 64 位存储到存储位置。"],["_mm_storel_epi64","将低 64 位整数 `a` 存储到内存位置。"],["_mm_storel_pd","将 `[2 x double]` 的 128 位 vector 的低 64 位存储到内存位置。"],["_mm_storer_pd","将 `a` 中的 2 个双精度 (64-bit) 浮点元素以相反的顺序存储到内存中。 `mem_addr` 必须在 16 字节边界上对齐，否则可能会产生一般保护异常。"],["_mm_storer_ps","以相反的顺序将四个 32 位浮点数存储到 aligned 存储器中。"],["_mm_storeu_epi16","将 a 中的 128 位 (由 8 个包装的 16 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。"],["_mm_storeu_epi32","将 a 中的 128 位 (由 4 个包装的 32 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。"],["_mm_storeu_epi64","将 a 中的 128 位 (由 2 个包装的 64 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。"],["_mm_storeu_epi8","将 a 中的 128 位 (由 16 个包装的 8 位整数组成) 存储到内存中。mem_addr 不需要在任何特定边界上对齐。"],["_mm_storeu_pd","将来自 `a` 的 128 位 (由 2 个包装的双精度 (64-bit) 浮点元素组成) 存储到内存中。"],["_mm_storeu_ps","将四个 32 位浮点数存储到内存中。内存对齐没有任何限制。 对于对齐的内存，`_mm_store_ps` 可能更快。"],["_mm_storeu_si128","将来自 `a` 的 128 位整数数据存储到内存中。"],["_mm_stream_pd","将 `[2 x double]` 的 128 位浮点 vector 存储到 128 位对齐的内存位置。 为了最大程度地减少缓存，数据被标记为非时间性的 (不太可能很快再次使用)。"],["_mm_stream_ps","使用非临时内存提示将 `a` 存储到 `mem_addr` 的内存中。"],["_mm_stream_sd","`a.0` 的非临时存储到 `p` 中。"],["_mm_stream_si128","将 128 位整数 vector 存储到 128 位对齐的内存位置。 为了最大程度地减少缓存，数据被标记为非时间性的 (不太可能很快再次使用)。"],["_mm_stream_si32","将 32 位整数值存储在指定的内存位置。 为了最大程度地减少缓存，数据被标记为非时间性的 (不太可能很快再次使用)。"],["_mm_stream_ss","`a.0` 的非临时存储到 `p` 中。"],["_mm_sub_epi16","从 `a` 中的包装的 16 位整数减去 `b` 中的包装的 16 位整数。"],["_mm_sub_epi32","从 `a` 中的包装的 32 位整数中减去 `b` 中的包装的 32 位整数。"],["_mm_sub_epi64","从 `a` 中的包装的 64 位整数中减去 `b` 中的包装的 64 位整数。"],["_mm_sub_epi8","从 `a` 中的包装的 8 位整数中减去 `b` 中的包装的 8 位整数。"],["_mm_sub_pd","从 `a` 中减去 `b` 中的包装的双精度 (64-bit) 浮点元素。"],["_mm_sub_ps","减去 __m128 vectors。"],["_mm_sub_round_sd","从 a 中的较低双精度 (64-bit) 浮点元素中减去 b 中较低的双精度 (64-bit) 浮点元素，将结果存储在 dst 的较低元素中，并将较高的元素从 a 复制到 dst 的较高元素。"],["_mm_sub_round_ss","从 a 中的下部单精度 (32-bit) 浮点元素中减去 b 中的下部单精度 (32-bit) 浮点元素，将结果存储在 dst 的下部元素中，并将上部 3 个包装的元素从 a 复制到上部元素 dst。"],["_mm_sub_sd","返回一个新的 vector，其中 `a` 的低端元素被 `a` 的低端元素减去 `b` 的低端元素所代替。"],["_mm_sub_ss","从 `a` 减去 `b` 的第一个组件，从 `a` 复制其他组件。"],["_mm_subs_epi16","使用饱和度从 `a` 的包装的 16 位整数减去 `b` 的包装的 16 位整数。"],["_mm_subs_epi8","使用饱和度从 `a` 的包装的 8 位整数减去 `b` 的包装的 8 位整数。"],["_mm_subs_epu16","使用饱和度从 `a` 中的包装的无符号 16 位整数减去 `b` 中的包装的无符号 16 位整数。"],["_mm_subs_epu8","使用饱和度从 `a` 中的包装无符号 8 位整数减去 `b` 中的包装无符号 8 位整数。"],["_mm_ternarylogic_epi32","提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个包装的 32 位整数中的每个位，来自 a，b 和 c 的相应位用于形成到 imm8 的 3 位索引，并且将 imm8 中该位的值写入 dst 中的相应位。"],["_mm_ternarylogic_epi64","提供执行任何三操作数二进制函数的功能的按位三元逻辑; 特定的二进制函数由 imm8 中的值指定。对于每个打包的 64 位整数中的每一位，a、b 和 c 中的相应位用于形成 imm8 中的 3 位索引，并将 imm8 中该位的值写入 dst 中的相应位。"],["_mm_test_all_ones","测试 `a` 128 位整数 vector 中的指定位是否全部为 1。"],["_mm_test_all_zeros","测试 128 位整数 vector 中的指定位是否全部为零。"],["_mm_test_epi16_mask","计算 a 和 b 中包装的 16 位整数的按位与，生成中间的 16 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。"],["_mm_test_epi32_mask","计算 a 和 b 中包装的 32 位整数的按位与，生成中间的 32 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。"],["_mm_test_epi64_mask","计算 a 和 b 中包装的 64 位整数的按位与，生成中间 64 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。"],["_mm_test_epi8_mask","计算 a 和 b 中包装的 8 位整数的按位与，生成中间 8 位值，如果中间值不为零，则在结果掩码 k 中设置相应的位。"],["_mm_test_mix_ones_zeros","测试 128 位整数 vector 中的指定位是否既不是全零也不是全 1。"],["_mm_testc_pd","计算 `a` 和 `b` 中 128 位 (表示双精度 (64-bit) 浮点元素) 的按位与，产生中间 128 位值，如果中间值中每个 64 位元素的符号位都将 `ZF` 设置为 1 为零，否则将 `ZF` 设置为 0。 计算 `a` 的按位 NOT，然后与 `b` 进行与运算，得到一个中间值，如果中间值中每个 64 位元素的符号位为零，则将 `CF` 设置为 1，否则将 `CF` 设置为 0。 返回 `CF` 值。"],["_mm_testc_ps","计算 `a` 和 `b` 中 128 位 (代表单精度 (32-bit) 浮点元素) 的 128 位按位与，生成中间 128 位值，如果中间值中每个 32 位元素的符号位都将 `ZF` 设置为 1 为零，否则将 `ZF` 设置为 0。 计算 `a` 的按位非，然后与 `b` 进行与运算，产生一个中间值，如果中间值中每个 32 位元素的符号位为零，则将 `CF` 设置为 1，否则将 `CF` 设置为 0。 返回 `CF` 值。"],["_mm_testc_si128","测试 128 位整数 vector 中的指定位是否全部为 1。"],["_mm_testn_epi16_mask","计算 a 和 b 中包装的 16 位整数的按位 NAND，生成中间的 16 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。"],["_mm_testn_epi32_mask","计算 a 和 b 中包装的 32 位整数的按位 NAND，生成中间的 32 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。"],["_mm_testn_epi64_mask","计算 a 和 b 中包装的 64 位整数的按位 NAND，生成中间的 64 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。"],["_mm_testn_epi8_mask","计算 a 和 b 中包装的 8 位整数的按位 NAND，生成中间的 8 位值，如果中间值为零，则在结果掩码 k 中设置相应的位。"],["_mm_testnzc_pd","计算 `a` 和 `b` 中 128 位 (表示双精度 (64-bit) 浮点元素) 的按位与，产生中间 128 位值，如果中间值中每个 64 位元素的符号位都将 `ZF` 设置为 1 为零，否则将 `ZF` 设置为 0。 计算 `a` 的按位 NOT，然后与 `b` 进行与运算，得到一个中间值，如果中间值中每个 64 位元素的符号位为零，则将 `CF` 设置为 1，否则将 `CF` 设置为 0。 如果 `ZF` 和 `CF` 的值均为零，则返回 1，否则返回 0。"],["_mm_testnzc_ps","计算 `a` 和 `b` 中 128 位 (代表单精度 (32-bit) 浮点元素) 的 128 位按位与，生成中间 128 位值，如果中间值中每个 32 位元素的符号位都将 `ZF` 设置为 1 为零，否则将 `ZF` 设置为 0。 计算 `a` 的按位非，然后与 `b` 进行与运算，产生一个中间值，如果中间值中每个 32 位元素的符号位为零，则将 `CF` 设置为 1，否则将 `CF` 设置为 0。 如果 `ZF` 和 `CF` 的值均为零，则返回 1，否则返回 0。"],["_mm_testnzc_si128","测试 128 位整数 vector 中的指定位是否既不是全零也不是全 1。"],["_mm_testz_pd","计算 `a` 和 `b` 中 128 位 (表示双精度 (64-bit) 浮点元素) 的按位与，产生中间 128 位值，如果中间值中每个 64 位元素的符号位都将 `ZF` 设置为 1 为零，否则将 `ZF` 设置为 0。 计算 `a` 的按位 NOT，然后与 `b` 进行与运算，得到一个中间值，如果中间值中每个 64 位元素的符号位为零，则将 `CF` 设置为 1，否则将 `CF` 设置为 0。 返回 `ZF` 值。"],["_mm_testz_ps","计算 `a` 和 `b` 中 128 位 (代表单精度 (32-bit) 浮点元素) 的 128 位按位与，生成中间 128 位值，如果中间值中每个 32 位元素的符号位都将 `ZF` 设置为 1 为零，否则将 `ZF` 设置为 0。 计算 `a` 的按位非，然后与 `b` 进行与运算，产生一个中间值，如果中间值中每个 32 位元素的符号位为零，则将 `CF` 设置为 1，否则将 `CF` 设置为 0。 返回 `ZF` 值。"],["_mm_testz_si128","测试 128 位整数 vector 中的指定位是否全部为零。"],["_mm_tzcnt_32","计算尾随的最低有效零位的数量。"],["_mm_ucomieq_sd","比较 `a` 和 `b` 的下部元素是否相等。"],["_mm_ucomieq_ss","比较 `a` 和 `b` 的低位的两个 32 位浮点数。 如果相等则返回 `1`，否则返回 `0`。 如果任一参数是安静的 NaN，则该指令不会发出异常信号。"],["_mm_ucomige_sd","比较 `a` 和 `b` 的下限元素是否大于等于。"],["_mm_ucomige_ss","比较 `a` 和 `b` 的低位的两个 32 位浮点数。 如果 `a` 中的值大于或等于 `b` 中的值，则返回 `1`，否则返回 `0`。 如果任一参数是安静的 NaN，则该指令不会发出异常信号。"],["_mm_ucomigt_sd","比较 `a` 和 `b` 的下限元素是否大于。"],["_mm_ucomigt_ss","比较 `a` 和 `b` 的低位的两个 32 位浮点数。 如果 `a` 中的值大于 `b` 中的值，则返回 `1`，否则返回 `0`。 如果任一参数是安静的 NaN，则该指令不会发出异常信号。"],["_mm_ucomile_sd","比较 `a` 和 `b` 的下限元素是否等于或小于等于。"],["_mm_ucomile_ss","比较 `a` 和 `b` 的低位的两个 32 位浮点数。 如果 `a` 中的值小于或等于 `b` 中的值，则返回 `1`，否则返回 `0`。 如果任一参数是安静的 NaN，则该指令不会发出异常信号。"],["_mm_ucomilt_sd","比较 `a` 和 `b` 的下限元素小于。"],["_mm_ucomilt_ss","比较 `a` 和 `b` 的低位的两个 32 位浮点数。 如果 `a` 中的值小于 `b` 中的值，则返回 `1`，否则返回 `0`。 如果任一参数是安静的 NaN，则该指令不会发出异常信号。"],["_mm_ucomineq_sd","比较 `a` 和 `b` 的下部元素是否相等。"],["_mm_ucomineq_ss","比较 `a` 和 `b` 的低位的两个 32 位浮点数。 如果它们不相等，则返回 `1`，否则返回 `0`。 如果任一参数是安静的 NaN，则该指令不会发出异常信号。"],["_mm_undefined_pd","返回带有未定义元素的 __m128d 类型的 vector。"],["_mm_undefined_ps","返回类型为 __m128 的 vector，其中包含未定义的元素。"],["_mm_undefined_si128","返回带有未定义元素的 __m128i 类型的 vector。"],["_mm_unpackhi_epi16","从 `a` 和 `b` 的高半部分解包并交织 16 位整数。"],["_mm_unpackhi_epi32","从 `a` 和 `b` 的高半部分解包并交织 32 位整数。"],["_mm_unpackhi_epi64","从 `a` 和 `b` 的高半部分解包并交织 64 位整数。"],["_mm_unpackhi_epi8","从 `a` 和 `b` 的高半部分解包并交织 8 位整数。"],["_mm_unpackhi_pd","所得的 `__m128d` 元素由两个 `__m128d` 交错输入元素的低阶值组成，即:"],["_mm_unpackhi_ps","从 `a` 和 `b` 的上半部分解包并交织单精度 (32-bit) 浮点元素。"],["_mm_unpacklo_epi16","从 `a` 和 `b` 的下半部分解包并交织 16 位整数。"],["_mm_unpacklo_epi32","从 `a` 和 `b` 的下半部分解包并交织 32 位整数。"],["_mm_unpacklo_epi64","从 `a` 和 `b` 的下半部分解包并交织 64 位整数。"],["_mm_unpacklo_epi8","从 `a` 和 `b` 的下半部分解包并交织 8 位整数。"],["_mm_unpacklo_pd","所得的 `__m128d` 元素由两个 `__m128d` 交错输入元素的高阶值组成，即:"],["_mm_unpacklo_ps","从 `a` 和 `b` 的下半部分解包并交织单精度 (32-bit) 浮点元素。"],["_mm_xor_epi32","计算 a 和 b 中包装的 32 位整数的按位 XOR，并将结果存储在 dst 中。"],["_mm_xor_epi64","计算 a 和 b 中包装的 64 位整数的按位 XOR，并将结果存储在 dst 中。"],["_mm_xor_pd","计算 `a` 和 `b` 的按位或。"],["_mm_xor_ps","包装的单精度 (32-bit) 浮点元素的按位异或。"],["_mm_xor_si128","计算 `a` 和 `b` 中 128 位 (表示整数数据) 的按位 XOR。"],["_mulx_u32","无符号乘法，且不影响标志。"],["_pdep_u32","将 `a` 的连续低阶位分散到 `mask` 指定的位置处的结果中。"],["_pext_u32","将 `mask` 指定的 `x` 的位收集到结果的连续低阶位位置。"],["_popcnt32","计算设置的位。"],["_rdrand16_step","读取硬件生成的 16 位随机值，并将结果存储在 val 中。 如果生成随机值，则返回 1，否则返回 0。"],["_rdrand32_step","读取硬件生成的 32 位随机值，并将结果存储在 val 中。 如果生成随机值，则返回 1，否则返回 0。"],["_rdseed16_step","读取符合 NIST SP800-90B 和 SP800-90C 的 16 位随机值，并存储在 val 中。 如果生成随机值，则返回 1，否则返回 0。"],["_rdseed32_step","读取符合 NIST SP800-90B 和 SP800-90C 的 32 位随机值，并存储在 val 中。 如果生成随机值，则返回 1，否则返回 0。"],["_rdtsc","读取处理器时间戳计数器的当前值。"],["_store_mask32","将 32 位掩码从 a 存储到内存中。"],["_store_mask64","将 64 位掩码从 a 存储到内存中。"],["_subborrow_u32","将无符号的 32 位整数 `a` 和 `b` 与无符号的 8 位进位 `c_in` (进位或溢出标志) 相加，并将无符号的 32 位结果存储在 `out` 中，并返回进位 (进位或溢出标志)。"],["_t1mskc_u32","清除 `x` 的最低有效零以下的所有位，并设置所有其他位。"],["_t1mskc_u64","清除 `x` 的最低有效零以下的所有位，并设置所有其他位。"],["_tzcnt_u32","计算尾随的最低有效零位的数量。"],["_tzmsk_u32","将所有位设置为低于 `x` 的最低有效位，并清除所有其他位。"],["_tzmsk_u64","将所有位设置为低于 `x` 的最低有效位，并清除所有其他位。"],["_xabort","强制将受限制的事务内存 (RTM) 区域终止。 Intel’s documentation."],["_xabort_code","当 [`_xbegin`] 的状态设置为 `_XABORT_EXPLICIT` 标志时，检索传递给 [`_xabort`] 的参数。"],["_xbegin","指定受限制的事务性存储器 (RTM) 代码区域的开始，并返回一个指示状态的值。"],["_xend","指定受限制的事务性存储器 (RTM) 代码区域的结尾。 Intel’s documentation."],["_xgetbv","读取 `xcr_no` 中指定的扩展控制寄存器 `XCR` 的内容。"],["_xrstor","使用 `mem_addr` 内存中存储的状态信息执行已启用处理器状态的全部或部分还原。"],["_xrstors","使用 `mem_addr` 内存中存储的状态信息执行已启用处理器状态的全部或部分还原。"],["_xsave","将已启用的处理器状态全部或部分保存到 `mem_addr` 的内存中。"],["_xsavec","将已启用的处理器状态全部或部分保存到 `mem_addr` 的内存中。"],["_xsaveopt","将已启用的处理器状态全部或部分保存到 `mem_addr` 的内存中。"],["_xsaves","将启用的处理器状态全部或部分保存到以下位置的内存中: `mem_addr`"],["_xsetbv","从 `val` 复制 64 位到 `a` 指定的扩展控制寄存器 (`XCR`)。"],["_xtest","查询处理器是在由受限事务存储器 (RTM) 还是硬件锁定扩展 (HLE) 标识的事务区域中执行。"],["has_cpuid","主机是否支持 `cpuid` 指令?"],["ud2","生成陷阱指令 `UD2`"]],"struct":[["CpuidResult","`cpuid` 指令的结果。"],["__m128","四种 `f32` 类型的 128 位宽集，特定于 x86"],["__m128bh","128 位宽的一组 8 个 `u16` 类型，特定于 x86"],["__m128d","两种 `f64` 类型的 128 位宽集，特定于 x86"],["__m128i","128 位宽的整数 vector 类型，特定于 x86"],["__m256","256 位宽的八种 `f32` 类型的集合，特定于 x86"],["__m256bh","256 位宽的 16 种 `u16` 类型集，特定于 x86"],["__m256d","256 位宽的四种 `f64` 类型的集合，特定于 x86"],["__m256i","256 位宽的整数 vector 类型，特定于 x86"],["__m512","512 位宽的十六种 `f32` 类型集，特定于 x86"],["__m512bh","512 位宽的 32 种 `u16` 类型集，特定于 x86"],["__m512d","八种 `f64` 类型的 512 位宽集，特定于 x86"],["__m512i","512 位宽的整数 vector 类型，特定于 x86"]],"type":[["_MM_CMPINT_ENUM","`_MM_CMPINT_ENUM` 类型用于在 AVX-512 内联函数中指定比较操作。"],["_MM_MANTISSA_NORM_ENUM","`MM_MANTISSA_NORM_ENUM` 类型用于指定 AVX-512 内联函数中的尾数归一化操作。"],["_MM_MANTISSA_SIGN_ENUM","`MM_MANTISSA_SIGN_ENUM` 类型用于指定 AVX-512 内联函数中的尾数签名操作。"],["_MM_PERM_ENUM","`MM_PERM_ENUM` 类型用于在 AVX-512 内联函数中指定重排操作。"],["__mmask16","AVX-512 内联函数中使用的 `__mmask16` 类型，一个 16 位整数"],["__mmask32","AVX-512 内联函数中使用的 `__mmask32` 类型，一个 32 位整数"],["__mmask64","AVX-512 内联函数中使用的 `__mmask64` 类型，一个 64 位整数"],["__mmask8","AVX-512 内联函数中使用的 `__mmask8` 类型，一个 8 位整数"]]});