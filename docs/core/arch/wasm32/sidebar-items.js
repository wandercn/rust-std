initSidebarItems({"fn":[["f32x4","从提供的操作数实现 SIMD 值。"],["f32x4_abs","计算一个 128 位 vector 的每个通道的绝对值，该绝对值解释为四个 32 位浮点数。"],["f32x4_add","将两个 128 位 vectors 的成对通道相加，将其解释为四个 32 位浮点数。"],["f32x4_ceil","按通道舍入到不小于输入的最近整数值。"],["f32x4_convert_i32x4","将解释为四个 32 位有符号整数的 128 位 vector 转换为 四个 32 位浮点数的 128 位 vector。"],["f32x4_convert_u32x4","将解释为四个 32 位无符号整数的 128 位 vector 转换为 四个 32 位浮点数的 128 位 vector。"],["f32x4_demote_f64x2_zero","将结果的两个双精度浮点通道转换为两个较低的单精度通道。 结果的两个较高通道被初始化为零。 如果转换结果不能表示为单精度浮点数，则将其四舍五入为最接近的偶数可表示数。"],["f32x4_div","将两个 128 位 vectors 的成对通道划分为四个 32 位浮点数。"],["f32x4_eq","比较两个 128 位 vectors，就好像它们是 4 个 32 位浮点数的两个 vectors 一样。"],["f32x4_extract_lane","从解释为 4 个包装的 f32 数字的 128 位 vector 中提取通道。"],["f32x4_floor","按通道舍入到不大于输入的最近整数值。"],["f32x4_ge","比较两个 128 位 vectors，就好像它们是 4 个 32 位浮点数的两个 vectors 一样。"],["f32x4_gt","比较两个 128 位 vectors，就好像它们是 4 个 32 位浮点数的两个 vectors 一样。"],["f32x4_le","比较两个 128 位 vectors，就好像它们是 4 个 32 位浮点数的两个 vectors 一样。"],["f32x4_lt","比较两个 128 位 vectors，就好像它们是 4 个 32 位浮点数的两个 vectors 一样。"],["f32x4_max","计算两个解释为四个 32 位浮点数的 128 位 vectors 的成对通道的最大值。"],["f32x4_min","计算两个解释为四个 32 位浮点数的 128 位 vectors 的成对通道的最小值。"],["f32x4_mul","将两个 128 位 vectors 的成对通道相乘，将其解释为四个 32 位浮点数。"],["f32x4_ne","比较两个 128 位 vectors，就好像它们是 4 个 32 位浮点数的两个 vectors 一样。"],["f32x4_nearest","按通道舍入到最接近的整数值; 如果两个值相等，则舍入到偶数。"],["f32x4_neg","对解释为四个 32 位浮点数的 128 位向量的每个通道求反。"],["f32x4_pmax","通道最大值，定义为 `a < b ? b : a`"],["f32x4_pmin","通道最小值，定义为 `b < a ? b : a`"],["f32x4_replace_lane","从解释为 4 个包装的 f32 编号的 128 位 vector 替换一个通道。"],["f32x4_splat","创建具有相同通道的 vector。"],["f32x4_sqrt","计算一个 128 位 vector 的每个通道的平方根，该 vector 解释为四个 32 位浮点数。"],["f32x4_sub","减去两个 128 位 vectors 的成对通道，它们被解释为四个 32 位浮点数。"],["f32x4_trunc","按通道舍入到最接近的整数值，幅度不大于输入。"],["f64x2","从提供的操作数实现 SIMD 值。"],["f64x2_abs","计算被解释为两个 64 位浮点数的 128 位 vector 的每个通道的绝对值。"],["f64x2_add","将两个 128 位 vectors 的成对通道相加，将其解释为两个 64 位浮点数。"],["f64x2_ceil","按通道舍入到不小于输入的最近整数值。"],["f64x2_convert_low_i32x4","从整数到浮点的逐行转换。"],["f64x2_convert_low_u32x4","从整数到浮点的逐行转换。"],["f64x2_div","将两个 128 位 vectors 的成对通道划分为两个 64 位浮点数。"],["f64x2_eq","比较两个 128 位 vectors，就好像它们是 2 个 64 位浮点数的两个 vectors 一样。"],["f64x2_extract_lane","从解释为 2 个包装的 f64 编号的 128 位 vector 中提取通道。"],["f64x2_floor","按通道舍入到不大于输入的最近整数值。"],["f64x2_ge","比较两个 128 位 vectors，就好像它们是 2 个 64 位浮点数的两个 vectors 一样。"],["f64x2_gt","比较两个 128 位 vectors，就好像它们是 2 个 64 位浮点数的两个 vectors 一样。"],["f64x2_le","比较两个 128 位 vectors，就好像它们是 2 个 64 位浮点数的两个 vectors 一样。"],["f64x2_lt","比较两个 128 位 vectors，就好像它们是 2 个 64 位浮点数的两个 vectors 一样。"],["f64x2_max","计算两个解释为两个 64 位浮点数的 128 位 vectors 的成对通道的最大值。"],["f64x2_min","计算两个解释为两个 64 位浮点数的 128 位 vectors 的成对通道的最小值。"],["f64x2_mul","将两个解释为两个 64 位浮点数的 128 位 vectors 的成对通道相乘。"],["f64x2_ne","比较两个 128 位 vectors，就好像它们是 2 个 64 位浮点数的两个 vectors 一样。"],["f64x2_nearest","按通道舍入到最接近的整数值; 如果两个值相等，则舍入到偶数。"],["f64x2_neg","取反解释为两个 64 位浮点数的 128 位 vector 的每个通道。"],["f64x2_pmax","通道最大值，定义为 `a < b ? b : a`"],["f64x2_pmin","通道最小值，定义为 `b < a ? b : a`"],["f64x2_promote_low_f32x4","将两个较低的单精度浮点通道转换为结果的两个双精度通道。"],["f64x2_replace_lane","从一个解释为 2 包装的 f64 编号的 128 位 vector 替换一个通道。"],["f64x2_splat","创建具有相同通道的 vector。"],["f64x2_sqrt","计算一个 128 位 vector 的每个通道的平方根，该 vector 解释为两个 64 位浮点数。"],["f64x2_sub","减去两个 128 位 vectors 的成对通道，它们被解释为两个 64 位浮点数。"],["f64x2_trunc","按通道舍入到最接近的整数值，幅度不大于输入。"],["i16x8","从提供的操作数实现 SIMD 值。"],["i16x8_abs","逐行包装绝对值。"],["i16x8_add","将两个 128 位 vectors 相加，就好像它们是两个包装的八个 16 位整数一样。"],["i16x8_add_sat","将两个 128 位 vectors 相加，就好像它们是两个包装的八个 16 位有符号整数一样，在溢出到 `i16::MAX` 时会饱和。"],["i16x8_all_true","如果所有通道都不为零，则返回 1; 如果任何通道都不为零，则返回 0。"],["i16x8_bitmask","提取 `a` 中每个通道的高位并生成一个所有位连接的标量掩码。"],["i16x8_eq","比较两个 128 位 vectors，就好像它们是 8 个 16 位整数的两个 vectors 一样。"],["i16x8_extadd_pairwise_i8x16","逐行整数扩展成对加法产生扩展结果 (结果比输入宽两倍)。"],["i16x8_extadd_pairwise_u8x16","逐行整数扩展成对加法产生扩展结果 (结果比输入宽两倍)。"],["i16x8_extend_high_i8x16","将较小通道 vector 的高一半转换为较大通道 vector，并对其进行符号扩展。"],["i16x8_extend_high_u8x16","将较小通道 vector 的高一半转换为较大通道 vector，扩展为零。"],["i16x8_extend_low_i8x16","将较小通道 vector 的下半部分转换为较大通道 vector，并扩展符号。"],["i16x8_extend_low_u8x16","将较小通道 vector 的下半部分转换为较大通道 vector，扩展为零。"],["i16x8_extmul_high_i8x16","逐行整数扩展乘法产生比输入宽两倍的结果。"],["i16x8_extmul_high_u8x16","逐行整数扩展乘法产生比输入宽两倍的结果。"],["i16x8_extmul_low_i8x16","逐行整数扩展乘法产生比输入宽两倍的结果。"],["i16x8_extmul_low_u8x16","逐行整数扩展乘法产生比输入宽两倍的结果。"],["i16x8_extract_lane","从解释为 8 个包装的 i16 数字的 128 位 vector 中提取通道。"],["i16x8_ge","比较两个 128 位 vectors，就好像它们是 8 个 16 位带符号整数的两个 vectors 一样。"],["i16x8_gt","比较两个 128 位 vectors，就好像它们是 8 个 16 位带符号整数的两个 vectors 一样。"],["i16x8_le","比较两个 128 位 vectors，就好像它们是 8 个 16 位带符号整数的两个 vectors 一样。"],["i16x8_load_extend_i8x8","加载 8 个 8 位整数，并将每个符号扩展到 16 位通道"],["i16x8_load_extend_u8x8","加载 8 个 8 位整数，零加载每个整数至 16 位通道"],["i16x8_lt","比较两个 128 位 vectors，就好像它们是 8 个 16 位带符号整数的两个 vectors 一样。"],["i16x8_max","比较通道有符号整数，并返回每对的最大值。"],["i16x8_min","比较通道有符号整数，并返回每对中的最小值。"],["i16x8_mul","将两个 128 位 vectors 相乘，就好像它们是两个包装的八个 16 位有符号整数一样。"],["i16x8_narrow_i32x4","通过使每个通道变窄，将两个输入 vectors 转换为较小的通道 vector。"],["i16x8_ne","比较两个 128 位 vectors，就好像它们是 8 个 16 位整数的两个 vectors 一样。"],["i16x8_neg","取反一个 8 位 16 位带符号整数的 128 位 vectors"],["i16x8_q15mulr_sat","Q15 格式的通道饱和舍入乘法。"],["i16x8_replace_lane","从解释为 8 个包装的 i16 编号的 128 位 vector 替换一个通道。"],["i16x8_shl","将每个通道向左移动指定的位数。"],["i16x8_shr","将每个通道向右移动指定的位数，并扩展符号。"],["i16x8_shuffle","与 [`i8x16_shuffle`] 相同，只是操作起来好像输入是八个 16 位整数，仅需 8 个索引即可重排。"],["i16x8_splat","创建具有相同通道的 vector。"],["i16x8_sub","将两个 128 位 vectors 相减，就好像它们是两个包装的八个 16 位整数一样。"],["i16x8_sub_sat","将两个 128 位 vectors 相减，就好像它们是两个包装的八个 16 位有符号整数一样，在溢出到 `i16::MIN` 时会饱和。"],["i32x4","从提供的操作数实现 SIMD 值。"],["i32x4_abs","逐行包装绝对值。"],["i32x4_add","将两个 128 位 vectors 相加，就好像它们是两个包装的四个 32 位整数一样。"],["i32x4_all_true","如果所有通道都不为零，则返回 1; 如果任何通道都不为零，则返回 0。"],["i32x4_bitmask","提取 `a` 中每个通道的高位并生成一个所有位连接的标量掩码。"],["i32x4_dot_i16x8","在两个输入 vectors 中逐行乘以带符号的 16 位整数，并将完整的 32 位结果的相邻对相加。"],["i32x4_eq","比较两个 128 位 vectors，就好像它们是 4 个 32 位整数的两个 vectors 一样。"],["i32x4_extadd_pairwise_i16x8","逐行整数扩展成对加法产生扩展结果 (结果比输入宽两倍)。"],["i32x4_extadd_pairwise_u16x8","逐行整数扩展成对加法产生扩展结果 (结果比输入宽两倍)。"],["i32x4_extend_high_i16x8","将较小通道 vector 的高一半转换为较大通道 vector，并对其进行符号扩展。"],["i32x4_extend_high_u16x8","将较小通道 vector 的高一半转换为较大通道 vector，扩展为零。"],["i32x4_extend_low_i16x8","将较小通道 vector 的下半部分转换为较大通道 vector，并扩展符号。"],["i32x4_extend_low_u16x8","将较小通道 vector 的下半部分转换为较大通道 vector，扩展为零。"],["i32x4_extmul_high_i16x8","逐行整数扩展乘法产生比输入宽两倍的结果。"],["i32x4_extmul_high_u16x8","逐行整数扩展乘法产生比输入宽两倍的结果。"],["i32x4_extmul_low_i16x8","逐行整数扩展乘法产生比输入宽两倍的结果。"],["i32x4_extmul_low_u16x8","逐行整数扩展乘法产生比输入宽两倍的结果。"],["i32x4_extract_lane","从解释为 4 个包装的 i32 数字的 128 位 vector 中提取通道。"],["i32x4_ge","比较两个 128 位 vectors，就好像它们是 4 个 32 位有符号整数的两个 vectors 一样。"],["i32x4_gt","比较两个 128 位 vectors，就好像它们是 4 个 32 位有符号整数的两个 vectors 一样。"],["i32x4_le","比较两个 128 位 vectors，就好像它们是 4 个 32 位有符号整数的两个 vectors 一样。"],["i32x4_load_extend_i16x4","加载四个 16 位整数，并将每个符号扩展到 32 位通道"],["i32x4_load_extend_u16x4","加载四个 16 位整数，零加载一个整数到 32 位通道"],["i32x4_lt","比较两个 128 位 vectors，就好像它们是 4 个 32 位有符号整数的两个 vectors 一样。"],["i32x4_max","比较通道有符号整数，并返回每对的最大值。"],["i32x4_min","比较通道有符号整数，并返回每对中的最小值。"],["i32x4_mul","将两个 128 位 vectors 相乘，就好像它们是两个包装的四个 32 位有符号整数一样。"],["i32x4_ne","比较两个 128 位 vectors，就好像它们是 4 个 32 位整数的两个 vectors 一样。"],["i32x4_neg","取反一个 128 位 vectors，该 vectors 解释为四个 32 位带符号整数"],["i32x4_replace_lane","从解释为 4 个包装的 i32 编号的 128 位 vector 替换一个通道。"],["i32x4_shl","将每个通道向左移动指定的位数。"],["i32x4_shr","将每个通道向右移动指定的位数，并扩展符号。"],["i32x4_shuffle","与 [`i8x16_shuffle`] 相同，但操作时如同输入为 4 32 位整数，仅需 4 个索引即可重排。"],["i32x4_splat","创建具有相同通道的 vector。"],["i32x4_sub","将两个 128 位 vectors 相减，就好像它们是两个包装的四个 32 位整数一样。"],["i32x4_trunc_sat_f32x4","将解释为四个 32 位浮点数的 128 位 vector 转换为包含四个 32 位带符号整数的 128 位 vector。"],["i32x4_trunc_sat_f64x2_zero","使用 IEEE `convertToIntegerTowardZero` 函数将两个双精度浮点通道饱和转换为两个较低的整数通道。"],["i64x2","从提供的操作数实现 SIMD 值。"],["i64x2_abs","逐行包装绝对值。"],["i64x2_add","将两个 128 位 vectors 相加，就好像它们是两个包装的两个 64 位整数一样。"],["i64x2_all_true","如果所有通道都不为零，则返回 1; 如果任何通道都不为零，则返回 0。"],["i64x2_bitmask","提取 `a` 中每个通道的高位并生成一个所有位连接的标量掩码。"],["i64x2_eq","比较两个 128 位 vectors，就好像它们是两个 64 位整数的两个 vectors。"],["i64x2_extend_high_i32x4","将较小通道 vector 的高一半转换为较大通道 vector，并对其进行符号扩展。"],["i64x2_extend_high_u32x4","将较小通道 vector 的高一半转换为较大通道 vector，扩展为零。"],["i64x2_extend_low_i32x4","将较小通道 vector 的下半部分转换为较大通道 vector，并扩展符号。"],["i64x2_extend_low_u32x4","将较小通道 vector 的下半部分转换为较大通道 vector，扩展为零。"],["i64x2_extmul_high_i32x4","逐行整数扩展乘法产生比输入宽两倍的结果。"],["i64x2_extmul_high_u32x4","逐行整数扩展乘法产生比输入宽两倍的结果。"],["i64x2_extmul_low_i32x4","逐行整数扩展乘法产生比输入宽两倍的结果。"],["i64x2_extmul_low_u32x4","逐行整数扩展乘法产生比输入宽两倍的结果。"],["i64x2_extract_lane","从解释为 2 个包装的 i64 编号的 128 位 vector 中提取通道。"],["i64x2_ge","比较两个 128 位 vectors，就好像它们是两个 64 位有符号整数的两个 vectors。"],["i64x2_gt","比较两个 128 位 vectors，就好像它们是两个 64 位有符号整数的两个 vectors。"],["i64x2_le","比较两个 128 位 vectors，就好像它们是两个 64 位有符号整数的两个 vectors。"],["i64x2_load_extend_i32x2","加载两个 32 位整数并将每个符号扩展到 64 位通道"],["i64x2_load_extend_u32x2","加载两个 32 位整数，零加载每个整数到 64 位通道"],["i64x2_lt","比较两个 128 位 vectors，就好像它们是两个 64 位有符号整数的两个 vectors。"],["i64x2_mul","将两个 128 位 vectors 相乘，就好像它们是两个包装的两个 64 位整数一样。"],["i64x2_ne","比较两个 128 位 vectors，就好像它们是两个 64 位整数的两个 vectors。"],["i64x2_neg","取反被解释为两个 64 位有符号整数的 128 位 vectors"],["i64x2_replace_lane","从一个解释为 2 个包装的 i64 编号的 128 位 vector 替换一个通道。"],["i64x2_shl","将每个通道向左移动指定的位数。"],["i64x2_shr","将每个通道向右移动指定的位数，并扩展符号。"],["i64x2_shuffle","与 [`i8x16_shuffle`] 相同，但操作时就像输入是两个 64 位整数，仅需 2 个索引即可重排。"],["i64x2_splat","创建具有相同通道的 vector。"],["i64x2_sub","将两个 128 位 vectors 相减，就好像它们是两个包装的两个 64 位整数一样。"],["i8x16","从提供的操作数实现 SIMD 值。"],["i8x16_abs","逐行包装绝对值。"],["i8x16_add","将两个 128 位 vectors 相加，就好像它们是两个包装的 16 个 8 位整数一样。"],["i8x16_add_sat","将两个 128 位 vectors 相加，就好像它们是两个包装的 16 个 8 位有符号整数一样，在溢出到 `i8::MAX` 时会饱和。"],["i8x16_all_true","如果所有通道都不为零，则返回 true，如果任何通道不为零，则返回 false。"],["i8x16_bitmask","提取 `a` 中每个通道的高位并生成一个所有位连接的标量掩码。"],["i8x16_eq","比较两个 128 位 vectors，就好像它们是 16 个 8 位整数的两个 vectors 一样。"],["i8x16_extract_lane","从解释为 16 个包装的 i8 数字的 128 位 vector 中提取通道。"],["i8x16_ge","比较两个 128 位 vectors，就好像它们是 16 个 8 位有符号整数的两个 vectors 一样。"],["i8x16_gt","比较两个 128 位 vectors，就好像它们是 16 个 8 位有符号整数的两个 vectors 一样。"],["i8x16_le","比较两个 128 位 vectors，就好像它们是 16 个 8 位有符号整数的两个 vectors 一样。"],["i8x16_lt","比较两个 128 位 vectors，就好像它们是 16 个 8 位有符号整数的两个 vectors 一样。"],["i8x16_max","比较通道有符号整数，并返回每对的最大值。"],["i8x16_min","比较通道有符号整数，并返回每对中的最小值。"],["i8x16_narrow_i16x8","通过使每个通道变窄，将两个输入 vectors 转换为较小的通道 vector。"],["i8x16_ne","比较两个 128 位 vectors，就好像它们是 16 个 8 位整数的两个 vectors 一样。"],["i8x16_neg","取反一个 16 位 8 位带符号整数的 128 位 vectors"],["i8x16_popcnt","计算每个通道内设置为 1 的位数。"],["i8x16_replace_lane","替换 128 位 vector 中的通道，该通道被解释为 16 个包装的 i8 数字。"],["i8x16_shl","将每个通道向左移动指定的位数。"],["i8x16_shr","将每个通道向右移动指定的位数，并扩展符号。"],["i8x16_shuffle","返回一个新的 vector，其通道从 16 个 immediate 操作数中指定的两个输入 vectors `$a` 和 `$b` 的通道中选择。"],["i8x16_splat","创建具有相同通道的 vector。"],["i8x16_sub","将两个 128 位 vectors 相减，就好像它们是两个包装的 16 个 8 位整数一样。"],["i8x16_sub_sat","将两个 128 位 vectors 相减，就好像它们是两个包装的 16 个 8 位有符号整数一样，在溢出到 `i8::MIN` 时会饱和。"],["i8x16_swizzle","返回带有从第二个输入 vector `s` 中指定的第一个输入 vector `a` 的通道中选择的通道的新 vector。"],["memory_atomic_notify","对应 wasm 的 `memory.atomic.notify` 指令"],["memory_atomic_wait32","对应 wasm 的 `memory.atomic.wait32` 指令"],["memory_atomic_wait64","对应 wasm 的 `memory.atomic.wait64` 指令"],["memory_grow","对应 wasm 的 `memory.grow` 指令"],["memory_size","对应 wasm 的 `memory.size` 指令"],["u16x8","从提供的操作数实现 SIMD 值。"],["u16x8_add","将两个 128 位 vectors 相加，就好像它们是两个包装的八个 16 位整数一样。"],["u16x8_add_sat","将两个 128 位 vectors 相加，就好像它们是两个包装的八个 16 位无符号整数一样，在溢出到 `u16::MAX` 时会饱和。"],["u16x8_all_true","如果所有通道都不为零，则返回 1; 如果任何通道都不为零，则返回 0。"],["u16x8_avgr","逐行舍入平均值。"],["u16x8_bitmask","提取 `a` 中每个通道的高位并生成一个所有位连接的标量掩码。"],["u16x8_eq","比较两个 128 位 vectors，就好像它们是 8 个 16 位整数的两个 vectors 一样。"],["u16x8_extadd_pairwise_u8x16","逐行整数扩展成对加法产生扩展结果 (结果比输入宽两倍)。"],["u16x8_extend_high_u8x16","将较小通道 vector 的高一半转换为较大通道 vector，扩展为零。"],["u16x8_extend_low_u8x16","将较小通道 vector 的下半部分转换为较大通道 vector，扩展为零。"],["u16x8_extmul_high_u8x16","逐行整数扩展乘法产生比输入宽两倍的结果。"],["u16x8_extmul_low_u8x16","逐行整数扩展乘法产生比输入宽两倍的结果。"],["u16x8_extract_lane","从解释为 8 个包装的 u16 数字的 128 位 vector 中提取一个通道。"],["u16x8_ge","比较两个 128 位 vectors，就好像它们是 8 个 16 位无符号整数的两个 vectors 一样。"],["u16x8_gt","比较两个 128 位 vectors，就好像它们是 8 个 16 位无符号整数的两个 vectors 一样。"],["u16x8_le","比较两个 128 位 vectors，就好像它们是 8 个 16 位无符号整数的两个 vectors 一样。"],["u16x8_load_extend_u8x8","加载 8 个 8 位整数，零加载每个整数至 16 位通道"],["u16x8_lt","比较两个 128 位 vectors，就好像它们是 8 个 16 位无符号整数的两个 vectors 一样。"],["u16x8_max","比较通道无符号整数，并返回每对的最大值。"],["u16x8_min","比较通道无符号整数，并返回每对中的最小值。"],["u16x8_mul","将两个 128 位 vectors 相乘，就好像它们是两个包装的八个 16 位有符号整数一样。"],["u16x8_narrow_i32x4","通过使每个通道变窄，将两个输入 vectors 转换为较小的通道 vector。"],["u16x8_ne","比较两个 128 位 vectors，就好像它们是 8 个 16 位整数的两个 vectors 一样。"],["u16x8_replace_lane","从解释为 8 个包装的 u16 数字的 128 位 vector 替换一个通道。"],["u16x8_shl","将每个通道向左移动指定的位数。"],["u16x8_shr","将每个通道向右移动指定的位数，以零为单位。"],["u16x8_shuffle","与 [`i8x16_shuffle`] 相同，只是操作起来好像输入是八个 16 位整数，仅需 8 个索引即可重排。"],["u16x8_splat","创建具有相同通道的 vector。"],["u16x8_sub","将两个 128 位 vectors 相减，就好像它们是两个包装的八个 16 位整数一样。"],["u16x8_sub_sat","将两个 128 位 vectors 相减，就好像它们是两个包装的八个 16 位无符号整数一样，溢出时饱和为 0。"],["u32x4","从提供的操作数实现 SIMD 值。"],["u32x4_add","将两个 128 位 vectors 相加，就好像它们是两个包装的四个 32 位整数一样。"],["u32x4_all_true","如果所有通道都不为零，则返回 1; 如果任何通道都不为零，则返回 0。"],["u32x4_bitmask","提取 `a` 中每个通道的高位并生成一个所有位连接的标量掩码。"],["u32x4_eq","比较两个 128 位 vectors，就好像它们是 4 个 32 位整数的两个 vectors 一样。"],["u32x4_extadd_pairwise_u16x8","逐行整数扩展成对加法产生扩展结果 (结果比输入宽两倍)。"],["u32x4_extend_high_u16x8","将较小通道 vector 的高一半转换为较大通道 vector，扩展为零。"],["u32x4_extend_low_u16x8","将较小通道 vector 的下半部分转换为较大通道 vector，扩展为零。"],["u32x4_extmul_high_u16x8","逐行整数扩展乘法产生比输入宽两倍的结果。"],["u32x4_extmul_low_u16x8","逐行整数扩展乘法产生比输入宽两倍的结果。"],["u32x4_extract_lane","从解释为 4 个包装的 u32 数字的 128 位 vector 中提取一个通道。"],["u32x4_ge","比较两个 128 位 vectors，就好像它们是 4 个 32 位无符号整数的两个 vectors 一样。"],["u32x4_gt","比较两个 128 位 vectors，就好像它们是 4 个 32 位无符号整数的两个 vectors 一样。"],["u32x4_le","比较两个 128 位 vectors，就好像它们是 4 个 32 位无符号整数的两个 vectors 一样。"],["u32x4_load_extend_u16x4","加载四个 16 位整数，零加载一个整数到 32 位通道"],["u32x4_lt","比较两个 128 位 vectors，就好像它们是 4 个 32 位无符号整数的两个 vectors 一样。"],["u32x4_max","比较通道无符号整数，并返回每对的最大值。"],["u32x4_min","比较通道无符号整数，并返回每对中的最小值。"],["u32x4_mul","将两个 128 位 vectors 相乘，就好像它们是两个包装的四个 32 位有符号整数一样。"],["u32x4_ne","比较两个 128 位 vectors，就好像它们是 4 个 32 位整数的两个 vectors 一样。"],["u32x4_replace_lane","从解释为 4 个包装的 u32 数字的 128 位 vector 替换一个通道。"],["u32x4_shl","将每个通道向左移动指定的位数。"],["u32x4_shr","将每个通道向右移动指定的位数，以零为单位。"],["u32x4_shuffle","与 [`i8x16_shuffle`] 相同，但操作时如同输入为 4 32 位整数，仅需 4 个索引即可重排。"],["u32x4_splat","创建具有相同通道的 vector。"],["u32x4_sub","将两个 128 位 vectors 相减，就好像它们是两个包装的四个 32 位整数一样。"],["u32x4_trunc_sat_f32x4","将解释为四个 32 位浮点数的 128 位 vector 转换为四个 32 位无符号整数的 128 位 vector。"],["u32x4_trunc_sat_f64x2_zero","使用 IEEE `convertToIntegerTowardZero` 函数将两个双精度浮点通道饱和转换为两个较低的整数通道。"],["u64x2","从提供的操作数实现 SIMD 值。"],["u64x2_add","将两个 128 位 vectors 相加，就好像它们是两个包装的两个 64 位整数一样。"],["u64x2_all_true","如果所有通道都不为零，则返回 1; 如果任何通道都不为零，则返回 0。"],["u64x2_bitmask","提取 `a` 中每个通道的高位并生成一个所有位连接的标量掩码。"],["u64x2_eq","比较两个 128 位 vectors，就好像它们是两个 64 位整数的两个 vectors。"],["u64x2_extend_high_u32x4","将较小通道 vector 的高一半转换为较大通道 vector，扩展为零。"],["u64x2_extend_low_u32x4","将较小通道 vector 的下半部分转换为较大通道 vector，扩展为零。"],["u64x2_extmul_high_u32x4","逐行整数扩展乘法产生比输入宽两倍的结果。"],["u64x2_extmul_low_u32x4","逐行整数扩展乘法产生比输入宽两倍的结果。"],["u64x2_extract_lane","从解释为 2 个包装的 u64 数字的 128 位 vector 中提取一个通道。"],["u64x2_load_extend_u32x2","加载两个 32 位整数，零加载每个整数到 64 位通道"],["u64x2_mul","将两个 128 位 vectors 相乘，就好像它们是两个包装的两个 64 位整数一样。"],["u64x2_ne","比较两个 128 位 vectors，就好像它们是两个 64 位整数的两个 vectors。"],["u64x2_replace_lane","从解释为 2 个包装的 u64 数字的 128 位 vector 替换一个通道。"],["u64x2_shl","将每个通道向左移动指定的位数。"],["u64x2_shr","将每个通道向右移动指定的位数，以零为单位。"],["u64x2_shuffle","与 [`i8x16_shuffle`] 相同，但操作时就像输入是两个 64 位整数，仅需 2 个索引即可重排。"],["u64x2_splat","创建具有相同通道的 vector。"],["u64x2_sub","将两个 128 位 vectors 相减，就好像它们是两个包装的两个 64 位整数一样。"],["u8x16","从提供的操作数实现 SIMD 值。"],["u8x16_add","将两个 128 位 vectors 相加，就好像它们是两个包装的 16 个 8 位整数一样。"],["u8x16_add_sat","将两个 128 位 vectors 相加，就好像它们是两个包装的 16 个 8 位无符号整数一样，在溢出到 `u8::MAX` 时会饱和。"],["u8x16_all_true","如果所有通道都不为零，则返回 true，如果任何通道不为零，则返回 false。"],["u8x16_avgr","逐行舍入平均值。"],["u8x16_bitmask","提取 `a` 中每个通道的高位并生成一个所有位连接的标量掩码。"],["u8x16_eq","比较两个 128 位 vectors，就好像它们是 16 个 8 位整数的两个 vectors 一样。"],["u8x16_extract_lane","从解释为 16 个包装的 u8 数字的 128 位 vector 中提取一个通道。"],["u8x16_ge","比较两个 128 位 vectors，就好像它们是 16 个 8 位无符号整数的两个 vectors 一样。"],["u8x16_gt","比较两个 128 位 vectors，就好像它们是 16 个 8 位无符号整数的两个 vectors 一样。"],["u8x16_le","比较两个 128 位 vectors，就好像它们是 16 个 8 位无符号整数的两个 vectors 一样。"],["u8x16_lt","比较两个 128 位 vectors，就好像它们是 16 个 8 位无符号整数的两个 vectors 一样。"],["u8x16_max","比较通道无符号整数，并返回每对的最大值。"],["u8x16_min","比较通道无符号整数，并返回每对中的最小值。"],["u8x16_narrow_i16x8","通过使每个通道变窄，将两个输入 vectors 转换为较小的通道 vector。"],["u8x16_ne","比较两个 128 位 vectors，就好像它们是 16 个 8 位整数的两个 vectors 一样。"],["u8x16_popcnt","计算每个通道内设置为 1 的位数。"],["u8x16_replace_lane","从解释为 16 个包装的 u8 数字的 128 位 vector 替换一个通道。"],["u8x16_shl","将每个通道向左移动指定的位数。"],["u8x16_shr","将每个通道向右移动指定的位数，以零为单位。"],["u8x16_shuffle","返回一个新的 vector，其通道从 16 个 immediate 操作数中指定的两个输入 vectors `$a` 和 `$b` 的通道中选择。"],["u8x16_splat","创建具有相同通道的 vector。"],["u8x16_sub","将两个 128 位 vectors 相减，就好像它们是两个包装的 16 个 8 位整数一样。"],["u8x16_sub_sat","将两个 128 位 vectors 相减，就好像它们是两个包装的 16 个 8 位无符号整数一样，溢出时饱和为 0。"],["u8x16_swizzle","返回带有从第二个输入 vector `s` 中指定的第一个输入 vector `a` 的通道中选择的通道的新 vector。"],["unreachable","生成陷阱指令 `UNREACHABLE`"],["v128_and","对两个输入的 128 位 vectors 进行按位和运算，返回结果 vector。"],["v128_andnot","`a` 的位按位与与 `b` 的位进行逻辑逆。"],["v128_any_true","如果设置了 `a` 中的任何一位，则返回 `true`，否则返回 `false`。"],["v128_bitselect","使用 `c` 中的位掩码在 1 时从 `v1` 中选择位，在 0 时从 `v2` 中选择位。"],["v128_load","从给定的堆地址加载 `v128` vector。"],["v128_load16_lane","从 `m` 加载 16 位值并将 `v` 的通道 `L` 设置为该值。"],["v128_load16_splat","加载单个元素，然后将其放置到 v128 vector 的所有通道中。"],["v128_load32_lane","从 `m` 加载 32 位值并将 `v` 的通道 `L` 设置为该值。"],["v128_load32_splat","加载单个元素，然后将其放置到 v128 vector 的所有通道中。"],["v128_load32_zero","将 32 位元素加载到 vector 的低位并将所有其他位设置为零。"],["v128_load64_lane","从 `m` 加载 64 位值并将 `v` 的通道 `L` 设置为该值。"],["v128_load64_splat","加载单个元素，然后将其放置到 v128 vector 的所有通道中。"],["v128_load64_zero","将 64 位元素加载到 vector 的低位并将所有其他位设置为零。"],["v128_load8_lane","从 `m` 加载一个 8 位值并将 `v` 的通道 `L` 设置为该值。"],["v128_load8_splat","加载单个元素，然后将其放置到 v128 vector 的所有通道中。"],["v128_not","翻转 128 位输入 vector 的每个位。"],["v128_or","对两个输入的 128 位 vectors 进行按位或逻辑运算，返回结果 vector。"],["v128_store","将 `v128` vector 存储到给定的堆地址。"],["v128_store16_lane","将 `v` 的通道 `L` 的 16 位值存储到 `m`"],["v128_store32_lane","将来自 `v` 的 `L` 通道的 32 位值存储到 `m`"],["v128_store64_lane","将来自 `v` 的 `L` 通道的 64 位值存储到 `m`"],["v128_store8_lane","将来自 `v` 的 `L` 通道的 8 位值存储到 `m`"],["v128_xor","对两个输入的 128 位 vectors 进行按位异或，返回结果 vector。"]],"struct":[["v128","WASM 特定的 128 位宽 SIMD vector 类型。"]]});