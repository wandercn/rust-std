<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="包装器类型，用于创建 `T` 的未初始化实例。"><meta name="keywords" content="rust, rustlang, rust-lang, MaybeUninit"><title>MaybeUninit in core::mem - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize1.55.0.css"><link rel="stylesheet" type="text/css" href="../../rustdoc1.55.0.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light1.55.0.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark1.55.0.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu1.55.0.css" disabled ><script id="default-settings"></script><script src="../../storage1.55.0.js"></script><script src="../../crates1.55.0.js"></script><noscript><link rel="stylesheet" href="../../noscript1.55.0.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon1.55.0.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x161.55.0.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x321.55.0.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow1.55.0.svg");}</style></head><body class="rustdoc union"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../core/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo1.55.0.png' alt='logo'></div></a><h2 class="location">Union MaybeUninit</h2><div class="sidebar-elems"><div class="block items"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><div class="sidebar-links"><a href="#method.array_assume_init">array_assume_init</a><a href="#method.as_mut_ptr">as_mut_ptr</a><a href="#method.as_ptr">as_ptr</a><a href="#method.assume_init">assume_init</a><a href="#method.assume_init_drop">assume_init_drop</a><a href="#method.assume_init_mut">assume_init_mut</a><a href="#method.assume_init_read">assume_init_read</a><a href="#method.assume_init_ref">assume_init_ref</a><a href="#method.new">new</a><a href="#method.slice_as_mut_ptr">slice_as_mut_ptr</a><a href="#method.slice_as_ptr">slice_as_ptr</a><a href="#method.slice_assume_init_mut">slice_assume_init_mut</a><a href="#method.slice_assume_init_ref">slice_assume_init_ref</a><a href="#method.uninit">uninit</a><a href="#method.uninit_array">uninit_array</a><a href="#method.write">write</a><a href="#method.write_slice">write_slice</a><a href="#method.write_slice_cloned">write_slice_cloned</a><a href="#method.zeroed">zeroed</a></div><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-Clone">Clone</a><a href="#impl-Copy">Copy</a><a href="#impl-Debug">Debug</a></div><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a><a href="#impl-Unpin">Unpin</a></div><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></div></div><h2 class="location">Other items in<br><a href="../index.html">core</a>::<wbr><a href="index.html">mem</a></h2><div id="sidebar-vars" data-name="MaybeUninit" data-ty="union" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img src="../../brush1.55.0.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img src="../../wheel1.55.0.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Union <a href="../index.html">core</a>::<wbr><a href="index.html">mem</a>::<wbr><a class="union" href="#">MaybeUninit</a><button id="copy-path" onclick="copy_path(this)" title="copy path"><img src="../../clipboard1.55.0.svg" width="19" height="18" alt="Copy item import" title="Copy item import to clipboard"></button></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#255-258" title="goto source code">[src]</a></span></h1><div class="docblock type-decl"><pre class="rust union">#[repr(transparent)]
pub union MaybeUninit&lt;T&gt; {
    // some fields omitted
}</pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>包装器类型，用于创建 <code>T</code> 的未初始化实例。</p>
<h1 id="初始化不变式" class="section-header"><a href="#初始化不变式">初始化不变式</a></h1>
<p>通常，编译器假定已根据变量类型的要求正确初始化了变量。例如，引用类型的变量必须对齐且非空。
即使在不安全的代码中，这也必须始终保持不变。
结果，将引用类型的变量初始化为零会导致瞬时 <a href="../../reference/behavior-considered-undefined.html">undefined behavior</a>，无论引用是否曾经被用来访问内存:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem</span>::{<span class="self">self</span>, <span class="ident">MaybeUninit</span>};

<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="ident">i32</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">mem::zeroed</span>() }; <span class="comment">// 未定义的行为! ⚠️</span>
<span class="comment">// 与 `MaybeUninit&lt;&amp;i32&gt;` 等效的代码:</span>
<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="ident">i32</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">MaybeUninit::zeroed</span>().<span class="ident">assume_init</span>() }; <span class="comment">// 未定义的行为! ⚠️</span></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(invalid_value)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3A%7Bself%2C%20MaybeUninit%7D%3B%0A%0Alet%20x%3A%20%26i32%20%3D%20unsafe%20%7B%20mem%3A%3Azeroed()%20%7D%3B%20%2F%2F%20%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA!%20%E2%9A%A0%EF%B8%8F%0A%2F%2F%20%E4%B8%8E%20%60MaybeUninit%3C%26i32%3E%60%20%E7%AD%89%E6%95%88%E7%9A%84%E4%BB%A3%E7%A0%81%3A%0Alet%20x%3A%20%26i32%20%3D%20unsafe%20%7B%20MaybeUninit%3A%3Azeroed().assume_init()%20%7D%3B%20%2F%2F%20%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA!%20%E2%9A%A0%EF%B8%8F%0A%7D&amp;edition=2018">Run</a></div>
<p>编译器将其用于各种优化，例如消除运行时检查和优化 <code>enum</code> 布局。</p>
<p>同样，完全未初始化的存储器可以包含任何内容，而 <code>bool</code> 必须始终为 <code>true</code> 或 <code>false</code>。因此，创建未初始化的 <code>bool</code> 是未定义的行为:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem</span>::{<span class="self">self</span>, <span class="ident">MaybeUninit</span>};

<span class="kw">let</span> <span class="ident">b</span>: <span class="ident">bool</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">mem::uninitialized</span>() }; <span class="comment">// 未定义的行为! ⚠️</span>
<span class="comment">// 与 `MaybeUninit&lt;bool&gt;` 等效的代码:</span>
<span class="kw">let</span> <span class="ident">b</span>: <span class="ident">bool</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">MaybeUninit::uninit</span>().<span class="ident">assume_init</span>() }; <span class="comment">// 未定义的行为! ⚠️</span></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(invalid_value)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3A%7Bself%2C%20MaybeUninit%7D%3B%0A%0Alet%20b%3A%20bool%20%3D%20unsafe%20%7B%20mem%3A%3Auninitialized()%20%7D%3B%20%2F%2F%20%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA!%20%E2%9A%A0%EF%B8%8F%0A%2F%2F%20%E4%B8%8E%20%60MaybeUninit%3Cbool%3E%60%20%E7%AD%89%E6%95%88%E7%9A%84%E4%BB%A3%E7%A0%81%3A%0Alet%20b%3A%20bool%20%3D%20unsafe%20%7B%20MaybeUninit%3A%3Auninit().assume_init()%20%7D%3B%20%2F%2F%20%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA!%20%E2%9A%A0%EF%B8%8F%0A%7D&amp;edition=2018">Run</a></div>
<p>此外，未初始化的存储器的特殊之处在于它没有固定的值 (“fixed” 表示 “it won’t change without being written to”)。多次读取相同的未初始化字节会产生不同的结果。
这使得在变量中具有未初始化的数据成为未定义的行为，即使该变量具有整数类型也可以保留任何固定位模式</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem</span>::{<span class="self">self</span>, <span class="ident">MaybeUninit</span>};

<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">mem::uninitialized</span>() }; <span class="comment">// 未定义的行为! ⚠️</span>
<span class="comment">// 与 `MaybeUninit&lt;i32&gt;` 等效的代码:</span>
<span class="kw">let</span> <span class="ident">x</span>: <span class="ident">i32</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">MaybeUninit::uninit</span>().<span class="ident">assume_init</span>() }; <span class="comment">// 未定义的行为! ⚠️</span></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Ballow(invalid_value)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3A%7Bself%2C%20MaybeUninit%7D%3B%0A%0Alet%20x%3A%20i32%20%3D%20unsafe%20%7B%20mem%3A%3Auninitialized()%20%7D%3B%20%2F%2F%20%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA!%20%E2%9A%A0%EF%B8%8F%0A%2F%2F%20%E4%B8%8E%20%60MaybeUninit%3Ci32%3E%60%20%E7%AD%89%E6%95%88%E7%9A%84%E4%BB%A3%E7%A0%81%3A%0Alet%20x%3A%20i32%20%3D%20unsafe%20%7B%20MaybeUninit%3A%3Auninit().assume_init()%20%7D%3B%20%2F%2F%20%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA!%20%E2%9A%A0%EF%B8%8F%0A%7D&amp;edition=2018">Run</a></div>
<p>(请注意，关于未初始化整数的规则尚未最终确定，但是除非被确定，否则建议避免使用它们。)</p>
<p>最重要的是，请记住，大多数类型具有其他不变式，而不仅仅是在类型级别被初始化。
例如，将 <code>1</code> 初始化的 <a href="../../std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> 视为已初始化 (在当前实现下; 这并不构成稳定的保证)，因为编译器知道的唯一要求是数据指针必须为非空值。
创建这样的 <code>Vec&lt;T&gt;</code> 不会立即导致未定义的行为，但是在大多数安全操作 (包括丢弃操作) 中都将导致未定义的行为。</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p><code>MaybeUninit&lt;T&gt;</code> 用于使不安全的代码能够处理未初始化的数据。
这是向编译器发出的信号，指示此处的数据可能不被初始化:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="comment">// 创建一个显式未初始化的引用。</span>
<span class="comment">// 编译器知道 `MaybeUninit&lt;T&gt;` 内部的数据可能无效，因此不是 UB:</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">i32</span><span class="op">&gt;</span><span class="ident">::uninit</span>();
<span class="comment">// 将其设置为有效值。</span>
<span class="ident">x</span>.<span class="ident">write</span>(<span class="kw-2">&amp;</span><span class="number">0</span>);
<span class="comment">// 提取已初始化的数据 - 仅在正确初始化 `x` 之后 * 才允许这样做!</span>
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">assume_init</span>() };</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0A%2F%2F%20%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%98%BE%E5%BC%8F%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%BC%95%E7%94%A8%E3%80%82%0A%2F%2F%20%E7%BC%96%E8%AF%91%E5%99%A8%E7%9F%A5%E9%81%93%20%60MaybeUninit%3CT%3E%60%20%E5%86%85%E9%83%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%83%BD%E6%97%A0%E6%95%88%EF%BC%8C%E5%9B%A0%E6%AD%A4%E4%B8%8D%E6%98%AF%20UB%3A%0Alet%20mut%20x%20%3D%20MaybeUninit%3A%3A%3C%26i32%3E%3A%3Auninit()%3B%0A%2F%2F%20%E5%B0%86%E5%85%B6%E8%AE%BE%E7%BD%AE%E4%B8%BA%E6%9C%89%E6%95%88%E5%80%BC%E3%80%82%0Ax.write(%260)%3B%0A%2F%2F%20%E6%8F%90%E5%8F%96%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%95%B0%E6%8D%AE%20-%20%E4%BB%85%E5%9C%A8%E6%AD%A3%E7%A1%AE%E5%88%9D%E5%A7%8B%E5%8C%96%20%60x%60%20%E4%B9%8B%E5%90%8E%20*%20%E6%89%8D%E5%85%81%E8%AE%B8%E8%BF%99%E6%A0%B7%E5%81%9A!%0Alet%20x%20%3D%20unsafe%20%7B%20x.assume_init()%20%7D%3B%0A%7D&amp;edition=2018">Run</a></div>
<p>然后，编译器知道不会对此代码进行任何错误的假设或优化。</p>
<p>您可以认为 <code>MaybeUninit&lt;T&gt;</code> 有点像 <code>Option&lt;T&gt;</code>，但是没有任何运行时跟踪且没有任何安全检查。</p>
<h2 id="out-pointers" class="section-header"><a href="#out-pointers">out-pointers</a></h2>
<p>您可以使用 <code>MaybeUninit&lt;T&gt;</code> 来实现 “out-pointers”: 与其从函数中返回数据，还不如将其传递给某个 (uninitialized) 内存的指针以将结果放入其中。
当对调用方来说，控制结果存储在内存中的分配方式很重要并且您希望避免不必要的移动时，这很有用。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">make_vec</span>(<span class="ident">out</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>) {
    <span class="comment">// `write` 不会丢弃老的内容，这一点很重要。</span>
    <span class="ident">out</span>.<span class="ident">write</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);
}

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="ident">MaybeUninit::uninit</span>();
<span class="kw">unsafe</span> { <span class="ident">make_vec</span>(<span class="ident">v</span>.<span class="ident">as_mut_ptr</span>()); }
<span class="comment">// 现在我们知道 `v` 已初始化! 这也可以确保正确丢弃 vector。</span>
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">v</span>.<span class="ident">assume_init</span>() };
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">v</span>, <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Aunsafe%20fn%20make_vec(out%3A%20*mut%20Vec%3Ci32%3E)%20%7B%0A%20%20%20%20%2F%2F%20%60write%60%20%E4%B8%8D%E4%BC%9A%E4%B8%A2%E5%BC%83%E8%80%81%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E8%BF%99%E4%B8%80%E7%82%B9%E5%BE%88%E9%87%8D%E8%A6%81%E3%80%82%0A%20%20%20%20out.write(vec!%5B1%2C%202%2C%203%5D)%3B%0A%7D%0A%0Alet%20mut%20v%20%3D%20MaybeUninit%3A%3Auninit()%3B%0Aunsafe%20%7B%20make_vec(v.as_mut_ptr())%3B%20%7D%0A%2F%2F%20%E7%8E%B0%E5%9C%A8%E6%88%91%E4%BB%AC%E7%9F%A5%E9%81%93%20%60v%60%20%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96!%20%E8%BF%99%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%A1%AE%E4%BF%9D%E6%AD%A3%E7%A1%AE%E4%B8%A2%E5%BC%83%20vector%E3%80%82%0Alet%20v%20%3D%20unsafe%20%7B%20v.assume_init()%20%7D%3B%0Aassert_eq!(%26v%2C%20%26%5B1%2C%202%2C%203%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
<h2 id="逐元素初始化数组" class="section-header"><a href="#逐元素初始化数组">逐元素初始化数组</a></h2>
<p><code>MaybeUninit&lt;T&gt;</code> 可用于按元素初始化大型数组:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem</span>::{<span class="self">self</span>, <span class="ident">MaybeUninit</span>};

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> {
    <span class="comment">// 创建一个未初始化的 `MaybeUninit` 数组。</span>
    <span class="comment">// `assume_init` 是安全的，因为我们声称这里已经初始化的类型是一堆 `MaybeUninit`，不需要初始化。</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span>: [<span class="ident">MaybeUninit</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span>; <span class="number">1000</span>] <span class="op">=</span> <span class="kw">unsafe</span> {
        <span class="ident">MaybeUninit::uninit</span>().<span class="ident">assume_init</span>()
    };

    <span class="comment">// 丢弃 `MaybeUninit` 不会执行任何操作。</span>
    <span class="comment">// 因此，使用裸指针分配代替 `ptr::write` 不会导致旧的未初始化值被丢弃。</span>
    <span class="comment">// 此外，如果在此循环期间存在 panic，则可能会发生内存泄漏，但不会出现内存安全问题。</span>
    <span class="kw">for</span> <span class="ident">elem</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">data</span>[..] {
        <span class="ident">elem</span>.<span class="ident">write</span>(<span class="macro">vec!</span>[<span class="number">42</span>]);
    }

    <span class="comment">// 一切都已初始化。</span>
    <span class="comment">// 将数组转换为初始化的类型。</span>
    <span class="kw">unsafe</span> { <span class="ident">mem::transmute</span>::<span class="op">&lt;</span><span class="kw">_</span>, [<span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>; <span class="number">1000</span>]<span class="op">&gt;</span>(<span class="ident">data</span>) }
};

<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">data</span>[<span class="number">0</span>], <span class="kw-2">&amp;</span>[<span class="number">42</span>]);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3A%7Bself%2C%20MaybeUninit%7D%3B%0A%0Alet%20data%20%3D%20%7B%0A%20%20%20%20%2F%2F%20%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%20%60MaybeUninit%60%20%E6%95%B0%E7%BB%84%E3%80%82%0A%20%20%20%20%2F%2F%20%60assume_init%60%20%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%88%91%E4%BB%AC%E5%A3%B0%E7%A7%B0%E8%BF%99%E9%87%8C%E5%B7%B2%E7%BB%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%B8%80%E5%A0%86%20%60MaybeUninit%60%EF%BC%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82%0A%20%20%20%20let%20mut%20data%3A%20%5BMaybeUninit%3CVec%3Cu32%3E%3E%3B%201000%5D%20%3D%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20MaybeUninit%3A%3Auninit().assume_init()%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20%2F%2F%20%E4%B8%A2%E5%BC%83%20%60MaybeUninit%60%20%E4%B8%8D%E4%BC%9A%E6%89%A7%E8%A1%8C%E4%BB%BB%E4%BD%95%E6%93%8D%E4%BD%9C%E3%80%82%0A%20%20%20%20%2F%2F%20%E5%9B%A0%E6%AD%A4%EF%BC%8C%E4%BD%BF%E7%94%A8%E8%A3%B8%E6%8C%87%E9%92%88%E5%88%86%E9%85%8D%E4%BB%A3%E6%9B%BF%20%60ptr%3A%3Awrite%60%20%E4%B8%8D%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%97%A7%E7%9A%84%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%80%BC%E8%A2%AB%E4%B8%A2%E5%BC%83%E3%80%82%0A%20%20%20%20%2F%2F%20%E6%AD%A4%E5%A4%96%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%9C%A8%E6%AD%A4%E5%BE%AA%E7%8E%AF%E6%9C%9F%E9%97%B4%E5%AD%98%E5%9C%A8%20panic%EF%BC%8C%E5%88%99%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%8C%E4%BD%86%E4%B8%8D%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E3%80%82%0A%20%20%20%20for%20elem%20in%20%26mut%20data%5B..%5D%20%7B%0A%20%20%20%20%20%20%20%20elem.write(vec!%5B42%5D)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20%E4%B8%80%E5%88%87%E9%83%BD%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82%0A%20%20%20%20%2F%2F%20%E5%B0%86%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E7%B1%BB%E5%9E%8B%E3%80%82%0A%20%20%20%20unsafe%20%7B%20mem%3A%3Atransmute%3A%3A%3C_%2C%20%5BVec%3Cu32%3E%3B%201000%5D%3E(data)%20%7D%0A%7D%3B%0A%0Aassert_eq!(%26data%5B0%5D%2C%20%26%5B42%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
<p>您也可以使用部分初始化的数组，这些数组可以在不稳定的数据结构中找到。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;
<span class="kw">use</span> <span class="ident">std::ptr</span>;

<span class="comment">// 创建一个未初始化的 `MaybeUninit` 数组。</span>
<span class="comment">// `assume_init` 是安全的，因为我们声称这里已经初始化的类型是一堆 `MaybeUninit`，不需要初始化。</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span>: [<span class="ident">MaybeUninit</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>; <span class="number">1000</span>] <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">MaybeUninit::uninit</span>().<span class="ident">assume_init</span>() };
<span class="comment">// 计算我们分配的元素数。</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data_len</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">0</span>;

<span class="kw">for</span> <span class="ident">elem</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">data</span>[<span class="number">0</span>..<span class="number">500</span>] {
    <span class="ident">elem</span>.<span class="ident">write</span>(<span class="ident">String::from</span>(<span class="string">&quot;hello&quot;</span>));
    <span class="ident">data_len</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
}

<span class="comment">// 对于数组中的每个项，如果我们分配了它，则将其丢弃。</span>
<span class="kw">for</span> <span class="ident">elem</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">data</span>[<span class="number">0</span>..<span class="ident">data_len</span>] {
    <span class="kw">unsafe</span> { <span class="ident">ptr::drop_in_place</span>(<span class="ident">elem</span>.<span class="ident">as_mut_ptr</span>()); }
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0Ause%20std%3A%3Aptr%3B%0A%0A%2F%2F%20%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%20%60MaybeUninit%60%20%E6%95%B0%E7%BB%84%E3%80%82%0A%2F%2F%20%60assume_init%60%20%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%88%91%E4%BB%AC%E5%A3%B0%E7%A7%B0%E8%BF%99%E9%87%8C%E5%B7%B2%E7%BB%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%B8%80%E5%A0%86%20%60MaybeUninit%60%EF%BC%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82%0Alet%20mut%20data%3A%20%5BMaybeUninit%3CString%3E%3B%201000%5D%20%3D%20unsafe%20%7B%20MaybeUninit%3A%3Auninit().assume_init()%20%7D%3B%0A%2F%2F%20%E8%AE%A1%E7%AE%97%E6%88%91%E4%BB%AC%E5%88%86%E9%85%8D%E7%9A%84%E5%85%83%E7%B4%A0%E6%95%B0%E3%80%82%0Alet%20mut%20data_len%3A%20usize%20%3D%200%3B%0A%0Afor%20elem%20in%20%26mut%20data%5B0..500%5D%20%7B%0A%20%20%20%20elem.write(String%3A%3Afrom(%22hello%22))%3B%0A%20%20%20%20data_len%20%2B%3D%201%3B%0A%7D%0A%0A%2F%2F%20%E5%AF%B9%E4%BA%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%AA%E9%A1%B9%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E5%88%86%E9%85%8D%E4%BA%86%E5%AE%83%EF%BC%8C%E5%88%99%E5%B0%86%E5%85%B6%E4%B8%A2%E5%BC%83%E3%80%82%0Afor%20elem%20in%20%26mut%20data%5B0..data_len%5D%20%7B%0A%20%20%20%20unsafe%20%7B%20ptr%3A%3Adrop_in_place(elem.as_mut_ptr())%3B%20%7D%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<h2 id="逐场初始化结构体" class="section-header"><a href="#逐场初始化结构体">逐场初始化结构体</a></h2>
<p>您可以使用 <code>MaybeUninit&lt;T&gt;</code> 和 <a href="../ptr/macro.addr_of_mut.html"><code>std::ptr::addr_of_mut</code></a> 宏来逐字段初始化结构体:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;
<span class="kw">use</span> <span class="ident">std::ptr::addr_of_mut</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Foo</span> {
    <span class="ident">name</span>: <span class="ident">String</span>,
    <span class="ident">list</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>,
}

<span class="kw">let</span> <span class="ident">foo</span> <span class="op">=</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">uninit</span>: <span class="ident">MaybeUninit</span><span class="op">&lt;</span><span class="ident">Foo</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">MaybeUninit::uninit</span>();
    <span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">uninit</span>.<span class="ident">as_mut_ptr</span>();

    <span class="comment">// 初始化 `name` 字段 使用 `write` 而不是通过 `=` 赋值，而不是在旧的、未初始化的值上调用 `drop`。</span>
    <span class="kw">unsafe</span> { <span class="macro">addr_of_mut!</span>((<span class="kw-2">*</span><span class="ident">ptr</span>).<span class="ident">name</span>).<span class="ident">write</span>(<span class="string">&quot;Bob&quot;</span>.<span class="ident">to_string</span>()); }

    <span class="comment">// 初始化 `list` 字段如果此处存在 panic，则 `name` 字段中的 `String` 泄漏。</span>
    <span class="kw">unsafe</span> { <span class="macro">addr_of_mut!</span>((<span class="kw-2">*</span><span class="ident">ptr</span>).<span class="ident">list</span>).<span class="ident">write</span>(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]); }

    <span class="comment">// 所有字段都已初始化，因此我们调用 `assume_init` 来获取已初始化的 Foo。</span>
    <span class="kw">unsafe</span> { <span class="ident">uninit</span>.<span class="ident">assume_init</span>() }
};

<span class="macro">assert_eq!</span>(
    <span class="ident">foo</span>,
    <span class="ident">Foo</span> {
        <span class="ident">name</span>: <span class="string">&quot;Bob&quot;</span>.<span class="ident">to_string</span>(),
        <span class="ident">list</span>: <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]
    }
);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0Ause%20std%3A%3Aptr%3A%3Aaddr_of_mut%3B%0A%0A%23%5Bderive(Debug%2C%20PartialEq)%5D%0Apub%20struct%20Foo%20%7B%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20list%3A%20Vec%3Cu8%3E%2C%0A%7D%0A%0Alet%20foo%20%3D%20%7B%0A%20%20%20%20let%20mut%20uninit%3A%20MaybeUninit%3CFoo%3E%20%3D%20MaybeUninit%3A%3Auninit()%3B%0A%20%20%20%20let%20ptr%20%3D%20uninit.as_mut_ptr()%3B%0A%0A%20%20%20%20%2F%2F%20%E5%88%9D%E5%A7%8B%E5%8C%96%20%60name%60%20%E5%AD%97%E6%AE%B5%20%E4%BD%BF%E7%94%A8%20%60write%60%20%E8%80%8C%E4%B8%8D%E6%98%AF%E9%80%9A%E8%BF%87%20%60%3D%60%20%E8%B5%8B%E5%80%BC%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%9C%A8%E6%97%A7%E7%9A%84%E3%80%81%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%80%BC%E4%B8%8A%E8%B0%83%E7%94%A8%20%60drop%60%E3%80%82%0A%20%20%20%20unsafe%20%7B%20addr_of_mut!((*ptr).name).write(%22Bob%22.to_string())%3B%20%7D%0A%0A%20%20%20%20%2F%2F%20%E5%88%9D%E5%A7%8B%E5%8C%96%20%60list%60%20%E5%AD%97%E6%AE%B5%E5%A6%82%E6%9E%9C%E6%AD%A4%E5%A4%84%E5%AD%98%E5%9C%A8%20panic%EF%BC%8C%E5%88%99%20%60name%60%20%E5%AD%97%E6%AE%B5%E4%B8%AD%E7%9A%84%20%60String%60%20%E6%B3%84%E6%BC%8F%E3%80%82%0A%20%20%20%20unsafe%20%7B%20addr_of_mut!((*ptr).list).write(vec!%5B0%2C%201%2C%202%5D)%3B%20%7D%0A%0A%20%20%20%20%2F%2F%20%E6%89%80%E6%9C%89%E5%AD%97%E6%AE%B5%E9%83%BD%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E5%9B%A0%E6%AD%A4%E6%88%91%E4%BB%AC%E8%B0%83%E7%94%A8%20%60assume_init%60%20%E6%9D%A5%E8%8E%B7%E5%8F%96%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%20Foo%E3%80%82%0A%20%20%20%20unsafe%20%7B%20uninit.assume_init()%20%7D%0A%7D%3B%0A%0Aassert_eq!(%0A%20%20%20%20foo%2C%0A%20%20%20%20Foo%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20%22Bob%22.to_string()%2C%0A%20%20%20%20%20%20%20%20list%3A%20vec!%5B0%2C%201%2C%202%5D%0A%20%20%20%20%7D%0A)%3B%0A%7D&amp;edition=2018">Run</a></div>
<h1 id="layout" class="section-header"><a href="#layout">Layout</a></h1>
<p><code>MaybeUninit&lt;T&gt;</code> 保证具有与 <code>T</code> 相同的大小，对齐方式和 ABI:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem</span>::{<span class="ident">MaybeUninit</span>, <span class="ident">size_of</span>, <span class="ident">align_of</span>};
<span class="macro">assert_eq!</span>(<span class="ident">size_of</span>::<span class="op">&lt;</span><span class="ident">MaybeUninit</span><span class="op">&lt;</span><span class="ident">u64</span><span class="op">&gt;</span><span class="op">&gt;</span>(), <span class="ident">size_of</span>::<span class="op">&lt;</span><span class="ident">u64</span><span class="op">&gt;</span>());
<span class="macro">assert_eq!</span>(<span class="ident">align_of</span>::<span class="op">&lt;</span><span class="ident">MaybeUninit</span><span class="op">&lt;</span><span class="ident">u64</span><span class="op">&gt;</span><span class="op">&gt;</span>(), <span class="ident">align_of</span>::<span class="op">&lt;</span><span class="ident">u64</span><span class="op">&gt;</span>());</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3A%7BMaybeUninit%2C%20size_of%2C%20align_of%7D%3B%0Aassert_eq!(size_of%3A%3A%3CMaybeUninit%3Cu64%3E%3E()%2C%20size_of%3A%3A%3Cu64%3E())%3B%0Aassert_eq!(align_of%3A%3A%3CMaybeUninit%3Cu64%3E%3E()%2C%20align_of%3A%3A%3Cu64%3E())%3B%0A%7D&amp;edition=2018">Run</a></div>
<p>但是请记住，<em>包含</em><code>MaybeUninit&lt;T&gt;</code> 的类型不一定是相同的布局。Rust 通常不保证 <code>Foo&lt;T&gt;</code> 的字段具有与 <code>Foo&lt;U&gt;</code> 相同的顺序，即使 <code>T</code> 和 <code>U</code> 具有相同的大小和对齐方式。</p>
<p>此外，由于任何位值对于 <code>MaybeUninit&lt;T&gt;</code> 都是有效的，因此编译器无法应用 non-zero/niche-filling 优化，从而可能导致更大的大小:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq!</span>(<span class="ident">size_of</span>::<span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span><span class="op">&gt;</span>(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(<span class="ident">size_of</span>::<span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">MaybeUninit</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>(), <span class="number">2</span>);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3A%7BMaybeUninit%2C%20size_of%7D%3B%0Aassert_eq!(size_of%3A%3A%3COption%3Cbool%3E%3E()%2C%201)%3B%0Aassert_eq!(size_of%3A%3A%3COption%3CMaybeUninit%3Cbool%3E%3E%3E()%2C%202)%3B%0A%7D&amp;edition=2018">Run</a></div>
<p>如果 <code>T</code> 是 FFI 安全的，则 <code>MaybeUninit&lt;T&gt;</code> 也是如此。</p>
<p>虽然 <code>MaybeUninit</code> 是 <code>#[repr(transparent)]</code> (表示它保证与 <code>T</code> 相同的大小，对齐方式和 ABI)，但是这 <em>不会</em> 更改任何先前的警告。
<code>Option&lt;T&gt;</code> 和 <code>Option&lt;MaybeUninit&lt;T&gt;&gt;</code> 可能仍具有不同的大小，并且包含 <code>T</code> 类型的字段的类型的布局 (和大小) 可能与该字段为 <code>MaybeUninit&lt;T&gt;</code> 的情况不同。
<code>MaybeUninit</code> 是一个是联合类型，并且 union 上的 <code>#[repr(transparent)]</code> 是不稳定的 (请参见 <a href="https://github.com/rust-lang/rust/issues/60405">跟踪问题</a>)。
随着时间的推移，对 union 的 <code>#[repr(transparent)]</code> 的确切保证可能会发生变化，并且 <code>MaybeUninit</code> 可能会或可能不会保留 <code>#[repr(transparent)]</code>。
就是说，<code>MaybeUninit&lt;T&gt;</code> 将总是保证它具有与 <code>T</code> 有相同的大小、对齐方式和 ABI; 只是 <code>MaybeUninit</code> 实现保证的方式可能会演变。</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h3><a href="#impl" class="anchor"></a><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#276-1158" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.new" class="method has-srclink"><h4 class="code-header">pub const fn <a href="#method.new" class="fnname">new</a>(val: T) -&gt; <a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h4><span class="since" title="Stable since Rust version 1.36.0, const since 1.36.0">1.36.0 (const: 1.36.0)</span><a href="#method.new" class="anchor"></a><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#295-297" title="goto source code">[src]</a></div></summary><div class="docblock"><p>创建一个使用给定值初始化的新 <code>MaybeUninit&lt;T&gt;</code>。
在此函数的返回值上调用 <a href="union.MaybeUninit.html#method.assume_init"><code>assume_init</code></a> 是安全的。</p>
<p>注意，丢弃 <code>MaybeUninit&lt;T&gt;</code> 永远不会调用 T 的丢弃代码。
确保 <code>T</code> 在初始化时被丢弃是您的责任。</p>
<h1 id="example" class="section-header"><a href="#example">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">MaybeUninit</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">MaybeUninit::new</span>(<span class="macro">vec!</span>[<span class="number">42</span>]);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Alet%20v%3A%20MaybeUninit%3CVec%3Cu8%3E%3E%20%3D%20MaybeUninit%3A%3Anew(vec!%5B42%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.uninit" class="method has-srclink"><h4 class="code-header">pub const fn <a href="#method.uninit" class="fnname">uninit</a>() -&gt; <a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h4><span class="since" title="Stable since Rust version 1.36.0, const since 1.36.0">1.36.0 (const: 1.36.0)</span><a href="#method.uninit" class="anchor"></a><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#317-319" title="goto source code">[src]</a></div></summary><div class="docblock"><p>以未初始化的状态创建一个新的 <code>MaybeUninit&lt;T&gt;</code>。</p>
<p>注意，丢弃 <code>MaybeUninit&lt;T&gt;</code> 永远不会调用 T 的丢弃代码。
确保 <code>T</code> 在初始化时被丢弃是您的责任。</p>
<p>有关一些示例，请参见 <a href="union.MaybeUninit.html" title="MaybeUninit">类型级文档</a>。</p>
<h1 id="example-1" class="section-header"><a href="#example-1">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">MaybeUninit</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">MaybeUninit::uninit</span>();</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Alet%20v%3A%20MaybeUninit%3CString%3E%20%3D%20MaybeUninit%3A%3Auninit()%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.uninit_array" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.uninit_array" class="fnname">uninit_array</a>&lt;const LEN:&nbsp;usize&gt;() -&gt; [Self; LEN]</h4><a href="#method.uninit_array" class="anchor"></a><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#353-356" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>maybe_uninit_uninit_array</code>)</div></div></summary><div class="docblock"><p>在未初始化状态下创建 <code>MaybeUninit&lt;T&gt;</code> 项的新数组。</p>
<p>Note: 在 future Rust 版本中，当 Rust 允许 <a href="https://github.com/rust-lang/rust/issues/76001">inline const expressions</a> 时，此方法可能变得不必要。</p>
<p>下面的示例可以使用 <code>let mut buf = [const { MaybeUninit::&lt;u8&gt;::uninit() }; 32];</code>。</p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">maybe_uninit_uninit_array</span>, <span class="ident">maybe_uninit_extra</span>, <span class="ident">maybe_uninit_slice</span>)]</span>

<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">extern</span> <span class="string">&quot;C&quot;</span> {
    <span class="kw">fn</span> <span class="ident">read_into_buffer</span>(<span class="ident">ptr</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span>, <span class="ident">max_len</span>: <span class="ident">usize</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">usize</span>;
}

<span class="doccomment">/// 返回实际读取的 (可能较小的) 数据切片</span>
<span class="kw">fn</span> <span class="ident">read</span>(<span class="ident">buf</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">MaybeUninit</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>]) <span class="op">-</span><span class="op">&gt;</span> <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] {
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="ident">len</span> <span class="op">=</span> <span class="ident">read_into_buffer</span>(<span class="ident">buf</span>.<span class="ident">as_mut_ptr</span>() <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span>, <span class="ident">buf</span>.<span class="ident">len</span>());
        <span class="ident">MaybeUninit::slice_assume_init_ref</span>(<span class="kw-2">&amp;</span><span class="ident">buf</span>[..<span class="ident">len</span>])
    }
}

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span>: [<span class="ident">MaybeUninit</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>; <span class="number">32</span>] <span class="op">=</span> <span class="ident">MaybeUninit::uninit_array</span>();
<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="ident">read</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buf</span>);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_uninit_array%2C%20maybe_uninit_extra%2C%20maybe_uninit_slice)%5D%0A%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Aextern%20%22C%22%20%7B%0A%20%20%20%20fn%20read_into_buffer(ptr%3A%20*mut%20u8%2C%20max_len%3A%20usize)%20-%3E%20usize%3B%0A%7D%0A%0A%2F%2F%2F%20%E8%BF%94%E5%9B%9E%E5%AE%9E%E9%99%85%E8%AF%BB%E5%8F%96%E7%9A%84%20(%E5%8F%AF%E8%83%BD%E8%BE%83%E5%B0%8F%E7%9A%84)%20%E6%95%B0%E6%8D%AE%E5%88%87%E7%89%87%0Afn%20read(buf%3A%20%26mut%20%5BMaybeUninit%3Cu8%3E%5D)%20-%3E%20%26%5Bu8%5D%20%7B%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20let%20len%20%3D%20read_into_buffer(buf.as_mut_ptr()%20as%20*mut%20u8%2C%20buf.len())%3B%0A%20%20%20%20%20%20%20%20MaybeUninit%3A%3Aslice_assume_init_ref(%26buf%5B..len%5D)%0A%20%20%20%20%7D%0A%7D%0A%0Alet%20mut%20buf%3A%20%5BMaybeUninit%3Cu8%3E%3B%2032%5D%20%3D%20MaybeUninit%3A%3Auninit_array()%3B%0Alet%20data%20%3D%20read(%26mut%20buf)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.zeroed" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.zeroed" class="fnname">zeroed</a>() -&gt; <a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h4><a href="#method.zeroed" class="anchor"></a><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#396-403" title="goto source code">[src]</a></div></summary><div class="docblock"><p>在未初始化状态下创建新的 <code>MaybeUninit&lt;T&gt;</code>，并用 <code>0</code> 字节填充内存。取决于 <code>T</code> 是否已经进行了正确的初始化。</p>
<p>例如，初始化 <code>MaybeUninit&lt;usize&gt;::zeroed()</code>，但不初始化 <code>MaybeUninit&lt;&amp;'static i32&gt;::zeroed()</code>，因为引用不能为空。</p>
<p>注意，丢弃 <code>MaybeUninit&lt;T&gt;</code> 永远不会调用 T 的丢弃代码。
确保 <code>T</code> 在初始化时被丢弃是您的责任。</p>
<h1 id="example-2" class="section-header"><a href="#example-2">Example</a></h1>
<p>此函数的正确用法: 用零初始化结构体，其中结构体的所有字段都可以将位模式 0 保留为有效值。</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span>(<span class="ident">u8</span>, <span class="ident">bool</span>)<span class="op">&gt;</span><span class="ident">::zeroed</span>();
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">assume_init</span>() };
<span class="macro">assert_eq!</span>(<span class="ident">x</span>, (<span class="number">0</span>, <span class="bool-val">false</span>));</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Alet%20x%20%3D%20MaybeUninit%3A%3A%3C(u8%2C%20bool)%3E%3A%3Azeroed()%3B%0Alet%20x%20%3D%20unsafe%20%7B%20x.assume_init()%20%7D%3B%0Aassert_eq!(x%2C%20(0%2C%20false))%3B%0A%7D&amp;edition=2018">Run</a></div>
<p>该函数的 <em>错误</em> 用法: 当 <code>0</code> 不是该类型的有效位模式时，调用 <code>x.zeroed().assume_init()</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">enum</span> <span class="ident">NotZero</span> { <span class="ident">One</span> <span class="op">=</span> <span class="number">1</span>, <span class="ident">Two</span> <span class="op">=</span> <span class="number">2</span> }

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span>(<span class="ident">u8</span>, <span class="ident">NotZero</span>)<span class="op">&gt;</span><span class="ident">::zeroed</span>();
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">assume_init</span>() };
<span class="comment">// 在一个对中，我们创建一个没有有效判别式的 `NotZero`。</span>
<span class="comment">// 这是未定义的行为。⚠️</span></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Aenum%20NotZero%20%7B%20One%20%3D%201%2C%20Two%20%3D%202%20%7D%0A%0Alet%20x%20%3D%20MaybeUninit%3A%3A%3C(u8%2C%20NotZero)%3E%3A%3Azeroed()%3B%0Alet%20x%20%3D%20unsafe%20%7B%20x.assume_init()%20%7D%3B%0A%2F%2F%20%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%AF%B9%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%E6%9C%89%E6%95%88%E5%88%A4%E5%88%AB%E5%BC%8F%E7%9A%84%20%60NotZero%60%E3%80%82%0A%2F%2F%20%E8%BF%99%E6%98%AF%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%E3%80%82%E2%9A%A0%EF%B8%8F%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.write" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.write" class="fnname">write</a>(&amp;mut self, val: T) -&gt; &amp;mut T</h4><span class="since" title="Stable since Rust version 1.55.0">1.55.0</span><a href="#method.write" class="anchor"></a><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#490-494" title="goto source code">[src]</a></div></summary><div class="docblock"><p>设置 <code>MaybeUninit&lt;T&gt;</code> 的值。</p>
<p>这将覆盖任何先前的值而不将其丢弃，因此请注意不要重复使用此两次，除非您要跳过运行析构函数。
为了您的方便，这也将 <code>self</code> 的内容 (现在已安全初始化) 返回变量引用。</p>
<p>由于内容存储在 <code>MaybeUninit</code> 中，如果 MaybeUninit 离开作用域而没有调用到 <a href="union.MaybeUninit.html#method.assume_init"><code>assume_init</code></a>、<a href="union.MaybeUninit.html#method.assume_init_drop"><code>assume_init_drop</code></a> 或类似对象，则不会为内部数据运行析构函数。
接收这个函数返回的附属引用引用的代码需要记住这一点。
Rust 的安全模型认为泄漏是安全的，但它们通常仍然是不可取的。
话虽这么说，但借用引用与其他任何一个借用引用一样，因此为其赋予新的值将摒弃旧的内容。</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<p>正确使用此方法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="ident">::uninit</span>();

{
    <span class="kw">let</span> <span class="ident">hello</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">write</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;Hello, world!&quot;</span>).<span class="ident">to_vec</span>());
    <span class="comment">// 设置 hello 不会预先分配，但不会泄漏它们</span>
    <span class="kw-2">*</span><span class="ident">hello</span> <span class="op">=</span> (<span class="kw-2">&amp;</span><span class="string">b&quot;Hello&quot;</span>).<span class="ident">to_vec</span>();
    <span class="ident">hello</span>[<span class="number">0</span>] <span class="op">=</span> <span class="string">&#39;h&#39;</span> <span class="kw">as</span> <span class="ident">u8</span>;
}
<span class="comment">// x 现在初始化:</span>
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">assume_init</span>() };
<span class="macro">assert_eq!</span>(<span class="string">b&quot;hello&quot;</span>, <span class="ident">s</span>.<span class="ident">as_slice</span>());</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Alet%20mut%20x%20%3D%20MaybeUninit%3A%3A%3CVec%3Cu8%3E%3E%3A%3Auninit()%3B%0A%0A%7B%0A%20%20%20%20let%20hello%20%3D%20x.write((%26b%22Hello%2C%20world!%22).to_vec())%3B%0A%20%20%20%20%2F%2F%20%E8%AE%BE%E7%BD%AE%20hello%20%E4%B8%8D%E4%BC%9A%E9%A2%84%E5%85%88%E5%88%86%E9%85%8D%EF%BC%8C%E4%BD%86%E4%B8%8D%E4%BC%9A%E6%B3%84%E6%BC%8F%E5%AE%83%E4%BB%AC%0A%20%20%20%20*hello%20%3D%20(%26b%22Hello%22).to_vec()%3B%0A%20%20%20%20hello%5B0%5D%20%3D%20'h'%20as%20u8%3B%0A%7D%0A%2F%2F%20x%20%E7%8E%B0%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96%3A%0Alet%20s%20%3D%20unsafe%20%7B%20x.assume_init()%20%7D%3B%0Aassert_eq!(b%22hello%22%2C%20s.as_slice())%3B%0A%7D&amp;edition=2018">Run</a></div>
<p>该方法的这种用法会导致泄漏:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span><span class="ident">::uninit</span>();

<span class="ident">x</span>.<span class="ident">write</span>(<span class="string">&quot;Hello&quot;</span>.<span class="ident">to_string</span>());
<span class="comment">// 这会泄漏包含的字符串:</span>
<span class="ident">x</span>.<span class="ident">write</span>(<span class="string">&quot;hello&quot;</span>.<span class="ident">to_string</span>());
<span class="comment">// x 现在初始化:</span>
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">assume_init</span>() };</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Alet%20mut%20x%20%3D%20MaybeUninit%3A%3A%3CString%3E%3A%3Auninit()%3B%0A%0Ax.write(%22Hello%22.to_string())%3B%0A%2F%2F%20%E8%BF%99%E4%BC%9A%E6%B3%84%E6%BC%8F%E5%8C%85%E5%90%AB%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%3A%0Ax.write(%22hello%22.to_string())%3B%0A%2F%2F%20x%20%E7%8E%B0%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96%3A%0Alet%20s%20%3D%20unsafe%20%7B%20x.assume_init()%20%7D%3B%0A%7D&amp;edition=2018">Run</a></div>
<p>这种方法可以用来避免在某些情况下不安全。下面的例子展示了一个固定大小的 arena 实现的一部分，它提供了固定的引用。
有了 <code>write</code>，我们就可以避免通过裸指针路径来写:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">maybe_uninit_extra</span>)]</span>
<span class="kw">use</span> <span class="ident">core::pin::Pin</span>;
<span class="kw">use</span> <span class="ident">core::mem::MaybeUninit</span>;

<span class="kw">struct</span> <span class="ident">PinArena</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
    <span class="ident">memory</span>: <span class="ident">Box</span><span class="op">&lt;</span>[<span class="ident">MaybeUninit</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>]<span class="op">&gt;</span>,
    <span class="ident">len</span>: <span class="ident">usize</span>,
}

<span class="kw">impl</span> <span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">PinArena</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">capacity</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">usize</span> {
        <span class="self">self</span>.<span class="ident">memory</span>.<span class="ident">len</span>()
    }
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">push</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">val</span>: <span class="ident">T</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">Pin</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">T</span><span class="op">&gt;</span> {
        <span class="kw">if</span> <span class="self">self</span>.<span class="ident">len</span> <span class="op">&gt;</span><span class="op">=</span> <span class="self">self</span>.<span class="ident">capacity</span>() {
            <span class="macro">panic!</span>(<span class="string">&quot;Attempted to push to a full pin arena!&quot;</span>);
        }
        <span class="kw">let</span> <span class="ident">ref_</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">memory</span>[<span class="self">self</span>.<span class="ident">len</span>].<span class="ident">write</span>(<span class="ident">val</span>);
        <span class="self">self</span>.<span class="ident">len</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
        <span class="kw">unsafe</span> { <span class="ident">Pin::new_unchecked</span>(<span class="ident">ref_</span>) }
    }
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_extra)%5D%0Aextern%20crate%20r%23core%3B%0Afn%20main()%20%7B%0Ause%20core%3A%3Apin%3A%3APin%3B%0Ause%20core%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Astruct%20PinArena%3CT%3E%20%7B%0A%20%20%20%20memory%3A%20Box%3C%5BMaybeUninit%3CT%3E%5D%3E%2C%0A%20%20%20%20len%3A%20usize%2C%0A%7D%0A%0Aimpl%20%3CT%3E%20PinArena%3CT%3E%20%7B%0A%20%20%20%20pub%20fn%20capacity(%26self)%20-%3E%20usize%20%7B%0A%20%20%20%20%20%20%20%20self.memory.len()%0A%20%20%20%20%7D%0A%20%20%20%20pub%20fn%20push(%26mut%20self%2C%20val%3A%20T)%20-%3E%20Pin%3C%26mut%20T%3E%20%7B%0A%20%20%20%20%20%20%20%20if%20self.len%20%3E%3D%20self.capacity()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20panic!(%22Attempted%20to%20push%20to%20a%20full%20pin%20arena!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20let%20ref_%20%3D%20self.memory%5Bself.len%5D.write(val)%3B%0A%20%20%20%20%20%20%20%20self.len%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20unsafe%20%7B%20Pin%3A%3Anew_unchecked(ref_)%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_ptr" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.as_ptr" class="fnname">as_ptr</a>(&amp;self) -&gt; *const T</h4><a href="#method.as_ptr" class="anchor"></a><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#530-533" title="goto source code">[src]</a></div></summary><div class="docblock"><p>获取指向包含值的指针。
除非初始化 <code>MaybeUninit&lt;T&gt;</code>，否则从该指针读取或将其转换为 quot 是未定义的行为。
写入该指针 (non-transitively) 指向的内存是未定义的行为 (<code>UnsafeCell&lt;T&gt;</code> 内部除外)。</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<p>正确使用此方法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="ident">::uninit</span>();
<span class="ident">x</span>.<span class="ident">write</span>(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);
<span class="comment">// 在 `MaybeUninit&lt;T&gt;` 中创建引用。可以，因为我们已将其初始化。</span>
<span class="kw">let</span> <span class="ident">x_vec</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">x</span>.<span class="ident">as_ptr</span>() };
<span class="macro">assert_eq!</span>(<span class="ident">x_vec</span>.<span class="ident">len</span>(), <span class="number">3</span>);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Alet%20mut%20x%20%3D%20MaybeUninit%3A%3A%3CVec%3Cu32%3E%3E%3A%3Auninit()%3B%0Ax.write(vec!%5B0%2C%201%2C%202%5D)%3B%0A%2F%2F%20%E5%9C%A8%20%60MaybeUninit%3CT%3E%60%20%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%BC%95%E7%94%A8%E3%80%82%E5%8F%AF%E4%BB%A5%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%88%91%E4%BB%AC%E5%B7%B2%E5%B0%86%E5%85%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82%0Alet%20x_vec%20%3D%20unsafe%20%7B%20%26*x.as_ptr()%20%7D%3B%0Aassert_eq!(x_vec.len()%2C%203)%3B%0A%7D&amp;edition=2018">Run</a></div>
<p>这个方法的错误用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="ident">::uninit</span>();
<span class="kw">let</span> <span class="ident">x_vec</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">x</span>.<span class="ident">as_ptr</span>() };
<span class="comment">// 我们创建了对未初始化的 vector 的引用! 这是未定义的行为。⚠️</span></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Alet%20x%20%3D%20MaybeUninit%3A%3A%3CVec%3Cu32%3E%3E%3A%3Auninit()%3B%0Alet%20x_vec%20%3D%20unsafe%20%7B%20%26*x.as_ptr()%20%7D%3B%0A%2F%2F%20%E6%88%91%E4%BB%AC%E5%88%9B%E5%BB%BA%E4%BA%86%E5%AF%B9%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%20vector%20%E7%9A%84%E5%BC%95%E7%94%A8!%20%E8%BF%99%E6%98%AF%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%E3%80%82%E2%9A%A0%EF%B8%8F%0A%7D&amp;edition=2018">Run</a></div>
<p>(请注意，围绕未初始化数据引用的规则尚未最终确定，但是除非被确定，否则建议避免使用它们。)</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_mut_ptr" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.as_mut_ptr" class="fnname">as_mut_ptr</a>(&amp;mut self) -&gt; *mut T</h4><a href="#method.as_mut_ptr" class="anchor"></a><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#569-572" title="goto source code">[src]</a></div></summary><div class="docblock"><p>获取指向包含值的可变指针。
除非初始化 <code>MaybeUninit&lt;T&gt;</code>，否则从该指针读取或将其转换为 quot 是未定义的行为。</p>
<h1 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h1>
<p>正确使用此方法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="ident">::uninit</span>();
<span class="ident">x</span>.<span class="ident">write</span>(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);
<span class="comment">// 在 `MaybeUninit&lt;Vec&lt;u32&gt;&gt;` 中创建引用。</span>
<span class="comment">// 可以，因为我们已将其初始化。</span>
<span class="kw">let</span> <span class="ident">x_vec</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="kw-2">*</span><span class="ident">x</span>.<span class="ident">as_mut_ptr</span>() };
<span class="ident">x_vec</span>.<span class="ident">push</span>(<span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="ident">x_vec</span>.<span class="ident">len</span>(), <span class="number">4</span>);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Alet%20mut%20x%20%3D%20MaybeUninit%3A%3A%3CVec%3Cu32%3E%3E%3A%3Auninit()%3B%0Ax.write(vec!%5B0%2C%201%2C%202%5D)%3B%0A%2F%2F%20%E5%9C%A8%20%60MaybeUninit%3CVec%3Cu32%3E%3E%60%20%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%BC%95%E7%94%A8%E3%80%82%0A%2F%2F%20%E5%8F%AF%E4%BB%A5%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%88%91%E4%BB%AC%E5%B7%B2%E5%B0%86%E5%85%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82%0Alet%20x_vec%20%3D%20unsafe%20%7B%20%26mut%20*x.as_mut_ptr()%20%7D%3B%0Ax_vec.push(3)%3B%0Aassert_eq!(x_vec.len()%2C%204)%3B%0A%7D&amp;edition=2018">Run</a></div>
<p>这个方法的错误用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="ident">::uninit</span>();
<span class="kw">let</span> <span class="ident">x_vec</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="kw-2">*</span><span class="ident">x</span>.<span class="ident">as_mut_ptr</span>() };
<span class="comment">// 我们创建了对未初始化的 vector 的引用! 这是未定义的行为。⚠️</span></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Alet%20mut%20x%20%3D%20MaybeUninit%3A%3A%3CVec%3Cu32%3E%3E%3A%3Auninit()%3B%0Alet%20x_vec%20%3D%20unsafe%20%7B%20%26mut%20*x.as_mut_ptr()%20%7D%3B%0A%2F%2F%20%E6%88%91%E4%BB%AC%E5%88%9B%E5%BB%BA%E4%BA%86%E5%AF%B9%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%20vector%20%E7%9A%84%E5%BC%95%E7%94%A8!%20%E8%BF%99%E6%98%AF%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%E3%80%82%E2%9A%A0%EF%B8%8F%0A%7D&amp;edition=2018">Run</a></div>
<p>(请注意，围绕未初始化数据引用的规则尚未最终确定，但是除非被确定，否则建议避免使用它们。)</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.assume_init" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.assume_init" class="fnname">assume_init</a>(self) -&gt; T</h4><a href="#method.assume_init" class="anchor"></a><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#623-630" title="goto source code">[src]</a></div></summary><div class="docblock"><p>从 <code>MaybeUninit&lt;T&gt;</code> 容器中提取值。这是确保数据将被丢弃的好方法，因为生成的 <code>T</code> 受到通常的丢弃处理。</p>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p>取决于调用方，以确保 <code>MaybeUninit&lt;T&gt;</code> 确实处于初始化状态。在内容尚未完全初始化时调用此方法会立即导致未定义的行为。
<a href="#initialization-invariant">类型级文档</a> 中包含了有关此初始化不可变变量的更多信息。</p>
<p>最重要的是，请记住，大多数类型具有其他不变式，而不仅仅是在类型级别被初始化。
例如，将 <code>1</code> 初始化的 <a href="../../std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> 视为已初始化 (在当前实现下; 这并不构成稳定的保证)，因为编译器知道的唯一要求是数据指针必须为非空值。</p>
<p>创建这样的 <code>Vec&lt;T&gt;</code> 不会立即导致未定义的行为，但是在大多数安全操作 (包括丢弃操作) 中都将导致未定义的行为。</p>
<h1 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h1>
<p>正确使用此方法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span><span class="ident">::uninit</span>();
<span class="ident">x</span>.<span class="ident">write</span>(<span class="bool-val">true</span>);
<span class="kw">let</span> <span class="ident">x_init</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">assume_init</span>() };
<span class="macro">assert_eq!</span>(<span class="ident">x_init</span>, <span class="bool-val">true</span>);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Alet%20mut%20x%20%3D%20MaybeUninit%3A%3A%3Cbool%3E%3A%3Auninit()%3B%0Ax.write(true)%3B%0Alet%20x_init%20%3D%20unsafe%20%7B%20x.assume_init()%20%7D%3B%0Aassert_eq!(x_init%2C%20true)%3B%0A%7D&amp;edition=2018">Run</a></div>
<p>这个方法的错误用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="ident">::uninit</span>();
<span class="kw">let</span> <span class="ident">x_init</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">assume_init</span>() };
<span class="comment">// `x` 尚未初始化，因此这最后一行导致未定义的行为。⚠️</span></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Alet%20x%20%3D%20MaybeUninit%3A%3A%3CVec%3Cu32%3E%3E%3A%3Auninit()%3B%0Alet%20x_init%20%3D%20unsafe%20%7B%20x.assume_init()%20%7D%3B%0A%2F%2F%20%60x%60%20%E5%B0%9A%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E5%9B%A0%E6%AD%A4%E8%BF%99%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C%E5%AF%BC%E8%87%B4%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%E3%80%82%E2%9A%A0%EF%B8%8F%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.assume_init_read" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.assume_init_read" class="fnname">assume_init_read</a>(&amp;self) -&gt; T</h4><a href="#method.assume_init_read" class="anchor"></a><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#694-701" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>maybe_uninit_extra</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/63567">#63567</a>)</div></div></summary><div class="docblock"><p>从 <code>MaybeUninit&lt;T&gt;</code> 容器中读取值。结果 <code>T</code> 受通常的 drop 处理影响。</p>
<p>只要有可能，最好改用 <a href="union.MaybeUninit.html#method.assume_init"><code>assume_init</code></a>，这样可以防止重复 <code>MaybeUninit&lt;T&gt;</code> 的内容。</p>
<h1 id="safety-1" class="section-header"><a href="#safety-1">Safety</a></h1>
<p>取决于调用方，以确保 <code>MaybeUninit&lt;T&gt;</code> 确实处于初始化状态。在内容尚未完全初始化时调用此方法会导致未定义的行为。
<a href="#initialization-invariant">类型级文档</a> 中包含了有关此初始化不可变变量的更多信息。</p>
<p>此外，类似于 <a href="../ptr/fn.read.html" title="ptr::read"><code>ptr::read</code></a> 函数，该函数创建内容的按位副本，无论所包含的类型是否实现 <a href="../marker/trait.Copy.html" title="Copy"><code>Copy</code></a> trait。
使用数据的多个副本时 (通过多次调用 <code>assume_init_read</code>，或先调用 <code>assume_init_read</code>，然后再调用 <a href="union.MaybeUninit.html#method.assume_init"><code>assume_init</code></a>)，您有责任确保确实可以复制数据。</p>
<h1 id="examples-6" class="section-header"><a href="#examples-6">Examples</a></h1>
<p>正确使用此方法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">maybe_uninit_extra</span>)]</span>
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="ident">::uninit</span>();
<span class="ident">x</span>.<span class="ident">write</span>(<span class="number">13</span>);
<span class="kw">let</span> <span class="ident">x1</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">assume_init_read</span>() };
<span class="comment">// `u32` 是 `Copy`，因此我们可能会多次读取。</span>
<span class="kw">let</span> <span class="ident">x2</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">assume_init_read</span>() };
<span class="macro">assert_eq!</span>(<span class="ident">x1</span>, <span class="ident">x2</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="ident">::uninit</span>();
<span class="ident">x</span>.<span class="ident">write</span>(<span class="prelude-val">None</span>);
<span class="kw">let</span> <span class="ident">x1</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">assume_init_read</span>() };
<span class="comment">// 复制 `None` 值是可以的，因此我们可能会多次读取。</span>
<span class="kw">let</span> <span class="ident">x2</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">assume_init_read</span>() };
<span class="macro">assert_eq!</span>(<span class="ident">x1</span>, <span class="ident">x2</span>);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_extra)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Alet%20mut%20x%20%3D%20MaybeUninit%3A%3A%3Cu32%3E%3A%3Auninit()%3B%0Ax.write(13)%3B%0Alet%20x1%20%3D%20unsafe%20%7B%20x.assume_init_read()%20%7D%3B%0A%2F%2F%20%60u32%60%20%E6%98%AF%20%60Copy%60%EF%BC%8C%E5%9B%A0%E6%AD%A4%E6%88%91%E4%BB%AC%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%A4%9A%E6%AC%A1%E8%AF%BB%E5%8F%96%E3%80%82%0Alet%20x2%20%3D%20unsafe%20%7B%20x.assume_init_read()%20%7D%3B%0Aassert_eq!(x1%2C%20x2)%3B%0A%0Alet%20mut%20x%20%3D%20MaybeUninit%3A%3A%3COption%3CVec%3Cu32%3E%3E%3E%3A%3Auninit()%3B%0Ax.write(None)%3B%0Alet%20x1%20%3D%20unsafe%20%7B%20x.assume_init_read()%20%7D%3B%0A%2F%2F%20%E5%A4%8D%E5%88%B6%20%60None%60%20%E5%80%BC%E6%98%AF%E5%8F%AF%E4%BB%A5%E7%9A%84%EF%BC%8C%E5%9B%A0%E6%AD%A4%E6%88%91%E4%BB%AC%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%A4%9A%E6%AC%A1%E8%AF%BB%E5%8F%96%E3%80%82%0Alet%20x2%20%3D%20unsafe%20%7B%20x.assume_init_read()%20%7D%3B%0Aassert_eq!(x1%2C%20x2)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
<p>这个方法的错误用法:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">maybe_uninit_extra</span>)]</span>
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="ident">::uninit</span>();
<span class="ident">x</span>.<span class="ident">write</span>(<span class="prelude-val">Some</span>(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]));
<span class="kw">let</span> <span class="ident">x1</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">assume_init_read</span>() };
<span class="kw">let</span> <span class="ident">x2</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">assume_init_read</span>() };
<span class="comment">// 现在，我们创建了同一 vector 的两个副本，当它们都被丢弃时，将导致双重释放!</span></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_extra)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Alet%20mut%20x%20%3D%20MaybeUninit%3A%3A%3COption%3CVec%3Cu32%3E%3E%3E%3A%3Auninit()%3B%0Ax.write(Some(vec!%5B0%2C%201%2C%202%5D))%3B%0Alet%20x1%20%3D%20unsafe%20%7B%20x.assume_init_read()%20%7D%3B%0Alet%20x2%20%3D%20unsafe%20%7B%20x.assume_init_read()%20%7D%3B%0A%2F%2F%20%E7%8E%B0%E5%9C%A8%EF%BC%8C%E6%88%91%E4%BB%AC%E5%88%9B%E5%BB%BA%E4%BA%86%E5%90%8C%E4%B8%80%20vector%20%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%89%AF%E6%9C%AC%EF%BC%8C%E5%BD%93%E5%AE%83%E4%BB%AC%E9%83%BD%E8%A2%AB%E4%B8%A2%E5%BC%83%E6%97%B6%EF%BC%8C%E5%B0%86%E5%AF%BC%E8%87%B4%E5%8F%8C%E9%87%8D%E9%87%8A%E6%94%BE!%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.assume_init_drop" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.assume_init_drop" class="fnname">assume_init_drop</a>(&amp;mut self)</h4><a href="#method.assume_init_drop" class="anchor"></a><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#726-731" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>maybe_uninit_extra</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/63567">#63567</a>)</div></div></summary><div class="docblock"><p>将包含的值放置到位。</p>
<p>如果您拥有 <code>MaybeUninit</code>，您也可以使用 <a href="union.MaybeUninit.html#method.assume_init"><code>assume_init</code></a> 作为替代。</p>
<h1 id="safety-2" class="section-header"><a href="#safety-2">Safety</a></h1>
<p>取决于调用方，以确保 <code>MaybeUninit&lt;T&gt;</code> 确实处于初始化状态。
在内容尚未完全初始化时调用此方法会导致未定义的行为。</p>
<p>最重要的是，必须满足类型 <code>T</code> 的所有其他不可变变量，因为 <code>T</code> (或其成员) 的 <code>Drop</code> 实现可能依赖于此。</p>
<p>例如，将 <a href="../../std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> 设置为无效但非空的地址使其初始化 (在当前实现下;
这并不构成稳定的保证)，因为编译器知道的唯一要求是数据指针必须非空。
但是，丢弃这样的 <code>Vec&lt;T&gt;</code> 会导致不确定的行为。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.assume_init_ref" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.assume_init_ref" class="fnname">assume_init_ref</a>(&amp;self) -&gt; &amp;T</h4><span class="since" title="Stable since Rust version 1.55.0">1.55.0</span><a href="#method.assume_init_ref" class="anchor"></a><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#788-795" title="goto source code">[src]</a></div></summary><div class="docblock"><p>获取对包含值的共享引用。</p>
<p>当我们要访问已初始化但没有 <code>MaybeUninit</code> 所有权 (防止使用 <code>.assume_init()</code>) 的 <code>MaybeUninit</code> 时，这很有用。</p>
<h1 id="safety-3" class="section-header"><a href="#safety-3">Safety</a></h1>
<p>在内容尚未完全初始化时调用此方法会导致未定义的行为: 取决于调用方，以确保 <code>MaybeUninit&lt;T&gt;</code> 确实处于初始化状态。</p>
<h1 id="examples-7" class="section-header"><a href="#examples-7">Examples</a></h1><h3 id="正确使用此方法" class="section-header"><a href="#正确使用此方法">正确使用此方法:</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="ident">::uninit</span>();
<span class="comment">// 初始化 `x`:</span>
<span class="ident">x</span>.<span class="ident">write</span>(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);
<span class="comment">// 现在已知我们的 `MaybeUninit&lt;_&gt;` 已初始化，可以创建对其的共享引用:</span>
<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="kw">unsafe</span> {
    <span class="comment">// SAFETY: `x` 已初始化。</span>
    <span class="ident">x</span>.<span class="ident">assume_init_ref</span>()
};
<span class="macro">assert_eq!</span>(<span class="ident">x</span>, <span class="kw-2">&amp;</span><span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Alet%20mut%20x%20%3D%20MaybeUninit%3A%3A%3CVec%3Cu32%3E%3E%3A%3Auninit()%3B%0A%2F%2F%20%E5%88%9D%E5%A7%8B%E5%8C%96%20%60x%60%3A%0Ax.write(vec!%5B1%2C%202%2C%203%5D)%3B%0A%2F%2F%20%E7%8E%B0%E5%9C%A8%E5%B7%B2%E7%9F%A5%E6%88%91%E4%BB%AC%E7%9A%84%20%60MaybeUninit%3C_%3E%60%20%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%AF%B9%E5%85%B6%E7%9A%84%E5%85%B1%E4%BA%AB%E5%BC%95%E7%94%A8%3A%0Alet%20x%3A%20%26Vec%3Cu32%3E%20%3D%20unsafe%20%7B%0A%20%20%20%20%2F%2F%20SAFETY%3A%20%60x%60%20%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82%0A%20%20%20%20x.assume_init_ref()%0A%7D%3B%0Aassert_eq!(x%2C%20%26vec!%5B1%2C%202%2C%203%5D)%3B%0A%7D&amp;edition=2018">Run</a></div>
<h3 id="这个方法的错误用法" class="section-header"><a href="#这个方法的错误用法">这个方法的错误用法:</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="ident">::uninit</span>();
<span class="kw">let</span> <span class="ident">x_vec</span>: <span class="kw-2">&amp;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">x</span>.<span class="ident">assume_init_ref</span>() };
<span class="comment">// 我们创建了对未初始化的 vector 的引用! 这是未定义的行为。⚠️</span></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Alet%20x%20%3D%20MaybeUninit%3A%3A%3CVec%3Cu32%3E%3E%3A%3Auninit()%3B%0Alet%20x_vec%3A%20%26Vec%3Cu32%3E%20%3D%20unsafe%20%7B%20x.assume_init_ref()%20%7D%3B%0A%2F%2F%20%E6%88%91%E4%BB%AC%E5%88%9B%E5%BB%BA%E4%BA%86%E5%AF%B9%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%20vector%20%E7%9A%84%E5%BC%95%E7%94%A8!%20%E8%BF%99%E6%98%AF%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%E3%80%82%E2%9A%A0%EF%B8%8F%0A%7D&amp;edition=2018">Run</a></div>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">cell::Cell</span>, <span class="ident">mem::MaybeUninit</span>};

<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="ident">::uninit</span>();
<span class="comment">// 使用 `Cell::set` 初始化 `MaybeUninit`:</span>
<span class="kw">unsafe</span> {
    <span class="ident">b</span>.<span class="ident">assume_init_ref</span>().<span class="ident">set</span>(<span class="bool-val">true</span>);
   <span class="comment">// ^^^^^^^^^^^^^^^</span>
   <span class="comment">// 引用未初始化的 `Cell&lt;bool&gt;`: UB!</span>
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3A%7Bcell%3A%3ACell%2C%20mem%3A%3AMaybeUninit%7D%3B%0A%0Alet%20b%20%3D%20MaybeUninit%3A%3A%3CCell%3Cbool%3E%3E%3A%3Auninit()%3B%0A%2F%2F%20%E4%BD%BF%E7%94%A8%20%60Cell%3A%3Aset%60%20%E5%88%9D%E5%A7%8B%E5%8C%96%20%60MaybeUninit%60%3A%0Aunsafe%20%7B%0A%20%20%20%20b.assume_init_ref().set(true)%3B%0A%20%20%20%2F%2F%20%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%0A%20%20%20%2F%2F%20%E5%BC%95%E7%94%A8%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%20%60Cell%3Cbool%3E%60%3A%20UB!%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.assume_init_mut" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.assume_init_mut" class="fnname">assume_init_mut</a>(&amp;mut self) -&gt; &amp;mut T</h4><span class="since" title="Stable since Rust version 1.55.0">1.55.0</span><a href="#method.assume_init_mut" class="anchor"></a><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#904-911" title="goto source code">[src]</a></div></summary><div class="docblock"><p>获取所包含值的可变 (unique) 引用。</p>
<p>当我们要访问已初始化但没有 <code>MaybeUninit</code> 所有权 (防止使用 <code>.assume_init()</code>) 的 <code>MaybeUninit</code> 时，这很有用。</p>
<h1 id="safety-4" class="section-header"><a href="#safety-4">Safety</a></h1>
<p>在内容尚未完全初始化时调用此方法会导致未定义的行为: 取决于调用方，以确保 <code>MaybeUninit&lt;T&gt;</code> 确实处于初始化状态。
例如，<code>.assume_init_mut()</code> 不能用于初始化 <code>MaybeUninit</code>。</p>
<h1 id="examples-8" class="section-header"><a href="#examples-8">Examples</a></h1><h3 id="正确使用此方法-1" class="section-header"><a href="#正确使用此方法-1">正确使用此方法:</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">extern</span> <span class="string">&quot;C&quot;</span> {
    <span class="doccomment">/// 初始化所有输入缓冲区的字节。</span>
    <span class="kw">fn</span> <span class="ident">initialize_buffer</span>(<span class="ident">buf</span>: <span class="kw-2">*</span><span class="kw-2">mut</span> [<span class="ident">u8</span>; <span class="number">1024</span>]);
}

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span>[<span class="ident">u8</span>; <span class="number">1024</span>]<span class="op">&gt;</span><span class="ident">::uninit</span>();

<span class="comment">// 初始化 `buf`:</span>
<span class="kw">unsafe</span> { <span class="ident">initialize_buffer</span>(<span class="ident">buf</span>.<span class="ident">as_mut_ptr</span>()); }
<span class="comment">// 现在我们知道 `buf` 已被初始化，因此我们可以对其进行 `.assume_init()`。</span>
<span class="comment">// 但是，使用 `.assume_init()` 可能会触发 1024 字节的 `memcpy`。</span>
<span class="comment">// 为了断言我们的缓冲区已经初始化而不复制它，我们将 `&amp;mut MaybeUninit&lt;[u8; 1024]&gt;` 升级为 `&amp;mut [u8; 1024]`:</span>
<span class="kw">let</span> <span class="ident">buf</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="ident">u8</span>; <span class="number">1024</span>] <span class="op">=</span> <span class="kw">unsafe</span> {
    <span class="comment">// SAFETY: `buf` 已初始化。</span>
    <span class="ident">buf</span>.<span class="ident">assume_init_mut</span>()
};

<span class="comment">// 现在我们可以将 `buf` 用作普通切片:</span>
<span class="ident">buf</span>.<span class="ident">sort_unstable</span>();
<span class="macro">assert!</span>(
    <span class="ident">buf</span>.<span class="ident">windows</span>(<span class="number">2</span>).<span class="ident">all</span>(<span class="op">|</span><span class="ident">pair</span><span class="op">|</span> <span class="ident">pair</span>[<span class="number">0</span>] <span class="op">&lt;</span><span class="op">=</span> <span class="ident">pair</span>[<span class="number">1</span>]),
    <span class="string">&quot;buffer is sorted&quot;</span>,
);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Aunsafe%20extern%20%22C%22%20fn%20initialize_buffer(buf%3A%20*mut%20%5Bu8%3B%201024%5D)%20%7B%20*buf%20%3D%20%5B0%3B%201024%5D%20%7D%0A%23%5Bcfg(FALSE)%5D%0Aextern%20%22C%22%20%7B%0A%20%20%20%20%2F%2F%2F%20%E5%88%9D%E5%A7%8B%E5%8C%96%E6%89%80%E6%9C%89%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%AD%97%E8%8A%82%E3%80%82%0A%20%20%20%20fn%20initialize_buffer(buf%3A%20*mut%20%5Bu8%3B%201024%5D)%3B%0A%7D%0A%0Alet%20mut%20buf%20%3D%20MaybeUninit%3A%3A%3C%5Bu8%3B%201024%5D%3E%3A%3Auninit()%3B%0A%0A%2F%2F%20%E5%88%9D%E5%A7%8B%E5%8C%96%20%60buf%60%3A%0Aunsafe%20%7B%20initialize_buffer(buf.as_mut_ptr())%3B%20%7D%0A%2F%2F%20%E7%8E%B0%E5%9C%A8%E6%88%91%E4%BB%AC%E7%9F%A5%E9%81%93%20%60buf%60%20%E5%B7%B2%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E5%9B%A0%E6%AD%A4%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8C%20%60.assume_init()%60%E3%80%82%0A%2F%2F%20%E4%BD%86%E6%98%AF%EF%BC%8C%E4%BD%BF%E7%94%A8%20%60.assume_init()%60%20%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%A7%A6%E5%8F%91%201024%20%E5%AD%97%E8%8A%82%E7%9A%84%20%60memcpy%60%E3%80%82%0A%2F%2F%20%E4%B8%BA%E4%BA%86%E6%96%AD%E8%A8%80%E6%88%91%E4%BB%AC%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E5%B7%B2%E7%BB%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E8%80%8C%E4%B8%8D%E5%A4%8D%E5%88%B6%E5%AE%83%EF%BC%8C%E6%88%91%E4%BB%AC%E5%B0%86%20%60%26mut%20MaybeUninit%3C%5Bu8%3B%201024%5D%3E%60%20%E5%8D%87%E7%BA%A7%E4%B8%BA%20%60%26mut%20%5Bu8%3B%201024%5D%60%3A%0Alet%20buf%3A%20%26mut%20%5Bu8%3B%201024%5D%20%3D%20unsafe%20%7B%0A%20%20%20%20%2F%2F%20SAFETY%3A%20%60buf%60%20%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82%0A%20%20%20%20buf.assume_init_mut()%0A%7D%3B%0A%0A%2F%2F%20%E7%8E%B0%E5%9C%A8%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%B0%86%20%60buf%60%20%E7%94%A8%E4%BD%9C%E6%99%AE%E9%80%9A%E5%88%87%E7%89%87%3A%0Abuf.sort_unstable()%3B%0Aassert!(%0A%20%20%20%20buf.windows(2).all(%7Cpair%7C%20pair%5B0%5D%20%3C%3D%20pair%5B1%5D)%2C%0A%20%20%20%20%22buffer%20is%20sorted%22%2C%0A)%3B%0A%7D&amp;edition=2018">Run</a></div>
<h3 id="这个方法的错误用法-1" class="section-header"><a href="#这个方法的错误用法-1">这个方法的错误用法:</a></h3>
<p>您不能使用 <code>.assume_init_mut()</code> 初始化值:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span><span class="ident">::uninit</span>();
<span class="kw">unsafe</span> {
    <span class="kw-2">*</span><span class="ident">b</span>.<span class="ident">assume_init_mut</span>() <span class="op">=</span> <span class="bool-val">true</span>;
    <span class="comment">// 我们已经创建了 (mutable) 引用未初始化的 `bool`!</span>
    <span class="comment">// 这是未定义的行为。⚠️</span>
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Alet%20mut%20b%20%3D%20MaybeUninit%3A%3A%3Cbool%3E%3A%3Auninit()%3B%0Aunsafe%20%7B%0A%20%20%20%20*b.assume_init_mut()%20%3D%20true%3B%0A%20%20%20%20%2F%2F%20%E6%88%91%E4%BB%AC%E5%B7%B2%E7%BB%8F%E5%88%9B%E5%BB%BA%E4%BA%86%20(mutable)%20%E5%BC%95%E7%94%A8%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%20%60bool%60!%0A%20%20%20%20%2F%2F%20%E8%BF%99%E6%98%AF%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%E3%80%82%E2%9A%A0%EF%B8%8F%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<p>例如，您不能 <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a> 进入未初始化的缓冲区:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">io</span>, <span class="ident">mem::MaybeUninit</span>};

<span class="kw">fn</span> <span class="ident">read_chunk</span> (<span class="ident">reader</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;_</span> <span class="kw-2">mut</span> <span class="kw">dyn</span> <span class="ident">io::Read</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">io::Result</span><span class="op">&lt;</span>[<span class="ident">u8</span>; <span class="number">64</span>]<span class="op">&gt;</span>
{
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buffer</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span>[<span class="ident">u8</span>; <span class="number">64</span>]<span class="op">&gt;</span><span class="ident">::uninit</span>();
    <span class="ident">reader</span>.<span class="ident">read_exact</span>(<span class="kw">unsafe</span> { <span class="ident">buffer</span>.<span class="ident">assume_init_mut</span>() })<span class="question-mark">?</span>;
                            <span class="comment">// ^^^^^^^^^^^^^^^^^^^^^^^^</span>
                            <span class="comment">// (mutable) 引用未初始化的内存!</span>
                            <span class="comment">// 这是未定义的行为。</span>
    <span class="prelude-val">Ok</span>(<span class="kw">unsafe</span> { <span class="ident">buffer</span>.<span class="ident">assume_init</span>() })
}</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3A%7Bio%2C%20mem%3A%3AMaybeUninit%7D%3B%0A%0Afn%20read_chunk%20(reader%3A%20%26'_%20mut%20dyn%20io%3A%3ARead)%20-%3E%20io%3A%3AResult%3C%5Bu8%3B%2064%5D%3E%0A%7B%0A%20%20%20%20let%20mut%20buffer%20%3D%20MaybeUninit%3A%3A%3C%5Bu8%3B%2064%5D%3E%3A%3Auninit()%3B%0A%20%20%20%20reader.read_exact(unsafe%20%7B%20buffer.assume_init_mut()%20%7D)%3F%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20(mutable)%20%E5%BC%95%E7%94%A8%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%86%85%E5%AD%98!%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E8%BF%99%E6%98%AF%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%E3%80%82%0A%20%20%20%20Ok(unsafe%20%7B%20buffer.assume_init()%20%7D)%0A%7D%0A%7D&amp;edition=2018">Run</a></div>
<p>也不能使用直接字段访问来进行逐字段逐步初始化:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">mem::MaybeUninit</span>, <span class="ident">ptr</span>};

<span class="kw">struct</span> <span class="ident">Foo</span> {
    <span class="ident">a</span>: <span class="ident">u32</span>,
    <span class="ident">b</span>: <span class="ident">u8</span>,
}

<span class="kw">let</span> <span class="ident">foo</span>: <span class="ident">Foo</span> <span class="op">=</span> <span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">foo</span> <span class="op">=</span> <span class="ident">MaybeUninit</span>::<span class="op">&lt;</span><span class="ident">Foo</span><span class="op">&gt;</span><span class="ident">::uninit</span>();
    <span class="ident">ptr::write</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">foo</span>.<span class="ident">assume_init_mut</span>().<span class="ident">a</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u32</span>, <span class="number">1337</span>);
                 <span class="comment">// ^^^^^^^^^^^^^^^^^^^^^</span>
                 <span class="comment">// (mutable) 引用未初始化的内存!</span>
                 <span class="comment">// 这是未定义的行为。</span>
    <span class="ident">ptr::write</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">foo</span>.<span class="ident">assume_init_mut</span>().<span class="ident">b</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw-2">mut</span> <span class="ident">u8</span>, <span class="number">42</span>);
                 <span class="comment">// ^^^^^^^^^^^^^^^^^^^^^</span>
                 <span class="comment">// (mutable) 引用未初始化的内存!</span>
                 <span class="comment">// 这是未定义的行为。</span>
    <span class="ident">foo</span>.<span class="ident">assume_init</span>()
};</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3A%7Bmem%3A%3AMaybeUninit%2C%20ptr%7D%3B%0A%0Astruct%20Foo%20%7B%0A%20%20%20%20a%3A%20u32%2C%0A%20%20%20%20b%3A%20u8%2C%0A%7D%0A%0Alet%20foo%3A%20Foo%20%3D%20unsafe%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20MaybeUninit%3A%3A%3CFoo%3E%3A%3Auninit()%3B%0A%20%20%20%20ptr%3A%3Awrite(%26mut%20foo.assume_init_mut().a%20as%20*mut%20u32%2C%201337)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20(mutable)%20%E5%BC%95%E7%94%A8%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%86%85%E5%AD%98!%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E8%BF%99%E6%98%AF%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%E3%80%82%0A%20%20%20%20ptr%3A%3Awrite(%26mut%20foo.assume_init_mut().b%20as%20*mut%20u8%2C%2042)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%5E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20(mutable)%20%E5%BC%95%E7%94%A8%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%86%85%E5%AD%98!%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E8%BF%99%E6%98%AF%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%A1%8C%E4%B8%BA%E3%80%82%0A%20%20%20%20foo.assume_init()%0A%7D%3B%0A%7D&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.array_assume_init" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.array_assume_init" class="fnname">array_assume_init</a>&lt;const N:&nbsp;usize&gt;(array: [Self; N]) -&gt; [T; N]</h4><a href="#method.array_assume_init" class="anchor"></a><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#941-951" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>maybe_uninit_array_assume_init</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/80908">#80908</a>)</div></div></summary><div class="docblock"><p>从 <code>MaybeUninit</code> 容器数组中提取值。</p>
<h1 id="safety-5" class="section-header"><a href="#safety-5">Safety</a></h1>
<p>调用方有责任保证数组的所有元素都处于初始化状态。</p>
<h1 id="examples-9" class="section-header"><a href="#examples-9">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">maybe_uninit_uninit_array</span>)]</span>
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">maybe_uninit_array_assume_init</span>)]</span>
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">array</span>: [<span class="ident">MaybeUninit</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>; <span class="number">3</span>] <span class="op">=</span> <span class="ident">MaybeUninit::uninit_array</span>();
<span class="ident">array</span>[<span class="number">0</span>].<span class="ident">write</span>(<span class="number">0</span>);
<span class="ident">array</span>[<span class="number">1</span>].<span class="ident">write</span>(<span class="number">1</span>);
<span class="ident">array</span>[<span class="number">2</span>].<span class="ident">write</span>(<span class="number">2</span>);

<span class="comment">// SAFETY: 现在安全了，因为我们初始化了所有元素</span>
<span class="kw">let</span> <span class="ident">array</span> <span class="op">=</span> <span class="kw">unsafe</span> {
    <span class="ident">MaybeUninit::array_assume_init</span>(<span class="ident">array</span>)
};

<span class="macro">assert_eq!</span>(<span class="ident">array</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_uninit_array)%5D%0A%23!%5Bfeature(maybe_uninit_array_assume_init)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Alet%20mut%20array%3A%20%5BMaybeUninit%3Ci32%3E%3B%203%5D%20%3D%20MaybeUninit%3A%3Auninit_array()%3B%0Aarray%5B0%5D.write(0)%3B%0Aarray%5B1%5D.write(1)%3B%0Aarray%5B2%5D.write(2)%3B%0A%0A%2F%2F%20SAFETY%3A%20%E7%8E%B0%E5%9C%A8%E5%AE%89%E5%85%A8%E4%BA%86%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%88%91%E4%BB%AC%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%86%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%0Alet%20array%20%3D%20unsafe%20%7B%0A%20%20%20%20MaybeUninit%3A%3Aarray_assume_init(array)%0A%7D%3B%0A%0Aassert_eq!(array%2C%20%5B0%2C%201%2C%202%5D)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.slice_assume_init_ref" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.slice_assume_init_ref" class="fnname">slice_assume_init_ref</a>(slice: &amp;[Self]) -&gt; &amp;[T]</h4><a href="#method.slice_assume_init_ref" class="anchor"></a><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#967-973" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>maybe_uninit_slice</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/63569">#63569</a>)</div></div></summary><div class="docblock"><p>假设所有元素都已初始化，请对其进行切片。</p>
<h1 id="safety-6" class="section-header"><a href="#safety-6">Safety</a></h1>
<p>取决于调用方，以确保 <code>MaybeUninit&lt;T&gt;</code> 元素确实处于初始化状态。</p>
<p>在内容尚未完全初始化时调用此方法会导致未定义的行为。</p>
<p>有关更多详细信息和示例，请参见 <a href="union.MaybeUninit.html#method.assume_init_ref"><code>assume_init_ref</code></a>。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.slice_assume_init_mut" class="method has-srclink"><h4 class="code-header">pub unsafe fn <a href="#method.slice_assume_init_mut" class="fnname">slice_assume_init_mut</a>(slice: &amp;mut [Self]) -&gt; &amp;mut [T]</h4><a href="#method.slice_assume_init_mut" class="anchor"></a><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#989-993" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>maybe_uninit_slice</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/63569">#63569</a>)</div></div></summary><div class="docblock"><p>假设所有元素都已初始化，请为其获取可变切片。</p>
<h1 id="safety-7" class="section-header"><a href="#safety-7">Safety</a></h1>
<p>取决于调用方，以确保 <code>MaybeUninit&lt;T&gt;</code> 元素确实处于初始化状态。</p>
<p>在内容尚未完全初始化时调用此方法会导致未定义的行为。</p>
<p>有关更多详细信息和示例，请参见 <a href="union.MaybeUninit.html#method.assume_init_mut"><code>assume_init_mut</code></a>。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.slice_as_ptr" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.slice_as_ptr" class="fnname">slice_as_ptr</a>(this: &amp;[<a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;]) -&gt; *const T</h4><a href="#method.slice_as_ptr" class="anchor"></a><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#999-1001" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>maybe_uninit_slice</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/63569">#63569</a>)</div></div></summary><div class="docblock"><p>获取一个指向数组第一个元素的指针。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.slice_as_mut_ptr" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.slice_as_mut_ptr" class="fnname">slice_as_mut_ptr</a>(this: &amp;mut [<a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;]) -&gt; *mut T</h4><a href="#method.slice_as_mut_ptr" class="anchor"></a><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#1007-1009" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>maybe_uninit_slice</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/63569">#63569</a>)</div></div></summary><div class="docblock"><p>获取指向数组第一个元素的可变指针。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.write_slice" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.write_slice" class="fnname">write_slice</a>&lt;'a&gt;(this: &amp;'a mut [<a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;], src: &amp;[T]) -&gt; &amp;'a mut [T] <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,&nbsp;</span></h4><a href="#method.write_slice" class="anchor"></a><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#1055-1066" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>maybe_uninit_write_slice</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/79995">#79995</a>)</div></div></summary><div class="docblock"><p>从 <code>src</code> 复制元素，将 <code>this</code> 现在初始化的内容返回给 <code>this</code> 的资源引用。</p>
<p>如果 <code>T</code> 未实现 <code>Copy</code>，请使用 <a href="union.MaybeUninit.html#method.write_slice_cloned"><code>write_slice_cloned</code></a></p>
<p>这类似于 <a href="https://doc.rust-lang.org/1.54.0/std/primitive.slice.html#method.copy_from_slice" title="slice::copy_from_slice"><code>slice::copy_from_slice</code></a>。</p>
<h1 id="panics" class="section-header"><a href="#panics">Panics</a></h1>
<p>如果两个切片的长度不同，则此函数将为 panic。</p>
<h1 id="examples-10" class="section-header"><a href="#examples-10">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">maybe_uninit_write_slice</span>)]</span>
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dst</span> <span class="op">=</span> [<span class="ident">MaybeUninit::uninit</span>(); <span class="number">32</span>];
<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> [<span class="number">0</span>; <span class="number">32</span>];

<span class="kw">let</span> <span class="ident">init</span> <span class="op">=</span> <span class="ident">MaybeUninit::write_slice</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">dst</span>, <span class="kw-2">&amp;</span><span class="ident">src</span>);

<span class="macro">assert_eq!</span>(<span class="ident">init</span>, <span class="ident">src</span>);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_write_slice)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Alet%20mut%20dst%20%3D%20%5BMaybeUninit%3A%3Auninit()%3B%2032%5D%3B%0Alet%20src%20%3D%20%5B0%3B%2032%5D%3B%0A%0Alet%20init%20%3D%20MaybeUninit%3A%3Awrite_slice(%26mut%20dst%2C%20%26src)%3B%0A%0Aassert_eq!(init%2C%20src)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">maybe_uninit_write_slice</span>, <span class="ident">vec_spare_capacity</span>)]</span>
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="ident">Vec::with_capacity</span>(<span class="number">32</span>);
<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> [<span class="number">0</span>; <span class="number">16</span>];

<span class="ident">MaybeUninit::write_slice</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">vec</span>.<span class="ident">spare_capacity_mut</span>()[..<span class="ident">src</span>.<span class="ident">len</span>()], <span class="kw-2">&amp;</span><span class="ident">src</span>);

<span class="comment">// SAFETY: 我们刚刚将 len 的所有元素复制到了备用容量中，vec 的第一个 src.len() 元素现在有效。</span>
<span class="kw">unsafe</span> {
    <span class="ident">vec</span>.<span class="ident">set_len</span>(<span class="ident">src</span>.<span class="ident">len</span>());
}

<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, <span class="ident">src</span>);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_write_slice%2C%20vec_spare_capacity)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Alet%20mut%20vec%20%3D%20Vec%3A%3Awith_capacity(32)%3B%0Alet%20src%20%3D%20%5B0%3B%2016%5D%3B%0A%0AMaybeUninit%3A%3Awrite_slice(%26mut%20vec.spare_capacity_mut()%5B..src.len()%5D%2C%20%26src)%3B%0A%0A%2F%2F%20SAFETY%3A%20%E6%88%91%E4%BB%AC%E5%88%9A%E5%88%9A%E5%B0%86%20len%20%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E5%A4%8D%E5%88%B6%E5%88%B0%E4%BA%86%E5%A4%87%E7%94%A8%E5%AE%B9%E9%87%8F%E4%B8%AD%EF%BC%8Cvec%20%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%20src.len()%20%E5%85%83%E7%B4%A0%E7%8E%B0%E5%9C%A8%E6%9C%89%E6%95%88%E3%80%82%0Aunsafe%20%7B%0A%20%20%20%20vec.set_len(src.len())%3B%0A%7D%0A%0Aassert_eq!(vec%2C%20src)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.write_slice_cloned" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.write_slice_cloned" class="fnname">write_slice_cloned</a>&lt;'a&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;this: &amp;'a mut [<a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;], <br>&nbsp;&nbsp;&nbsp;&nbsp;src: &amp;[T]<br>) -&gt; &amp;'a mut [T] <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></h4><a href="#method.write_slice_cloned" class="anchor"></a><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#1115-1157" title="goto source code">[src]</a></div><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>maybe_uninit_write_slice</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/79995">#79995</a>)</div></div></summary><div class="docblock"><p>将元素从 <code>src</code> 克隆到 <code>this</code>，返回一个资源引用引用到 <code>this</code> 现在初始化的内容。
任何已经初始化的元素都不会被丢弃。</p>
<p>如果 <code>T</code> 实现 <code>Copy</code>，请使用 <a href="union.MaybeUninit.html#method.write_slice"><code>write_slice</code></a></p>
<p>这类似于 <a href="https://doc.rust-lang.org/1.54.0/std/primitive.slice.html#method.clone_from_slice" title="slice::clone_from_slice"><code>slice::clone_from_slice</code></a>，但不会丢弃现有元素。</p>
<h1 id="panics-1" class="section-header"><a href="#panics-1">Panics</a></h1>
<p>如果两个切片的长度不同，或者 <code>Clone</code> panics 的实现，则此函数将为 panic。</p>
<p>如果存在 panic，将丢弃已经克隆的元素。</p>
<h1 id="examples-11" class="section-header"><a href="#examples-11">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">maybe_uninit_write_slice</span>)]</span>
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dst</span> <span class="op">=</span> [<span class="ident">MaybeUninit::uninit</span>(), <span class="ident">MaybeUninit::uninit</span>(), <span class="ident">MaybeUninit::uninit</span>(), <span class="ident">MaybeUninit::uninit</span>(), <span class="ident">MaybeUninit::uninit</span>()];
<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> [<span class="string">&quot;wibbly&quot;</span>.<span class="ident">to_string</span>(), <span class="string">&quot;wobbly&quot;</span>.<span class="ident">to_string</span>(), <span class="string">&quot;timey&quot;</span>.<span class="ident">to_string</span>(), <span class="string">&quot;wimey&quot;</span>.<span class="ident">to_string</span>(), <span class="string">&quot;stuff&quot;</span>.<span class="ident">to_string</span>()];

<span class="kw">let</span> <span class="ident">init</span> <span class="op">=</span> <span class="ident">MaybeUninit::write_slice_cloned</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">dst</span>, <span class="kw-2">&amp;</span><span class="ident">src</span>);

<span class="macro">assert_eq!</span>(<span class="ident">init</span>, <span class="ident">src</span>);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_write_slice)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Alet%20mut%20dst%20%3D%20%5BMaybeUninit%3A%3Auninit()%2C%20MaybeUninit%3A%3Auninit()%2C%20MaybeUninit%3A%3Auninit()%2C%20MaybeUninit%3A%3Auninit()%2C%20MaybeUninit%3A%3Auninit()%5D%3B%0Alet%20src%20%3D%20%5B%22wibbly%22.to_string()%2C%20%22wobbly%22.to_string()%2C%20%22timey%22.to_string()%2C%20%22wimey%22.to_string()%2C%20%22stuff%22.to_string()%5D%3B%0A%0Alet%20init%20%3D%20MaybeUninit%3A%3Awrite_slice_cloned(%26mut%20dst%2C%20%26src)%3B%0A%0Aassert_eq!(init%2C%20src)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">maybe_uninit_write_slice</span>, <span class="ident">vec_spare_capacity</span>)]</span>
<span class="kw">use</span> <span class="ident">std::mem::MaybeUninit</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="ident">Vec::with_capacity</span>(<span class="number">32</span>);
<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> [<span class="string">&quot;rust&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;pretty&quot;</span>, <span class="string">&quot;cool&quot;</span>, <span class="string">&quot;language&quot;</span>];

<span class="ident">MaybeUninit::write_slice_cloned</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">vec</span>.<span class="ident">spare_capacity_mut</span>()[..<span class="ident">src</span>.<span class="ident">len</span>()], <span class="kw-2">&amp;</span><span class="ident">src</span>);

<span class="comment">// SAFETY: 我们刚刚将 len 的所有元素克隆到了备用容量中，vec 的第一个 src.len() 元素现在有效。</span>
<span class="kw">unsafe</span> {
    <span class="ident">vec</span>.<span class="ident">set_len</span>(<span class="ident">src</span>.<span class="ident">len</span>());
}

<span class="macro">assert_eq!</span>(<span class="ident">vec</span>, <span class="ident">src</span>);</pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(maybe_uninit_write_slice%2C%20vec_spare_capacity)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Amem%3A%3AMaybeUninit%3B%0A%0Alet%20mut%20vec%20%3D%20Vec%3A%3Awith_capacity(32)%3B%0Alet%20src%20%3D%20%5B%22rust%22%2C%20%22is%22%2C%20%22a%22%2C%20%22pretty%22%2C%20%22cool%22%2C%20%22language%22%5D%3B%0A%0AMaybeUninit%3A%3Awrite_slice_cloned(%26mut%20vec.spare_capacity_mut()%5B..src.len()%5D%2C%20%26src)%3B%0A%0A%2F%2F%20SAFETY%3A%20%E6%88%91%E4%BB%AC%E5%88%9A%E5%88%9A%E5%B0%86%20len%20%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E5%85%8B%E9%9A%86%E5%88%B0%E4%BA%86%E5%A4%87%E7%94%A8%E5%AE%B9%E9%87%8F%E4%B8%AD%EF%BC%8Cvec%20%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%20src.len()%20%E5%85%83%E7%B4%A0%E7%8E%B0%E5%9C%A8%E6%9C%89%E6%95%88%E3%80%82%0Aunsafe%20%7B%0A%20%20%20%20vec.set_len(src.len())%3B%0A%7D%0A%0Aassert_eq!(vec%2C%20src)%3B%0A%7D&amp;version=nightly&amp;edition=2018">Run</a></div>
</div></details></div></details><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Clone" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T:&nbsp;<a class="trait" href="../marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>&gt; <a class="trait" href="../clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h3><a href="#impl-Clone" class="anchor"></a><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#261-267" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone" class="method trait-impl has-srclink"><h4 class="code-header">fn <a href="../clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; Self</h4><a href="#method.clone" class="anchor"></a><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#263-266" title="goto source code">[src]</a></div></summary><div class='docblock'><p>返回值的副本。 <a href="../clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone_from" class="method trait-impl has-srclink"><h4 class="code-header">fn <a href="../clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: &amp;Self)</h4><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a href="#method.clone_from" class="anchor"></a><a class="srclink" href="../../src/core/clone.rs.html#130-132" title="goto source code">[src]</a></div></summary><div class='docblock'><p>从 <code>source</code> 执行复制分配。 <a href="../clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Debug" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h3><a href="#impl-Debug" class="anchor"></a><span class="since" title="Stable since Rust version 1.41.0">1.41.0</span><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#270-274" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.fmt" class="method trait-impl has-srclink"><h4 class="code-header">fn <a href="../fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="../fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4><a href="#method.fmt" class="anchor"></a><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#271-273" title="goto source code">[src]</a></div></summary><div class='docblock'><p>使用给定的格式化程序格式化该值。 <a href="../fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></details></div></details><div id="impl-Copy" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T:&nbsp;<a class="trait" href="../marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>&gt; <a class="trait" href="../marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h3><a href="#impl-Copy" class="anchor"></a><a class="srclink" href="../../src/core/mem/maybe_uninit.rs.html#253" title="goto source code">[src]</a></div></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><div id="impl-Send" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../marker/trait.Send.html" title="trait core::marker::Send">Send</a>,&nbsp;</span></h3><a href="#impl-Send" class="anchor"></a></div><div id="impl-Sync" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,&nbsp;</span></h3><a href="#impl-Sync" class="anchor"></a></div><div id="impl-Unpin" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="union" href="union.MaybeUninit.html" title="union core::mem::MaybeUninit">MaybeUninit</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,&nbsp;</span></h3><a href="#impl-Unpin" class="anchor"></a></div></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Any" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="../marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Any" class="anchor"></a><a class="srclink" href="../../src/core/any.rs.html#132-136" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.type_id" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="../any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;Self) -&gt; <a class="struct" href="../any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4><a href="#method.type_id" class="anchor"></a><a class="srclink" href="../../src/core/any.rs.html#133-135" title="goto source code">[src]</a></div></summary><div class='docblock'><p>获取 <code>self</code> 的 <code>TypeId</code>。 <a href="../any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Borrow%3CT%3E" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-Borrow%3CT%3E" class="anchor"></a><a class="srclink" href="../../src/core/borrow.rs.html#208-213" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="../borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;Self) -&gt; &amp;T</h4><a href="#method.borrow" class="anchor"></a><a class="srclink" href="../../src/core/borrow.rs.html#210-212" title="goto source code">[src]</a></div></summary><div class='docblock'><p>从拥有的值中一成不变地借用。 <a href="../borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><a class="srclink" href="../../src/core/borrow.rs.html#216-220" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow_mut" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="../borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut Self) -&gt; &amp;mut T</h4><a href="#method.borrow_mut" class="anchor"></a><a class="srclink" href="../../src/core/borrow.rs.html#217-219" title="goto source code">[src]</a></div></summary><div class='docblock'><p>从拥有的值中借用。 <a href="../borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-From%3CT%3E" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3><a href="#impl-From%3CT%3E" class="anchor"></a><a class="srclink" href="../../src/core/convert/mod.rs.html#546-550" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="../convert/trait.From.html#tymethod.from" class="fnname">from</a>(T) -&gt; T</h4><a href="#method.from" class="anchor"></a><a class="srclink" href="../../src/core/convert/mod.rs.html#547-549" title="goto source code">[src]</a></div></summary><div class='docblock'><p>执行转换。</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-Into%3CU%3E" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="../convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3><a href="#impl-Into%3CU%3E" class="anchor"></a><a class="srclink" href="../../src/core/convert/mod.rs.html#535-542" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.into" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="../convert/trait.Into.html#tymethod.into" class="fnname">into</a>(Self) -&gt; U</h4><a href="#method.into" class="anchor"></a><a class="srclink" href="../../src/core/convert/mod.rs.html#539-541" title="goto source code">[src]</a></div></summary><div class='docblock'><p>执行转换。</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-TryFrom%3CU%3E" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="../convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><a class="srclink" href="../../src/core/convert/mod.rs.html#583-592" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Error-1" class="type trait-impl has-srclink"><h4 class="code-header">type <a href="../convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="../convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4><a href="#associatedtype.Error-1" class="anchor"></a></div></summary><div class='docblock'><p>发生转换错误时返回的类型。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_from" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="../convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(U) -&gt; <a class="enum" href="../result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="../convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="../convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4><a href="#method.try_from" class="anchor"></a><a class="srclink" href="../../src/core/convert/mod.rs.html#589-591" title="goto source code">[src]</a></div></summary><div class='docblock'><p>执行转换。</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><div id="impl-TryInto%3CU%3E" class="impl has-srclink"><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="../convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3><a href="#impl-TryInto%3CU%3E" class="anchor"></a><a class="srclink" href="../../src/core/convert/mod.rs.html#569-578" title="goto source code">[src]</a></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Error" class="type trait-impl has-srclink"><h4 class="code-header">type <a href="../convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="../convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="../convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4><a href="#associatedtype.Error" class="anchor"></a></div></summary><div class='docblock'><p>发生转换错误时返回的类型。</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_into" class="method trait-impl has-srclink"><h4 class="code-header">pub fn <a href="../convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(Self) -&gt; <a class="enum" href="../result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="../convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="../convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4><a href="#method.try_into" class="anchor"></a><a class="srclink" href="../../src/core/convert/mod.rs.html#575-577" title="goto source code">[src]</a></div></summary><div class='docblock'><p>执行转换。</p>
</div></details></div></details></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="core" data-search-index-js="../../search-index1.55.0.js" data-search-js="../../search1.55.0.js"></div><script src="../../main1.55.0.js"></script></body></html>